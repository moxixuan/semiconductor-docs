"use strict";(globalThis.webpackChunksemiconductor_docs=globalThis.webpackChunksemiconductor_docs||[]).push([[4743],{2073(e,t,n){n.d(t,{A:()=>a});var i=n(6540);const a=function({pdfLink:e,pdfSize:t,title:n,description:a}){if(!e)return null;const r=e.startsWith("http"),s=(e=>{if(!e)return null;try{const t=new URL(e,r?void 0:window.location.origin);return t.pathname.split("/").pop()}catch{return e.split("/").pop()}})(e);return i.createElement("div",{className:"pdf-download-card"},i.createElement("div",{className:"pdf-download-card__header"},i.createElement("div",{className:"pdf-download-card__icon"},"\ud83d\udce5"),i.createElement("div",{className:"pdf-download-card__title"},i.createElement("h3",null,"\u4e0b\u8f7d\u5b8c\u6574PDF"),n&&i.createElement("p",{className:"pdf-download-card__doc-title"},n))),i.createElement("div",{className:"pdf-download-card__info"},i.createElement("div",{className:"pdf-download-card__meta"},i.createElement("span",{className:"pdf-download-card__label"},"\u6587\u4ef6\u5927\u5c0f:"),i.createElement("span",{className:"pdf-download-card__value"},"string"==typeof(o=t)?o:o<1048576?`${(o/1024).toFixed(1)}KB`:`${(o/1024/1024).toFixed(1)}MB`)),a&&i.createElement("div",{className:"pdf-download-card__description"},a),r&&i.createElement("div",{className:"pdf-download-card__notice"},i.createElement("span",{className:"pdf-download-card__notice-icon"},"\u2139\ufe0f"),i.createElement("span",null,"\u6b64\u6587\u4ef6\u6258\u7ba1\u5728GitHub Releases\uff0c\u53ef\u80fd\u9700\u8981GitHub\u8d26\u53f7"))),i.createElement("div",{className:"pdf-download-card__actions"},i.createElement("a",{href:e,className:"pdf-download-card__button pdf-download-card__button--primary",download:r?void 0:s,target:r?"_blank":void 0,rel:r?"noopener noreferrer":void 0},i.createElement("span",{className:"pdf-download-card__button-icon"},"\u2b07\ufe0f"),"\u4e0b\u8f7dPDF"),r&&i.createElement("a",{href:e,className:"pdf-download-card__button pdf-download-card__button--secondary",target:"_blank",rel:"noopener noreferrer"},i.createElement("span",{className:"pdf-download-card__button-icon"},"\ud83d\udd17"),"\u5728\u65b0\u7a97\u53e3\u6253\u5f00")));var o}},5680(e,t,n){n.d(t,{xA:()=>h,yg:()=>u});var i=n(6540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach(function(t){a(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=i.createContext({}),d=function(e){var t=i.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},h=function(e){var t=d(e.components);return i.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},l=i.forwardRef(function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,c=e.parentName,h=o(e,["components","mdxType","originalType","parentName"]),l=d(n),u=a,m=l["".concat(c,".").concat(u)]||l[u]||p[u]||r;return n?i.createElement(m,s(s({ref:t},h),{},{components:n})):i.createElement(m,s({ref:t},h))});function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=l;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var d=2;d<r;d++)s[d]=n[d];return i.createElement.apply(null,s)}return i.createElement.apply(null,n)}l.displayName="MDXCreateElement"},7246(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var i=n(8168),a=(n(6540),n(5680));n(2073);const r={title:"E42-0704 - \xa9 SEMI 1995, 2004...",description:"SEMI\u6807\u51c6\u6587\u6863",sidebar_label:"E42-0704 - \xa9 SEMI 1995, 2004...",sidebar_position:360,tags:["SEMI","Standard"],custom_props:{source_type:"pdf",source_file:"semi-chapter-036.pdf",chapter:36,page_count:50}},s=void 0,o={unversionedId:"standards/semi/semi-chapter-036",id:"standards/semi/semi-chapter-036",title:"E42-0704 - \xa9 SEMI 1995, 2004...",description:"SEMI\u6807\u51c6\u6587\u6863",source:"@site/docs/standards/semi/semi-chapter-036.md",sourceDirName:"standards/semi",slug:"/standards/semi/semi-chapter-036",permalink:"/semiconductor-docs/docs/standards/semi/semi-chapter-036",draft:!1,editUrl:"https://github.com/your-org/semiconductor-docs/tree/main/docs/standards/semi/semi-chapter-036.md",tags:[{label:"SEMI",permalink:"/semiconductor-docs/docs/tags/semi"},{label:"Standard",permalink:"/semiconductor-docs/docs/tags/standard"}],version:"current",sidebarPosition:360,frontMatter:{title:"E42-0704 - \xa9 SEMI 1995, 2004...",description:"SEMI\u6807\u51c6\u6587\u6863",sidebar_label:"E42-0704 - \xa9 SEMI 1995, 2004...",sidebar_position:360,tags:["SEMI","Standard"],custom_props:{source_type:"pdf",source_file:"semi-chapter-036.pdf",chapter:36,page_count:50}},sidebar:"standardsSidebar",previous:{title:"E40-0705 - \xa9 SEMI 1995, 2005...",permalink:"/semiconductor-docs/docs/standards/semi/semi-chapter-035"},next:{title:"E42-0704 - \xa9 SEMI 1995, 2004...",permalink:"/semiconductor-docs/docs/standards/semi/semi-chapter-037"}},c={},d=[{value:"CLASS/\xee",id:"class\xee",level:2},{value:"timestamp format.",id:"timestamp-format",level:2},{value:"Timestamp format.",id:"timestamp-format-1",level:2},{value:"characters.",id:"characters",level:2},{value:"characters.",id:"characters-1",level:2},{value:"characters.",id:"characters-2",level:2},{value:"80 characters.",id:"80-characters",level:2},{value:"80 characters.",id:"80-characters-1",level:2}],h={toc:d};function p({components:e,...t}){return(0,a.yg)("wrapper",(0,i.A)({},h,t,{components:e,mdxType:"MDXLayout"}),(0,a.yg)("p",null,'PdfDownloadCard\npdfLink="/pdfs/semi/036.pdf"\npdfSize="1.14MB"\ntitle="E42-0704 - \xa9 SEMI 1995, 2004..."\ndescription="SEMI\u6807\u51c6\u6587\u6863\uff0c\u517150\u9875"\n/'),(0,a.yg)("h1",{id:"\u6587\u6863\u6807\u9898"},"\u6587\u6863\u6807\u9898"),(0,a.yg)("p",null,'SEMI E42-0704 \xa9 SEMI 1995, 2004 20\nfor namespace   and   class,   and   there   are   rules   for\ndetermining the appropriate version.\nThe recipe name must always be specified.\nFor external  references  within  a  recipe,  the  default\nclass  is  the  class  of  the  recipe  making  the  reference.\nThe  proper  class  is  determined  when  the  recipe  is\nlinked (see Section 3.2.4.1.3).\nWhere a recipe version is unspecified, the recipe of that\nclass  and  name  having  the  highest  approval  level  will\nbe used. Where several recipes are found with the same\napproval level, the one with the highest version will be\nused.  Where  the  version  is  unspecified  in  an  external\nreference,  the  correct  version  is  determined  when  a\nlinked recipe set is built by the link operation.\nFor  references  with  managed  recipes,  if  no  namespace\nis  specified,  the  default  is  namespace  of  the  referring\nrecipe.\n3. 2.4  Advanced Recipe Capabilities\n3. 2.4.1  Multi-Part Recipes \xf3 Use of multi-part recipes\nis  often  dictated  by  the  recipe  executor,  which  may\nrequire  a  set  of  recipes  of  different  classes  for  its\nprocess.  In  addition,  support  for  multi-part  recipes  can\nbe  helpful  for  the  user,  in  particular  where  recipes  are\notherwise  long.  The  recipe  language  may  define  use  of\nsubrecipes  analogous  to  that  of  subroutines  in  ordinary\nprogramming   languages.   This   enables   better   re-use\nwhere   a   high   degree   of   similarity   exists   between\ndifferent recipes.\nWhere recipes of more than one class are required, it is\nconvenient  to  allow  one  recipe  to  reference  another.  A\nrecipe in the PROCESS class, for example, may refer to\nrecipes  in  other  classes  to  ensure  that  an  entire  set  of\nrecipes is executed together.\nIt  is  also  convenient  to  allow  one  recipe  to  reference\nother recipes within the same class, where a substantial\nset  of  instructions  and/or  settings  are  common  to  a\nvariety of other recipes.\nA reference within the body of one recipe to a different\nrecipe is called an external reference. The exact syntax\nin  which  this  is  done  is  determined  by  the  recipe\nlanguage used. An external  reference  may  also  specify\nvalues    for    variable    parameters    defined    in    the\nreferenced recipe or in one of its subrecipes.\n3. 2.4.1.1  Subrecipes  \xf3 When  one  recipe  references\nanother  recipe,  both  recipes  are  required  for  execution.\nThe starting recipe is called the main recipe.\nSubrecipes are those recipes that are referenced by the\nmain recipe, or by another subrecipe of the main recipe.\nA recipe that references other recipes is a parent recipe\nto  the  referenced  subrecipes.  A  parent  recipe  is  not\nnecessarily  a  main  recipe.  A  main  recipe  must  not  be\nreferenced by any of its subrecipes.\nExternal    references    to    recipes    within    the    same\nnamespace   may   or   may   not   be   explicit.   That   is,\nreferences  to  the  current  class  (i.e.,  the  class  of  the\nrecipe  being  verified)  may  be  implicit,  and  versions\nmay  be  left  to  the  rules  for  determining  the  default\nversion at link-time.\nA   recipe   may   also   reference   recipes   in   another\nnamespace.  This  occurs  either  when  a  recipe  is  to  be\ndelegated or when a recipe in a namespace accessed by\nmultiple agents  must  reference  a  hardware-dependent\nor   other   agent-specific   recipe   kept   in   a   default\nnamespace.   The   default   namespace   of   a   recipe\nexecutor  is  always  referenced  within  a  recipe  as  the\nnamespace  named  "Default".  This  name  is  interpreted\nby  the  recipe  executor  at  execution  time,  based  on  its\nattribute DefaultNamespace\n(see Section 6.3).\nWhen specified in a text string within a recipe with the\nsubrecipe\'s identifier,  the  identifier  is  preceded  by  the\nvalue  of  the  namespace\'s  identifier,  followed  by  a\ngreater-than   symbol   ">".   This   is   called   the   recipe\nspecifier. For a recipe ETCH version 5 in a namespace\nnamed "NS-MOM", this would be specified as\n\xecNS-MOM>/PROCESS/ETCH;5\xee.\nAccording  to  the  rules  of  OSS,  object  type  may  be\nomitted when it may be otherwise determined. In RMS,\ndetermination is made according to order.\n3. 2.4.1.2  Delegated Recipes \xf3 A recipe may reference\nrecipes in another namespace that are to be executed by\na component  agent  and  are  termed  delegated  recipes.\nAlthough   referenced   by   another   recipe,   delegated\nrecipes  are  not  considered  as  subrecipes  of  the  parent\n(referencing)  recipe  as  they  are  to  be  executed by  a\ndifference agent  and  are  themselves  required  to  be  a\nmain  recipe.  A  reference  to  a  delegated  recipe  is  the\nequivalent    to    an    automated    "select"    and    "start"\nsequence  of  commands  from  the  supervisor.  As  such,\nthey  are  generally  subject  to  the  constraints  of  a  select\noperation.\nDelegated recipes may or may not require the name of\nthe executing agent (recipe executor), depending on the\nrules  of  the  particular  implementation.  For  example,  a\nsupervisor  may  be  able  to  determine  the  appropriate\nexecuting  agent  at  run-time,  based  on  the  namespace\nspecified.  However,  the  ability  to  specify  a  particular\nexecuting  agent  is  important  to  the  user,  as  process\nresults   may   be   sensitive   to   a   particular   equipment\ninstallation.  Therefore,  recipe  languages  that  support\ndelegation  shall  allow  specification  of  the  particular\nexecuting  agent  to  be  used.  The  text  format  of  the  full\nrecipe specifier in this case is:'),(0,a.yg)("p",null,'SEMI E42-0704 \xa9 SEMI 1995, 2004 21\n\xecAgent-Name>Namespace-Name>CLASS/Name;Version\xee.\nThe required order of identifiers within the specifier is:\nagent, namespace, recipe.\n3. 2.4.1.3    Linked   Recipe   Sets   \xf3   Where   one   recipe\nreferences  another,  a  set  of  recipes  to  be  executed\ntogether  is  formed  by  starting  at  the  main  recipe  and\ncollecting  the  external  references  to  identify  all  the\nmembers  of  the  set.  This  set  is  called  a  linked  recipe\nset, and the operation of collecting the references is the\nlink operation.\n3. 2.4.2   Variable  Parameters  \xf3  Variable  parameters\nare  variables  that  can  be  assigned  values  from  outside\nthe  recipe  itself.  Variable  parameters  allow  recipes  to\nuse  variables  rather  than  constants  for  such  actions  as\nsetting  temperature  setpoints,  time  delay  intervals,  and\ndata-set  names.  This  capability  greatly  extends  the  re-\nusability of a recipe.\nA parameter  first  is  formally  defined  within  a  recipe\nbody   and   given   a   unique   parameter   name,   a\nparameter  initial  value  (default  value)  for  use  when\nthe  recipe  is  selected  for  execution,  unless  overridden.\nWhere   applicable,   the   definition   also   includes   a\nparameter  restriction  that  represents  one  or  more\nconditions  that  any  value  assigned  to  that  parameter  is\nrequired to satisfy to be valid.\nThe  syntax  for  parameter  definitions  in  recipe  bodies\nremains  unspecified,  so  long  as  it  conforms  to  the\nsyntax of the recipe language and contains the required\nelements.   Other   restrictions   concerning   the   use   of\nvariable  parameters  may  be  imposed  by  the  recipe\nexecutor\'s   supplier   through   the   specification   of   the\nrecipe language.\nThe parameter domain is the set of all possible values\nof  a  given  form  (see  Section  1.4.3)  that  fulfill  the\nconditions of the parameter restriction (if any).\nThe   form   need   not   be   included   in   the   parameter\ndefinition  declared  within  the  recipe  body,  but  rather\nmay  be  derived  by  the  recipe  executor  during  the\nverification   process   from   the   way   in   which   the\nparameter is applied within the recipe. If temperature is\nmaintained   internally   as   an   unsigned   integer,   for\nexample, those parameters that are used in the recipe to\nassign temperature setpoints and ranges would typically\nbe  required  by  the  supplier  of  the  executing  agent  to\nrepresent  unsigned  integers  as  well.  The  supplier  shall\ndocument  the  forms  and  valid  domains  for  each  of  the\nparameters that may be used as a variable parameter.\nNOTE:    The  parameter\'s  value  may  be  changed  from\nits initial (default) value within the text of a recipe, and\nit   may   also   be   set   as   an   "argument"   passed   to   a\nsubrecipe.  These  capabilities  are  a  function  of  the\nrecipe language and are beyond the scope of RMS.\nTwo  categories  of  parameters  are  defined:  numeric\nand non-numeric.\n3. 2.4.2.1   Numeric  Parameters  \xf3  Numeric  parameters\ninclude  all  parameters  that  can  take  on  any  numeric\nvalue  for  its  format  type  between  a  parameter  low\nlimit and parameter high limit.\nThe parameter  restriction  for  a  numeric  parameter  in\nany  of  the  attributes  that  store  parameter  definitions\nshall  be  a  text  string  that  conforms  to  one  of  the\nfollowing:\n\u2022 "(a,b)\n\uf8f0\uf8fb UNITS" the domain of numbers x such that\na<x<b\n\u2022 "(a, )\n\uf8f0\uf8fb UNITS" the domain of numbers x such that\na<x<+\u221e\n\u2022 "( ,b)\n\uf8f0\uf8fb UNITS" the domain of numbers x such that\n-\u221e<x<b\n\u2022 "UNITS"   the   domain   of   numbers   x   such   that\n-\u221e<x<+\u221e.\nwhere:'),(0,a.yg)("h1",{id:"1"},"1"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},'a  and  b  are  numeric  values  formed  from  the  digits\n"0"  through  "9",  the  plus  and  minus  signs  "+"  and\n"-",  the  period  ".",  and  the  letters  "E"  or  "e"  for\nfloating point numbers,')),(0,a.yg)("h1",{id:"2"},"2"),(0,a.yg)("ol",{start:2},(0,a.yg)("li",{parentName:"ol"},"\uf8f0\uf8fb represents optional  whitespace, and")),(0,a.yg)("h1",{id:"3"},"3"),(0,a.yg)("ol",{start:3},(0,a.yg)("li",{parentName:"ol"},'UNITS is a valid case-sensitive\nstring conforming to\nthe  Units  of  Measure  Identifiers  (see  SEMI  E5,\nSection 9).\nFor  example,  both  of  the  following  strings  are  valid:\n"(500,2000)\uf8f0\uf8fbdegC" and "(0,100)".\nTo  include  equality,  parentheses  are  replaced  by  the\nsquare  brace  "','["  and/or  "]','"  on  the  left  or  right  end,\nrespectively.    For    example,    "[a,b)"    represents    the\ndomain of numbers x such that a\u2264x<b.\nTo  specify  units  only,  with  no  restriction  on  range,  the\nlow  limit  may  be  set  to  -\u221e  and  the  high  limit  to  +\u221e.\nHowever,  the  low  and  high  limit  shall  not  exceed\nabsolute  minimum  and  maximum  limits  set  for  that\nparameter by the recipe executor\'s supplier.\nNumeric  parameters  with  no  parameter  restriction  are\npure numbers (with no units) with a domain of (-\u221e,\u221e).\nA numeric parameter shall have a format type of one of\nthe following:\n\u2022 text   string   of   a   length   of   no   more   than   80\ncharacters,\n\u2022 signed or unsigned integer of an even length,\n\u2022 floating point number of an even length.')),(0,a.yg)("p",null,'SEMI E42-0704 \xa9 SEMI 1995, 2004 22\nText  strings  are  restricted  to  the  character  set  defined\nabove to represent the low and high limits of the domain\nand   shall   convert   to   a   numeric   value   within   that\ndomain.\n3. 2.4.2.2  Non-Numeric Parameters \xf3 A non-numeric\nparameter   is   any   parameter   other   than   a   numeric\nparameter,  including  parameters  whose  domains  are\nsets of discrete numbers that cannot be represented by a\nsingle  mathematical  interval,  and  strings  that  represent\nnames. Non-numeric  values  may  or  may  not  place\nrestrictions on the replacement value. A parameter that\ncontains the name of a wafer map, for example, cannot\nbe   easily   restricted   by   a   general   rule\n7\n,   whereas   a\nparameter     that     contains     a     string     identifying\nthermocouple type can be restricted to one of a defined,\nunordered  set  of  valid  strings.  Restrictions  for  non-\nnumeric  parameters  might  also  consist  of,  or  include,\nlogical expressions that shall evaluate to TRUE before a\nvalue may be used.\nIf   a   recipe   language   has   been   defined   for   the\ncorresponding class   of   recipes,   the   syntax   for   the\nrestriction  is  taken  directly  from  the  formal  definition\nof  that  parameter within  the  body  of  a  source  form\nrecipe  (and  therefore  conforms  to  the  specification  for\nthat   recipe   language).   Otherwise,   the   restriction   is\nexpressed  in  a  syntax  defined  by  the  recipe  executor\'s\nsupplier specifically for parameter attributes.\nFor  example,  the  parameter  for  a  furnace  recipe  may\nspecify which set of PID values should be used, where\nsets   A-F   exist   on   the   equipment.   The   automatic\nrestriction   on   the   value   for   such   a   parameter,   as\nspecified  by  the  recipe  executor\'s  supplier,  might  be\n"{A,B,C,D,E,F}"   with   the   default   for   the   value\nspecified  as  the  character  "C"  with  a  format  type  of\n"ASCII string of length 1".\nIn another example, a restriction might be that the value\nbe taken from the enumerated set\n\xec{cassette,  lot    ,  batch    }\xee.\n3. 2.4.2.3  Agent-Specific   Parameters   \xf3 In   order   to\n"tune" a recipe so that it produces the same result on all\nrecipe  executors  of  the  same  type,  it  may  be  necessary\nto provide a different initial value for the parameter or\na    different    parameter    restriction    for    individual\nexecuting  agents.  A  special  editing  facility  may  be\nprovided  by  the  recipe  manager  to  allow  the  original\nvalue  and/or  restriction  of  a  parameter  to  be  modified\nfor a specific executing agent.'),(0,a.yg)("p",null,'7 Typically, the validity of parameters which are unrestricted names\ncan only be established at run-time.\nNOTE:    Agent-specific  parameter  definitions  replace\nthe  corresponding  original  definitions  in  the  recipe  that\nis downloaded to the recipe executor. At run-time, they\nare  superseded  by  parameter  values  specified  for  the\nrecipe executor\'s select operation.\n3. 2.5  Attributes  \xf3 The  name  of  an  attribute  is  a  text\nstring required to be unique for its object. The names of\nthe  attributes  defined  in  this  document  are  reserved  for\ntheir standard use.\nIdentification  attributes  are  those  used  to  identify  the\nobject  in  OSS.  These  attributes  are  available  through\nOSS, but in RMS, services are handled separately from\nthe other attributes and are not transferred in parameters\nfor "recipe attributes".\nAttributes   other   than   identification   attributes   and\nmandatory  attributes  discussed  below  always  have  a\ndefined default  value.  Attributes  with  a  default  value\nnot  otherwise  specified  are  considered  to  have  a  null\nvalue corresponding to their form as their default value.\nThe null  value  for  a  text  string  is  a  zero-length  string.\nThe null  value  for  a  numeric  form  is  zero.  The  null\nvalue for a boolean form is FALSE. The null value for\nan empty list or structure is an empty (zero-length) list.\nThe  manner  of  representing  null  values  is  left  to  the\nprotocol.\nAn  attribute  is  cleared  or  reset  by  setting  its  value  to\nthe default value.\nMandatory attributes are attributes that are required to\nalways have a non-default value.\nCertain attributes are required, including all mandatory\nattributes.  A  required  attribute  is  one  that  shall  be\nsupported  with  a  non-default  value.  For  example,  the\nBodyFormat\nattribute   is   required.   This   means   that\nobject  form  recipes  (for  which  BodyFormat\nhas  a  non-\ndefault value) shall be supported by a namespace.\nAny  attribute  defined  in  this  standard  shall  only  be\nmodified   according   to   the   rules   specified   for   that\nattribute.\nAttributes  of  the  managed  recipe  and  the  execution\nrecipe   may   be   accessed   through   Object   Services.\nHowever,  only  certain  of  the  attributes  may  be  set\nthrough Object Services.\nFor  purposes  of  OSS,  all  attributes  defined  in  RMS\nshall  be  recognized.  That  is,  a  response  to  a  GetAttr\nservice request that references any attribute of an object\ndefined  in  RMS  for  that  object  shall  not  return  an\n"invalid attribute" error. If the attribute is not supported\nby  the  application,  then  it  shall  show  the  value  of  that\nattribute  as  having  the  null  value  appropriate  for  its\nform, and it shall deny attempts to set its value through\nthe SetAttr service.'),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 23\n3. 2.5.1  Descriptors    \xf3 Two    types    of    mandatory\nattributes  of  particular  importance  are  the  timestamp\nand length  attributes.  These  are  provided  for  the  body,\nfor  each  agent-specific  dataset,   and   for   the   set   of\nattributes   of   the   recipe   object   itself,   including   the\ntimestamp and length attributes of the body.\nA descriptor   contains   the   length and timestamp\nattributes (in that order) of one or more of the aspects of\na  recipe:  its  attributes,  its  body,  or  an  agent-specific\ndataset. Descriptors  are  used  to  compare  two  recipes\nstored in different namespaces or in a namespace and in\nthe recipe execution area of a recipe executor.\nNOTE:    Provision  of  a  real-time  clock  or  other  device\ncapable   of   counting   time   in   centiseconds   greatly\nimproves    the    value    of    the    timestamps    for    this\ncomparison.\n3. 3   Full  and  Minimal  Recipe  Models  \xf3  Figure  3.5\ncontains   an   object   model   for   the   managed   and\nexecution   recipes   supporting   all   of   the   standard\nattributes defined in RMS. Non-identifier attributes are\nshown  in  alphabetical  order.  Many  of  these  attributes\nare  not  required  for  minimal  applications.  Minimal\nmodels  for  the  managed  and  execution  recipes  are\nshown in Sections 3.4.2.3 and 3.5.2, respectively."),(0,a.yg)("p",null,"Figure 3.5\nFull Recipe Object Model"),(0,a.yg)("p",null,'SEMI E42-0704 \xa9 SEMI 1995, 2004 24\n3. 4  Managed   Recipes   \xf3   This   section   defines   the\nmanaged recipe and its attributes.\n3. 4.1  Generic Attributes \xf3 For clarity, the attributes of\nthe managed   recipe   are   sometimes   called   generic\nattributes   to   distinguish   them   from   agent-specific\nattributes or attributes of the execution recipe.\nAttributes   that   are   not   specifically   defined   in   this\nstandard  may  be  defined  by  an  application  or  by  the\nuser. Attributes that are defined by a namespace or by a\nrecipe  executor  for  its  own  use  shall  be  changed  only\nby  rules  specified  and  documented  by  the  originator  of\nthe attribute.\nTo   prevent   conflict   between   non-standard   attribute\nnames  and  names  which  may  become  standard  in  the\nfuture, non-standard attribute names shall start with the\nprefix "UD_" (the two characters "U" and "D" followed\nby the underline character). It is the responsibility of the\noriginator  to  provide  unique  attribute  names.  When\nusing other RMS services, non-standard attributes shall\nfollow all standard attributes.\nIt is desirable that a method be provided for the user to\ndefine new attributes.\n3. 4.1.1        Timestamp       Attributes       \xf3       Timestamp\ninformation   (date   and   time   of   the   last   change)   is\nimportant  to  recipe  management.  Timestamp  attributes\nare maintained by the recipe namespace and may not be\nchanged otherwise.\nA timestamp attribute shall always contain the date and\ntime  that  the  particular  aspect  of  the  recipe  was  last\nchanged.  This  attribute  is  a  text  string  of  the  form\n"yyyymmddhhmmsscc"  for  the  year  yyyy,  the  month\nmm,  the  day  dd,  the  hour  hh,  the  minutes  mm,  the\nseconds ss, and the centiseconds cc.\nThe timestamp of the body is called EditTime\nand is set\nwhen a recipe is first created and updated whenever the\nbody is modified in any way.\nBecause  a  recipe\'s  attributes  may  be  changed  without\nchanging  the  body,  both  the  recipe\'s  generic  attributes\nand  each  set  of  agent-specific  attributes  themselves\neach   have   a   timestamp   attribute.   For   the   generic\nattributes,     the     timestamp     attribute     is     called\nAttrChgTime\n. The set of agent-specific attributes (of an\nagent-specific  dataset)  has  its  own  timestamp  attribute,\ncalled AgentSpec_ChgTime\n.\n3. 4.1.2  Length  Attributes  \xf3 There  are  three  length\nattributes, one which contains the length of body, one\nthat  contains  the  length  of  the  generic  attributes,  and\none   that   contains   the   length   of   the   agent-specific\nattributes. Length   attributes   are   calculated   without\nregard to either protocol overhead or storage overhead,\nsuch  as  proprietary  formats  used  for  internal  storage\nthat  may  change  from  one  implementation  to  another.\nThis  preserves  the  length  across  different  conventions\nused  for  recipe  storage  and  different  communications\nprotocol.\nThe length attribute of the body, BodyLength\n, contains\nthe length of the body in bytes. The length of the body\nis calculated as the number of bytes it will require when\ntransferred, excluding any overhead, such as that which\nmight be required for protocol format information.\nThe length of an individual\nattribute is calculated as the\nsum   of   the   lengths   of   the   attribute   name   and   the\nattribute value.\nThe  length  of  a  set\nof  attributes  shall  be  calculated  as\nthe  sum  of  the  lengths  of  the  individual  attributes  that\nare set to a non-default value at the time the calculation\nis  performed,  including  the  length  attribute  itself.  All\nattributes  set  to  their  default  value,  at  the  time  the\nlength  is  calculated,  are  excluded  from  the  calculation.\nThis  is  because  only  the  attributes  with  a  non-default\nvalue are transferred when a recipe is moved into or out\nof  a  namespace.  It  also  results  in  a  more  significant\nchange to value of the length attribute when an attribute\nis set to a non-default value.\n3. 4.1.3  Descriptors \xf3 The descriptors of the managed\nrecipe   are   the   body   descriptor   (BodyLength\nand\nEditTime\n),      the      generic attribute      descriptor\n(AttrLength\nand  AttrChgTime),  and  the  agent-specific\ndescriptor (AgentSpec\n_AttrLength               and\nAgentSpec\n_ChgTime).  The  recipe  descriptor  for  a\nmanaged recipe consists of the attribute descriptor, the\nbody descriptor (in that order), followed by descriptors\nof any existing agent-specific datasets.\n3. 4.2   Managed  Recipe  Object  Attribute  Definitions  \xf3\nThis  section  provides  the  formal  definitions  for  the\nrecipe\'s generic attributes. For Object Services, a recipe\nis  considered  as  the  owner  of  its  components,  any\nagent-specific  datasets.  The  body  may  not  be  accessed\nthrough Object Services.\nAttributes  in  Tables  3.1  and  3.2  are  presented  in  the\nfollowing order:\n\u2022 identification  attributes,  including  object  type  and\nidentifier, appearing above the heavy line in Tables\n3. 1 and 3.2,\n\u2022 mandatory attributes   and   the   other   required\nattributes, in the order in which they are to appear\nwhen a recipe is transferred,\n\u2022 optional attributes in alphabetical order, and\n\u2022 non-standard attributes, which are transferred last.'),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 25\nWhen transferring a recipe with RMS services, identification attributes are not included in the list of attributes, and\nrequired attributes are sent, in order, before optional attributes. Non-mandatory attributes having their default value\nare not transferred, since their absence indicates their value, but they are always available through Object Services.\nOrder of optional attributes is not dictated.\n3. 4.2.1 Generic  Attribute  Definitions  \xf3  Table  3.1  provides  the  formal  definition  of  the  generic  attributes  of  the\nmanaged recipe."),(0,a.yg)("p",null,'Table 3.1  Managed Recipe Attribute Definition\nAttribute Name Definition Access Rqmt Form\nIdentification Attributes\nObjType The object type. RO Y Text: "MRcp"\nObjID An identifier derived from Class, Name, and\nVersion. No part of a recipe\'s identifier shall be\nchanged except through renaming.\nRO              Y              Formatted              text.\nName A logical name assigned by the user when the recipe\nis created or renamed.\nRO              Y              Text.\nClass The recipe\'s class (e.g., "/PROCESS/" or\n"/PROCESS/LOADER/").\nRO              Y              Formatted              text:\n"CLASS/CLASS/../CLASS/"\nVersion The version of the recipe.                                                  RO                                                  Y                                                  Text.\nMandatory Attributes\nAttrLength The total length of the generic attributes, in bytes.\nMandatory.\nRO              Y              Unsigned              integer.\nAttrChgTime Timestamp of the last change to a generic attribute.\nMandatory.\nRO              Y              Formatted              text.\nBodyLength Length of the recipe\'s body, in bytes. Mandatory.            RO             Y            Unsigned            integer.\nEditTime Timestamp of when the body was created or last\nupdated. Mandatory.\nRO Y Formatted text.  Timestamp\nformat.\nRequired Attributes\nBodyFormat Indicates the form and format of the recipe\'s body.\nDefault is zero.\nRO              Y              Enumerated              unsigned\ninteger:\n0 = source,\n1 = object,'),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},"1 reserved.\nVerified Indicates whether the recipe's body is syntactically\ncorrect. Reset when the recipe is created or updated.\nDefault is FALSE.\nRO              Y              Boolean.\nLinked Indicates whether the recipe is linked. Reset when\nthe recipe is originated, verified, or unlinked.\nDefault is FALSE.\nRO              Y              Boolean.\nOptional Attributes\nApprovalLevel Indicates the level of approval assigned by an\nauthorized user. Default is zero. Reset when the\nrecipe is originated or linked. For a linked recipe,\nmay not be higher than any of its subrecipes.\nRW             N             Unsigned             integer.\nComments                   User                   comments.                   RW                   N                   Text. Maximum length is 80\ncharacters.\nEditedBy The name of the person who last edited the recipe. RO N Text. Maximum length is 40\ncharacters.\nEstRunTime The nominal or estimated execution (run) time of the\nrecipe, in seconds. Reset when the recipe is created\nor updated. Set when the recipe is verified. May be\nRW             N             Unsigned             integer.")),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 26\nAttribute Name Definition Access Rqmt Form\nrecalculated to total time for a main recipe when\nlinked. Used for scheduling purposes. Algorithm for\ncalculation shall be documented. Default is 0.\nExecChgCtrl Specifies change control requirements for recipe.\n(See Section 6.5.)\nRW N Binary. Bitwise (MSB =\n8",(0,a.yg)("strong",{parentName:"p"},").\n1 - The recipe body may be\nchanged,\n2 - Change notification is\nrequired,\n3 - Recipe may be selected\nafter change,\n4 - Most recent parameter\nsettings shall be saved.\nExtRef A list of all recipe specifiersas referenced within the\nrecipe. Explicit versions not required. Reset when\nthe recipe is created, updated, and verified.\nRO N List of formatted text.\nLinkList A complete list of recipe specifiers found in the\nExtRef\nattribute of a main recipe and all of its sub-\nrecipes, with duplicates removed and all versions\nexplicitly determined. Set for the main recipe when\nlinked\n. Reset when the recipe is originated or\nverified. Required for multi-part recipe support.\nRO N List of formatted text.\nLinkParam A list of all variable parameter definitions contained\nin the Parameters\nattribute of a main recipe and all of\nits subrecipes, with duplicates removed. Reset when\nthe recipe is created, updated, or verified. Set when\nthe recipe is linked. Required for variable parameter\nsupport.\nRO N Structure composed of\nparameter name, initial value,\nand restrictions.\nParameters A list of variable parameter definitions contained in\nthe recipe. Reset when the recipe is created,\nupdated, and verified. Set when the recipe is\nverified. Required only for variable parameter\nsupport.\nRO N Structure composed of\nparameter name, initial value,\nand restrictions.\nSrcRcpID Identifier of the source form recipe from which a\nderived object form recipe is derived. Value\ndetermined by the verifier of the recipe. Required\nonly for support of derived object form recipes.\nRO              N              Formatted              text.\nVerificationID Identification code set by the verifier of the recipe.\nMay be used to determine out-of-date formats that\nneed to be reverified.\nRO N Text. Maximum length is 40\ncharacters.\nUD_*                          Non-standard                          attribute                          defined by supplier or user.\nAsterisk indicates the part of the attribute name that\nis provided in this definition. Shall be preserved\nexactly except by the entity that defined it.\nRO N Varies with definition. Text\nform is limited to 80\ncharacters.\n"),' NOTE: SEMI E4 and E5 number bits 1\xf18, where Bit 8 = MSB (most significant bit).\n3. 4.2.2   Agent-Specific  Attribute  Definitions  \xf3  The  names  of  user-defined  attributes  shall  start  with  the  prefix\n"AgentSpec',(0,a.yg)("em",{parentName:"p"},"UD"),'" and shall be preserved without modification from transferred recipes. These attributes follow all\nstandard attributes when transferred.\nAn agent-specific  dataset  exists  only  if  an  agent-specific  attribute  other  than  the  timestamp  and  attribute-length\nattributes of the dataset itself have been set.'),(0,a.yg)("p",null,'SEMI E42-0704 \xa9 SEMI 1995, 2004 27\nTable 3.2 defines the attributes of the agent-specific dataset object.\nTable 3.2  Agent-Specific Dataset Object Attribute Definition\nAttribute Name Definition Access Rqmt Form\nObjType The object type. RO Y Text = "MRcpASDS"\nObjID The object\'s identifier. Contains the value in\nAgentSpec',(0,a.yg)("em",{parentName:"p"},"Agent\n.\nRO              Y              Text.\nAgentSpec_Agent The name of the executing agent to which the other\nattributes in the dataset apply. Mandatory.\nRO              Y              Text.\nAgentSpec_AttrLength   The length of the agent-specific attributes, in bytes.\nMandatory.\nRO              Y              Unsigned              integer.\nAgentSpec_ChgTime Timestamp of when an agent-specific attribute was last\nchanged. Mandatory.\nRO              Y              Formatted              text.\nAgentSpec_Comments   Comments specific to the agent entered by the author. RW N Text. Maximum length\nis 80 characters.\nAgentSpec_LinkParam   A list of variable parameter definitions modified from\nthe list in LinkParam\n. Valid only for a linked main\nrecipe. Parameter name and form may not be changed.\nRO N List of Structure\ncomposed parameter\nname, value, and\nrestrictions.\nCertified The certification-level for the specific agent, assigned\nby an authorized user. Reset when\nAgentSpec_LinkParam is modified. Required for\ncertification support.\nRW             N             Unsigned             integer.\nAgentSpec_UD"),"*           Non-standard           attribute           defined by the supplier or user.\nAsterisk indicates the part of the attribute name that is\nprovided in this definition. Must be preserved exactly\nexcept by the defining entity.\nRO N Varies with definition.\nText form is limited to\n80 characters.\n3. 4.2.3   Minimal  Managed  Recipe  \xf3  The  minimal  model  for  a  managed  recipe  is  shown  in  Figure  3.6.  Only\nrequired attributes are supported in this model. This model can only be used for single-part recipes in the dedicated\nnamespace, such as the default namespace required for stand-alone equipment. There are no agent-specific datasets."),(0,a.yg)("p",null,"Figure 3.6\nObject Model for Minimal Managed Recipe"),(0,a.yg)("p",null,'SEMI E42-0704 \xa9 SEMI 1995, 2004 28\n3. 5  Execution Recipes \xf3 The type of recipe handled by\na recipe  executor  is  called  an  execution  recipe.  This\ntype  of  recipe  has  attributes  and  a  body  but  does  not\nhave  an  agent-specific  dataset.  Most  of  the  generic\nattributes  of  the  managed  recipe,  and  certain  of  the\nagent-specific   attributes,   are   also   attributes   of   the\nexecution   recipe,   while   in   other   cases,   a   generic\nattribute and an agent-specific attribute are merged and\nplaced in a new execution recipe attribute.\nA managed  recipe is converted to an execution  recipe\nwhen  the  recipe  is  downloaded  to  the  recipe  executor,\nand  correspondingly,  an  execution  recipe  is  converted\nto  a  managed  recipe  when uploaded  from  the  recipe\nexecutor.\nThe execution recipe is defined in detail in Section 6.3.\n4  Recipe Namespace\nThis section defines the basic conceptual model for the\nrecipe  namespace,  a  logical  domain  for  recipe  storage\nand management, within which the identifier of a recipe\nis  guaranteed  to  be  unique.  The  model  in  the  current\nsection     is     applicable     to     implementations     with\ncentralized  storage.  Section  5  defines  an  extension  of\nthe basic model for a distributed recipe namespace.\nIn general, the term "namespace" refers to a domain of\nunique identifiers.  The  issue  of  namespace boundaries\nexists  for  all  object  types,  particularly  in  a  distributed\nenvironment,  and  is  not  unique  to  recipes.  However,\nwithin  the  context  of  RMS,  namespace is used as a\nsynonym for recipe namespace.\n4. 1  Motivations  \xf3 A  recipe\'s  identifier  may  not  be\nunique  across  different  namespaces  or  throughout  a\nfactory.  (That  is,  a  given  identifier  may  be  used  by\ninternally   different   recipes   except   within   a   single\nnamespace.) A primary role of a namespace is to define\nan area within which the uniqueness of any given recipe\nidentifier may be guaranteed.\nThe   requirements   for   Recipe   Management   that   are\naddressed in this section include:\n\u2022 to  define  the  boundaries  of  specific  areas  where\nrecipes  may  be  uniquely  identified,  stored,  and\nretrieved,\n\u2022 to  define  the  attributes   and   operations   for   the\nmanagement  domain  of  recipes,  including  recipe\nprotection and recipe operations,\n\u2022 to allow control of removable media,\n\u2022 to allow stand-alone equipment to execute recipes,\n\u2022 to   facilitate   smooth   integration   of   stand-alone\nequipment into on-line factory systems,\n\u2022 to   allow integrated equipment   to   continue   to\nexecute  recipes  when  communications  have  been\nlost, and\n\u2022 to  provide  the  basis  for  the  distributed  model  in\nSection  5,  which  allows  a  supervisor  to  use  and\nmanage  the  storage  capacity  of  its  subordinate\nagents.\n4. 2  Namespace Model \xf3 The namespace model serves\ntwo major purposes. First, it provides a common set of\nmanagement rules. Second, it allows a set of recipes to\nbe shared among a group of executing agents that have\na  common  process  type,  common  functionality,  and  a\ncommon recipe language.\nFigure 4.1 shows the basic namespace model with four\nobjects:  the  recipe,  the  namespace  itself,  a  namespace\ncomponent  called  recipe  namespace  segment,  and  a\nrecipe namespace manager.\nThe    recipe    namespace    manager    (or    manager)\nrepresents   the   interface   for   the   namespace   to   the\nexternal   world   and   the   internal   decision   authority\nwithin  the  namespace.  All  services  for  the  namespace\nand  its  recipes  are  provided  by  the  manager.  The\nnamespace  itself  is  passive.  While  it  has  important\nattributes,  the  namespace has  no  operations,  and  it\nprovides no services.\nThe    recipe    namespace    segment    (or    segment)\nrepresents  both  the  internal  storage  element  and  the\nactual  manipulation  of  recipes  within  the  namespace,\nunder  the  supervision  of  the  manager.  In  the  basic\nmodel,   it   also   provides   no   public   services.   The\nrelationship  between  the  segment  and  the  manager  in\nthis model is presumed to be internal to an application.\nFigure  4.1  represents  a  namespace  with  centralized\nstorage.  However,  it  can  easily  be  extended  to  the\ndistributed   recipe   namespace,   which   may   have\nmultiple segments, each provided by a different external\nagent.  For  that  case,  the  manager  and  segment  must\nprovide public services for one another.'),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 29"),(0,a.yg)("p",null,"Figure 4.1\nRecipe Namespace Model\nAll operations performed on a recipe through Recipe Management services are performed within the namespace by,\nor under the supervision of, the namespace manager, with two exceptions. A namespace manager is not required to\nunderstand the syntax of the recipe languages. For this reason, recipe editing (modifying a recipe's body) is not part\nof  the  namespace  definition,  and  verification  shall  be  provided  by  a  recipe  executor  of  an  appropriate  executing\nagent (see Section 6). These two activities require an in-depth understanding of the particular recipe languages used.\nTheir separation from the other activities allows generic namespace capabilities to be provided.\n4. 3   Namespace  Specifications  \xf3  The  combination  of  the  recipe  namespace,  its  segment  component,  and  its\nmanager provides storage, retrieval, and management of recipes conforming to RMS.\nA namespace  manager  is  responsible  for  maintaining  the  integrity  of  the  namespace,  the  integrity  of  the  recipes\nwithin  the  namespace,  and  the  integrity  of  the  recipe  identifiers.  It  understands  the  rules  regarding  recipes,  their\nattributes, and their components, and it is responsible for enforcing those rules. It will not allow a read-only recipe\nto  be  changed  or  deleted,  for  example.  Therefore,  it  will  not  accept  a  recipe  with  an  identifier  already  used  by  a\nread-only recipe.\nA namespace  has  no  restrictions  on  the  read  access  of  a  recipe  as  a  whole  or  of  its  attributes,  nor  is  it  concerned\nwith the uses to which they might be put outside the namespace. The ability for multiple agents to share the same\nrecipes  is  determined  solely  by  the  ability  of  the  agents  to  access  the  same  namespace.  Issues  of  security  and\nauthentication are beyond the scope of RMS.\nThe  term  recipe  namespace,  or  namespace,  is  used  inclusively  to  refer  to  those  attributes,  operations,  and  other\nrequirements  common  to  both  the  namespace  described  in  this  section  and  to  its  distributed subtype.  The  term\ncentralized  namespace  is  used  in  references  to  an  instance  (implementation)  of  the  basic  model  and  to  clarify\nstatements that do not apply to instances of the distributed subtype.\nA  centralized  namespace  is  analogous  to  a  single  directory  of  files,  where  duplicate  file  names  are  not  allowed.  It\nmay exist in several different configurations that are incidental to namespace requirements.\nIt  is  possible  to  provide  a  namespace  that  uses  removable  media  for  its  physical  storage.  Recipes  may  then  be\ntransferred to and from this namespace to any other namespace.\nIn  no  case  shall  it  be  possible  to  transfer  recipes  into  a  namespace  except  according  to  the  requirements  for\nnamespace management. For example, a read-only recipe may not be replaced.\nThe centralized namespace may be applied several ways. An agent with execution capabilities that may be operated\nin  stand-alone  mode  shall  provide  itself  with  a  centralized  namespace  to  be  used  when  operating  in  stand-alone\nmode.  Other  agents,  such  as  diskless  process  modules  in  a  cluster,  may  expect  to  rely  upon  the  namespace\ncapabilities provided by the cluster supervisor."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 30\n4. 4    Member   Agents   \xf3   A namespace   that   contains\nrecipes   used   by   multiple   agents is   called   shared.\nOtherwise, it is called dedicated or non-shared. Figure\n4. 2 illustrates two dedicated namespaces, one provided\nby  an  etcher  and  one  by  its  host.  This  terminology  is\nintroduced  for  clarification  and  descriptive  purposes\nonly."),(0,a.yg)("p",null,"Figure 4.2\nHost Backup of Equipment Namespace\nThe  Members\nattribute  of  the  namespace  contains  the\nnames  (object  identifiers)  of  the  agents  that  use  the\nrecipes  in  the  namespace,  and  these  agents  are  called\nmember  agents  (members)  of  the  namespace.  The\nnamespace manager uses  this  information  as  it  may\nrequire  assistance  from  a  member  agent  to  verify  a\nrecipe.\nIf  the  Members\nattribute  of  the  namespace contains\nmultiple agent names,  then  the  namespace  is  shared.\nOtherwise, it may be non-shared or not yet completely\nset up. If it is empty (null), the namespace has not been\ncompletely set up and is not fully functional, as certain\noperations,  including  recipe  verification,  require  it  to\nhave content.\n4. 5  Illustrations  \xf3 This  section  provides  illustrations\nof   several   possible   configurations   of   a   centralized\nnamespace.\nFigure  4.2  illustrates  an  etcher  that  has  its  own  local\nnamespace  and  that  communicates  with  its  supervisor\nover  an  RS-232  line.  The  supervisor  in  this  example\nmaintains  a  separate  namespace,  providing  backup  for\nrecipes of particular significance.\nFigure  4.3  illustrates  a  supervisor  with  four  diskless\nsubordinates.   In   this   configuration,   the   supervisor\nprovides   recipes   for   all   four   subordinates   from   a\ncentralized namespace."),(0,a.yg)("p",null,"Figure 4.3\nNamespace Provided by Supervisor\nFigure   4.4   illustrates   four   executing   agents   on   a\ncommon  network  with  a  supervisory  agent  and  a  sixth\nagent    providing    a    centralized    namespace.    Each\nexecuting   agent   is   able   to   access   the   namespace\nindependently of the supervisor."),(0,a.yg)("p",null,"Figure 4.4\nShared Network Access\nFigures  4.3  and  4.4  both  represent  examples  of  shared\ncentralized namespaces.\n4. 6  Attribute Definition Tables \xf3 Table 4.1 defines the\nattributes of the recipe namespace."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 31"),(0,a.yg)("p",null,'Table 4.1  Recipe Namespace Attribute Definition\nAttribute Name Definition Access Rqmt Form\nObjType The object type. RO Y Text = "RNS"\nObjID                    The                    name of the namespace. RO Y Text. A name of "Default" is\nprohibited.\nRecipeReadOnly-\nLevel\nThe level of approval at which recipes are read-only.              RW              Y              Unsigned              integer.\nMembers               The               names of agents capable of verifying and executing\nthe recipes in the namespace.\nRW             Y             List             of             agent names\n(identifiers).\nSynchOn Level of synchronization (see Section 9.5). Required if\nsynchronization is supported.\nRW N Unsigned integer:\nEither 0 = Disabled, or any\ncombination (sum) of:\n1 = changes in body\n2 = new execution recipe\n8 = changes in last value\n16 = new derived object\nform execution recipe\nSynchFail              Specifiers              for              execution recipes for which an attempt to\nsynchronize failed. Required if synchronization is\nsupported.\nRW N List of formatted text.'),(0,a.yg)("p",null,'Table 4.2 defines the attributes of the recipe namespace manager objects.  The  name (identifier) of the manager  is\nnot  generally  of  interest,  as  the  namespace  specifier  is  more  commonly  used.  However,  it  is  important  for  the\nmanager to be accessible through Object Services.\nTable 4.2 Recipe Namespace Manager Attribute Definition\nAttribute Name Definition Access Rqmt Form\nObjType The object type. RO Y Text = "RNS_Mgr"\nObjID                        The                        manager\'s name. RO Y Text.\nNamespaceName      The      name of the namespace managed. RO Y Text.'),(0,a.yg)("p",null,'5  Distributed Recipe Namespace\nA distributed  recipe  namespace  is  a  recipe  namespace  that  utilizes  the  storage  capacity  of  multiple  agents  for\nrecipe  storage.  Recipes  are  stored  in  special  recipe  namespace  segments  provided  by  the  different  agents.  These\nsegments  are  distributed  recipe  namespace  segments  and  are  supervised  by  the  distributed  recipe  namespace\nmanager.\nThis  section  defines  the  different  objects  that  together  provide  the  distributed  recipe  namespace  capability:  the\ndistributed  recipe  namespace,  the  distributed  recipe  namespace  manager,  the  distributed  recipe  namespace\nsegment,  and  the  distributed  recipe  namespace  recorder.  Detailed  descriptions  of  operations  are  contained  in\nSection 10.\nThroughout  this  document,  the  acronym  DRNS  refers  to  the  term  "distributed  recipe  namespace"  and  is  used\nprimarily to differentiate a DRNS subtype object from its supertype.\n5. 1  Motivations \xf3 The distributed recipe namespace capability provides a method for using the storage capacity of\nmultiple agents, as illustrated in Figure 5.1. This reduces the storage requirements of a centralized factory system,\nimproves performance by allowing recipes to be used by those agents, and provides a centralized management of the\nnamespace to ensure that the uniqueness of the recipe identifier is properly maintained.'),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 32\nFigure  5.1  illustrates  a  distributed  recipe  namespace  with  four  segments,  each  provided  by  a  different  agent,  and\neach agent also having a local namespace."),(0,a.yg)("p",null,"Figure 5.1\nIllustration of Agents, Segments, and Local Namespaces"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 33\n5. 2  Overview \xf3 The DRNS object model (Figure 5.2) is a specialization of the model introduced in Section 4. The\ndistributed recipe namespace, the DRNS segment, and the DRNS manager are subtypes of the recipe namespace, the\nrecipe  namespace  segment,  and  the  recipe  namespace  manager  respectively.  Each  inherits  the  attributes  and\noperations of its corresponding supertype. Only those attributes and operations that are specific to the DRNS types\nare shown in object representations."),(0,a.yg)("p",null,"Figure 5.2\nDistributed Recipe Namespace Model"),(0,a.yg)("p",null,"The namespace supertype has exactly one segment of storage. Where storage is centralized, the segment is internal\nand  private  to  the  namespace.  However,  in  the  case  of  the  distributed  recipe  namespace,  there  may  be  multiple\nDRNS segments, each provided by a separate agent. For this reason, the DRNS segment is a standardized object.\nThe distributed recipe namespace separates the management of recipes within a specific recipe storage area from the\nmanagement  of  the  entire  namespace.  The  management  of  individual  recipes  within  a  specific  storage  area  is\ndelegated  to  the  distributed  recipe  namespace  segment.  The  distributed  recipe  namespace  manager  manages  the\nvarious segments  and  the  namespace  itself.  The  manager  is  responsible  for  knowing  the  identifiers  of  all  recipes\nstored in the entire namespace. It requires a knowledge of the structure of the recipe's identifier and the significance\nof the version in differentiating between recipes of the same name and different versions.\nThe DRNS recorder provides a backup facility for information required to automate the rebuilding of a distributed\nrecipe namespace. It is external to the DRNS namespace and to its DRNS manager."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 34\n5. 3    Distributed   Recipe   Namespace   Issues   \xf3   This\nsection  introduces  issues  that  are  applied  to  more  than\none  object  within  the  distributed  recipe  namespace\ncapability.\n5. 3.1  Object  Services  \xf3  Attachment  is  a  relationship\nbetween  a  managed  object  and  its  manager  that  is\ndefined   in   OSS   (SEMI   E39).   One   object   may   be\nattached, detached, and reattached to a manager. When\nattached,  the  managed  object  is  able  to  recognize  that\ncertain  critical  services  have  been  requested  by  its\nmanager.   The   segment   and   recorder   objects   shall\ncomply   with   requirements   for   the   operations   and\nservices  defined  in  SEMI  E39  (OSS)  to  attach,  detach,\nand  reattach  to  and  from  a  DRNS  manager.  They  shall\nalso allow their manager to modify specified attributes\nthat are otherwise read-only.\nThe ability to create and delete a segment or recorder is\noptional.\nThe authorized  user  may  request  a  DRNS  manager  to\nattach or detach a specified segment or recorder.\n5. 3.2  Logical  Recipe  \xf3  A  logical  recipe  is  defined  as\na  recipe  with  a  specific  body  and  a  specific  set  of\ngeneric  attribute  values.  Every  managed  recipe  stored\nis an instance of a logical recipe.\nIn  a  distributed  recipe  namespace,  it  is  normal  for\ninstances  (copies)  of  a  given  logical  recipe  to  exist  in\nmore  than  one  DRNS  segment  at  any  time.  In  other\nwords,  multiple  duplicate  copies  of  a  recipe  with  the\nsame identifier   may   co-exist   within   the   distributed\nrecipe   namespace.   To   retain   the   integrity   of   the\nnamespace,  this  can  be  allowed  if,  and  only  if,  each\ncopy of a recipe with a given identifier is an instance of\nthe  same  logical  recipe.  It  is  the  responsibility  of  the\nDRNS   manager   to   ensure   this   logical   identity   is\nmaintained.\nAgent-specific    datasets    are    not    included    in    the\ndefinition of the logical recipe because multiple agent-\nspecific   datasets   may   exist   independently   of   one\nanother,  and  only  the  dataset  specific  to  the  agent\nproviding  the  DRNS  segment  is  normally  kept  in  that\nsegment.\n5. 3.3  Change  Requests  \xf3  A  change  request  occurs\nwhenever a user, an external application, or an attached\nDRNS segment requests the DRNS manager to make, or\npermit, any change in a recipe. Information concerning\nchange  requests  is  kept  in  the  form  of  logical  change\nrequest  records.  Once  a  change  request  is  made,  a\nchange  request  record  is  created  and  maintained  until\nthe  change  has  been  either  completed  or  discarded.\nBecause the information represented by change request\nrecords  is  publicly  available,  they  provide  a  degree  of\ndiagnostic capability.\nThe change   request   record   is   not   a   formal   or\nstandardized  object,  but  it  represents  the  information\nthat is available through services.\nChange  management  is  the  most  critical  issue  of  the\nDRNS  capability  and  is  discussed  in  detail  in  different\nsections below.\n5. 4   Distributed  Recipe  Namespace  Segment  \xf3  The\ndistributed recipe namespace segment (Figure 5.3) is\nresponsible   for   all   of   the   activities   that   directly\nmanipulate    recipes,    including    storage,    retrieval,\ndeletion, and operations that change a recipe's attributes\nor body.  This  requires  a  micro-level  knowledge  of  the\nrecipe's identifier,  its  structure,  the  inter-relationships\nbetween the various recipe attributes, how the recipe is\nstored,  and  how  it  is  transferred.  It  also  includes  a\nmacro-level  knowledge  of  all  of  the  identifiers  of  the\nrecipes  that  it  has  stored.  The  DRNS  segment  shall\nensure that only one recipe with a given identifier exists\nwithin   that   DRNS   segment.   The   contents   of   an\nunattached DRNS segment shall be read-only.\nA DRNS  segment  and  its  storage  are  provided  by  an\nagent,   which   could   be   equipment,   an   independent\n\xecrecipe server\xee, or other factory systems."),(0,a.yg)("p",null,"Figure 5.3\nDistributed Recipe Namespace Segment\n5. 4.1   Master  and  Dedicated  Segments  \xf3  A  master\nsegment  is  a  specialization  of  a  DRNS  segment  that  is\ncapable  of  storing  multiple  agent-specific  datasets  per\nrecipe. Master  segments  are  not  dedicated  to  a  single\nequipment  and  are  used  to  store  a  full  copy  (including\nall   existing   agent-specific   datasets)   of   all   logical\nrecipes  within  the  namespace.  It  is  required  that  every"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 35\ndistributed  recipe  namespace  manager  be  capable  of\nsupporting   at   least   one   attached   master   segment.\nAdditional master   segments   may   be   desirable   for\nfurther backup protection.\nThe   term   dedicated   segment   is   used   to   refer   to\nsegments   that   are   not   master   segments. Dedicated\nsegments  store  at  most  one  agent-specific  dataset  per\nrecipe.    Because    a    DRNS    segment    provided    by\nequipment  would  not  expect  to  keep  agent-specific\ndatasets for other equipment, equipment normally does\nnot provide master segment capability.\nMaster    and    dedicated    segments    have    the    same\nattributes  and  support  the  same  message  services,  but\nthey  respond  differently  to  agent-specific  datasets  and\nare  used  for  different  purposes.  A  master  segment\nrequires  approval  prior  to  changing  an  agent-specific\ndataset.\n5. 4.2  Change  Restrictions  \xf3  The  DRNS  segment  may\nprovide access to recipes within its storage to the other\ncomponents   of   the   agent   providing   the   storage.\nHowever, neither the generic attributes nor the body of\nrecipes  stored  by  the  segment  shall  be  changed  except\nwith  the  explicit  approval  of  the  distributed  recipe\nnamespace manager.\nDedicated DRNS segments that are attached to a DRNS\nmanager  may  change  the  contents  of  an  agent-specific\ndataset  without  first  asking  permission.  However,  they\nare  required  to  notify  the  manager  of  any  change  as\nsoon as it occurs.\nThe attribute RecipeReadOnlyLevel\nis set by the DRNS\nmanager  to  the  value  of  the  corresponding  namespace\nRecipeReadOnlyLevel\nattribute  when  the  segment  is\nfirst  attached  and  whenever  the  namespace  attribute  is\nchanged.  This  attribute  has  the  same  function  as  the\nnamespace attribute and allows the segment to prohibit\nchanges based on a recipe's approval level as defined in\nSection  8.2.5.  For  example,  the  segment  shall  deny\nrequests to modify a write-protected recipe.\nThe DRNS  segment  is  prohibited  from  changing  its\ncontents  whenever  it  is  unattached.  However,  recipes\nand  recipe  attributes  may  be  read  at  any  time  by  other\nentities,   including   other   components   of   the   owner\nagent.\nAny  changes  to  a  logical  recipe  stored  by  the  DRNS\nsegment  shall  first  be  approved  by  the  DRNS  manager\nbefore\nthe change is made. This includes any changes to\nthe body or to any generic attribute. This is required for\ntwo  reasons.  First,  two  different  DRNS  segments  may\nattempt  to  change  a  recipe  at  the  same  time,  and  this\nactivity  must  be  coordinated.  Second,  to  protect  the\nintegrity   of   the   recipe   identifier   where   multiple\ninstances   of   a   recipe   exist,   the   distributed   recipe\nnamespace  is  required  to  ensure  that  all  such  instances\nhave   been   updated   appropriately   with   that   change\nbefore other changes to the same recipe are allowed.\nNOTE:  The  prohibition  against  unauthorized  change\ndoes  not  preclude  the  saving  of  such  changes  external\nto  the  DRNS  segment  while  waiting  for  authorization.\nHowever,  changes  made  by  other  DRNS  segments,\nsubsequent  to  such  changes  and  prior  to  authorization,\nmay invalidate these changes.\nCommunications  between  the  different  components  of\nan agent  that  do  not  require  or  use  the  formal  services\ndefined  by  RMS  are  considered  as  proprietary  to  the\nagent  and  are  neither  covered  nor  excluded  by  RMS,\nsubject to the above restrictions against change."),(0,a.yg)("p",null,"Figure 5.4\nDistributed Recipe Namespace Recorder\n5. 5   Distributed  Recipe  Namespace  Recorder  \xf3  The\ndistributed  recipe  namespace  recorder  provides  a\nmethod of externally storing and retrieving information\ncritical    to    automated    rebuilding    of    a    damaged\ndistributed  recipe  namespace.  It  contains  two  types  of\ninformation:  a  list  of  the  DRNS  segments  that  are\nattached  to  the  DRNS  manager  and  the  current  change\nrequest record in process per recipe.\nA DRNS recorder may be attached and detached from a\nDRNS   manager,   and   reattached   to   that   manager.\nInformation  that  it  contains  is  available  to  anyone  but\nmay only be changed by its manager.\nThe DRNS recorder is able to store the DRNS segment\nspecifiers  (the  object  specifiers)  of  the  attached  DRNS\nsegments  in  its  Segments\nattribute.  This  information\nallows    a    distributed    recipe    namespace    to    be\nautomatically rebuilt in the event that the namespace, or"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 36\nthe DRNS  manager,  is  damaged  and  its  information\nbecomes lost or unavailable.\nThe DRNS  recorder  is  also  used  to  store  the  current\nchange  request  per  recipe,  to  delete  a  change  request,\nand to return the set of change requests for one or more\nrecipes.  The  attribute  LockedRecipes\nprovides  a  list  of\nidentifiers for recipes with change requests.\nThe DRNS  manager  shall  use  the  services  of  a  DRNS\nrecorder  when  one  is  attached  to  the  namespace  by  a\nservice user. However, use (attachment) of a recorder is\noptional  for  the  user.  The  DRNS  recorder  is  provided\nfor  remote  storage  of  critical  information  and  is  not\nintended as a general source of information for the user.\nIt   is   not   able   to   provide   inactive   change   request\ninformation."),(0,a.yg)("p",null,"Figure 5.5\nDistributed Recipe Namespace\n5. 6      Distributed     Recipe     Namespace     Management\nInformation  \xf3  The  DRNS management  information\nobject is private and proprietary to the DRNS manager.\nIt  is  included  in  Figure  5.2  as  an  emphasis  on  the\nimportance  of  the  information  that  a  DRNS  manager\nrequires  for  management.  This  includes,  but  is  not\nlimited to, the recipe identifiers stored in each attached\nsegment and all existing change request records.\nThe DRNS manager is required to know the contents of\nall of its attached segments at all times. It shall be able\nto uniquely identify each instance of a recipe within the\ndistributed   recipe   namespace.   It   is   responsible   for\ntracking  the  current  status  of each instance of a logical\nrecipe  within  the  distributed  recipe  namespace  when  a\nchange to a recipe within one segment is being updated\nto other segments. The DRNS management information\nis important for these purposes.\n5. 7   Distributed  Recipe  Namespace  \xf3  The  distributed\nrecipe  namespace  has  three  additional  attributes,  as\nshown  in  Figure  5.5,  that  are  read-only,  set  by  the\nDRNS  manager.  The  attribute  Segments\ncontains  a  list\nof the object specifiers of the DRNS segments currently\nattached.  The  attribute  Recorder\ncontains  the  object\nspecifier  of  an  assigned  DRNS  recorder.  The  attribute\nLockedRecipes\ncontains  a  list  of  recipe  identifiers  of\nrecipes with existing change request records.\n5. 8   Distributed  Recipe  Namespace  Manager  \xf3  The\ndistributed  recipe  namespace  manager  (Figure  5.6)  is\nresponsible   for   ensuring   that   the   distributed   recipe\nnamespace  and  DRNS  segments  operate  together  and\nfor  maintaining  namespace  integrity  as  a  whole.  It  is\nrequired  to  know  the  identities  of  its  attached  DRNS\nrecorder  and  DRNS  segments  and  the  contents  (recipe\nidentifiers) of each attached DRNS segment at all times."),(0,a.yg)("p",null,"Figure 5.6\nDistributed Recipe Namespace Manager\nThe  current  attachments  of  the  DRNS  manager  are\nmaintained in the DRNS namespace attributes Recorder"),(0,a.yg)("p",null,"and  Segments\nand  through  the  services  of  the  DRNS\nrecorder  described  in  Section  5.5.  Whenever  a  DRNS\nsegment  is  attached,  the  DRNS  manager  shall  add  the\nsegment  specifier  to  the  namespace  attribute  Segments"),(0,a.yg)("p",null,"and   to   the   current   list   maintained   by   the   DRNS\nrecorder.  Whenever  a  DRNS  segment  is  detached,  the\nDRNS  manager  shall  remove  its  specifier  from  the\nSegments\nattribute and from the DRNS recorder's list.\nThe DRNS  manager  is  able  to  know  which  recipes  are\nstored  in  each  DRNS  segment  through  use  of  Object\nServices   provided   for   or   by   the   individual   DRNS\nsegments.   It   shall   maintain   the   integrity   of   the\nnamespace  through  ensuring  that  an  identifier  of  any\nrecipe  stored  within  the  namespace  represents  exactly\none logical   recipe.   This   is   achievable   because   the\nmanager  must  give  explicit  approval  of  any  change  of\nlogical recipes (generic attributes or body) stored by the\nDRNS segments."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 37\nFigure 5.7\nChange Request Record\n5. 8.1  Change Management \xf3 A change request occurs\nwhenever  a  user  or  an  attached  segment  requests  the\ndistributed  recipe  namespace  manager  to  make,  or\npermit,  a  specific  type  of  change.  A  change  request\nrecord  (Figure  5.7)  contains  information  about  who\nrequested   what   type   of   change.   This   allows   later\ndiagnostics when necessary.\nA change   request   record   is   created   for   a   recipe\nwhenever an attached DRNS segment requests a change\nand  is  deleted  when  the  requested  change  has  been\ncompleted  or  discarded.  A  change  request  is  either\ninactive or active. Once a change request is made, it is\nconsidered   as   inactive   until   the   change   has   been\napproved  by  the  DRNS  manager.  Once  approved,  it  is\nconsidered as active.\nThe change request record is not a standardized object\nand  is  not  accessed  directly  through  public  services.\nHowever,  the  information  represented  by  the  change\nrequest  record  shall  be  available,  upon  request,  from\nthe DRNS  manager  for  all  inactive  and  active change\nrequests.  For  this  reason,  it  is  convenient  to  model  the\nchange request record as an object.\nA  recipe  for  which  a  change  request  exists  is  called\nlocked. Otherwise, it is unlocked.\nThe DRNS  manager  is  responsible  for  ensuring  that\nonly  one  change request  per  recipe  is  active  at  any\ntime. The results of each approved change request shall\nbe  updated  appropriately  to  each  of  the  other  DRNS\nsegments with a copy of the same logical recipe before\na subsequent change to the recipe is approved.\n5. 9 Building  a  Distributed  Recipe  Namespace  \xf3  A\ndistributed  recipe  namespace  is  built  up  in  several\nstages.   The   distributed   recipe   namespace   and   its\nassociated DRNS manager are created separately in the\nfirst  stage.  The  individual  DRNS  segments  are  first\ncreated  and  then  attached  to  the  DRNS  manager.  At\nleast one DRNS segment must be attached to the DRNS\nmanager before it can accept recipes, as the distributed\nrecipe namespace has no other means of storage. Figure\n5. 8 illustrates the attachment relationship."),(0,a.yg)("p",null,"Figure 5.8\nThe Attachment Relationship\nThe  attached  DRNS  segments  may  later  be  detached\nfrom  the  namespace  and  then  either  attached  again  to\nthe   same   namespace   or   to   a   different   namespace\nwithout  affecting  the  recipes  stored  within  the  DRNS\nsegment.\nNOTE: When a DRNS segment with existing recipes is\ndetached and then attached to a different namespace, its\nrecipe identifiers  fall  within  the  domain  of  the  new\nnamespace.   This   may   require   some   recipes   to   be\nrenamed before the attach process is complete.\n5. 10     Rebuilding    a    Damaged    Distributed    Recipe\nNamespace  \xf3  A  distributed  recipe  namespace,  or  its\nmanager,  may  become  damaged  or  unavailable.  If  a\nDRNS  recorder  was  attached  to  the  damaged  name-\nspace, then rebuilding the namespace can be automated.\nA  new  distributed  recipe  namespace  and  new  DRNS\nmanager are   created,   assigning   the   old   namespace\nname   as   the   object   identifier   ObjID\nfor   the   new\nnamespace.   The   new   DRNS   manager   should   be\nassigned  a  different  identifier,  however,  as  a  security\nmeasure.  The  user  may  then  request  the  new  DRNS\nmanager  to  rebuild  the  namespace  with  the  old  DRNS\nrecorder.  A  namespace  may  also  be  rebuilt  without  a\nrecorder   if   the   list   of   segment   specifiers   can   be\nprovided by the user. However, the user is not expected\nto  provide  the  information  retained  through  change\nrequest records.\n5. 11  Object Attribute Definition Tables \xf3 This section\ncontains    the    formal    attribute    definitions    for    the\ndistributed recipe namespace capability. Except for the\nobject    identifier    attributes,    attributes    are    listed\nalphabetically.\nDRNS\nManager\nDRNS\nSegment\nDRNS\nRecorder\nis attached to\nis attached to"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 38\nObjects  that  are  subtypes  of  objects  introduced  in  Section  4  inherit  the  attributes  of  the  supertype  objects.  These\nattributes are not repeated in this section.\n5. 11.1  Distributed Recipe Namespace Segment Attribute Definition \xf3 Table 5.1 defines the attributes required for a\ndistributed recipe namespace segment, and Table 5.2 defines the attributes of the subtype master segment."),(0,a.yg)("p",null,"Table 5.1  Distributed Recipe Namespace Segment Attribute Definition\nAttribute Name Description Access Rqmt Form\nObjType The object type. RO Y Text = \xecRNSDSegment\xee\nObjID The object name (identifier). RO Y Text.\nNamespace The name (ObjID) of the namespace to which the\nsegment belongs. May be set by the manager.\nRO              Y              Text.\nNamespaceManager       Identifies       the       distributed recipe namespace manager.\nMay be set by the manager.\nRO              Y              Text.\nRecipeReadOnlyLevel    Used to track the corresponding attribute of the\nnamespace to which the segment belongs. May be set\nby the manager.\nRO              Y              Unsigned              integer."),(0,a.yg)("p",null,"Table 5.2  Distributed Recipe Namespace Master Segment Attribute Definition\nAttribute Name Description Access Rqmt Form\nObjType The object type. RO Y Text = \xecRNSDMaster\xee\nObjID The object name (identifier). RO Y Text."),(0,a.yg)("ol",{start:5},(0,a.yg)("li",{parentName:"ol"},"11.2  Distributed Recipe Namespace Recorder Attribute Definition \xf3 Table 5.3 defines the attributes required for\na distributed recipe namespace recorder.")),(0,a.yg)("p",null,"Table 5.3  Distributed Recipe Namespace Recorder Attribute Definition\nAttribute Name Description Access Rqmt Form\nObjType The object type. RO Y Text = \xecRNSDRecorder\xee\nObjID                              Text.                              RO                              Y                              Text.\nLockedRecipes               List               of               identifiers of recipes with existing change\nrequest records.\nRO Y List of formatted text.\nNamespace                      Identifies                      the                      namespace to which the recorder is\nattached. May be set by the manager.\nRO              Y              Text.\nNamespaceManager       Identifies       the       distributed recipe namespace manager.\nMay be set by the manager.\nRO              Y              Text.\nSegments                        List                        of                        specifiers of currently attached segments. RO Y List of formatted text."),(0,a.yg)("ol",{start:5},(0,a.yg)("li",{parentName:"ol"},"11.3  Distributed  Recipe  Namespace  Attribute  Definition  \xf3  Table  5.4  defines  the  attributes  required  for  a\ndistributed recipe namespace.")),(0,a.yg)("p",null,"Table 5.4  Distributed Recipe Namespace Attribute Definition\nAttribute Name Description Access Rqmt Form\nObjType The object type. RO Y Text = \xecRNSD\xee\nObjID                              Text.                              RO                              Y                              Text.\nLockedRecipes A list of identifiers of all recipes with existing change\nrequest records.\nRO Y List of formatted text.\nRecorder                         The                         recorder specifier of the attached distributed\nrecipe namespace recorder.\nRO              Y              Text.\nSegments A list of specifiers of the distributed namespace\nsegments attached to the namespace.\nRO Y List of formatted text."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 39\n5. 11.4  Distributed Recipe Namespace Manager Attribute Definition \xf3 Table 5.5 defines the attributes required for\na distributed recipe namespace manager."),(0,a.yg)("p",null,"Table 5.5  Distributed Recipe Namespace Manager Attribute Definition\nAttribute Name Definition Access Rqmt Form\nObjType The object type. RO Y Text = \xecRNS_MgrD\xee\nObjID                              The                              manager\xeds name. RO Y Text.\n6  Recipe Executor\nThis section describes the basic concepts for the recipe executor and the execution recipe that it stores.\nThe recipe executor is the component of an executing agent that reads and comprehends the contents of a recipe (its\nbody)  and  puts  into  effect  its  instructions,  settings,  and/or  other  data.  The  object  model  of  the  recipe  executor  is\nshown in Figure 6.1."),(0,a.yg)("p",null,"Figure 6.1\nRecipe Executor\nThe  recipe  executor  is  able  to  temporarily  store  recipes  for  execution  purposes,  and  it  may  also  be  able  to  store\nexecution recipes for later execution.\nThe execution process is beyond the scope of RMS.\n6. 1  Motivations  \xf3  Specification  of  the  recipe  executor  and  the  execution  recipe  that  it  stores  is  necessary  to\ncomplete  the  management  of  recipes  in  the  factory.  The  recipe  executor  provides  limited  storage  for  recipes  and\nminimum capability to manage them. The storage provided is intended to be temporary only.\nSome recipe executors have the ability to purposefully change a recipe's body or create new recipes. To ensure that\nexecution  recipes  remain  synchronized  with  the  managed  recipes  in  a  recipe  namespace,  additional  rules  are\nrequired for such cases.\nThe requirements for RMS that are addressed by the recipe executor include the following:\n\u2022 The ability to create, edit, and change recipes outside the executing agents that execute them,\n\u2022 The ability for executing agents to use recipes developed externally,\n\u2022 The ability to share recipes among equipment of the same type,\n\u2022 Protection  of  stored  execution  recipes  and  of  currently  selected  recipes  from  unexpected  or  unauthorized\nchange,"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 40\n\u2022 Execution   of   recipes   without   errors,   including\nerrors  detected  during  verification  and  validation\nerrors  caused  by  improper  settings  or  parameters\nor incompatibility with the current configuration,\n\u2022 The   ability   to   change   a   recipe's   parameters\nbetween runs in a systematic way without changing\nthe recipe itself,\n\u2022 The  ability  to  dynamically  connect  and  disconnect\nthe executing   agent   from   the   communications\nenvironment, and\n\u2022 The  ability  of  standalone  equipment  to  execute\nrecipes without a communications link.\n6. 2  Description  \xf3  The  recipe   executor   is   able   to\nreceive a downloaded execution recipe and temporarily\nstore   it.   The   executor   can   verify   the   recipe   body\n(Section  11.2.2)  both  at  the  time  of  the  download  and\nafter  the  recipe  has  been  stored.  It  is  able  to  store  at\nleast as many recipes as it requires for a single process\ncycle, which is determined by its own requirements.\nRecipes   stored   by   the   recipe   executor    may    be\ndownloaded   from   more   than   one   namespace.   To\nprevent ambiguity or conflict between recipe identifiers\nfrom different namespaces, the name of the namespace\nfrom  which  the  recipe  was  originally  downloaded  is\nretained in the identifier of the execution recipe.\nThe  recipe  executor selects  one  or  more  specified\nrecipes  by  validating  them  and  preparing  them  for\nexecution.  This  may  include  moving  the  recipes  into  a\nseparate recipe execution area to create an executable\ncopy  recipe.  The  executable  copy  recipe,  if  it  exists\nseparately,  shall  be  protected  from  inadvertent  change\ncaused  by  other  activities,  such  as  downloading  a  new\nrecipe.  The  executable copy  recipe  is  not  otherwise\naddressed  by  RMS.  If  a  separate  copy  is  selected,  the\nstored execution recipe shall be protected from change.\nProtection  from  change  and  permission  to  change  are\ndiscussed in Section 6.6.\nValidation of a recipe consists of checking the values of\nits  settings  and  variable  parameters  against  existing\nsupplier-defined  and/or  user-defined  restrictions,  and\nensuring the recipe, or the linked recipe set, is valid for\nthe    current    configuration    of    the    executor    (e.g.\nequipment or attached module).\nAdditionally, the recipe executor is able to calculate the\namount  of  available  storage,  to  delete  recipes  from  its\nstorage  to  make  room  for  new  recipes,  to  de-select\nrecipes  by  preventing  them  from  being  re-executed\nwithout another explicit select, to rename an execution\nrecipe,  and  to  provide  requested  information  about\nitself  and  its  stored  execution  recipes,  in  conformance\nwith OSS.\n8"),(0,a.yg)("p",null,"The recipe  executor  may  wish  to  rewrite  source  form\nrecipes  into  a  proprietary  derived  object  form  that  is\nmore efficient for execution or storage purposes. Where\nthis  type  of  recipe  is  to  be  stored  for  re-use,  a  new\nidentifier is required for the object form, as described in\nSection   3.2.2.1.2.   Derived   object   form   recipes   are\ndiscussed in detail in Section 11.2.2.1.\n6. 3   The  Execution  Recipe  \xf3  An  execution  recipe  is  a\ntype  of  recipe,  as  shown  in  Section  3,  Figure  3.5.  The\nrecipe  executor  stores  recipes  as  execution  recipes.\nExecution  recipes  are  created  in  one  of  two  ways:  they\nare  either  downloaded  from  a  recipe  namespace,  or\nthey are created by the recipe executor.\n6. 3.1  Comparison  of  Managed  and  Execution  Recipes\n\xf3  An  execution  recipe  differs  from  a  managed  recipe\nin two ways: its attributes and its lack of agent-specific\ndatasets.\nThe differences in attributes between a managed recipe\nand an execution recipe consist of:\n\u2022 The  addition  of  Namespace\nas  an  identification\nattribute of the execution recipe,\n\u2022 The     intermediate     parameters,     ExtRef\nand\nParameters\n, of a verified managed recipe, required\nfor  the  namespace  link  operation,  are  not  used  by\nthe recipe  executor  and  are  not  retained  in  the\nexecution recipe,\n\u2022 The     attributes     LinkParam\nand     AgentSpec\nLinkParam of the managed recipe  are  merged  into\nthe single attribute ExecLinkParam\n,\n\u2022 The   attributes   of   the   remaining   agent-specific\ndataset are  absorbed  into  the  attributes  of  the\nexecution recipe, and\n\u2022 The addition of the attribute length ExecAttrLength"),(0,a.yg)("p",null,"and      attribute      timestamp      ExecAttrChgTime"),(0,a.yg)("p",null,"attributes, and\n\u2022 The  additional  attribute  ChangedBody\n,  which  is\nrequired  for  execution  recipes  where  the  recipe\nexecutor is capable of changing the recipe body or\nof creating new recipes and is not otherwise used.\nThe  conversion  of  a  managed  recipe  to  and  from  an\nexecution  recipe  is  the  responsibility  of  the  namespace\nmanager and is discussed in Sections 9.4.8 and 9.4.9.\nMost of these differences are invisible for an unverified\nrecipe   or   minimal   recipe   implementations.   For   an"),(0,a.yg)("p",null,"8 SEMI E39 (Object Services Standard)"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 41\nunverified recipe, all of the above attributes are cleared\nto  their  default  value  and  are  not  transferred  with  the\nrecipe.  Attributes  needed  for  multi-part  recipes  and\nvariable   parameters   are   not   required   for   minimal\nimplementations.  Figure  6.2  provides  a  model  of  the\nminimal implementation of an execution recipe to meet\nRMS requirements."),(0,a.yg)("p",null,"Figure 6.2\nObject Model for Minimal Execution Recipe\n6. 3.2  Downloaded  Recipes  \xf3  To  download  a  recipe\nfrom    a    namespace,    the    namespace    manager    is\nresponsible  for  first  converting  the  attributes  of  the\nspecified managed  recipe  into  those  of  the  execution\nrecipe.   The   recipe   executor   stores   the   downloaded\nrecipe as an execution recipe. The body of the recipe is\nunchanged  by  the  download  operation  and  may  be  in\nsource form or object form, including the derived object\nform. (See Section 11.2.2.1.)\nThe namespace  manager  may  optionally  request  that\nthe  recipe  being  downloaded  replace  any  pre-existing\nrecipe  with  the  same  identifier.  Otherwise,  if  such  a\nrecipe exists, the download request is denied.\nUpon  request,  the  recipe  executor  shall  verify  a  recipe\nthat  it  has  previously  stored  and  return  to  the  requestor\nthe information required for recipe management.\nAttributes  of  the  execution  recipe  that  have  the  same\nattribute name as either a generic attribute or an agent-\nspecific attribute of the managed recipe are not changed\nexcept in specific cases.\nThe  attributes  giving  the  timestamp  and  length  of  the\nattributes  of  the  execution  recipe  are  different  from\nthose  of  the  managed  recipe.  This  allows  the  generic\nand body   descriptors   of   a   managed   recipe   to   be\ncompared   with   the   corresponding   attributes   of   an\nexecution  recipe  for  traceability.  The  timestamp  of  the\nexecution  recipe's  attributes  is  ExecChgTime\n,  and  the\nlength  of  its  attributes  is  ExecAttrLength\n.  These  are\ncalculated   by   the   recipe   executor   at   the   time   the\nexecution  recipe  is  stored  and  updated  whenever  other\nattributes of the recipe change.\n6. 3.3  Execution  Recipe  Identifier  \xf3  The  identifier  of\nan execution  recipe,  in  addition  to  the  recipe  name,\nclass, and version of the managed recipe, also contains\nthe    name    of    the    originating    namespace.    The\noriginating namespace  is  the  namespace  from  which\nthe   recipe   was   originally   downloaded.   For   recipes\nnewly created within the storage of the recipe executor,\nthis  is  the  namespace  to  which  the  recipe  will  be\nuploaded.\nThe full identifier of an execution recipe  is  identical  to\nthat used within recipes to indicate the recipe is external\nto  that  of  the  referencing  recipe  (see  Section  3.2.4.1.1)\nand has the form:\n\xecNamespace Name>/CLASS/.../CLASS/name; version\xee.\n6. 3.4   Execution  Recipe  Descriptor  \xf3  The  descriptors\nof the execution recipe consist of the execution attribute\ndescriptor  (ExecAttrLength  and  Exec-AttrChgTime),\nthe generic    attribute    descriptor    (AttrLength    and\nAttrChgTime),  and  the  body  descriptor  (BodyLength\nand   EditTime).   The   execution   recipe   descriptor\nconsists   of   the   execution   attribute   descriptor,   the\ngeneric attribute descriptor, and the body descriptor, in\nthat order.\n6. 3.5   Execution  Recipe  Attribute  Definitions  \xf3  Table\n6. 1  provides  the  formal  definition  of  the  attributes  of\nthe execution   recipe.   Attributes   in   Table   6.1   are\nclassified  as  identification  attributes,  mandatory  and\nother  required  attributes,  optional  attributes,  and  non-\nstandard attributes. Identification attributes are not used\nin  RMS  services  as  \xecrecipe  attributes\xee  and  are  used\nsolely   to   specify   one   or   more   execution   recipes.\nSupport for all required attributes is necessary for RMS\ncompliance.  Support  for  the  remaining  attributes  is  not\nrequired.\nThe execution  recipe\xeds  attribute  length  and  timestamp\nattributes  are  transferred  first  when  a  recipe  attribute\nsection (Section 14.1) is uploaded.\nAttributes   that   are   described   as   \xecpreserved\xee   are\nmaintained  without  change  from  a  downloaded  recipe.\nFor recipes that are first created by the recipe executor,\nsuch  as  hardware-specific  recipes,  they  are  set  to  their\nappropriate values. Default values have been added for\nattributes that cannot be determined.\nAttributes  in  Table  6.1  are  presented  in  the  following\norder:\n\u2022 Identification  attributes,  including  object  type  and\nidentifier, the first six listed in the table,"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 42\n\u2022 Mandatory   attributes   and   the   other   required\nattributes, in the order in which they are to appear\nwhen a recipe is transferred.\n\u2022 Optional attributes in alphabetical order, and\n\u2022 Non-standard attributes, transferred last.\nDefault  values  for  non-mandatory  attributes  are  shown\nin  the  last  column.  Null  values  (indicated  by  \xecNULL\xee)\nare  dependent  upon  the  particular  form  (see  Section\n3. 2.5)."),(0,a.yg)("p",null,"Table 6.1  Execution Recipe Attribute Definition\nAttribute Name Definition Access Rqmt Form Default Value\nIdentification Attributes\nObjType The object type. RO Y        Text:        \xecERcp\xee                           \xecERcp\xee\nObjID An identifier derived from\nNamespace, Class, Name, and\nVersion\nRO              Y              Formatted              text.              -\nNamespace The name of the originating\nnamespace.\nRO              Y              Text.              NULL\nName A logical name assigned by the user\nwhen the recipe is created.\nRO              Y              Text.              -\nClass The recipe\xeds class\n(e.g., \xec/PROCESS/\xee or\n\xec/PROCESS/LOADER/\xee).\nRO              Y              Formatted              text:\n\xecCLASS/CLASS/../"),(0,a.yg)("h2",{id:"class\xee"},"CLASS/\xee"),(0,a.yg)("p",null,"Version The version of the recipe.                         RO                         Y                         Text.                         -\nMandatory Attributes\nExecAttrLength          The          length attribute for the attributes\nof the execution recipe. Calculated\nwhen the recipe is downloaded and\nwhenever an attribute changes.\nRO Y List of formatted text. -\nExecChgTime             The             timestamp of a change to the\nattributes of the execution recipe.\nRO              Y              Formatted              text,"),(0,a.yg)("h2",{id:"timestamp-format"},"timestamp format."),(0,a.yg)("p",null,"AttrLength                  Preserved.                  RO                  Y                  Unsigned                  integer.                  0\nAttrChgTime              Preserved.              RO              Y              Formatted              text.              NULL\nRequired Attributes\nBodyLength Preserved unless recipe is modified.\nLength of the recipe\xeds body, in\nbytes.\nRO              Y              Unsigned              integer.              -\nEditTime Preserved unless recipe is modified.\nTimestamp of when the body was\ncreated or modified.\nRO              Y              Formatted              text."),(0,a.yg)("h2",{id:"timestamp-format-1"},"Timestamp format."),(0,a.yg)("p",null,"BodyFormat Indicates the form and format of the\nrecipe\xeds body.\nRO              Y              Enumerated              unsigned\ninteger:\n0 = source,\n1 = object,"),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},"1 reserved.\n0\nVerified Indicates whether the recipe\xeds body\nis syntactically correct.\nRO              Y              Boolean.              FALSE\nLinked Indicates whether the recipe is\nlinked.\nRO              Y              Boolean.              FALSE\nChangedBody Set to TRUE if the recipe body has\nchanged without a subsequent\nupload to the originating namespace.\nNOTE: This attribute is never\nuploaded to a namespace. Required\nonly if recipe can be changed or\ncreated.\nRO              Y              Boolean.              FALSE")),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 43\nAttribute Name Definition Access Rqmt Form Default Value\nExecChgCtrl Preserved. Specifies change control\nrequirements for recipe.\nRO              Y              Binary.\nBitwise (MSB=8):\n1 - The recipe body\nmay be changed,\n2 \xf1 Change\nnotification required,\n4 - Recipe may be\nselected after change,\n8 - Most recent\nparameter setting shall\nbe saved.\n0\nOptional Attributes\nAgentSpecComments Copied from the original agent-\nspecific attribute when downloaded.\nSet by the user.\nRO              N              Text.              Maximum\nlength is 80"),(0,a.yg)("h2",{id:"characters"},"characters."),(0,a.yg)("p",null,"ApprovalLevel Indicates the level of approval\nassigned by an authorized user.\nRW             N             Unsigned             integer.             0\nCertified Preserved from the agent-specific\nattribute as downloaded. May be\nused as control for production-\nworthy recipes.\nRO              N              Unsigned              integer.              0\nComments User comments. Preserved from the\ngeneric attribute as downloaded.\nRO              N              Text.              Maximum\nlength is 80"),(0,a.yg)("h2",{id:"characters-1"},"characters."),(0,a.yg)("p",null,"EditedBy Preserved unless recipe is modified.\nThe name of the person or executing\nagent who last modified the recipe.\nRO              N              Text.              Maximum\nlength is 80"),(0,a.yg)("h2",{id:"characters-2"},"characters."),(0,a.yg)("p",null,"EstRunTime The nominal or estimated execution\n(run) time of the recipe, in seconds.\nUsed for scheduling purposes.\nPreserved from the generic attribute\nas downloaded.\nRO              N              Unsigned              integer.              0\nExecLinkParam          Preserved          unless          last value is\nchanged (Section 6.6.4). Contains\nthe list of parameter definitions,\nincluding any agent-specific\nmodifications. Required for variable\nparameter support.\nRO N Structure composed o\nf\nparameter name,\ninitial value, and\nrestrictions.\nNULL\nLinkList Preserved. A complete list of recipe\nspecifiers for a linked recipe set.\nRequired for multipart recipe\nsupport.\nRO N List of formatted text. NULL\nSrcRcpID                    For                    a                    derived object form recipe,\ncontains the recipe identifier of the\noriginal source form recipe.\nRequired only for derived object\nform recipes.\nRO              N              Formatted              text.              NULL\nVerificationID Identifier code used by the verifier\nof the recipe. May be used to\ndetermine out-of-date formats that\nneed to be reverified.\nRO              N              Text.              Maximum\nlength is 40\ncharacters.\nNULL\nNon-Standard Attributes\nAgentSpec- UD * Preserved from the original agent-\nspecific attributes as downloaded.\nRO N Defined by supplier or\nuser. Text limited to"),(0,a.yg)("h2",{id:"80-characters"},"80 characters."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 44\nAttribute Name Definition Access Rqmt Form Default Value\nUD * Non-standard attribute defined by\nsupplier or user. Asterisk indicates\nthe part of the attribute name that is\nprovided in this definition. Shall be\npreserved exactly, except by the\nentity that defined it.\nRO N Varies with definition.\nText form is limited to"),(0,a.yg)("h2",{id:"80-characters-1"},"80 characters."),(0,a.yg)("ol",{start:6},(0,a.yg)("li",{parentName:"ol"},"4  Default  Namespace  \xf3  The  default  namespace  is  a  dedicated  centralized  namespace  (see  Section  4.4)  that  is\nused  for  all  agent-specific  recipes.  A  recipe  executor  that  uses  agent-specific  recipes,  such  as  thermocouple\ncalibration tables, shall be provided with a namespace for such recipes. Equipment that may be operated in a stand-\nalone  mode,  and  that  requires  agent-specific  recipes,  shall  also  provide  a  local  namespace  to  be  used  for  this\npurpose. A single namespace shall be used to satisfy both requirements.\nThe recipe executor shall provide a user-settable attribute DefaultNamespace\nthat contains the name of the default\nnamespace. The default namespace shall be available on power-up for stand-alone operation. For executing agents\nintended to operate only in a supervised configuration, such as cluster process modules, the default namespace may\nbe provided by the supervisor.\nA  recipe  in  a  default  namespace  is  referenced  within  a  recipe  body  by  specifying  a  namespace  named  \xecDefault\xee.\nThis allows controlled specification by namespace role for hardware-specific recipes."),(0,a.yg)("li",{parentName:"ol"},"5  Recipe Storage \xf3 Discussion of types of storage used by the recipe executor is provided to clarify terminology.\nStorage  is  generally  assumed  to  consume  space  in  some  form,  and  the  amount  of  space  available  for  recipes  is\nassumed to be finite, so that adding recipes reduces the amount of space available and deleting recipes increases the\namount of space available. These assumptions are based on current technologies and are not requirements.\nThe recipe executor may have one or more types of storage area for recipes, shown in Figure 6.3. The storage area\nused  for  the  current  process  cycle  is  called  the  recipe  execution  area.  This  is  the  minimum  storage  capacity\nrequired. Executable  copy  recipes  in  the  recipe  execution area  may  or  may  not  be  transformed  for  execution\npurposes but shall retain the attributes of the execution recipe. The recipe execution area shall be protected from all\ninadvertent  and  unintentional  change,  including  change  resulting  from  transferring  a  recipe  to  or  from  a  recipe\nnamespace or from editing a recipe.")),(0,a.yg)("p",null,"Figure 6.3\nObject Model for Recipe Executor\nExtra  storage  area,  for  additional  recipes  that  are  not\ncurrently selected,   when   provided,   is   called   the\nexecution recipe storage.\nA  separate  intermediate  area  for  temporary  storage  of\nunverified  downloaded  recipes  may  also  be  provided.\nThis  area  is  the  verification  area.  The  separation  of\nthis  area  provides  protection  for  the  executable  copy\nrecipes  and  the  execution  recipes.  Recipes  that  fail"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 45\nverification, or that have been requested to be discarded\nwithout storage after verification, may be removed from\nthis area more easily when it is separate.\nA recipe temporarily placed in a verification area shall\nbe   immediately   either   discarded   or   else   moved   to\nexecution    recipe    storage    following    a    successful\nverification.\nThe term stored recipes in this section refers to recipes\nin execution recipe storage.\nThe  storage  areas  of  the  recipe  executor  may  or  may\nnot  be  volatile.  The  verification  area, recipe  execution\narea, and the execution recipe storage are not required\nto  be  physically  separate,  so  long  as  recipes  in  each\nlogical   area   are   protected   from   change   caused   by\nactivities in the other areas.\n6. 6  Change Control \xf3 Storage provided by the recipe\nexecutor  is  intended  as  temporary,  and  only  minimum\nmanagement  capability  is  required,  such  as  the  ability\nto rename or delete recipes.\nSome    recipe    executors    may    choose    to    provide\nadditional capabilities, such as the ability to create new\nrecipes,  to  edit  existing  recipes,  to  build  a  compressed\nderived  object  form  recipe,  to  modify  existing  recipes\nthrough  the  execution  process  itself,  and/or  to  save  the\nlast value used for variable parameter settings. Certain\nrestrictions  apply  to  these  activities.  Each  different\ncapability  provided  for  creating  and  changing  recipes\nshall be explicitly documented by the supplier.\nIn general, change is controlled by the user through the\nattribute   ExecChgCtrl\n.   ExecChgCtrl   specified   four\nseparate  types  of  control  related  to  change,  including\npermission to subsequently select or re-select a changed\nrecipe  and  a  requirement  that  the  originating  recipe  be\nnotified of all protected changes to the recipe.\nThe recipe   executor   is   prohibited   from   setting   the\nLinked\nattribute of any recipe to TRUE.\nThe recipe  executor  is  responsible  for  ensuring  the\nuniqueness of the identifiers of the recipes that it stores.\nDetailed  requirements  governing  the  creation  of  new\nrecipes  and  the  changes  protected  by  ExecChgCtrl\nare\ndefined in Section 11.\n6. 6.1 Recipe  Creation  \xf3  Certain  recipe executors  may\nbe  able  to  create  recipes.  This  capability  is  allowed  to\ncover the hardware-dependent recipes and the provision\nof   editing   services.   Mechanisms   for   creating   and\nchanging recipes are beyond the scope of RMS. Change\nnotification is required for all newly created recipes.\n6. 6.2  Recipe  Compression  \xf3  A  source  form  recipe\nmay  be  compressed  to  obtain  a  derived  object  form\nrecipe,   described   in   Section   3.2.2.1.2.   This   is   not\nconsidered as a newly created recipe, as the source form\nand derived  object  form  recipes  achieve  the  identical\nprocess results. For this reason, most of the attributes of\nthe source   form   recipe,   including   the   Linked\nand\nExecChgCtrl\nattributes, are passed to the derived object\nform.  A  change  notification requirement for the source\nform  recipe  extends  to  the  derived  object  form  as  well,\nincluding  notification  when  the  derived  object  form  is\nbuilt.  Requirements  for  the  derived  object  form  recipe\nare defined in detail in Section 11.2.2.1.\n6. 6.3    Changes   to   Stored   Recipes   \xf3   The   recipe\nexecutors  may  be  able  to  change an  existing  recipe  by\nchanging  its  body.  Certain  hardware-dependent  recipes\nmay  sometimes  be  changed  by,  or  as  a  result  of,  the\nexecution  process  itself.  Recipes  also  may  be  changed\nthrough   an   editing   activity,   including   interactive\n\xecteach\xee and automated \xecself-teach\xee operations provided\nby   some   systems.   Except   where   expressly   granted\npermission  to  change  an  existing  recipe  through  the\nExecChgCtrl\nattribute,   the   bodies   of   all   recipes   in\nstorage  shall  be  protected  from  change.  This  is  not  the\nsame  as  the  write-protection  of  the  namespace  in  that\nexecution  recipes  may  be  deleted and renamed  by  an\nauthorized  user  and  by  the  manager  of  the  originating\nnamespace.\nDepending upon the value of the ExecChgCtrl\nattribute\nof the recipe, permission to change the execution recipe\n(stored  in  the  execution  recipe  storage)  is  granted  or\ndenied  in  advance  and  allows  case-by-case  granularity.\nUnless  explicitly  granted  permission,  a  changed recipe\nmay not be subsequently selected or re-selected.\nPurposeful  change  during  the  execution  process  for\nhardware-dependent    recipes    is    included    in    the\nExecChgCtrl\nattribute  permission  to  change  the  recipe\nbody.  For  example,  furnaces  may  be  able  to  update  a\n\xecprofile recipe\xee during a normal process cycle. Recipes\nchanged   purposefully   by   the   execution   process   are\nassumed  to  represent  the  best,  most  up-to-date,  and\nmost  valid  version  of  a  hardware-dependent  class  of\nrecipe.    Suppliers    of    recipe    executors    with    this\ncapability  shall  provide  complete  documentation  of  the\nclass of  recipe  changed  and  the  circumstances  under\nwhich it is changed.\nThe ExecChgCtrl\nattribute  of  a  recipe  may  require  that\nthe originating   namespace   be   notified   of   change.\nChange notification consists of a notification message\nsent   to   the   originating   namespace   that   alerts   the\nnamespace  manager  that  a  recipe  has  been  changed  or\noriginated.   Where   change   notification   is   required\nthrough   ExecChgCtrl,   the   namespace   manager   is\nresponsible   for   subsequently   uploading   the   recipe,\nassigning it a new identifier if necessary, and requesting\nthe  renaming  of  the  execution  recipe  as  necessary  to\nremain synchronized."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 46\n6. 6.4  Last  Value  \xf3  Some  recipe  executors  may  also\nwant  to  save  the  last  value  set  by  the  user  for  each\nvariable parameter and use it as the new initial value of\nthat parameter when the same recipe is rerun.\nThis   is   useful   when   internal   conditions   drift   in   a\nconsistent   manner   over   time,   the   parameters   are\noccasionally modified to compensate for such drift, and\nthe last setting used is, therefore, a better \xecdefault\xee than\nthe one specified in the recipe itself.\nPermission  to  save  the  last  value  may  be  expressly\ngranted by the user in the recipe attribute ExecChgCtrl\n.\nCare    should    be    taken    to    prevent    unintentional\nmodifications.\n6. 7  Production  \xf3  Equipment  utilizations  states  are\ndefined  by  SEMI  E10  (Standard  for  Definition  and\nMeasurement  of  Equipment  Reliability,  Availability,\nand  Maintainability  (RAM)).  These  states  include  the\nPRODUCTIVE  and  STANDBY  states  used  by  the\nfactory  for  normal  production  work.  The  attributes\nProdApprove\nand  ProdCertify  are  defined  as  required\nonly  for  equipment  supporting  states  defined  in  this\ndocument.\nTo  ensure  that  only  recipes  authorized  for  production\nare   executed   while   the   executing   agent   is   in   the\nPRODUCTIVE   state,   or   are   selected   while   in   the\nSTANDBY   state,   the   authorized  user   may   set   the\nvalues of the attributes ProdApprove\nand/or ProdCertify\nto non-zero values. Non-zero values in ProdApprove\nor\nProdCertify\nrepresent    minimums    for    a    recipe's\nApprovalLevel\nand Certified attributes, respectively.\nThe recipe  executor  is  responsible  for  comparing  the\ncorresponding   recipe   attributes   ApprovalLevel\nand\nCertified\n.   When   a   recipe   is   selected   for   execution\n(implicitly     or     explicitly)     while     either     of     the\nPRODUCTIVE   or   STANDBY   states   is   active,   the\nvalue  of  ApprovalLevel\nis  required  to  be  equal  to  or\ngreater than the value in ProdApprove\n, and the value in\nCertified\nis  required  to  be  equal  to  or  greater  than  the\nvalue in ProdCertify\n. Otherwise, the select shall fail.\n6. 8   Recipe  Executor  Attributes  \xf3  The  recipe executor\nis  owned  by  the  agent  that  provides  a  recipe  execution\nresource.  The  recipe  executor  in  turn  owns  the  recipes\nthat it has stored. It shall support Object Services for its\nowned object types and for itself.\nTable 6.2 defines the attributes of the recipe executor in\nalphabetical order."),(0,a.yg)("p",null,'Table 6.2  Recipe Executor Attribute Definition\nAttribute Name Definition Access Rqmt Form\nObjType The object type. RO Y Text = "RcpExec"\nObjID                               Text.                               RO                               Y                               Text.\nDefaultNamespace The name of an executing agent\xeds namespace\nused for all hardware-dependent and other\nagent-specific recipes.\nRW           Y           Text.\nProdApprove The minimum value of a recipe\xeds approval\nlevel accepted during productive and standby\nstates. Required for SEMI E10 support only.\nRW           N           Unsigned           integer.\nProdCertify The minimum value of a recipe\xeds certification\nlevel accepted during productive and standby\nstates. Required for SEMI E10 support only.\nRW           N           Unsigned           integer.\nRunCycleUnit The process unit on which the calculation of the\nestimated value of the recipe generic attribute\nEstRunTime is based.\nRO           N           Case-sensitive           formatted           text\ncomposed of a unit of\nmeasure and an optional\nnumeric suffix. Compliant\nwith SEMI E5, Section 9.\nRecipeSelectID A list of recipe identifiers for the currently\nselected recipes.\nRO Y List of formatted text.\nRecipeSelect-\nParameters\nA list of all parameter definitions in effect for\nthe i\nth\nrecipe identifier in RecipeSelectID. The\nmaximum value for i is determined by the\nequipment supplier as the maximum number of\nrecipes which may be selected at the same time.\nRequired if variable parameters are supported.\nRO N List of structures composed\nof parameter name, parameter\nvalue, parameter restriction.'),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 47\n7  Agents\nThis  section  describes  the  agent  and  resources  as  they  are  used  in  Recipe  Management.  The  concept  of  agent  is\nintroduced  to  cover  the  different  types  of  RMS  implementations  and  to  provide  a  context  for  the  other  specific\nobject types introduced in RMS.\n7. 1  Definitions \xf3 A resource is an owned entity that has an active role in factory operations. A factory has many\ndifferent kinds of resources. Some resources, such as valves, may be primarily physical. A software application is a\ntype of resource not generally considered as physical. The factory itself is a resource for the corporation.\nAn agent is  a  system  in  a  factory  \xf3  a  type  of  resource  that  includes  both  hardware  and  software  components,  at\nleast  some  of  which  are  also  resources.  Intelligent  equipment  that  provides  recipe  namespace  capability,  for\nexample,  would  be  an  agent with  a  recipe  namespace  resource,  as  well  as  a  computer  platform,  operating  system,\nand  electro-mechanical  components,  some  or  all  of  which  represent  other  types  of  resources.  An  agent  may  be  a\ncomponent of another agent, and it may also contain other agents as components. For example, a cluster module is a\ncomponent of a cluster and may itself contain intelligent subsystems as components.\nAgents may, in some cases, share certain resources with other agents. An example is a docking station that connects\ntwo clusters.\nServices  defined  by  RMS  may  be  provided  at  various  levels  within  the  factory.  The  generic  term  agent  may  be\napplied  at  any  of  these  levels  as  appropriate.  Typical  agents  that  use  and  provide  Recipe  Management  services\ninclude equipment,  clusters,  cluster  modules,  cells,  and  independent  recipe  namespace  servers\n9"),(0,a.yg)("p",null,".  The  term  agent\napplies equally well to each of these.\nA service  resource  is  a  set  of  services  within  a  particular  area  of  specialization.  Service  resources  of  interest  to\nRMS  are  the  recipe  namespace  resource,  the  recipe  execution  resource,  and  the  Object  Services  Resource.  The\nservice resource object, illustrated in Figure 7.1, allows a group of message services defined by a service standard\n(such  as  RMS)  to  be  represented  by  a  single  object,  one  of  the  subtypes  of  the  service  resource.  However,  this\nconcept is introduced for clarification only. The service resource object is not a standardized object."),(0,a.yg)("p",null,"Figure 7.1\nExamples of Service Resource Subtypes"),(0,a.yg)("p",null,"An agent  is  introduced  as  a  standardized  object that provides one or more service resources. Figure 7.1 shows an\nexample of an agent composed of different service resources. Also, an agent  may  supervise subordinate agents or\nbe supervised by a superior agent, each of which in turn will possess their own service resources."),(0,a.yg)("p",null,"9 A recipe namespace server is an agent whose primary function is to provide recipe namespace capabilities."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 48\nAgents  interact  with  one  another  collaboratively  and/or\nhierarchically,  through  the  service  resources  that  they\nprovide, to perform work in the factory.\n7. 2   RMS  Resources  \xf3  The  service  resources  defined\nby  RMS  are  the  recipe  namespace  resource  and  the\nrecipe execution resource.\nA recipe  namespace  resource  consists  of  the  set  of\nmessage  services  defined  in  Section  12,  corresponding\nto  the  namespace operations  defined  in  Sections  8  and"),(0,a.yg)("h1",{id:"9"},"9"),(0,a.yg)("ol",{start:9},(0,a.yg)("li",{parentName:"ol"},"All  services  required  for  operations  designated  as\nrequired  are  fundamental  and  shall  be  provided  for  an\nRMS-compliant recipe namespace resource.\nA recipe  execution  resource  consists  of  the  set  of\nmessages  defined  in  Section  14  corresponding  to  the\nrecipe  executor  operations  defined  in  Section  11.  All\nservices  required  for  operations  designated  as  required\nare fundamental  and  shall  be  provided  for  an  RMS-\ncompliant recipe execution resource."),(0,a.yg)("li",{parentName:"ol"},"3   Agent  Attributes  \xf3  Table  7.1  defines  the  public\nattributes   of   agents   that   are   required   for   recipe\nmanagement.\nTable 7.1  Agent Attribute Definition\nAttribute\nName")),(0,a.yg)("p",null,"Definition"),(0,a.yg)("p",null,"Access"),(0,a.yg)("p",null,"Reqt"),(0,a.yg)("p",null,"Form\nObjType      Agent      object\ntype.\nRO              Y                            Text:\n\xecAgent\xee\nObjID          The          agent's\nname, assigned\nby an\nauthorized\nuser.\nRO              Y                            Text."),(0,a.yg)("p",null,"8  Recipe Management Operations\nThere  are  two  important  kinds  of  operations  involving\nrecipes   within   a   namespace.   Those   that   change   a\nrecipe's    attributes    or    body    are    called    recipe\nmanagement  operations.  Those  that  affect  the  set  of\nrecipe identifiers within a namespace are part of recipe\nnamespace management operations. A few operations\nqualify  as  both  recipe  management  and  namespace\nmanagement and are discussed in their different aspects\nunder both topics.\nA  third  type  of  operation  is  informational  only  and\nrequires  reading  but  not  changing  recipe  attributes.\nOperations  of  this  type  that  require  knowledge  of  the\nattributes of the namespace or  of  more  than  one  recipe\nare discussed in Section 9.\nThis section describes recipe management operations.\nRequests  for  recipe  operations  are  always  directed  to\nthe namespace   where   the   recipe   is   stored.   Recipe\nmanagement operations are delegated by the namespace\nmanager to    the    namespace    segment,    which    is\nconsidered as the recipe manager. This is invisible for\na centralized  namespace  and  explicit  for  a  distributed\nrecipe namespace.\nOperations may be invoked by the operator or through\nnamespace services  defined  in  Section  12.  In  many\ncases,  service  scenarios  consist  of  a  single  message\nrequest  from  the  service  user  and  a  corresponding\nresponse  from  the  namespace  manager.  This  case  is\nillustrated  in  Section  12.2,  Figure  12.1.  Operations\nrequiring  additional  messages  are  discussed  in  Section\n8. 2.\nThe service user is responsible for proper authorization\nof  the  user  prior  to  requesting  an  operation  that  is\nrestricted to authorized users\nthrough RMS services.\n8. 1   Recipe  Lifecycle  \xf3  A  typical  production  recipe\ngoes through various stages in its development within a\nnamespace.  These  stages  are  shown  below  in  a  typical\norder through their associated operations. The attributes\nconcerning the body are provided by the initiator of the\noperation.\ncreate \xf3  The  create operation  enters  a  recipe  body\ninto the namespace.\nEditing  is  expected,  but  not  required,  to  be  performed\noutside   the   namespace.   Where   provided   by   the\nmanager, the same requirements concerning creating or\nupdating a recipe are to be followed.\nupdate \xf3 A recipe is updated when a body (typically,\na  modification  of  the  original  body)  is  entered  into  the\nnamespace to replace the body of an existing recipe that\nis  not  write-protected.  The  attributes  concerning  the\nbody are provided by the initiator of the operation.\nverify \xf3 The verify operation is used to build a recipe.\nChecks for semantic correctness may also be performed\nat this time but are not required. The recipe body is read\nand checked for syntactical correctness, and all external\nreferences   and   variable   parameter   definitions   are\ncollected.  The  verification operation  may  be  delegated\nto   a   recipe   executor,   which   returns   the   required\ninformation.\nwrite-protect \xf3 At some point during its development,\nan authorized  user  needs  to  be  able  to  prevent  the\naccidental  deletion  or  modification  of  a  recipe  and\nrequests   to   have   it   be   write-protected.   A   write-\nprotected   (read-only)   recipe   may   not   be   updated,\nrenamed, deleted, unlinked, or relinked.\nlink \xf3  The  link  operation  is  used  to  signify  that  the\nrecipe  is  ready  for  execution.  If  the  recipe  has  external\nreferences, linking  also  builds  a  linked  recipe  set  by\ncollecting    the    external    references    and    variable\nparameter definitions and saving them for quick access"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 49\nin  the  main  recipe's  attributes.  Linking  resolves  all\nidentifiers explicitly  for  recipes  that  are  within  the\nnamespace.\nunlink \xf3 At times it may be desirable to undo the link\noperation.  The  unlink  operation  clears those  attributes\nset  by  the  last  link  operation.  A  write-protected  recipe\nmay not be unlinked.\napprove \xf3 The factory uses the recipe's approval level\nto  indicate  the  level  of  its  authorization.  For  example,\napproval  levels  of  1,  2,  and  3  may  indicate  \xecwrite-\nprotected,\xee     \xecauthorized     for     engineering,\xee     and\n\xecauthorized for production,\xee respectively.\nmodify    variable    parameters    \xf3    The    variable\nparameter   definitions   of   a   linked recipe   may   be\nadjusted  for  a  specific  executing  agent  to  achieve  the\ndesired  result.  For  example,  a  generic  parameter  for\ntime  may  be  incremented  repeatedly  for  a  specific\nfurnace until it goes out of range, which indicates that it\nneeds  to  be  cleaned.  If  the  recipe  did  not  previously\nhave   an   agent-specific   dataset   for   this   agent,   this\noperation causes one to be created.\ncertify \xf3 An authorized user (typically by the process\nengineer   who   developed   the   recipe)   assigns   it   a\ncertification-level   to   indicate   that   it   achieves   the\ndesired result on a specific executing agent. The factory\nmay require certain certification levels for production.\nde-certify \xf3 the certification level of the recipe is reset\nto zero.\nunprotect \xf3  Before  a  recipe  can  be  updated,  deleted,\nrenamed,  re-linked,  or  unlinked,  the  recipe  must  be\nunprotected.\ndelete  \xf3  Deleting a  recipe  causes  it  to  be  removed\nfrom the namespace.\n8. 2    Description   of   Operations   \xf3   Operations   that\nrequire    additional    messages    are    of    two    types:\noperations  that  may  be  performed  on  more  than  one\nrecipe (such as certify recipe) and operations that may\nrequire  interactions  with  a  recipe  executor  to  complete\n(verify recipe). The scenario for verify recipe is shown\nin Section 9.4.7.\nThe    remaining    operations    that    require    additional\nmessages   are   invoked   with   the   namespace service\nRMNAction,  where  multiple  recipes  are  specified  for\nthe  operation.  Operations  such  as  these  may  require\nmore  time  to  complete.  The  initial  response  to  the\nmessage  service  request  only  indicates  the  intent  to\nperform  the  operation.  In  this  case,  the  scenario  is\nillustrated by Figure 8.1 and Figure 12.2, Section 12.2.\nThe namespace  manager  performs  the  operation  for\neach   recipe,   in   the   order   specified,   and   upon   the\ncompletion  of  each  operation,  sends  the  notification\nmessage   RMNComplete   with   the   results   for   that\noperation. (See Sections 12.15 and 12.17 for additional\ndetails.)"),(0,a.yg)("p",null,"Figure 8.1\nMessage Flow with Completion Notification\nRecipe  management  operations  are  categorized  into\nthree  types:  recipe  origination,  recipe  building,  and\nrecipe authorization.\nRecipe   origination   includes   those   operations   that\ncreate  or  modify  an  entire  recipe.  Recipe  building\nincludes   the   verification,   link,   unlink,   and   modify\nvariable  parameter  operations.  Recipe  authorization\nincludes  the  write-protect, unprotect,  approve,  and\ncertify operations.\nExcept    for    those    operations    that    only    provide\ninformation, recipe  management  operations  change  the\nstate  of  the  recipe.  Section  8.3  contains  the  complete\nstate model, and a table of transitions is given in Table\n3. 1. Substates of this model are provided for illustration\nin  sections  defining  the  operations  that  affect  these\nsubstates.\n8. 2.1  General Requirements \xf3 The generic length and\ntimestamp attributes AttrLength\nand AttrChgTime shall\nbe   updated   whenever   any   other   generic   attribute\nchanges value.\nAn agent-specific  dataset  for  a  specific  agent exists\nonly  when  a  non-required  attribute  is  given  a  non-\ndefault value, such as whenever a recipe is certified for\na  given  agent.  If  the  non-required  attributes  are  all\ncleared,  the  agent-specific  dataset  is removed  and  no\nlonger  exists.  Otherwise,  the  agent-specific  length  and\ntimestamp  attributes  for  an  agent-specific  dataset  shall\nbe  updated  whenever  one  of  its  attributes  changes\nvalue.\n8. 2.2  Recipe Origination \xf3 A recipe may be originated\nby  the  create  recipe  operation  and  by  the  copy  recipe\noperation. The copy recipe operation creates a duplicate\nof an original recipe and assigns it a new identifier. All"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 50\nof  the  attributes  of  the  original  are  copied  directly.\nThese     operations     are     included     in     Namespace\nManagement in Section 9.4.1.\n8. 2.2.1  Create  Recipe  \xf3  A  recipe  is  created  when  a\nrecipe body  is  first  entered  into  a  namespace   and\nassigned   a   new   identifier.   The   recipe's   mandatory\nattributes  are  set.  All  other  attributes  take  on  their\ndefault    values.    The    values    for    the    attributes\nBodyLength\n, EditTime, and EditedBy are required to be\nprovided  by  the  initiator  of  the  create  operation.  The\nattribute BodyFormat\nis also provided at this time if it is\nnot  in  source  form  (i.e.,  if  BodyFormat\nhas  a  non-\ndefault value).\nA  newly  created  recipe  has  an  active  state  model\n(Figure   8.7).   The   recipe   is   in   the   UNVERIFIED,\nUNLINKED,  UNAPPROVED,  UNPROTECTED,  and\nUNCERTIFIED states.\nThe create   recipe   operation   is   invoked   with   the\nRMNCreate service.\n8. 2.2.2   Update  Recipe  \xf3  The update  operation  is\nidentical  to  that  of  create  except  that  an  unprotected\nrecipe  with  the  specified  identifier  already  exists,  and\nthe  new  body  replaces  the  existing  body.  Attributes\nconcerning the body are provided by the initiator of the\nrequest, as for the create operation. All non-mandatory\nattributes  are  cleared  (reset  to  their  default  values).\nAny existing agent-specific datasets are discarded.\nThe update   recipe   operation   is   invoked   with   the\nRMNUpdate service.\n8. 2.3  Recipe Building \xf3 Building a recipe is a two-step\nprocess. First the recipe is verified and then linked.\n8. 2.3.1   Verify  Recipe  \xf3  The  verify  operation  is  the\nonly  time  it  is  necessary  to  parse  the  contents  of  the\nrecipe body  until  the  recipe  is  executed.  The  primary\npurpose  of  this  process  is  to  ensure  that  the  syntactical\nand lexical structure of the body is correct. One or more\nchecks for semantic correctness may also be performed\nas  part  of  the  verification  operation,  but  this  is  not\nrequired.\nActual verification  is  performed  by  a  member  agent's\nrecipe   executor   at   the   request   of   a   namespace\nmanager.   For   this   reason,   this   operation   is   also\ndiscussed  under  namespace  management  in  Section\n9. 4.7.\nRecipes may be stored in a namespace in an incomplete\nor  unfinished  form.  For  recipes  in  source  form,  the\nverification  procedure  shall  be  performed  only  at  the\nrequest   of   the   user.   It   shall   not   be   performed\nautomatically.\nThere  are  four  attributes  affected  by  the  verification\noperation:     Verified\n,     EstRunTime,     ExtRef,     and\nParameters\n.\nThe   boolean   generic   attribute   Verified\nis   used   to\nindicate the recipe's state with respect to this procedure.\nVerified\nis  cleared when  a  recipe  is  first  created  and\nwhenever it is updated. Verified\nis set TRUE only when\nthe  recipe  passes  the  verification  by  a  recipe  executor.\nA recipe is considered to be verified if, and only if, the\nVerified\nattribute  is  TRUE.  Figure  8.2  illustrates  the\nrecipe's VERIFICATION state. For a description of the\ntransitions, see Table 8.1 in Section 8.3."),(0,a.yg)("p",null,"Figure 8.2\nVerification State Model\nThe   values   for   the   attributes   EstRunTime\n,   ExtRef,\nParameters\n, and VerificationID are returned (where set)\nby  the  recipe  executor  when  the  verification  has  been\nsuccessful.  If  the  operation  is  unsuccessful,  they  shall\nbe cleared.\nExtRef\ncontains  a  list  of  all  external  references  found\nwithin  the  body  of  the  recipe  by  the  recipe  executor.\nThese  references  may  be  explicit\nor  implicit,  leaving\nthe class and/or version unspecified.\nThe verify   recipe   operation   is   invoked   with   the\nRMNAction service.\n8. 2.3.2  Link Recipe \xf3 The link operation is a required\noperation  that  may  be  requested  at  any  time  by  the\noperator  or  supervisor.  Successful  completion  of  the\nlink  operation  indicates  that  the  recipe  is  ready  for\nexecution.   For   single-part   recipes   without   variable\nparameters,  linking consists only of setting the generic"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 51\nattribute  Linked  to  TRUE.  Figure  8.3  illustrates  the\nLINKAGE  state  of  the  recipe.  For  a  description  of  the\ntransitions, see Table 8.1 in Section 8.3."),(0,a.yg)("p",null,"Figure 8.3\nLink State Model\nFor   multi-part   recipes,   this   operation   also   collects\nexternal  references  and  variable  parameter  definitions\ninto  the  LinkList\nand  LinkParam  attributes,  to  be  used\nby the recipe executor at run-time.\nExternal references contained within multi-part recipes\nare  not  required  to  specify  the  class  of  the  subrecipe\nwhen the class is the same as that of the parent recipe.\nWhere class  is  omitted  in  a  recipe  identifier  in  the\nExtRef\nattribute,  the  link  operation  is  responsible  for\nadding  the  class  of  the  parent  recipe  in  the  identifier\nadded  to  the  LinkList\nparameter,  as  the  parent/child\nrelationship cannot be derived from the final contents of\nLinkList\n.\nExternal  references  are  assumed  to  refer  to  recipes\nwithin the same namespace and are not required to give\nexplicit\nversions   unless   they   specify   a   different\nnamespace.  This  ensures  that  the  user  will  be  able  to\nlink  together  the  \xecbest  choice\xee  subrecipes.  The  exact\nvalue of versions of such references is determined only\nat the time the main recipe is linked.\nThe link operation is performed on a main recipe. That\nis,  it  only  modifies  attributes  of  the  main  recipe.  It\nresolves  all  external  references  within  that  recipe  and\nwithin  any  of  its  subrecipes  according  to  well-defined\nrules for determining default versions at the time of the\nlink.  At  the  same  time,  variable  parameter  definitions\nare   collected.   The   resulting   explicit   references   are\nplaced  in  the  LinkList\nattribute, variable  parameter\ndefinitions are placed in LinkParam\n, the ApprovalLevel\nattribute is cleared, the Linked\nattribute is set to TRUE,\nand the main recipe is then said to be linked.\nSubrecipes    are    not    affected    by    this    operation.\nSubrecipes  of  a  main  recipe  have  no  knowledge  of\nparents  or  of  linkages.  As  a  result,  it  is  possible  to\ndelete   or   change   a   subrecipe   with   an   unintended\ndetrimental   impact   on   a   linked   recipe   set.   Factory\npolicy may designate certain levels of approval to mean\n\xecthis   recipe   is   used   by   (linked   into)   one   or   more\nprotected recipes.\xee\nFor  multi-part  recipes,  linking  starts  at  the  main  recipe\nand  works  through  all  chains  of  referenced  subrecipes\nto  determine  the  complete  set  of  identifiers  that  will\ncomprise the recipe as a whole. The link operation is a\nmechanical  procedure  that  may  be  performed  at  any\ntime.\nSuccessful linking implies that all referenced subrecipes\nhave  been  located  and  parsed  for  further  references\nuntil  all  references  are  exhausted.  The  link  operation\nshall  fail  when  any  recipe  or  subrecipe  within  the\nnamespace either is unverified or cannot be located.\nIf   the   same   parameter   name   is   used   to   define   a\nparameter  in  more  than  one  recipe  of  a  set  of  recipes\nthat  are  linked together,  the  name  shall  represent  the\nsame parameter    and    have    the    same    parameter\ndefinition  in  all  recipes  in  the  set,  to  avoid  ambiguity.\nParameters   with   the   same   parameter   name   and\ndiffering definitions   shall   cause,   at   a   minimum,   a\nwarning to the user when the link operation completes.\nFor  purposes  of  comparison  of  results,  the  order  of\nreferences in LinkList\nand LinkParam at the completion\nof  the  link  operation  shall  conform  to  the  results  when\nthe following sequence is used:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"Copy the contents of ExtRef\nfrom the main recipe to\nLinkList\n, resolving class  and  version to each recipe\nidentifier   as   needed.   For   support   of   variable\nparameters, also copy the contents of Parameters to\nLinkParam\n. If ExtRef is empty, then LinkList is also\nempty and the parsing process is complete."),(0,a.yg)("li",{parentName:"ol"},"If   LinkList\nis   not   empty,   begin   with   the   first\nreference in LinkList\nas the link target reference."),(0,a.yg)("li",{parentName:"ol"},"If  the  link  target  reference  lies  within  the  same\nnamespace,    resolve    the    class    and    version    if\nnecessary.  (Note:  the  referenced  recipe  must  be\nalready present within the namespace at the time the\nlink  is  performed,  or  else  the  link  fails.)  If  the  link\ntarget reference specifies a different namespace, go\nto  Step  (6)  \xf3  the  link  operation  of  this  chain\nterminates  (without  error)  without  an  attempt  to\nlocate the actual recipe or its ExtRef\nattribute. If the")),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 52\nrecipe  is  located,  then  it  is  called  the  link  target\nrecipe."),(0,a.yg)("h1",{id:"4"},"4"),(0,a.yg)("ol",{start:4},(0,a.yg)("li",{parentName:"ol"},"Determine  the  contents  of  the  Verified\nattribute  of\nthe link target recipe. If Verified\nis FALSE, the link\noperation fails immediately.")),(0,a.yg)("h1",{id:"5"},"5"),(0,a.yg)("ol",{start:5},(0,a.yg)("li",{parentName:"ol"},"Determine  the  contents  of  the  ExtRef\nattribute  of\nthe  link  target  recipe.  Remove  any  references  that\nduplicate   those   already   contained   in   LinkList\n,\nresolve class and version as needed, and append the\nresult   to   LinkList\n.   If   variable   parameters   are\nsupported,     also     determine     the     contents     of\nParameters\nin   the   link   target   recipe,   remove\nparameters   already   defined   in   LinkParam\n,   and\nappend the result to LinkParam\n.")),(0,a.yg)("h1",{id:"6"},"6"),(0,a.yg)("ol",{start:6},(0,a.yg)("li",{parentName:"ol"},"Set  the link target reference to the next reference in\nLinkList\nand  repeat  steps  (3)  through  (6)  until  all\nreferences in LinkList\nhave been processed.\nFor  recipes  with  no  external  references,  the  LinkList")),(0,a.yg)("p",null,"list   will   be   empty.   Similarly,   for   recipes   with   no\nvariable parameters, the LinkParam\nlist will be empty.\nThe effect of allowing incomplete recipe versions to be\nspecified  within  a  recipe  body,  and  determined  only\nwhen  the  main  recipe  is  linked,  means  that  a  linked\nrecipe  set  (the  set  of  recipes  linked  together)  produced\non one occasion may not be the same as those produced\non  a  different  occasion.  Therefore,  it  is  necessary  to\nprotect  the  contents  of  the  LinkList\nattribute  from\ninadvertent change.\nFor this reason, the link operation cannot be performed\non a read-only recipe with the Linked\nattribute already\nset from a previous link. Any attempt to link an already\nlinked  read-only  recipe  either  shall  be  denied  or  a  new\ncopy  of  that  recipe  shall  be  generated  with  a  new\nidentifier,  which  may  then  be  automatically  approved\nand linked.\nThe link    recipe    operation    is    invoked    with    the\nRMNAction service.\n8. 2.3.3  Unlink  Recipe  \xf3  A  linked  recipe  that  is  not\nwrite-protected   may   also   be   unlinked.   The   unlink\noperation clears    the    generic    attributes    Linked\n,\nLinkList\n,   and   LinkParam.   If   the   recipe   has   agent-\nspecific datasets, the attributes Certified\nand AgentSpec\nLinkParam are cleared. If no other non-required agent-\nspecific  attributes  have  a  non-default  value,  the  agent-\nspecific dataset is removed.\nThe unlink   recipe   operation   is   invoked   with   the\nRMNAction service.\n8. 2.3.4    Modify   Variable   Parameters   \xf3   The   recipe\nattributes          Parameters\n,          LinkParam,          and\nAgentSpec\n_LinkParam   each   consist   of   a   list   of\nparameter   definitions.   Each   parameter   definition\ncontains  the  parameter  name,  parameter  initial  value,\nand the parameter restriction (if any) specified for that\nparameter  by  a  formal  definition  within  the  recipe\nbody.\nIn order to \xectune\xee a recipe so that it produces the same\nresult  on  all  executing  agents  of  the  same  type,  it  may\nbe  necessary  to  provide  a  different  initial  value  or  a\ndifferent parameter   restriction   for   one   or   more\nparameters for individual executing agents. The agent-\nspecific   attribute   AgentSpec_LinkParam\nis   used   to\nprovide this capability.\nAgentSpec_LinkParam\nis   an   optional   agent-specific\nattribute  that  contains  a  list  of  alternate  parameter\ndefinitions  for  one  or  more  of  the  variable  parameters\nincluded   in   the   definitions   in   the   generic   attribute\nLinkParam\nof a linked recipe. A special editing facility\nmay  be  provided  to  allow  an  authorized  user  to  add,\ndelete,     or     modify parameter     definitions     to\nAgentSpec_LinkParam\n.\nParameter definitions initially are added individually to\nAgentSpec_LinkParam\nby  copying  the  definition  for\nthat parameter  from  LinkParam\n.  The  initial  value  or\nrestriction then may be modified by the user, subject to\nthe  absolute  restrictions,  such  as  minima  and  maxima,\nimposed  by  the  executing  agent's  supplier.  The  initial\nvalue   may   be   changed   to   any   value   within   the\nparameter domain.\nAny  modification  of  the  restriction  shall  cause  the\ncertification   level   to   be   cleared   in   the   Certified"),(0,a.yg)("p",null,"attribute.  This  is  required  because  of  the  potential\nimpact on fab operations of a change in the restriction.\nThe  UNITS  in  the  restriction  of  a  numeric  parameter\nmay be modified within constraints imposed by the use\nof the parameter and the executing agent's supplier. For\nexample, a two-byte unsigned integer named WaitTime\nthat  is  used  to  set  a  variable  time  delay  period  may\npermit units of either \xecmin\xee (minutes) or \xecs\xee (seconds).\nIt   is   desirable,   but   not   required,   that   suppliers   of\nexecuting    agents    support    different    options    for\nspecifications of UNITS. The possible options for each\npotential variable  parameter  shall  be  documented  by\nthe supplier."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 53\nThe modify  variable  parameter  operation  consists  of\nadding, deleting,  or  modifying  a  specific  parameter\ndefinition       to       a       list       of       definitions       in\nAgentSpec",(0,a.yg)("em",{parentName:"p"},"LinkParam\nfor a specific agent.\nA definition  is  added  when  it  is  copied  directly  from\nthe     LinkParam\nattribute     to     the     AgentSpec"),"\nLinkParam\nattribute without modification. A definition\nshall only be added if there is currently no definition for\na parameter  with  the  same  parameter  name  in  the\nAgentSpec",(0,a.yg)("em",{parentName:"p"},"LinkParam\nattribute.\nA definition  is  deleted  when  it  is  completely  removed\nfrom     the     list     of     definitions     in     AgentSpec")),(0,a.yg)("p",null,"LinkParam\n.\nA definition  is  modified  when  the  value  or  restriction\nof      an      existing      definition      is      replaced      in\nAgentSpec_LinkParam\n.\nThe modify  variable  parameters  operation  is  invoked\nwith the RMNVarPar service.\n8. 2.4 Recipe   Authorization   \xf3   Recipe   authorization\noperations  include  those  that  allow  an  authorized  user\nto  change  the  value  in  the  generic  attribute  Approval-\nLevel or the agent-specific attribute Certified.\nThe de-certify  operation  is  invoked  with  the  service\nRMNAction.\n8. 2.4.1     Approve    Recipe    \xf3    Recipe    management\nprovides  two  different  methods  of  controlling  how  a\nrecipe    is    applied:    through    the    generic    attribute\nApprovalLevel\nand  through  the  agent-specific  attribute\nCertified\n.   The   recipe's   approval   level   (the   value\ncontained  in  ApprovalLevel\n)  is  also  used  to  protect  it\nfrom change.\nA   recipe   goes   through   different   stages   during   its\nlifecycle.  After  a  recipe  has  been  initially  created,  it\nwill  typically  go  through  a  dynamic  period  while  it  is\ntested and adjusted until it produces the desired results.\nApprovalLevel\nis an unsigned integer used to designate\nthe  different  stages  in  a  recipe's  life  cycle.  It  is  set  to\nzero  (its  default  value)  whenever  a  recipe  is  created,\nupdated, or linked.\nThe approval  operation  allows  an  authorized  user  to\nset  ApprovalLevel\nto  a  non-zero  value.  Otherwise,  it\nmay not be set externally.\nA  recipe  is  said  to  be  approved  whenever  Approval-\nLevel    is    non-zero.    An    example    of    a    factory's\nimplementation   of   approval   levels   is   given   in   the\nappendix, Section 8.3. Figure 8.4 illustrates the recipe's\nAPPROVAL  state.  For  a  description  of  the  transitions,\nsee Table 8.1 in Section 8.3."),(0,a.yg)("p",null,"Figure 8.4\nApproval State Model\nA subrecipe  may  be  approved  independently  from  any\nrecipes which reference it.\nA  linked  recipe  may  not  be  approved  to  a  level  higher\nthan the lowest approval level of any of its subrecipes.\nTherefore,  all  subrecipes  referenced  in  the  attribute\nLinkList\nof  a  linked  recipe  must  be  located  prior  to\ngranting   an   approval   level   other   than   zero.   The\nApprovalLevel\nattribute  of  the   subrecipes   must   be\nincreased  to  a  value  equal  to,  or  greater  than,  the\nrequired level  by  an  authorized  user  before  the  higher\napproval level of the linked recipe is accepted.\nThe  restriction  on  the  approval  level  of  the  linked\nrecipe  requires  the  user  to  purposefully  change  the\napproval  level  in  order  to  protect  the  entire  linked\nrecipe set as a unit from unexpected change, as it is by\nthe main recipe identifier that the recipe as a whole will\nbe  known.  It  should  be  noted  that  approval of a  linked\nrecipe  is  not  the  same  as  approval  of  the  individual\nparts, as a subrecipe which is appropriate in one recipe\nmay be inappropriate in another.\nThe approve   recipe   operation   is   invoked   with   the\nRMNAction service.\n8. 2.4.2  Certify  \xf3 The certify  operation  sets  the  value\nof Certified\nfor a specific executing agent to a non-zero\nvalue  specified  by  an  authorized  user.  This  operation\naffects   no   other   attributes   (except   the   length   and\ntimestamp   attributes   of   the   affected   agent-specific\ndataset)."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 54\nA  recipe  may  be  syntactically  and  procedurally  correct\nbut,    due    to    the    differences    between    different\ninstallations of agents with access to a namespace, may\ngive  different  results  on  these  different  installations.\nRecipe certification   signifies   that   a   linked   recipe\nproduces the desired results on a specific installation.\nA   recipe   is   considered   certified   for   agent   if   the\ncertification-level    contained    in    the    agent-specific\nattribute  Certified\nis  non-zero.  Otherwise,  the  recipe  is\nuncertified.  A  certified recipe  is  de-certified  when  the\ncertification-level is set to zero.\nA  recipe  may  be  certified  and  de-certified  only  by  an\nauthorized   user.   Figure   8.6   illustrates   the   recipe's\nCERTIFICATION   states.   For   a   description   of   the\ntransitions, see Table 8.1 in Section 8.3."),(0,a.yg)("p",null,"Figure 8.6\nCertification State Model\nRecipes  with  variable  parameters  may  be  certified  for\nspecific values   and   restrictions of some of these\nvariables.   If   so,   such   values   are   stored   in   the\nAgentSpec_LinkParam\nattribute.\nOnly  recipes  with  the  Linked\nattribute  set  to  TRUE\nmay be certified.\nThe certify   recipe   operation   is   invoked   with   the\nRMNAction service.\n8. 2.4.3  De-certify  \xf3 The de-certify  operation  clears\nthe Certified\nattribute for a specific agent at the request\nof an authorized user.\nA   recipe   may   need   to   be   de-certified   after   major\nmaintenance  has  been  performed  and  later  re-certified\nonly after testing its results.\n8. 2.5  Recipe  Protection  \xf3 The namespace  attribute\nRecipeReadOnlyLevel  is  used  as  a  threshold  to  govern\nthe  level  of  approval  required  for  individual  recipes  to\nbe  protected.  A  recipe  is  protected  when  the  value  in\nits  ApprovalLevel  attribute  is  equal  to,  or  greater  than,\nRecipeReadOnlyLevel.    All    recipes    are    protected\nwhenever    the    namespace\xeds    RecipeReadOnlyLevel\nattribute  is  equal  to  zero.  Figure  8.5  illustrates  the\nrecipe's  PROTECTION  states.  For  a  description  of  the\ntransitions, see Table 8.1 in Section 8.3."),(0,a.yg)("p",null,"Figure 8.5\nProtection State Model"),(0,a.yg)("p",null,"If the value of RecipeReadOnlyLevel\nis n, then recipes\nwith approval  levels  greater  than,  or  equal  to,  n  are\nread-only.  The  body  of  a  read-only  recipe  may  not  be\nchanged   in   any   way,   including   by   over-writing   or\ndeleting. The identifier of a read-only recipe may not be\nrenamed.  A  linked  recipe  that  is  read-only  may  not  be\nre-linked.\nThe recipe   protect   operation    sets    the    value    of\nApprovalLevel\nto     the     value     in     RecipeRead\nOnlyLevel\n.   For   linked   recipes   with   subrecipes,   the\noperation  is  denied  if  the  resulting  approval  level  for\nthe main recipe would be higher than any subrecipe, as\ndescribed in Section 8.2.4."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 55\nIf the value in RecipeReadOnlyLevel is zero, all recipes\nwithin    the    namespace    are    automatically    write-\nprotected,     regardless     of     the     support     for     the\nApprovalLevel\nattribute.\nThe protect   recipe   operation   is   invoked   with   the\nRMNAction service.\n8. 2.6  Unprotect  \xf3 The read-only  status  of  a  recipe\nmay be changed either by changing its approval level to\na value less than the value of RecipeReadOnlyLevel\nor\nby increasing the value in RecipeReadOnlyLevel\n.\nNOTE: If RecipeReadOnlyLevel is zero, all recipes are\nwrite-protected  regardless  of  the  value  in  approval-\nlevel.\nA  protected  recipe  may  be  changed  to  unprotected  at\nthe request of an authorized user. This operation clears\nthe ApprovalLevel\nattribute.\nThe  unprotect  recipe  operation  is  invoked  with  the\nRMNAction service.\n8. 2.7   Informational  Operations  \xf3  Object  Services  are\nused to request the current value of one or more recipe\nattributes   and   to   set   one   or   more   values.   Certain\nattributes  have  restricted  access  and  may  not  be  set\nthrough  RMS  services.  These  attributes  are  identified\nas \xecRO\xee (read-only) in Tables 3.1 and 3.2 in the column\nlabeled  \xecAccess\xee  in  Section  3.4.2.  When  attributes\nidentified  as  \xecRW\xee  (read-write)  are  set  through  Object\nServices, the appropriate attribute length and timestamp\nattributes shall be updated appropriately.\nIn  addition  to  Object  Services,  the  get  descriptors\noperation provides important information.\n8. 2.7.1  Get   Recipe   Descriptors   \xf3   The   get   recipe\ndescriptor operation   returns   the   descriptor   of   a\nspecified   recipe:   the   generic   descriptor,   the   body\ndescriptor,  and  the  agent-specific  descriptors  of  any\nexisting agent-specific datasets.\nA recipe descriptor may be used to determine if two or\nmore recipes are identical or which is most recent.\nThe get recipe descriptors operation is invoked with the\nRMNGetDescriptor service.\n8. 3  Recipe  State  Model  \xf3  An  existing  recipe  has\ndifferent states of interest to RMS. These are shown in\nFigure 8.7. The Recipe Available State Model in Figure\n8. 7 combines the separate models for VERIFICATION,\nAPPROVAL,      PROTECTION,      LINKAGE,      and\nCERTIFICATION   as   AND   substates   of   RECIPE\nAVAILABLE."),(0,a.yg)("p",null,"Figure 8.7\nRecipe Available State Model"),(0,a.yg)("p",null,"These states have been discussed in previous sections and are associated with one or more of the recipe's attributes,\nas follows:\nVERICATION:     Verified\n,\nAPPROVAL:     ApprovalLevel\n,"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 56\nPROTECTION: the interaction of ApprovalLevel and the namespace attribute RecipeReadOnlyLevel,\nLINKAGE:     Linked\n, and\nCERTIFICATION:     Certified\n.\nThe table of transitions is given in Table 8.1.\nTable 8.1  Table of Transitions"),(0,a.yg)("h1",{id:""}),(0,a.yg)("h1",{id:"current-----------state-----------trigger-----------new-state-action-comment"},"Current           State           Trigger           New State Action Comment"),(0,a.yg)("p",null,"1      (entry      to      Recipe\nAvailable)\nRecipe is created. Recipe Available. Initialize generic\nattributes.\nNone.\n2      (default      entry      to\nVERIFICATION)\nRecipe is created. UNVERIFIED Verified reset. Newly created recipe is\nunverified.\n3      UNVERIFIED      Requested verification\noperation is successful.\nVERIFIED                Set                Verified to\nTRUE.\nVerification is performed\nby the recipe executor.\n4      VERIFIED      Requested      verification\noperation, on previously\nverified recipe, fails.\nUNVERIFIED          Reset          Verified. Verification is performed\nby the recipe executor.\n5 VERIFIED Recipe is updated.                   UNVERIFIED                   Reset                   Verified. Updated recipe must be re-\nverified.\n6      (default      entry      to\nLINKAGE)\nRecipe is created. UNLINKED Reset Linked,\nLinkList, and\nLinkParam\n.\nNewly created recipe is\nunlinked.\n7      UNLINKED      Authorized user requested\nlink operation is successful.\nLINKED                   Set                   Linkedto TRUE.\nSet LinkList and\nLinkParam\n.\nSingle-part recipes set\nLinked only.\n8      LINKED      Recipe      is      updated.                  UNLINKED                  Reset                  Linked,\nLinkList\n, and\nLinkParam\n.\nSingle-part recipes set\nLinked\nonly.\n9      LINKED      Recipe      is      re-verified.              UNLINKED              Reset              Linked,\nLinkList\n, and\nLinkParam\n.\nSingle-part recipes set\nLinked\nonly.\n10     LINKED     Authorized user requests the\nunlink operation.\nUNLINKED             Reset             Linked,\nLinkList\n, and\nLinkParam.\nSingle-part recipes set\nLinked only.\n11     (default     entry     to\nPROTECTION)\nRecipe is created. If RecipeRead-\nOnlyLevel\nis zero,\nnew state is\nPROTECTED.\nOtherwise, it is\nUNPROTECTED.\nNone. All recipes are read only\nwhen\nRecipeReadOnlyLevel\nis\nzero.\n12     UNPROTECTED     Authorized user request to\nprotect the recipe.\nPROTECTED           Set           ApprovalLevelto\nthe value in\nRecipeReadOnly-\nLevel.\nRecipe is protected when\napproval level =\nRecipeReadOnlyLevel\n.\n13     UNPROTECTED     Authorized     user     sets\nRecipeReadOnlyLevel to\nvalue greater than or equal\nto approval level.\nPROTECTED           None.           Recipe           is           protected when\napproval level greater than\nor equal to\nRecipeReadOnlyLevel\n.\n14     PROTECTED     Authorized user sets\napproval level to a value less\nthan RecipeReadOnlyLevel\n.\nUNPROTECTED     None.     Recipe     is     unprotected when\napproval level less than\nRecipeReadOnlyLevel\n.\n15     PROTECTED     Authorized user sets\nRecipeReadOnlyLevel\nto a\nUNPROTECTED     None.     Recipe     is     unprotectedwhen\napproval level less than"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 57\nvalue greater than approval\nlevel.\nRecipeReadOnlyLevel\n.\n16     (default     entry     to\nAPPROVAL)\nRecipe is created. UNAPPROVED Reset\nApprovalLevel\n.\nNewly created recipe is\nunapproved.\n17     UNAPPROVED     Authorized user sets non-\nzero approval level.\nAPPROVED             Set             ApprovalLevelas\nspecified by the user.\nUser assigns approval level\nto a specific value.\n18     APPROVED     Authorized user sets\napproval level to zero.\nUNAPPROVED       Reset\nApprovalLevel\n.\nUser assigns a zero value as\napproval level.\n19     APPROVED     Recipe     is     linked.                     UNAPPROVED                     Reset\nApprovalLevel\n.\nUser is required to\nspecifically approve a\nnewly linked recipe set.\n20     APPROVED     Recipe     is     updated.                  UNAPPROVED                  Reset\nApprovalLevel\n.\nA modified recipe is\nunapproved.\n21     (default     entry     to\nCERTIFICATION)\nRecipe is created.                   UNCERTIFIED                   None.                   Newly created recipe has\nno agent-specific attributes.\n22     UNCERTIFIED     Authorized user assigned\nnon-zero certification level.\nCERTIFIED              Create              agent-specific\ndataset if necessary.\nSet Certified\nto\nspecified value.\nUser assigns certification\nlevel.\n23     CERTIFIED     Authorized user assigned\nzero certification level.\nUNCERTIFIED        Reset        Certified.  Agent-specific dataset not\nrequired if there are no\nagent-specific attributes.\n24     CERTIFIED     Authorized user changes\nagent-specific variable\nparameter restrictions.\nUNCERTIFIED        Reset        Certified\n. A change in restrictions\naffects performance of\nrecipe.\n25     CERTIFIED     Recipe is unlinked.                  UNCERTIFIED                  Reset                  Certified\nattribute.\nAgent-specific dataset not\nrequired if there are no\nagent-specific attributes.\n26     RECIPE\nAVAILABLE\nAuthorized user deletes\nunprotected recipe.\n(Undefined recipe\nno longer exists.)\nStorage occupied by\nrecipe becomes\navailable.\nNone."),(0,a.yg)("ol",{start:8},(0,a.yg)("li",{parentName:"ol"},"4  Table of Operations \xf3 Table 8.2 lists the recipe management operations in the order presented in this section.\nThe  column  labelled  \xecRqmt\xee  is  used  to  indicate  those  operations  that  are  required  for  fundamental  compliance  to\nRMS.\nTable 8.2  Recipe Management Operations\nOperation                                                                              Description                                                                              Rqmt\ncreate recipe")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"A new recipe body is entered into the namespace. Y\nupdate recipe"),(0,a.yg)("li",{parentName:"ul"},"The body of an existing recipe is replaced. Y\nverify recipe Check the syntax or format of a recipe body for correctness. Y\nlink recipe A main recipe is linked.                                                                                                          Y\nunlink recipe An unprotected linked recipe is unlinked.                                                                              N\nmodify variable parameters A linked recipe's parameter definitions are modified within an agent-specific dataset.N\napprove recipe Set the recipe's approval level to a non-zero value. N\nprotect recipe Set the recipe's approval level to the value in RecipeReadOnlyLevel.                                  N\nunprotect recipe Set the recipe's approval level to zero. N\ncertify recipe A linked recipe's certification level is set to a non-zero value. N\ndecertify recipe A linked recipe's certification level is set to zero. N\nget recipe descriptor A recipe's descriptor is requested. Y\n*This operation is also covered under Namespace Management Operations.")),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 58\n9  Namespace Management Operations\nNamespace       management       operations       include\noperations that affect the namespace itself in some way\nand those operations that provide information about the\nnamespace  or  its  manager,  or  that  require  knowledge\nabout more than one recipe.\nNamespace operations defined in RMS are presented in\ngroups of similar functionality:\n\u2022 operations  on  the  namespace  (create,  delete,  and\nrename namespace),\n\u2022 operations   that   provide   information   about   the\nnamespace  or  its  recipes  (get  available  storage,\ncheck recipe status, and get best version), and\n\u2022 operations  on  recipes  that  affect  the  set  of  recipe\nidentifiers  within  the  namespace  and/or  moving  a\nrecipe  as  a  whole  (create,  delete,  store,  retrieve,\ncopy, and rename recipe),\n\u2022 operations  that  always  require  interactions  with  a\nrecipe   executor (verify,   download,   and   upload\nrecipe).\nNamespace  management  operations  may  be  invoked\nthrough namespace  services  defined  in  Section  12.  In\nmost   cases,   service   scenarios   consist   of   a   single\nmessage    request    from    the    service    user    and    a\ncorresponding  response  from  the  namespace  manager.\nThis case is illustrated in Section 12.1.\nScenarios  are  shown  only  for  operations  that  require\nadditional  messages.  These  operations  are  one  of  two\ntypes:  operations that may be performed on more than\none  recipe  (such  as  delete  recipe)  and  operations  that\nrequire interactions with a recipe executor to complete.\nOperations  such  as  these  may  require  more  time  to\ncomplete.  The  initial  response  to  the  message  service\nrequest   only   indicates   the   intent   to   perform   the\noperation. The namespace manager informs the service\nuser  of  the  completion  of  each  individual  operation  by\nsending  the  notification  message  RMNComplete.  (See\nSection 12.1 for more detail.)\n9. 1  Applications of Object Services \xf3 A manager shall\ncomply   with   SEMI   E39   (Object   Services   Standard\n(OSS):          Concepts,     Behavior,     and     Services)\nspecifications  for  fundamental  requirements  and  with\nthe requirements for Filters and Owner Objects.\n9. 1.1    Object   Specifiers   \xf3   The   \xecowns/owned   by\xee\nrelationship   is   used   by   OSS   to   define   the   object\nspecifier  used  for  scope.  Recipes  within  a  namespace\nare owned by the namespace in which they reside. The\nnamespace in turn is owned by its manager. The agent\nthat  provides  the  storage  and  services  for  a  centralized\nnamespace owns both the manager and the namespace.\nAn object specifier has the form of:\n\xectype\n1\n: id\n1"),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},"\xd6type\nn\n: id\nn\n\xee\nwhere  \xectype\ni\n\xee  and  \xecid\ni\n\xee  represent  the  object  type  and\nobject identifier, respectively, of the ith object instance\nin the sequence, and where each object is owned by the\npreceding object in the sequence and is the owner of the\nsucceeding object.\nA namespace specifier is an object specifier applied to\nnamespaces.  A  recipe  specifier  is  an  object  specifier\napplied to recipes.\nObject  types  in  the  object  specifier  may  be  omitted\nwhere   they   may   be   otherwise   determined.   For   the\nrecipe  specifier,  when  omitted,  they  are  determined  by\ntheir  relative  positions,  with  the  recipe  identifier  in  the\nfinal   position,   preceded   by   a   namespace   identifier.\nAdditional identifiers  preceding  that  of  the  namespace\nare those of agents.\nAn  example  of  a  namespace  specifier  for  a  namespace\n\xecNS-MOM\xee  owned  by  an  agent  \xecEtch01\xee  would  be\n\xecAgent:Etch01>RNS:NS-MOM>\xee   or   (where   object\ntypes   can   be   otherwise   determined)   \xecEtch01>NS-\nMOM\xee.  A  recipe  specifier  for  recipe  \xec/PROCESS/\nABC;5\xee    stored    in    NS-MOM    would    be    \xecAgent:\nEtch01>RNS:NS-MOM>/PROCESS/ABC;\n5>\xee.\nWhere   the   manager is to be used instead of the\nnamespace,  the  object  type  of  the  manager  must  be\nincluded.\nA recipe in a namespace also owns its components. An\nagent-specific  attribute  is  accessed  through  the  recipe\nowner.\n9. 1.2   Required  Object  Services  \xf3  A manager  shall\nsupport operations for Get Attributes and Set Attributes\nfor  the  attributes  of  the  namespace,  the  recipes  within\nthe namespace,  and  the  manager  itself.  For  a  shared\nnamespace,  access  to  different  agent-specific datasets\nshall be supported.\nWhen a recipe\xeds attributes are changed through the Set\nAttributes operation, the appropriate attribute timestamp\nand length attributes shall be updated as well.\nA manager   shall   support   the   Get   Type   and   Get\nAttribute   Name   operations   for   the   object   types   of\nnamespace, recipe, recipe components, and manager.\n9. 2  Namespace  Operations  \xf3  This  section  describes\noperations that are performed on a namespace.\n9. 2.1   Create  Namespace  \xf3  The  create  namespace\noperation  is  used  to  define  a  namespace  and  assign  a\nname  to  be  used  as  its  identifier  ObjID\n.  The  name  is\nassigned only by an authorized user, except that a name")),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 59\nof    \xecDefault\xee    is    prohibited.    Once    created,    the\nnamespace shall be ready to accept recipes.\nThis  is  an  optional  capability  that  is  not  required  if  the\nowner  agent  that  provides  the  namespace  capabilities\nalso   provides   an   installed   default   namespace   (see\nSection 6) that cannot be deleted. In this case, a means\nof  recreating  the  namespace  shall  be  provided  in  the\nevent the namespace becomes damaged.\nThe create  namespace  operation  is  invoked  with  the\nmessage service RMNCreateNS.\n9. 2.2    Delete   Namespace   \xf3   The delete   namespace\noperation   is   the   inverse   of   the   create   namespace\noperation.  A  namespace  that  is  not  empty  may  not  be\ndeleted.  It  is  recommended  that  the  default  namespace\nof  a  recipe  executor  should  not  be  deleted.  This  is  an\noptional    capability    required    only    if    the    create\nnamespace operation is supported.\nThe delete  namespace  operation  is  invoked  by  the\nmessage service RMNDeleteNS.\n9. 2.3   Rename  Namespace  \xf3  The rename  namespace\noperation  allows  an  authorized  user  to  change  the\nidentifier of the namespace. It is recommended that the\ndefault  namespace  of  a  recipe  executor  should  not  be\nrenamed. This is an optional capability required only if\nthe create namespace operation is supported.\nThe rename  namespace  is  invoked  by  the  message\nservice RMNRenameNS.\n9. 3  Namespace Informational Operations\n9. 3.1    Get   Available   Storage   \xf3   The get   available\nstorage operation  is  used  to  determine  the  size  of  the\nremaining  recipe  storage  capacity,  in  bytes.  The  value\nreturned  shall  exclude  any  overhead  requirements  for\nstorage  of  one  generic  recipe.  That  is,  it  shall  be\nassumed that sufficient storage exists for a single recipe\nwith  a  combined  generic  attribute  length  and  body\nlength  less  than  or  equal  to  the  returned  value,  and\nignoring   possible   space   requirements   for   additional\nagent-specific datasets. This is a required operation.\nThe get  available  storage  operation  is  invoked  by  the\nmessage service RMNSpaceInquire.\n9. 3.2   Check  Recipe  Status  \xf3  The check  recipe  status\noperation  checks  a  recipe  identifier  and  returns  the\nstatus  for  existence  and  read-only  (PROTECTED  or\nUNPROTECTED   state).   It   also   returns   the   next\navailable numeric version. This is a required operation.\nThis  operation  may  be  used  to  determine  if  a  given\nrecipe identifier  will  be  accepted  prior  to  sending  it  to\nthe namespace and to obtain an available version if the\noriginal identifier is used for a read-only recipe.\nThe check  recipe  status  operation  is  invoked  by  the\nmessage service RMNRecStatInquire.\n9. 3.3    Get   Best   Version   \xf3   The get   best   version\noperation checks for the best default version of a recipe\nwith  a  specified  class  and  name  and  for  an  optional\nspecific member  agent. If a member  agent is specified,\nthen  in  addition  to  the  rules  for  selection  of  a  default\nversion  defined  in  Section  3.2.3.4.1,  the  version  with\nthe highest certification level for that agent is selected.\nThis is a required operation.\nThe get   best   version   operation   is   invoked   by   the\nmessage service RMNVersionInquire.\n9. 4    Namespace   Recipe   Operations   \xf3   This   section\ndescribes  the  recipe  operations  that  affect  the  set  of\nrecipe identifiers  within  the  namespace  and/or  involve\nmoving an entire recipe.\n9. 4.1   Create  Recipe  \xf3  A  recipe  is  created  through  the\ncreate  recipe  operation  when  a  namespace is sent a\nrecipe with an identifier, body, body descriptor, and the\nattributes    BodyFormat\nand    EditedBy    only.    This\noperation     sets     the     attributes     AttrLength\nand\nAttrChgTime\nand    clears    the    remaining    generic\nattributes.\nThis  capability  allows  a  recipe  body  that  has  been\ncreated  off-line  to  be  stored  in  a  namespace.  It  is\nrequired  of  any  namespace  intended  for  use  other  than\nas  a  default  namespace  for  hardware-specific  recipes\nonly\n10\n.\nThe create  recipe  operation  is  invoked  by  the  message\nservice RMNCreate.\n9. 4.2  Delete Recipe \xf3 The delete recipe operation has\nthe  effect  of  deleting  a  recipe  from  the  namespace.\nComplete physical erasure of the recipe is not required,\nbut the recipe is no longer considered to be stored in the\nnamespace,  is  no  longer  accessible,  and  the  storage\nspace that it used is freed.\nA read-only recipe may not be deleted.\nThe delete  recipe  operation  is  invoked  by  the  message\nservice  RMNAction.  More  than  one  recipe  may  be\nspecified  by  the  service  user.  Figure  9.1  illustrates  the\nflow of messages in this case. The namespace manager\nresponds  to  the  initial  request  with  an  intent  to  comply\nbefore  performing  any  deletions.  As  each  deletion  is\ncompleted, the manager notifies the service user of the\nresults using RMNComplete."),(0,a.yg)("p",null,"10 In the case of the default namespace dedicated to hardware-\nspecific recipes, the recipes may always be created initially by the\nrecipe executor and uploaded to namespace."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 60"),(0,a.yg)("p",null,"Figure 9.1\nDelete Recipe Scenario\n9. 4.3  Store  Recipe  \xf3 The store  recipe  operation  is\nused  to  store  a  complete  recipe,  including  its  body,\ngeneric   attributes,   and   one   or   more   agent-specific\ndatasets,  in  a  namespace.  Note:  methods  of  storing\nrecipes are not specified by RMS.\nStorage shall be denied if the specified recipe identifier\nis  already  used  by  an  existing  read-only  recipe  or  if\nthere  is  insufficient  storage  available  for  the  recipe.\nOtherwise,   the   recipe   shall   be   accepted   into   the\nnamespace.\nThe store  recipe  operation  is  invoked  by  the  message\nservice RMNStore.\n9. 4.4   Retrieve  Recipe  \xf3  The retrieve  recipe  request\nspecifies  the  identifier  of  a  recipe.  If  the  recipe  exists\nwithin  the  namespace,  the  namespace  manager  returns\nthe   requested   recipe.   Otherwise,   it   shall   deny   the\nrequest. This is a required operation.\nIt   is   also   possible   to   retrieve   a   recipe's   generic\nattributes set to a non-default value and/or one or more\nof   its   agent-specific   datasets   without   retrieving   its\nbody.\nThe retrieve recipe operation is invoked by the message\nservice RMNRetrieve.\n9. 4.5  Copy Recipe \xf3 The copy recipe operation causes\na new copy of a recipe, with a different identifier from\nthe original recipe, to be created within the namespace.\nIf the identifier for the new copy is already in use by a\npre-existing read-only recipe, the namespace shall deny\nthe request.\nThe copy  recipe  operation  is  invoked  by  the  message\nservice RMNCopy.\n9. 4.6   Rename  Recipe  \xf3  The  rename  recipe  operation\ncauses  a  recipe  to  be  assigned  a  new  identifier within\nthe namespace. If the new identifier is already in use by\na  pre-existing  read-only  recipe,  the  namespace  shall\ndeny  the  request.  In  this  case,  it  may  suggest  a  new\nversion according to the rules in Section 3.2.3.3.\nThe rename recipe operation is invoked by the message\nservice RMNRename.\n9. 4.7   Verify  Recipe  \xf3  A manager  is  not  required  to\nunderstand   the   syntax   or   semantics   of   the   recipe\nlanguage   of   a   source   recipe   or   to   understand   the\ninternal  format  of  an  object  form  recipe.  To  verify  a\nrecipe, the manager may require the services of a recipe\nexecutor,  described  in  Section  6.  In  this  case,  the\nmanager   shall   request   verification   from   the   recipe\nexecutor  of  one  of  the  agents  listed  in  its  Members"),(0,a.yg)("p",null,"attribute  and  shall  return  the  resulting  status  and  error\ninformation to the initial requestor. (See Section 11 for\nmore detail.) This is a required operation."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 61"),(0,a.yg)("p",null,"Figure 9.2\nVerify Scenario\nThe verify  recipe  operation  is  invoked  by  the  message\nservice   RMNAction.   Figure   9.2   shows   a   typical\nsequence of the message flow when the verify operation\nis   requested   for   multiple   recipes.   The   namespace\nmanager responds  to  the  service  request  RMNAction\n(Verify)   with   an   intent   to   perform   the   requested\noperations.   Each   recipe   specified   in   the   request   is\ndownloaded  to  a  recipe  executor  of  an  agent  listed  in\nthe namespace  attribute  Members\n.  (Note:  where  the\nnamespace  manager  and  recipe  executor  are  provided\nby   the   same   agent,   formal   RMS   services   are   not\nrequired  for  communications  between  the  two.)  In  this\nexample,    the    recipe    executor    responds    to    the\nnamespace  manager  with  an  intent  to  comply,  verifies\nthe  recipe,  and  returns  the  information  required  for  the\ncompletion   of   the   verify   operation   as   described   in\nSection   8.2.3.1.   The   namespace   manager,   in   turn,\nreturns the final status of the operation for that recipe in\nthe notification message RMNComplete.\nThe recipe executor provides   two   operations   for\nperforming  verifications,  \xecdownload  and  verify\xee  and\n\xecverify\xee.  The  former  operation  does  not  typically  re-\nverify  already  verified  recipes.  See  Sections  11.2.1  and\n11. 2.2 for detail.\nThe verify  recipe  operation  is  invoked  by  the  message\nservice RMNAction.\n9. 4.8    Download   Recipe   \xf3   The download   recipe\noperation  causes  the  namespace  manager  to  download\na recipe to the recipe executor of a specified agent (see\nSection  11.2.1).  This  operation  differs  from  the  verify\noperation,    which    results    in    a    download    to    an\nunspecified  recipe  executor  if  the  namespace  manager\nis not able to perform the verification without help.\nThe  namespace  manager  is  responsible  for  converting\nthe  form  of  a  managed  recipe  to  that  of  an  execution\nrecipe  for  downloading.  This  is  accomplished  through\nthe following steps:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"If  the  recipe  is  not  verified,  then  no  conversion  is\nperformed.     The     attributes     ExecAttrLength\nand\nExecAttrChgTime\nare  set  and  maintained  only  by  the\nrecipe executor.  These  attributes  are  not  sent  with  the\ndownloaded recipe."),(0,a.yg)("li",{parentName:"ol"},"The  generic  attributes  ExtRef\nand  Parameters  of  the\nverified recipe are not sent with the downloaded recipe."),(0,a.yg)("li",{parentName:"ol"},"If an agent-specific dataset exists that corresponds to\nthe destination recipe executor, and if the agent-specific\nattributes  AgentSpec  Comments\nand  Certified  are  non-\nempty,   they   are   included   in   the   attributes   of   the\ndownloaded recipe."),(0,a.yg)("li",{parentName:"ol"},"The   execution   recipe   attribute   ExecLinkParam")),(0,a.yg)("p",null,"combines    the    contents    of    the    generic    attribute\nLinkParam\nand  the  agent-specific  attribute  AgentSpec\nLinkParam.   If   an   agent-specific dataset   exists   that\ncorresponds  to  the  destination  recipe  executor,  and  if\nthere    are    variable    parameter    initial    values    and\nrestrictions  in  the  agent-specific  attribute  AgentSpec\nLinkParam,   then   they   replace   their   corresponding\nelements  in  the  generic  attribute  LinkParam\n,  and  the\nresults are placed in the ExecLinkParam\nattribute of the\ndownloaded recipe."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 62\nThe download   recipe   operation   is   invoked   by   the\nmessage service RMNAction.\n9. 4.9   Upload  Recipe  \xf3  The upload  recipe  operation\ncauses  the  manager  to  upload  a  recipe  from  the  recipe\nexecutor of a specified agent (see Section 11.2.3). This\noperation  is  the  equivalent  of  a  namespace-initiated\nrecipe create (if the specified recipe identifier does not\nalready exist in the namespace) or a recipe update.\nThe upload  operation  allows  recipes  that  have  been\ncreated or modified by the recipe executor to be placed\nunder  management  in  a  namespace.  Such  recipes  are\nalways unlinked.\nIn   addition,   it   is   possible   to   upload   previously\ndownloaded recipes. However, due to the differences in\nthe attributes, certain intermediate information available\nin  a  managed  recipe,  such  as  ExtRef\nand  Parameters,\nmust   be   re-created   for   the   uploaded   recipe   by\nrequesting  the  recipe  executor  to  verify  the  recipe  and\nsend the results.\nIn the case of the derived object form recipe, where the\noriginal   source   recipe   identified   in   the   SrcRcpID"),(0,a.yg)("p",null,"attribute  (common  to  both  recipe  types)  exists  within\nthe namespace,  most  of  the  attributes  of  the  derived\nobject form recipe are identified to those of the original.\nThe     exceptions     are     the     attributes     AttrLength\n,\nAttrChgTime\n,      BodyLength,      BodyFormat,      and\nEditTime\n, which are all set by the recipe executor at the\ntime the derived object form recipe is derived.\nThe namespace  manager  is  responsible  for  converting\nthe  uploaded  execution  recipe  to  a  managed  recipe  for\nstorage in the namespace. This is accomplished through\nthe following steps:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"If  the  recipe  is  not  verified,  then  no  conversion  is\nperformed.     The     attributes     ExecAttrLength\nand\nExecAttrChgTime, if uploaded, are discarded."),(0,a.yg)("li",{parentName:"ol"},"The  generic  attributes  ExtRef\nand  Parameters  of  the\nverified  recipe  are  not  sent  with  the  uploaded  recipe.\nThey must be obtained separately through the verify."),(0,a.yg)("li",{parentName:"ol"},"If an agent-specific dataset exists that corresponds to\nthe  destination  recipe  executor,  then  if  the  execution\nrecipe  attributes  AgentSpec  Comments\nand  Certified\nare  non-empty,  they  are  placed  in  the  corresponding\nattributes  of  an  agent-specific  dataset  for  that  recipe\nexecutor.   If   necessary,   an   agent-specific   dataset   is\ncreated."),(0,a.yg)("li",{parentName:"ol"},"Any    variable    parameter    initial    values    and\nrestrictions in the execution recipe attribute AgentSpec-")),(0,a.yg)("p",null,"LinkParam\nreplace  their  corresponding  elements  in  the\ncorresponding agent-specific attribute (if the dataset for\nthat agent  exists)  in  the  uploaded  recipe.  If  it  can  be\ndetermined  that  the  contents  of  AgentSpec  LinkParam"),(0,a.yg)("p",null,"are  not  different  from  those  of  the  generic  attribute\nLinkParam\n(as  in  the  case  of  a  derived  object  form\nrecipe),    then    AgentSpec    LinkParam\nshould    be\ndiscarded.  If  necessary,  an  agent-specific  dataset  is\ncreated for the appropriate agent.\nThe upload recipe operation is invoked by the message\nservice RMNAction.\n9. 5  Synchronization \xf3   In   addition   to   the   explicit\noperations  that  are  invoked  through  specific  message\nservices,  the  recipe  namespace manager  may  provide\nthe   optional   capability   of   sychronization   of   the\nmanaged  recipes  with  execution  recipes  stored  by  the\nrecipe  executors  of  its  member  agents.  This  section\ndescribes the synchronization capability.\nThe ExecChgCtrl\nattribute of a recipe is used to specify\ntypes  of  permitted  changes  in  execution  recipes.  The\nrecipe  executor  is  permitted  to  change  the  recipe  body\nor to save the last settings used for variable parameters\nin  the  ExecLinkParam\nattribute  of  the  execution  recipe\nonly     when     expressly     granted     permission     in\nExecChgCtrl\n.\nExecChgCtrl\nmay  also  require  the  recipe  executor  to\nsend  a  change  notification  message  to  the  recipe\xeds\noriginating namespace. The originating namespace is\neither   the   namespace   from   which   the   recipe   was\ndownloaded or to which a new recipe will be uploaded.\nChange   notification   applies   to   both   the   explicitly\npermitted  changes  (modification  and  saving  the  last\nvalue)  and  to  a  derived  object  form recipe  built  from  a\nsource  form  recipe. Change  notification  informs  the\nnamespace  that  a  change  of  interest  to  the  namespace\nhas occurred.\nNamespaces  with  synchronization  capability  provide\ntwo  additional  attributes,  SynchOn\nand  SynchFail.  The\nfirst  allows  the  user  to  disable  synchronization  or  to\nselect  the  types  of  synchronization  desired,  and  the\nsecond records execution recipe specifiers of recipes for\nwhich synchronization failed.\nSynchronization for a new or changed recipe, or a new\nrecipe form,  consists  of  uploading  the  execution recipe\nfor  which  a  change  notification has been received and,\nwhen necessary to protect a read-only recipe, assigning\nit  a  new  version  number  and  requesting  the  recipe\nexecutor to rename the corresponding execution recipe.\nNote   that   the   recipe   executor   is   required   to   deny\nattempts   to   rename   a   currently   selected   execution\nrecipe.\nThe recipe  executor  saves  the  last  value  of  a  variable\nparameter   in   the   execution   recipe   attribute   Exec-\nLinkParam. Synchronization   for   a   new   last   value\nconsists  of  getting  the  value  of  this  attribute  from  the\nrecipe executor and updating the AgentSpec LinkParam"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 63\nattribute  of  the  agent-specific  dataset  for  the  recipe\nexecutor\xeds  agent.  Note  that  attributes  of  a  recipe  may\nchange without affecting the version number.\nSynchronization   may   fail   either   through   failure   to\nproperly upload  an  execution  recipe,  through  failure  to\nproperly  retrieve  the  value  of  the  execution recipe\xeds\nExecLinkParam\nattribute,    or    through    failure    to\nsuccessfully  rename  the  recipe  stored  by  the  recipe\nexecutor.  The  attribute  SynchFail\ncontains  a  list  of\nrecipe  specifiers  of  the  execution  recipes  for  which\nsynchronization    was    attempted    but    failed    to    be\nsuccessfully  completed.  A  recipe  specifier  shall  be\ndeleted  from  SynchFail\nif  a  later  attempt  at  the  failed\noperation  for  that  recipe  is  successful.  The  authorized\nuser may  also  remove  one  or  all  recipe  specifiers from\nthis attribute.\nThe attribute SynchOn\nis set by the user to indicate the\ntypes  of  changes  for  which  synchronization  shall  be\nperformed. SynchOn\nmay  be  set  to  specify  synchroniz-\nation for changes to the body, changes to the last value,\ncreation of a new recipe, building a new derived object\nform recipe from a source form, or any combination of\nthese settings. A value of zero disables synchronization.\nSynchOn\nis  an  unsigned  integer.  Possible  values  are\neither  0  (disabled)  or  any  combination  (sum)  of  one  or\nmore of the following decimal values:\n0     =     synchronization     disabled\n1 = changes in body\n2     =     new     execution recipes\n8     =  changes  in  the  last  value  of  one  or  more\nvariable    parameters    (i.e.,    to    the    ExecParam\nattribute of the execution recipe)\n16   =   new   derived object form execution recipes\nNOTE:  Where  possible,  the  values  of  SynchOn\nand\nExecChgCtrl\naddress  the  same  change  issues.  For  this\nreason, a value of 4 is not used, and a new value of 16\nis added.\n9. 6   Table  of  Operations  \xf3  Table  9.1  lists  all  the\noperations defined for namespace management.\nThe  column  labeled  \xecRqmt\xee  is  used  to  indicate  those\noperations that are required for fundamental compliance\nto RMS as a recipe namespace resource."),(0,a.yg)("p",null,"Table 9.1  Namespace Operations\nOperation                                                                                Description                                                                                Rqmt\ncreate namespace A new namespace is created and assigned an identifier. N\ndelete namespace A namespace is deleted. N\nrename namespace The namespace identifier is re-assigned. N\nget available storage Determine the amount of recipe storage available. Y\ncheck recipe status Determine the existence and read-only status of a recipe, and obtain the next numeric version.          Y\nget best version Determine the default version for a given recipe class and name and for an optional agent.                 Y\ncreate recipe A new recipe body is entered into the namespace. Y\ndelete recipe A recipe's identifier is removed from the namespace. Y\nstore recipe A recipe is stored in a namespace. Y\nretrieve recipe A recipe is sent from the namespace. Y\ncopy recipe A new recipe is originated as a copy of an existing recipe. N\nrename recipe A recipe is assigned a new identifier. N\nverify recipe Check the syntax or format of a recipe body for correctness. Y\ndownload recipe A recipe is downloaded to a specified agent's recipe executor.                                                              Y\nupload recipe A recipe is created or updated by uploading a recipe body from a specified agent's recipe\nexecutor.\nN\n9. 7  Namespace Events \xf3 A user of recipe namespace services is potentially interested in any change that occurs to\nor  within  a  namespace  that  was  not  initiated  by  the  user  itself.  Two  such  events  are  defined:  Recipe  Namespace\nChange  and  Recipe  Change.  A  Recipe  Namespace  Change  event  occurs  when  a  namespace  is  created,  deleted,  or\nrenamed,  or  when  a  recipe  is  created,  deleted,  copied,  or  renamed.  A  Recipe  Change  event  occurs  whenever  the\nbody or any of the attributes, including agent-specific attributes, of an existing recipe is changed."),(0,a.yg)("p",null,'SEMI E42-0704 \xa9 SEMI 1995, 2004 64\nThe   selection   of   events   to   be   reported,   and   the\nmechanisms  for  reporting  these  events,  are  defined  in\nSEMI E53 (Event Reporting).\n10  Distributed Recipe Namespace\nManagement Operations\nThis  section  defines  the  operations  required  for  the\ndistributed recipe namespace capability. Operations are\ndefined for the DRNS segment, the DRNS recorder, and\nthe DRNS  manager,  in  that  order.  Support  for  the\ndistributed  recipe  namespace  capability  is  not  required\nfor RMS compliance.\n10. 1  Distributed       Recipe       Namespace       Segment\nOperations  \xf3  This  section  defines  the  operations  that\nshall be supported by the distributed recipe namespace\nsegment.\n10. 1.1  Object   Services   \xf3   The   DRNS segment   is\nconsidered to own the recipes that it stores.\nThe segment  specifier  is  the  object  specifier  for  a\nDRNS         segment         and         has         the         form\n"type1:id1>...>type2:id2".  An  attached  DRNS  segment\nis  owned  by  the  agent  providing  the  DRNS  segment\ncapabilities,  by  the  distributed  recipe  namespace  of\nwhich it is a component, and by the DRNS manager  to\nwhich  it  is  attached,  and  shall  be  accessible  by  any  of\nthese  three  paths.  An  unattached  DRNS  segment  is\nowned by the providing agent.\nAn example of a segment specifier for a DRNS segment\nnamed  ABC_Etch_Seg,  a  component  of  a  namespace\nnamed   WetEtchA   provided   by   an   agent   named\nWetEtch003, is\n"Agent:WetEtch003>RNSD:WetEtchA>RNSDSegmen\nt:ABC_Etch_Seg".\nFor   a   master   segment   Alpha   provided   by   agent\nRecipeServer, this becomes\n"Agent:RecipeServer>RNSD:WetEtchA>RNSDMaster\n:Alpha."\nNOTE:   The   form   of   the   specifier   used   for   DRNS\nsegments  and  DRNS  recorders  will  vary.  For  example,\nto specify a segment to be attached to a DRNS manager,\nthe specifier must include the object type and identifier\nfor  the  agent  providing  the  segment  capability.  Once\nthe segment is attached, it may be specified through the\nnamespace hierarchy, as in the example above.\n10. 1.1.1  Attribute  Read/Write  \xf3  The  DRNS  segment\nshall  support  the  get  attributes  operation  for  itself  and\nall recipes that it has stored.\nIt   shall   support   the   set   attributes   operation   for   its\nrecipes only according to the restrictions against change\ndefined in Section 5.4.2 and within Section 10.1.\nIf  requested  to  change  read/write  attributes,  it  shall\nrequest  and  receive  permission  to  change  attributes\nprior to making such change.\nA  request  to  change  either  several  generic  attributes  at\nthe same time, or several agent-specific attributes for a\nspecific agent-specific  dataset  at  the  same  time,  is\nconsidered   for   approval   purposes   as   one   change.\nHowever,  changes  to  both  generic  and  agent-specific\nattributes shall not be included in one change request or\nchange.\n10. 1.1.2  Create and Delete Operations \xf3 The segment\nmay  support  both  the  create  object  and  delete  objects\npair of operations. The authorized user who invokes the\ncreate object operation shall assign a name to be used as\nits name  ObjID\n.  The  name  "Default"  is  prohibited.\nOnce created,   the   segment   shall   be   attached   to   a\nspecific manager   before   it   is   permitted   to   accept\nrecipes.\nThe  create  and  delete  operations  are  optional  if  the\nowner   agent   that   provides   the   distributed   recipe\nnamespace  segment  capabilities  provides  an  installed\ndistributed  recipe  namespace  segment  that  cannot  be\ndeleted. In this case, a means of recreating the segment\nshall  be  provided  in  the  event  the  segment  becomes\ndamaged.  If  one  of  these  two  operations  is  supported,\nboth are required.\nThe   attributes   Namespace\n,  NamespaceManager,   and\nRecipeReadOnlyLevel\nshall  be  set  to  null  values  at  the\ntime the segment is created.\nA segment  that  is  attached  or  that  contains  recipes  (is\nnot empty) shall not be deleted.\n10. 1.1.3     Object    Attachment    Operations    \xf3    The\nsegment  shall  support  the  operations  to  attach  and\nreattach  to  a  DRNS  manager,  and  also  the  operations\ninvoked  by  its  manager  to  detach  itself  from  a  DRNS\nnamespace manager. It shall also support the attach set\nattributes  operation.  Certain  RMS  operations  shall  be\naccepted  only  when  received  from  its  manager,  as\nindicated below.\nAll  requests  for  changes  to  recipes  within  the  segment\nshall  be  sent  to  the  DRNS  manager  to  which  it  is\nattached.\nThe manager    shall    set    the    segment    attributes\nNamespace\n,   NamespaceManager,    and    RecipeRead-\nOnlyLevel  when  attaching  or  reattaching  a  segment.  It\nmay  change  these  attributes  for  an  attached  segment  at\nany time.\nThe  detach  operation  breaks  the  logical  connection\nbetween  the  segment  and  its  manager.  The  segment\nbecomes  unattached,  and  the  values  of  Namespace\n,\nNamespaceManager\n, and RecipeReadOnlyLevel are set'),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 65\nto  a  null  value.  All  recipes  and  recipe  attributes  are\nconsidered  as  read-only  during  the  time  the  segment  is\nunattached.\nThe  reattach  object  operation  is  used  in  rebuilding  a\ndistributed  recipe  namespace.  This  operation  sets  the\nvalue  of  the  attribute  NamespaceManager\nto  the  name\nof  the  new  manager.  The  segment  returns  a  new  token\nvalue to the manager.\nThe  request  to  reattach  itself  serves  to  inform  the\nsegment  that  any  of  its  pending  change  requests  not\npreviously  approved  have  now  been  forgotten.  The\nsegment should either discard the request or resubmit it\nto its new manager.\n10. 1.2    Segment   Recipe   Management   Operations   \xf3\nWithin a distributed recipe namespace environment, all\nrecipe    management    operations    (Section    8)    and\nnamespace    recipe    operations    (Section    9.4)    are\nperformed  by  the  DRNS  segment.  The  DRNS  segment\nshall support all operations defined in these sections.\nOperations  defined  in  Section  9.4  that  involve  a  recipe\nexecutor,   such   as   download   and   upload,   shall   be\nperformed  only  with  a  recipe  executor  that  is  either\nowned   by   the   agent   providing   the   DRNS   segment\ncapability  or  is  owned  by  a  component  within  the\ninternal  hierarchy  of  that  agent.  For  example,  a  DRNS\nsegment  provided  by  a  cluster  tool  may  download  to  a\nrecipe  executor  owned  by  a  cluster  module  but  not  to\nequipment external to the cluster."),(0,a.yg)("p",null,"Figure 10.1\nSegment-Initiated Change Request Message Flow\n10. 1.2.1  Requirements for Approval \xf3 Operations that\nchange  a  recipe  in  any  way  shall  be  denied  unless  the\nDRNS  segment  is  attached  to  a  DRNS  manager.  All\nchanges to logical recipes within a DRNS segment shall\nbe approved by the DRNS manager before the changes\nare made to the recipe stored within the DRNS segment.\nChanges  to  agent-specific datasets  stored  by  attached\ndedicated  segments  are  pre-approved.  This  is  possible\nsince,  at  most,  one  dedicated  segment  has  an  agent-\nspecific  dataset  for  a  specific  agent  for  any  given\nrecipe.  However,  the  segment  shall  notify  its  manager\nimmediately  after  any  such  change  by  sending  the\nRMDNotify   notification,   which   shall   include   the\nattribute   AgentSpec_Agent\n,   to   identify   the   agent-\nspecific  dataset,  as  well  as  all  agent-specific  attributes\nthat  changed,  regardless  of  whether  they  have  been\nreset to their default value or set to a non-default value.\n(Otherwise,  the  entire  agent-specific  dataset  would  be\nrequired.)\nA master   segment,   however,   is   prohibited   from\nchanging   an   agent-specific   dataset   without   explicit\npermission from the manager.\nRequests for changes that are made with RMS services\ndefined  in  Section  12  may  be  sent  from  any  service\nuser, including the DRNS manager. The DRNS segment\nmay  reject  requests  for  invalid  changes,  such  as  a\nrequest  to  modify  a  read-only  recipe.  Otherwise,  the\nDRNS  segment  shall  request  approval  from  its  DRNS\nmanager   for   each   change   (Section   10.3.5).   The\nmanager  responds  by  either  approving,  denying,  or\nputting the request on hold.\nNOTE:   Service   requests   sent   directly   to   a   DRNS\nsegment may not, in some circumstances, be fulfilled.\nIf  the  change  request  is  denied,  then  the  change  is\nprohibited immediately. If it is put on hold, the segment\nshall  retain  the  information  necessary  to  effect  the\ndesired change at a later time.\nIf  the  change  request  is  approved,  the  DRNS  segment\nshall proceed with the change and shall notify its DRNS\nmanager when the change is completed, either normally\nor    abnormally,    through    sending    the    notification\nRMDComplete with the results, as illustrated in Figure\n10. 1.\nThe DRNS  manager  will  put  a  change  request  on  hold\nwhen another change request exists for the same recipe\nand   the   recipe   is   locked.   In   this   case,   the   DRNS\nmanager responds to the segment's change request with\nan operation identifier that the manager uses later when\nsending a segment change approval request."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 66"),(0,a.yg)("p",null,'Figure 10.2\nMessage Flow for Manager Approval of Change\nRequest\n10. 1.2.2    Segment   Change   Approval   \xf3   The   DRNS\nsegment   may   receive   a   segment   change   approval\nrequest for an action that the DRNS segment had earlier\nrequested.  This  informs  the  DRNS  segment  that  an\nearlier change  request  made  by  the  DRNS segment has\nnow  been  approved  for  immediate  action  or  has  been\ncompletely denied.\nThe segment shall respond in one of three ways:\n\xf3   It   may   reject   the   approval   due   to   changes   in\ncircumstances  since  the  original  request  was  made\n(Figure 10.2(a).\n\xf3  It  may  first  fulfill  the  change  request  and  then\nrespond   that   the   change   request   has   now   been\ncompleted,   either   successfully   or   unsuccessfully\n(Figure 10.2(a).\n\xf3  It  may  first  respond  that  it  accepts  the  change\nrequest  and  then  attempt  to  complete  the  change.\nWhen change request has been completed, normally\nor abnormally, the segment shall notify the manager\nof  the  results  with  the  RMDComplete  notification\nservice (Figure 10.2(b).\nRejection  of  segment  change  approval  shall  be  used\nwhen  the  change  is  no  longer  desired.  For  example,  a\nDRNS   segment   "S"   may   request   to   link   a   write-\nprotected  recipe,  and  the  manager  responds  that  the\nrequest   is   on   hold.   Before   the   segment   receives\napproval  for  that  change,  the  same  logical  recipe  is\nlinked  by  a  different  attached  DRNS  segment,  and  the\nresults  are  updated  to  each  DRNS  segment  having  a\ncopy  of  the  logical  recipe,  including  segment  "S".  In\nthis case, the recipe may not be relinked.\n11'),(0,a.yg)("p",null,"The segment  change  approval  operation  is  invoked  by\nthe   message   service   RMDSApproveAction   by   the\nsegment's DRNS manager and is otherwise invalid.\n10. 1.2.3   Scenario  of  a  Segment  Change  Request  \xf3  A\ntypical scenario is illustrated in Table 10.3.\nIn  this  scenario,  a  local  operator  wants  to  change  the\ngeneric   attribute   EditedBy\n.   The   segment   requests\napproval  for  a  generic  attributes  change.  However,  an\nactive change request exists for this recipe."),(0,a.yg)("p",null,"11 Both the DRNS manager and the DRNS segment are responsible\nfor compliance to RMS namespace requirements"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 67"),(0,a.yg)("p",null,"Table 10.3  Typical Change Request Scenario\nManager                                                                                           Segment\nReceives request for attribute change from local operator.\nRequests change from manager.\n<- RMDChangeRequest.req"),(0,a.yg)("p",null,"Manager already has an active change request to link that recipe\nand answers that the request is on hold:\nRMDChangeRequest.rsp ->"),(0,a.yg)("p",null,"The active change request completes. The manager updates the\nchange to the segment:\nRMNStore.req ->"),(0,a.yg)("p",null,"The segment responds that it will make the change and notify\nthe requestor when done.\n<- RMNStore.rsp\nThe segment requests approval to make the second change:\n<- RMDChangeRequest.req\nThe manager approves the second request immediately:\nRMDChangeRequest.rsp ->"),(0,a.yg)("p",null,"The segment stores the generic attributes sent by its manager.\n<- RMDComplete.nfy\nThe segment notifies the requestor of the second change (in\nthis case, its manager) that the change is complete.\n<- RMNComplete.nfy\nWhen all other segments are similarly updated, the manager\nnow approves the segment\xeds earlier request to change generic\nattributes:\nRMDSApproveAction.req ->"),(0,a.yg)("p",null,"The segment makes the approved change to EditedBy\nand then\nresponds:\n<- RMDSApproveAction.rsp\nThe segment sends notification to the operator making request\nfor first change.\nchange:\n<- RMNComplete.nfy\nThe manager requests the new set of generic attributes:\nRMNRetrieve.req ->"),(0,a.yg)("p",null,"The segment sends the generic attributes to any requestor:\n<- RMNRetrieve.rsp"),(0,a.yg)("ol",{start:10},(0,a.yg)("li",{parentName:"ol"},"2  Distributed  Recipe  Namespace  Recorder  \xf3  This  section  defines  the  operations  supported  by  the  distributed\nrecipe namespace recorder."),(0,a.yg)("li",{parentName:"ol"},'2.1  Object Services \xf3 The recorder specifier is the object specifier of the recorder. A recorder is owned by the\nagent  providing  the  DRNS  recorder  capabilities.  When  attached  to  a  DRNS  manager,  it  is  also  owned  by  that\nmanager. An example of the object specifier for a recorder named Recorder182 provided by agent RecorderServer\nis\n"Agent:RecorderServer>RNSDRecorder:Recorder182>".')),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 68\n10. 2.1.1  Attribute Read/Write \xf3 The DRNS distributed\nrecipe   namespace   recorder   shall   support   the   get\nattributes   operation   for   its   attributes.   It   shall   deny\nattempts  to  set  its  attributes  through  the  set  attributes\nservice.\n10. 2.1.2   Object  Create  and  Delete  Operations  \xf3  The\nrecorder  may  support  both  the  create  object  and  delete\nobject  pair  of  operations.  The  authorized  user  who\ninvokes the create object operation shall assign a name\nto  be  used  as  its  name  ObjID\n.  The  name  \"Default\"  is\nprohibited.\nOnce created,   the   recorder   shall   be   attached   to   a\nspecific manager before it is ready to accept data. Once\ncreated,  the  recorder  shall  set  its  attributes  other  than\nObjID\nto null or empty values.\nThe create and delete operations  are  not  required  if  the\nowner   agent   that   provides   the   distributed   recipe\nnamespace  recorder  capabilities  provides  an  installed\ndistributed  recipe  namespace  recorder  that  cannot  be\ndeleted. In this case, a means of recreating the recorder\nshall  be  provided  in  the  event  the  recorder  becomes\ndamaged. If either of these two operations is supported,\nboth are required.\n10. 2.1.3     Object    Attachment    Operations    \xf3    The\nrecorder  shall  support  the  operations  to  attach  and\nreattach to a DRNS manager, and the detach and attach\nset  attributes  when  invoked  by  the  DRNS  manager  to\nwhich it is attached.\nThe recorder  attributes  Namespace\nand  Namespace-\nManager are set by the attach and reattach operations.\nThe  detach  operation  breaks  the  logical  connection  of\nthe recorder to the namespace and managers by setting\nthe recorder  attributes  Namespace\nand  Namespace-\nManager to null values.\nNOTE: In the event that a distributed recipe namespace\nbecomes  damaged,  its  recorder  should  be  left  attached\nso that it may later be reattached to a new manager.\nThe    reattach    operation    is    used    in    rebuilding    a\ndistributed recipe namespace.\n10. 2.2  Add   Segment   Record   \xf3   The   add   segment\nrecord   operation   adds   a   given   segment   (its   object\nspecifier) to the DRNS recorder's internal list of DRNS\nsegments.  A  request  to  add  a  DRNS  segment  that  is\nalready in the list shall be denied.\nThe add  segment  record  operation  is  invoked  by  the\nservice RMDRAddSegRecord.\n10. 2.3   Delete  Segment  Record  \xf3  The  delete  segment\nrecord operation deletes a given segment specifier from\nthe DRNS recorder's internal list of DRNS segments. A\nrequest  to  delete  a  segment  not  in  the  current  list  shall\nbe denied.\nThe delete  segment  record  operation  is  invoked  by  the\nservice RMDRDelSegRecord.\n10. 2.4    Add   Change   Request   Record   \xf3   The   add\nchange   request   record   operation   adds   a   change\nrequest   record   to   the   DRNS   recorder.   The   DRNS\nrecorder keeps, at most, one change request record per\nrecipe  at  any  time.  This  is  intended  to  represent  a\nchange currently approved and active for that recipe. If\nthe DRNS recorder already has a change request record\nfor  the  specified  recipe,  the  information  in  the  new\nchange request replaces the previous information.\nThe  contents  of  the  change  request  record  are  defined\nin Section 10.3.7.4.\nThe add change request record operation is invoked by\nthe service RMDRAddChgRecord.\n10. 2.5   Delete  Change  Request  Record  \xf3  The  delete\nchange  request  record  operation  removes  a  change\nrequest record for a specified recipe.\nThe delete  change  request  record  operation  is  invoked\nby the service RMDRDelChgRecord.\n10. 2.6  Get Change Request Record \xf3 The get change\nrequest  record  operation  returns  the  current  change\nrequest   record   for   a   specified   recipe   or   assigned\nsegment.\nThe get change request record operation is invoked by\nthe  service  RMDRGetChgRecord  and  is  available  to\nany service user.\n10. 3     Distributed    Recipe    Namespace    Management\nOperations  \xf3  Operations  defined  in  Sections  8  and  9\nshall be supported by the DRNS manager. This section\ndefines the additional operations provided by the DRNS\nmanager.  Operations  defined  in  Sections  8  and  9.4  are\ndelegated  by  the  DRNS  manager  to  an  attached  DRNS\nsegment.\n10. 3.1  Object   Services   \xf3   The   DRNS   manager   is\nconsidered  to  own  the  DRNS  segments  and  any  DRNS\nrecorder  currently  attached  to  the  distributed  recipe\nnamespace.  In  addition  to  the  object  services  required\nin  Section  9,  the  DRNS  manager  shall  support  the  get\ntype  and  get  attribute  name  operations  for  its  attached\nobjects.   The   DRNS   manager   shall   support   object\nservices  directed  to  any  of  its  attached  objects  and  to\nrecipes stored by specific DRNS segments.\nThe DRNS  manager  is  considered  to  own  the  recipes\nthat are owned through delegation by any of its attached\nDRNS  segments.  The  Get  Attributes  and  Set  Attributes\noperations   for   a   recipe   may   be   directed   to   the\ndistributed recipe namespace."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 69\nThe  object  specifier  for  an  object  owned  by  a  DRNS\nmanager is formed by concatenating the object type and\nidentifier  for  either  the  manager  or  the  namespace,\nfollowed  by  the  object  type  and  identifier  of  each\nowned  object  in  the  ownership  hierarchy.  An  example\nof  the  object  specifier  for  a  recipe  XYZ;3  stored  by\nDRNS  segment  ABC",(0,a.yg)("em",{parentName:"p"},'Etch_Seg  within  the  distributed\nrecipe namespace WetEtch003 would be:\n"RNSD:WetEtch003>RNSDSegment:ABC_Etch'),"\nSeg>MRcp:XYZ;3\"\nIf  an  agent  or  a  DRNS  segment  is  specified,  then  the\nDRNS  manager  shall  delegate  the  operation  to  the  that\nsegment. Otherwise, the operation shall be delegated to\na master segment.\nA  request  to  set  one  or  more  read-write  attributes  of  a\nrecipe  is  treated  by  the  DRNS  manager  as  a  change\nrequest.\n10. 3.2  Delete   Distributed   Recipe   Namespace   \xf3   A\ndistributed recipe namespace with attachments may not\nbe deleted.\nThe delete  distributed  recipe  namespace  operation  is\ninvoked   by   the   service   RMNDeleteNS   defined   in\nSection 9.2.2.\n10. 3.3   Attach  and  Detach  Supervised  Objects  \xf3  This\nsection  defines  the  support  required  for  the  authorized\nuser to request a DRNS manager to attach or detach one\nor  more  segments  or  a  recorder.  The  operations  and\nservices are defined in detail in SEMI E39 (OSS).\n10. 3.3.1  Attach   Supervised   Object   \xf3   The   attach\nsupervised    object    operation    is    invoked    by    an\nauthorized user to request the DRNS manager to attach\na specified unattached segment or recorder.\nWhen   a   request   to   attach   a   supervised   object   is\naccepted, the DRNS manager sends an attach or detach\nrequest to the specified object.\nThe DRNS   manager   shall   have   the   capability   of\nmanaging   at   least   one   attached   dedicated   and   one\nattached master   segment   at   a   time.   At   most,   one\nrecorder  shall  be  attached  to  a  DRNS  manager  at  any\ngiven time.\nOnce  attached,  the  segment  or  recorder  becomes  a\nformal  part  of  the  namespace  and  is  owned  by  the\nmanager.\nWhen  adding  attachments  to  a  DRNS  manager,  the\nrecorder should be added first, so that it may be used to\nrecord  the  segments  as  they  are  subsequently  attached.\nWhen   the   distributed   recipe   namespace   manager\nreceives  a  request  to  attach  a  segment,  it  sends  that\nrequest  to  the  specified  segment.  If  the  operation  is\nsuccessful,  and  if  a  recorder  is  attached,  the  manager\nrequests  the  distributed  recipe  namespace  recorder  to\nrecord the segment specifier (the object specifier for the\nsegment).  If  the  agent  providing  the  segment  is  not\nalready in the namespace attribute Members\n, it is added\nat this time.\nThe  operation  of  attaching  a  recorder  shall  set  the\ndistributed  recipe  namespace  attribute  Recorder\nto  the\nvalue  of  the  recorder's  attribute  ObjID\n.  The  operation\nof  attaching  a  segment  shall  add  the  segment  specifier\nto   the   Segments\nattribute   of   the   distributed  recipe\nnamespace.\nWhen  a  recorder  is  attached,  all  subsequent  operations\nthat   attach   and   detach   segments   shall   update   the\nrecorder  through  its  operations  to  add  and  remove  a\nrecord of the segment.\nSpecifiers  used  in  the  namespace  attributes  Recorder"),(0,a.yg)("p",null,"and  Segments\n,  and  segment  specifiers  stored  in  the\nDRNS   recorder,   shall   use   the   form   including   the\nspecifier  for  the  agent  providing  the  capability  for  the\nrecorder  or  segment.  This  is  required  for  identification\noutside   the   scope   of   the   current   namespace.   For\nexample,  if  it  later  becomes  necessary  to  rebuild  the\ndistributed recipe namespace, then the segment must be\nlocated through its agent owner rather than through the\nnamespace.\n10. 3.3.2  Detach   Supervised   Object   \xf3   An   attached\nsegment  or  recorder may be detached at any time. The\nmanager  forwards  the  request  to  the  specified  object.\nWhen  a  segment  is  detached,  if  a  recorder  is  attached,\nthen  the  manager  requests  the  recorder  to  remove  the\nsegment that is being detached.\nThe  user  may  request  a  DRNS  manager  to  detach  an\nattached recorder  or  segment  at  any  time.  When  a\nrecorder  is  detached,  the  distributed  recipe  namespace\nattribute  Recorder\nshall  be  set  to  a  null  value.  When  a\nsegment  is  detached,  its  specifier  is  removed  from  any\nattached recorder  and  from  the  Segments\nattribute  of\nthe distributed recipe namespace.\n10. 3.4    Change   Request   Management   \xf3   A   change\nrequest  occurs  whenever  the  DRNS  manager  receives\nany request, from any source, to change a recipe or the\ncontents   of   the   distributed   recipe   namespace   as   a\nwhole.  This  includes  requests  to  change  the  recipe\nidentifier,    a    generic    attribute,    an    agent-specific\nattribute,  or  the  body  of  an  existing  recipe.  It  also\nincludes   all   changes   that   affect   the   set   of   recipe\nidentifiers within the distributed recipe namespace.\nRequests  for  changes  may  come  from  a  source  that  is\neither internal or external to the namespace.\n10. 3.4.1    External   Change   Requests   \xf3   The   DRNS\nmanager   may   receive   a   request,   through   recipe"))}p.isMDXComponent=!0}}]);