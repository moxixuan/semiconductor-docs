---
title: "E97-0200A - © SEMI 200021 const..."
description: "SEMI标准文档"
sidebar_label: "E97-0200A - © SEMI 200021 const..."
sidebar_position: 55
tags: ['SEMI', 'Standard']
custom_props:
  source_type: 'pdf'
  source_file: 'semi-chapter-055.pdf'
  chapter: 55
  page_count: 50
---

import PdfDownloadCard from '@site/src/components/PdfDownloadCard';

<PdfDownloadCard
  pdfLink="/pdfs/semi/055.pdf"
  pdfSize="N/A"
  title="E97-0200A - © SEMI 200021 const..."
  description="SEMI标准文档，共50页"
/>



&lt;!-- Page 1 --&gt;

SEMI E97-0200A © SEMI 200021 const string JobStateChangedSubject =/JobSupervision/Job/StateChanged;/\* This enumerated type identifies the states of Jobs. It is used in event notifications of state changes. \*/ enum JobState &#123;JobUndefined,JobCreated,JobQueued,JobActive,JobExecuting,JobNotPaused,JobPausing,JobPaused,JobNotStopping,JobStopping,JobNotAborting,JobAborting,JobFinished,JobCanceled,JobCompleted,JobStopped,JobAborted &#125;; struct JobStateChangedFilters &#123;Global::Property name;Global::Property previousState;Global::Property newState;&#125;;JobStateChangedFilters Properties: Name Value Type DescriptionName string The name of the Job.PreviousState string Previous state preceding the most recent change.NewState RegistrationState New state following the most recent change. struct JobStateChangedEvent &#123;string eventSubject;Global::TimeStamp eventTimeStamp;JobStateChangedFilters eventFilterData;Global::Properties eventNews;Job aJob;&#125;;/\* If the Job cannot be completed by the specified deadline, a JobDeadlineCannotBeMetEvent should be sent asearly as possible, not necessarily after the deadline has passed. \*/ const string JobDeadlineCannotBeMetSubject =/JobSupervision/Job/DeadlineCannotBeMet; struct JobDeadlineCannotBeMetFilters &#123;Global::Property name;Global::Property deadline;&#125;;

&lt;!-- Page 2 --&gt;

SEMI E97-0200A © SEMI 2000 22 JobDeadlineCannotBeMetFilters Properties: Name Value Type DescriptionName string The name of the Job.Deadline Global::TimeStamp Value of the Deadline that cannot be met. struct JobDeadlineCannotBeMetEvent &#123;string eventSubject;Global::TimeStamp eventTimeStamp;JobDeadlineCannotBeMetFilters eventFilterData;Global::Properties eventNews;Job aJob;&#125;;/\* This event is posted when a Jobs deadline date has changed. \*/ const string JobDeadlineChangedSubject =/JobSupervision/Job/DeadlineChanged; struct JobDeadlineChangedFilters &#123;Global::Property name;Global::Property previousDeadline;Global::Property newDeadline;&#125;;JobDeadlineChangedFilters Properties: Name Value Type DescriptionName string The name of the Job.PreviousDeadline Global::TimeStamp Previous Deadline.NewDeadline Global::TimeStamp New Deadline. struct JobDeadlineChangedEvent &#123;string eventSubject;Global::TimeStamp eventTimeStamp;JobDeadlineChangedFilters eventFilterData;Global::Properties eventNews;Job aJob;&#125;;Exceptions: None.Provided Services:/\* Ask the Job for its JobRequestor. \*/ JobRequestor getJobRequestor ()raises (Global::FrameworkErrorSignal);/\* Get a named Job property from its Job Specification. \*/ Global::Property getJobProperty (in Global::PropertyName aPropertyName)raises (Global::FrameworkErrorSignal,Global::InvalidPropertyNameSignal,Global::PropertyNotFoundSignal);/\* Set a named Job property in its Job Specification. \*/

&lt;!-- Page 3 --&gt;

SEMI E97-0200A © SEMI 200023 void setJobProperty (in Global::Property aProperty)raises (Global::FrameworkErrorSignal,Global::SetValueOutOfRangeSignal,Global::InvalidPropertyNameSignal,Global::UnsupportedPropertySignal,Global::ReadOnlyPropertySignal);/\* Indicates whether results are available for this Job. Each specialization may determine what constitutes results. \*/ boolean areJobResultsAvailable()raises( Global::FrameworkErrorSignal );/\* Retrieve the latest results. Each implementation determines what constitutes relevant results. This may be used forreturning current results for complex Jobs. \*/ JobSupervisor::Results getJobResults()raises( Global::FrameworkErrorSignal );/\* Begin the process to pause the Job at the next safe opportunity. Results in the transition to Pausing state andeventually Paused state. \*/ void makePaused ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);/\* Request Job resume activity from the previous Pause. Results in the transition to the executing state. \*/ void makeExecuting ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);/\* Request to cancel the Job. This operation is only valid if the Job is in the Queued state (e.g. the Job cannot becanceled once it is Active). This operation results in the transition to the Canceled state. \*/ void makeCanceled ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);/\* Begin the process to stop the Job. This is an orderly termination and should never cause irreparable problems (e.g.should not stop etching a wafer in mid-cycle). This operation results in the transition to the Stopping state andeventually the Stopped state. \*/ void makeStopped ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);/\* Begin the process to abort the Job. Caution should be used with this operation. Aborting a Job requires immediatetermination of the Job and could result in irrecoverable change to factory or material state. This operation results inthe transition to the Aborting state and eventually the Aborted state. \*/ void makeAborted ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);/\* Determine whether the Job is in state indicated. \*/ boolean isAborting ( )raises (Global::FrameworkErrorSignal); boolean isAborted ( )raises (Global::FrameworkErrorSignal);

&lt;!-- Page 4 --&gt;

SEMI E97-0200A © SEMI 2000 24 boolean isActive ( )raises (Global::FrameworkErrorSignal); boolean isCanceled ( )raises (Global::FrameworkErrorSignal); boolean isCompleted ( )raises (Global::FrameworkErrorSignal); boolean isExecuting ( )raises (Global::FrameworkErrorSignal); boolean isFinished ( )raises (Global::FrameworkErrorSignal); boolean isPausing ( )raises (Global::FrameworkErrorSignal); boolean isPaused ( )raises (Global::FrameworkErrorSignal); boolean isQueued ( )raises (Global::FrameworkErrorSignal); boolean isStopping ( )raises (Global::FrameworkErrorSignal); boolean isStopped ( )raises (Global::FrameworkErrorSignal);/\* Return the estimated time remaining until Job completion. The quality of this estimate is dependent both on thespecific Job derivative and on the implementation. If the Job is Finished or Canceled, a zero Duration will bereturned. \*/ Duration timeRemaining ( )raises (Global::FrameworkErrorSignal); &#125;; // JobContracted Services: Interface Component ServiceJobRequestor JobSupervision informJobStateChange

&lt;!-- Page 5 --&gt;

SEMI E97-0200A © SEMI 200025 QUEUED FINISHED COMPLETED ABORTED STOPPED CANCELED ACTIVE ABORTING STOPPING EXECUTINGPAUSE PAUSING PAUSED COMPLETED ABORTED STOPPED ABORTING STOPPING EXECUTING 15 1 CANCELED PAUSE PAUSING PAUSED PAUSING PAUSED 45 10 12 3 6 7 13 2 14 9 8 11 Figure 5Job Dynamic Model 6.6.3.1 For implementations (e.g., Job derivatives), the Executing state is expected to be extended by partitioning itinto at least two orthogonal states. One would hold the Pause states. The other would contain the implementationbehavior of Executing.Object State Tables:

&lt;!-- Page 6 --&gt;

SEMI E97-0200A © SEMI 2000 26 Table 3 Job State Definitions and Query Table State Definition Query for State viaABORTED In this state the Job has aborted execution. This is asubstate of Finished.boolean isAborted(); sent to an instance ofJob; returns TRUEJobSequence allFinishedJobs (); sent toinstance of JobSupervisor will provide someindication.ABORTING ABORTING represents an immediate termination of theJob and activities not completed before the aborting willbe terminated. After ABORTING, execution is notintended to continue. boolean isAborting(); sent to an instance ofJob; returns TRUE ACTIVE This is a parent state representing that the Job isACTIVE for the JobSupervisor; i.e., the current status ofthe Job is tracked by the JobSupervisor when the Job isin the ACTIVE state. boolean isActive(); sent to an instance of Job;returns TRUE.JobSequence allActiveJobs (); or JobfindActiveJobNamed (in string jobName);sent to instance of JobSupervisor.CANCELED In this state the Job has been removed from the Queueand will never become Active. This is a substate ofFinished. boolean isCanceled(); sent to an instance ofJob; returns TRUE COMPLETED This state represents that the Job has successfullycompleted execution. This is a substate of Finished.boolean isCompleted(); sent to an instance ofJob; returns TRUE.Job findCompletedJobNamed (in stringjobName); sent to instance of JobSupervisorJobSequence allFinishedJobs (); sent toinstance of JobSupervisor will provide someindication.EXECUTING This state represents that the Job is EXECUTING.Specializations of Job will normally develop substatesrepresenting the specialized Job execution behavior. boolean isExecuting(); sent to an instance ofJob; returns TRUE. PAUSE Parent state of PAUSING, PAUSED None.PAUSED In this state the Job has paused execution. boolean isPaused(); sent to an instance of Job;returns TRUE.PAUSING In this state the Job is being paused by the executor ofthe Job. Execution is intended to continue.boolean isPausing(); sent to an instance ofJob; returns TRUE.QUEUED In this state the Job is waiting to become active. boolean isQueued(); sent to an instance ofJob; returns TRUE. JobSequenceallQueuedJobs (); or JobfindQueuedJobNamed (in string jobName);sent to instance of JobSupervisor.STOPPED In this state the Job has stopped execution. This is asubstate of Finished.boolean isStopped(); sent to an instance ofJob; returns TRUE.JobSequence allFinishedManagedJobs (); sentto instance of JobSupervisor will providesome indication.STOPPING In this state the Job is being stopped. Execution is notintended to continue.STOPPING represents an ordered termination of the JobActivities. Job Activities not completed before stoppingmay or may not be performed, depending on theimplementation. boolean isStopping(); sent to an instance ofJob; returns TRUE. FINISHED This is a parent state representing that the Job hasfinished execution, through either successful execution,abort, or stop. This is the superstate of Completed,Aborted, Stopped, and Canceled. boolean isFinished(); sent to an instance ofJob; returns TRUE.JobSequence allFinishedJobs (); sent toinstance of JobSupervisor.

&lt;!-- Page 7 --&gt;

SEMI E97-0200A © SEMI 200027 Table 4 Job State Transitions # Current State Trigger New State Action Comment1 Non Existent Job creation. QUEUED JobStateChanged Eventpublished by the instance of JobNone. 2 QUEUED Internal to component. EXECUTING JobStateChanged Eventpublished by the instance of JobJob has started. 3 EXECUTING void makePaused ( );sent to the Job; or voidPauseAllJobs ( ); sent toan instance ofJobSupervisor. PAUSING JobStateChanged Eventpublished by the instance of JobJob has been told topause. 4 PAUSING Internal to component PAUSED JobStateChanged Eventpublished by the instance of JobJob has completedPAUSING activities.Wait for resume.5 PAUSED void makeExecuting ( );sent to the Job or voidresumeAllJobs (); sentto an instance ofJobSupervisor. EXECUTING JobStateChanged Eventpublished by the instance of JobRestart EXECUTINGfrom the pointPAUSED at. 6 EXECUTING Internal to component COMPLETED Execution of the Job wassuccessful or completednormally. None. 7 EXECUTING void makeAborted ( );sent the Job or voidabortAllJobs ( ); sent tothe JobSupervisor. ABORTING Execution of the Job stopsimmediately. Product or Jobwill be unfinished. None. 8 PAUSE void makeAborted ( );sent the Job or voidabortAllJobs ( ); sent tothe JobSupervisor. ABORTING Active Job is abortedimmediately.None. 9 ABORTING Internal to component ABORTED JobStateChanged Eventpublished by the instance of JobJob has completedaborting activities.10 STOPPING void makeAborted ( );sent the Job or voidabortAllJobs ( ); sent tothe JobSupervisor. ABORTING JobStateChanged Eventpublished by the instance of JobNone. 11 PAUSE void makeStopped( );sent to the Job or voidstopAllJobs( ); sent tothe JobSupervisor. STOPPING JobStateChanged Eventpublished by the instance of JobNone. 12 STOPPING Internal to component STOPPED JobStateChanged Eventpublished by the instance of JobJob has completedstopping activities.13 EXECUTING void makeStopped( );sent to the Job or voidstopAllJobs( ); sent tothe JobSupervisor. STOPPING JobStateChanged Eventpublished by the instance of JobNone. 14 QUEUED void makeCanceled( );sent to the Job.CANCELED JobStateChanged Eventpublished by the instance of JobJob has been canceledbefore startingexecution. It cannotbe restarted.15 FINISHED void removeFinished-Job (in Job aJob); sentto an instance ofJobSupervisor. Non Existent JobStateChanged Eventpublished by the instance of JobJob has been removedfrom the finishedqueue.

&lt;!-- Page 8 --&gt;

SEMI E97-0200A © SEMI 2000 28 6.6.4 JobRequestor InterfaceModule: AbstractIFInterface: JobRequestorInherited Interface: Implementation DependentDescription: In order to request work of a JobSupervisor using the requestJob operation, a componentmust implement the JobRequestor interface. This is a companion interface toJobSupervisor. The JobRequestor may also subscribe to the state change events of theJob, if more detail is required. interface JobRequestor &#123;Exceptions: None.Published Events: None.Provided Services:/\* The Job has transitioned to a new state. Required for transition to Executing from Queued and for any transitionto a Finished sub-state. This operation is in addition to the required JobStateChangedEvent notifications. \*/ void informJobStateChange (in Job aJob,in Job::JobState previousState,in Job::JobState newState)raises (Global::FrameworkErrorSignal); &#125;; // JobRequestorContracted Services: None.Dynamic Model: None.Scenario:aJobRequestor:JobRequestoraJobSupervisor:JobSupervisoraJob :Job 1: requestJob (Properties, JobRequestor) 2: Return Job 3: informJobStateChange (Job, Queued, Executing) 4: informJobStateChange (Job, Active, Finished) Create Job Here Figure 6Job Supervision Scenario 6.6.4.1 Figure 6 shows the most basic of scenarios for Job Supervision interactions. It proceeds in this fashion:6.6.4.1.1 The JobRequestor populates a JobSpecification then requests a Job according to that specification.

&lt;!-- Page 9 --&gt;

SEMI E97-0200A © SEMI 200029 6.6.4.1.2 In response to the Job request, the JobSupervisor facilitates the creation of a Job to represent the task. Ahandle to the Job is returned to the JobRequestor (assuming the Job request is accepted).6.6.4.1.3 The Job Supervision compone nt (e.g. in the form of the Job) informs the JobRequestor when the Jobbegins.6.6.4.1.4 The Job Supervision compone nt (e.g. in the form of the Job) informs the JobRequestor when the Job hascompleted (assuming successful completion). It also issues events for each state change (not shown in the scenariodiagram).6.7 Factory Component6.7.1 The Factory interfaces provide configuration services to specify the existence and connectivity of factoryresources that constitute a factory. This includes area configuration and the registration of CIM system components,and the ability to dynamically configure a factory to enforce business policy.6.7.1.1 These interfaces are included h ere to satisfy dependencies and meet needs of other CIM FrameworkComponents. These interfaces will be moved to the Factory Operations Component in a subsequent revision ballot. Re s ourc e Ow nedEntity Factory Component C omponentManager Machine Pe rs on MESFactory 0..\* 0..1 0..\* 0..1registers Area 0 ..\* 0..\* 0 ..\* 0..\* gr oups 0..\* 0..\* 0..\* 0..\* groups 0..\*0..\* Figure 7Factory Component Information Model

&lt;!-- Page 10 --&gt;

SEMI E97-0200A © SEMI 2000 30 6.7.2 Factory Declarations6.7.2.1 The following declarations are used by the interfaces of the Factory Component.interface ComponentManager; interface Area; typedef sequence ComponentManagerSequence; typedef sequence  AreaSequence; exception AreaNotFoundSignal &#123;Area requestedArea;&#125;; exception AreaDuplicateSignal &#123; &#125;; exception AreaNotAssignedSignal &#123; &#125;; exception AreaRemovalFailedSignal &#123; &#125;; 6.7.3 MESFactory InterfaceModule: FactoryOperationsInterface: MESFactoryInherited Interface: AbstractIF::ResourceDescription: The MESFactory interface represents one particular factory. This instance is a compositeobject referring to the objects that represent factory resources, particularly CIM systemcomponents. The factory instance provides overall startup and shutdown capability. interface MESFactory : AbstractIF::Resource &#123;Exceptions: None.Published Events:/\* MES Factory state change event definition. \*/ const string MESFactoryStateChangedSubject = /Factory/MESFactory/StateChanged;/\* This enumerated type identifies the states of the MES Factory. It is used in event notifications of state changes. \*/ enum MESFactoryState &#123;FactoryUndefined,FactoryStartingUp,FactoryOperating,FactoryGoingToStandby,FactoryStandby,FactoryShuttingDownImmediately,FactoryShuttingDownNormally,FactoryOff &#125;; struct MESFactoryStateChangedFilters &#123;Global::Property name;Global::Property previousState;Global::Property newState;&#125;;

&lt;!-- Page 11 --&gt;

SEMI E97-0200A © SEMI 200031 MESFactoryStateChangedFilters Properties: Name Value Type DescriptionMESFactoryName string The name of the MES Factory.PreviousState MESFactoryState Previous state preceding the most recent change.NewState MESFactoryState New state following the most recent change. struct MESFactoryStateChangedEvent &#123;string eventSubject;Global::TimeStamp eventTimeStamp;MESFactoryStateChangedFilters eventFilterData;Global::Properties eventNews;MESFactory aMESFactory;&#125;;/\* Registration of Component Manager has changed \*/ const string ComponentManagerRegistrationChangedSubject =/Factory/MESFctory/ComponentManagerRegistrationChanged;/\* This enumerated type identifies the states of Component Manager registration. It is used in event notifications ofstate changes. \*/ enum RegistrationState &#123;RegistrationUndefined,Registered,NotRegistered &#125;; struct RegistrationChangedFilters &#123;Global::Property MESFactoryName;Global::Property componentManagerName;Global::Property newState;&#125;;RegistrationChangedFilters Properties: Name Value Type DescriptionMESFactoryName string The name of the MES Factory.ComponentManagerName string The name of the Component Manager.NewState RegistrationState New state following the most recent change. struct ComponentManagerRegistrationChangedEvent &#123;string eventSubject;Global::TimeStamp eventTimeStamp;RegistrationChangedFilters eventFilterData;Global::Properties eventNews;MESFactory aMESFactory;ComponentManager aComponentManager;&#125;;Provided Services:/\* Add an area to the receiver. Returns the area. \*/ Area addArea (in Area anArea)raises (AreaDuplicateSignal,Global::FrameworkErrorSignal);

&lt;!-- Page 12 --&gt;

SEMI E97-0200A © SEMI 2000 32 /\* Remove an area from the receiver. Returns the area removed. \*/ Area removeArea (in Area anArea)raises (Global::FrameworkErrorSignal,AreaRemovalFailedSignal,AreaNotAssignedSignal);/\* Returns the factory areas \*/ AreaSequence allAreas ( )raises (Global::FrameworkErrorSignal);/\* Returns collections of various factory resources. \*/ EquipmentTracking::MachineSequence allMachines ( )raises (Global::FrameworkErrorSignal);/\* Returns a collection of the component managers for the factory. \*/ ComponentManagerSequence allComponentManagers ( )raises (Global::FrameworkErrorSignal);/\* A component informs the factory that it has completed startup. \*/ void informComponentManagerIsOperating (in ComponentManager aComponentManager)raises (Global::FrameworkErrorSignal);/\* A component informs the factory that it has completed shutdown. \*/ void informComponentManagerIsStopped (in ComponentManager aComponentManager)raises (Global::FrameworkErrorSignal);/\* Factory is requested to go to STARTING UP state. Note MESFactory inherits from the Resource interface and isstarted up using the operations defined in that interface. During the startup and shutdown the factory delegatesappropriate requests to all registered components. \*/ void makeStartingUp ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);/\* Factory is requested to specified state. \*/ void makeOperating ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal); void makeStandby ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal); void makeShuttingDownNormaly ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal); void makeShuttingDownImmediately ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal); void makeOff ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);/\* Answer whether the factory is in the state indicated \*/

&lt;!-- Page 13 --&gt;

SEMI E97-0200A © SEMI 200033 boolean isOutOfService ( )raises (Global::FrameworkErrorSignal); boolean isOff ( )raises (Global::FrameworkErrorSignal); boolean isStartingUp ( )raises (Global::FrameworkErrorSignal); boolean isInService ( )raises (Global::FrameworkErrorSignal); boolean isOperating ( )raises (Global::FrameworkErrorSignal); boolean isShuttingDownNormaly ( )raises (Global::FrameworkErrorSignal); boolean isShuttingDownImmediately ( )raises (Global::FrameworkErrorSignal); boolean isGoingToStandby ( )raises (Global::FrameworkErrorSignal); boolean isStandby ( )raises (Global::FrameworkErrorSignal); &#125;; // MESFactoryContracted Services: None.Dynamic Model:

&lt;!-- Page 14 --&gt;

SEMI E97-0200A © SEMI 2000 34 OU T OF SER VIC E STAR TING U P OFF SH U TTIN G D OWN N OR MAL L Y SH U TTIN G D OWN IMMED IATELY IN SER VIC E OPER ATIN G GOIN G TO STAN DBY STAN D BY STAR TING U P OFF SH U TTIN G D OWN N OR MAL L Y SH U TTIN G D OWN IMMED IATELY OPER ATIN G GOIN G TO STAN DBY STAN D BY 2 4 5 6 7 8 9 10 1 3 Figure 8MESFactory Dynamic Model

&lt;!-- Page 15 --&gt;

SEMI E97-0200A © SEMI 200035 Table 5 MESFactory State Definitions and Query Table State Definition Query for State viaOUT OF SERVICE A superstate, inherited from Resource,encompassing the next four substate definitions.boolean isOutOfService ( );sent to the instance of MESFactory returnsFALSE.OFF In this state the MESFactory has a building,machines and other resources. No CIM activitiesshould be allowed. ComponentManagers shouldnot be registered yet. boolean isOff ( );sent to the instance of MESFactory returnsTRUE. STARTING UP In this state the MESFactory has requestedstartup sequences for all resources.boolean isStartingUp ( );sent to the instance of MESFactory returnsTRUE.SHUTTING DOWNNORMALYIn this state MESFactory resources and materialare brought to a safe state in preparation forterminating in an orderly fashion. boolean isShuttingDownNormaly ( );sent to the instance of MESFactory returnsTRUE.SHUTTING DOWNIMMEDIATELYIn this state the MESFactory is shutting downwithout regard for the safe state of material orpotential product and data loss. All processes areterminated immediately. boolean isShuttingDownImmediately ( );sent to the instance of MESFactory returnsTRUE. IN SERVICE A superstate, inherited from Resource,encompassing the next three substate definitions.boolean isInService ( );sent to the instance of MESFactory returnsTRUE.OPERATING In this state the MESFactory is able to processproduct. Applications are prepared to supportfactory operations to process product. boolean isOperating ( );sent to the instance of MESFactory returnsTRUE.GOING TOSTANDBYIn this state the MESFactory is performingsequences to make the transition to STANDBY.It brings all product and equipment to a safestopping place. boolean isGoingToStandby ( );sent to the instance of MESFactory returnsTRUE. STANDBY STANDBY means nearly available forimmediate use. In this state the MESFactory isidle and available; applications are able torespond to a subset of selected messages. boolean isStandby ( );sent to the instance of MESFactory returnsTRUE. Table 6 MESFactory State Transition Table # Current State Trigger New State Action Comment1 non-existent No CIM Frameworktrigger necessaryOFF Building(s), machines andother resources are addedafter this transition. The MESFactory objectinstance is unique in theFramework. It is the onlyobject that must be createdby the implementation.2 OFF void makeStartingUp( ); sent to theinstance ofMESFactory. STARTINGUPStartup sequenceperformed, includingdelegated messages tocomponent managers.Resource inheritedinterface also definesstartup.3 STARTINGUPvoid makeOperating( ); sent to theinstance ofMESFactory. OPERATING MESFactory is operatingevent published by theinstance of MESFactory. Relevant registeredcomponents inform thefactory when they havecompleted startup prior tostartup being complete.

&lt;!-- Page 16 --&gt;

SEMI E97-0200A © SEMI 2000 36 # Current State Trigger New State Action Comment4 OPERATING void makeStandby( ); sent to theinstance ofMESFactory. GOING TOSTANDBYMESFactory is requested togo to STANDBY state. 5 GOING TOSTANDBYcompletion ofStandby transition byMESFactory. STANDBY MESFactory is inSTANDBY state eventpublished by the instance ofMESFactory. All component managers,machines and material areidle and in a safe state. 6 STANDBY void makeOperating( ); sent toMESFactory OPERATING void startup ( ); sent to aninstance of Component-Manager. Since standby means nearlyavailable for immediateuse, this startup transitionshould be minimal.7 IN SERVICE voidmakeShuttingDownImmediately ( ); sentto the instance ofMESFactory. SHUTTINGDOWNIMMEDI-ATELY void shutdownImmediate( ); sent to all instances ofregistered ComponentManagers. As an action, messagesdelegated to componentmanagers. The Resourceinherited interface alsoimplementsshutdownImmediate8 SHUTTINGDOWNIMMEDI-ATELY void makeOff (); sentto the instance ofMESFactory. OFF void informComponentManagerIsStopped (inComponentManageraComponentManager); sentto the instance ofMESFactory by theComponent Managers.MESFactory is off eventpublished by the instance ofMESFactory. The MESFactory polls theComponentManagers andResources for completionof shutdown before theMESFactory statetransitions to OFF. 9 IN SERVICE voidmakeShuttingDownNormally ( ); sent tothe instance ofMESFactory. SHUTTINGDOWNvoid shutdown Normal ( );sent to all instances ofregistered Component-Managers. As an action, messagesdelegated to componentmanagers. 10 SHUTTINGDOWNNORMALLY void makeOff ( );sent to the instanceof MESFactory. OFF void informComponentManagerIsStopped (inComponentManageraComponentManager); sentto the instance ofMESFactory by theComponent Managers.MESFactory is off eventpublished by the instance ofMESFactory. The MESFactory polls theComponentManagers andResources for completionof shutdown before theMESFactory statetransitions to OFF. 6.7.4 Area InterfaceModule: FactoryOperationsInterface: AreaInherited Interface: OwnedEntityDescription: Area is the interface corresponding to a physical or logical grouping of factory resources(the complement of machines and/or personnel assigned to it). Area may represent asingular entity or it may represent a collection of other Areas. For example, an Area mayrepresent an entire facility for maintenance purposes, or an Area may represent aprocessing area such as a bay which is comprised of zones.

&lt;!-- Page 17 --&gt;

SEMI E97-0200A © SEMI 200037 The association between an Area and its composite Areas may be hierarchical or theremay simply be a collection of peer Areas without any explicit or implicit relationship.Area may or may not be an optional construct, depending on such issues as security. interface Area &#123;Exceptions: None.Published Events:/\* Area configuration changed event definition. \*/ const string AreaConfigurationChangedSubject =/Factory/Area/AreaConfigurationChanged;/\* This enumerated type identifies the types of configuration changes for Areas. It is used in event notifications ofstate changes. \*/ enum AreaChangeType &#123;MachinesChanged,PersonsChanged,SubAreaChanged &#125;; struct AreaConfigurationChangedFilters &#123;Global::Property name;Global::Property changeType;&#125;;AreaConfigurationChangedFilters Properties: Name Value Type DescriptionName string The name of the Area.ChangeType AreaChangeType The type of change to the Area. struct AreaConfigurationChangedEvent &#123;string eventSubject;Global::TimeStamp eventTimeStamp;AreaConfigurationChangedFilters eventFilterData;Global::Properties eventNews;Area anArea;&#125;; Provided Services:/\* Answer the Area to which this Area is associated. If no membership has been established, nil is returned. \*/ Area getSuperArea ( )raises (Global::FrameworkErrorSignal);/\* Get the unique identifier for the Area. \*/ string getAreaIdentifier ( )raises (Global::FrameworkErrorSignal);/\* Adds a machine to the receiver. Returns the machine added. \*/

&lt;!-- Page 18 --&gt;

SEMI E97-0200A © SEMI 2000 38 EquipmentTracking::Machine addMachine (in EquipmentTracking::Machine aMachine)raises (Global::FrameworkErrorSignal,EquipmentTracking::MachineDuplicateSignal);/\* Create an association between an Area and the Area to which it belongs. The service will add the Area indicatedby the argument to the receivers set of subareas. The service will also update the superarea for the argument. Theservice returns the argument. \*/ Area addSubArea (in Area anArea)raises (Global::FrameworkErrorSignal,AreaDuplicateSignal);/\* Adds a person to the receiver. Returns the person added. \*/ Labor::Person addPerson (in Labor::Person aPerson)raises (Global::FrameworkErrorSignal,Labor::PersonDuplicateSignal);/\* Remove the association between an Area and the Area to which it belongs. The service will remove the Areaindicated by the argument from the receivers set of subareas. The service will also nullify membership (ownership)for the argument. \*/ void removeSubArea (in Area anArea)raises (Global::FrameworkErrorSignal,AreaNotAssignedSignal,AreaRemovalFailedSignal);/\* Removes a machine from the receiver. \*/ void removeMachine (in EquipmentTracking::Machine aMachine)raises (Global::FrameworkErrorSignal,EquipmentTracking::MachineNotAssignedSignal,EquipmentTracking::MachineRemovalFailedSignal);/\* Removes a person from the receiver. \*/ void removePerson (in Labor::Person aPerson)raises (Global::FrameworkErrorSignal,Labor::PersonNotAssignedSignal,Labor::PersonRemovalFailedSignal);/\* Set the unique identifier for the Area. \*/ void setAreaIdentifier (in string identifier)raises (Global::FrameworkErrorSignal,Global::DuplicateIdentifierSignal);/\* Returns the set of subareas associated with this Area, that is, the Areas contained within this higher-level Area.If no membership has been established, an empty set is returned. \*/ AreaSequence allSubAreas ( )raises (Global::FrameworkErrorSignal);/\* Returns the receivers set of process machines. \*/ EquipmentTracking::MachineSequence allMachines ( )raises (Global::FrameworkErrorSignal);/\* Returns the receivers set of persons \*/ Labor::PersonSequence allPersons ( )raises (Global::FrameworkErrorSignal);

&lt;!-- Page 19 --&gt;

SEMI E97-0200A © SEMI 200039 &#125;; // AreaContracted Services: None.Dynamic Model: None. 6.7.5 Component Manager InterfaceModule: FactoryOperationsInterface: ComponentManagerInherited Interface: ResourceDescription: The ComponentManager is an abstract interface that supports the registration and control(enabling/disabling) of a components interface and for managing the resources in itsdomain.Exceptions: None.Published Events: interface ComponentManager : Resource &#123;/\* Component Manager state has changed \*/ const string ComponentManagerStateChangedSubject =/Factory/ComponentManager/ComponentManagerStateChanged;/\* This enumerated type identifies the states of Component Managers. It is used in event notifications of statechanges. \*/ enum ComponentManagerState &#123;ComponentManagerUndefined,ComponentManagerStopped,ComponentManagerStartingUp,ComponentManagerShuttingDown &#125;; struct ComponentManagerStateChangedFilters &#123;Global::Property name;Global::Property previousState;Global::Property newState;&#125;;ComponentManagerStateChangedFilters Properties: Name Value Type DescriptionName string The name of the ComponentManager.PreviousState ComponentManagerState Previous state prior to the most recent transition.NewState ComponentManagerState New state following the most recent transition.struct ComponentManagerStateChangedEvent &#123;string eventSubject;Global::TimeStamp eventTimeStamp;ComponentManagerStateChangedFilters eventFilterData;Global::Properties eventNews;ComponentManager aComponentManager;&#125;;Provided Services:/\* This operation causes the component to do its portion of the registration interchange with the factory indicated bythe argument. \*/

&lt;!-- Page 20 --&gt;

SEMI E97-0200A © SEMI 2000 40 void makeRegistered (in MESFactory aFactory)raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);/\* This operation causes the component to remove its registration from the factory. \*/ void makeNotRegistered (in MESFactory aFactory)raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);/\* This operation causes a registered component to perform its startup sequence. Each manager gets itself to thepoint where it is capable of interacting with other components. When it is ready to support all services defined in theinterface, the component manager tells the factory that component startup is complete. \*/ void makeStartingUp ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);/\* This operation causes the component to perform its shutdown sequence and then enter the state STOPPED.During shutting down activities, time is allotted to bringing the resources of a component to a safe stoppingcondition. The component manager tells the factory that component shutdown is complete. \*/ void makeShuttingDown ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);/\* This operation causes the component to go into the state STOPPED without regard to data loss or the stoppingcondition of resources or material. There is no communication with the factory. \*/ void makeStopped ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);/\* This operation causes a registered component to go into the state IN SERVICE from the state STOPPED. \*/ void makeInService ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);/\* Answer whether the status of the component is that indicated. \*/ boolean isStopped ( )raises (Global::FrameworkErrorSignal); boolean isStartingUp ( )raises (Global::FrameworkErrorSignal); boolean isShuttingDown ( )raises (Global::FrameworkErrorSignal); boolean isNotRegistered ( )raises (Global::FrameworkErrorSignal); boolean isRegistered ( )raises (Global::FrameworkErrorSignal); &#125;; // ComponentManagerContracted Services: None.

&lt;!-- Page 21 --&gt;

SEMI E97-0200A © SEMI 200041 Dynamic Model: Component Manager Registration NOT REGISTERED REGISTERED NOT REGISTERED 1 REGISTERED 23 23 Component Manager Service Status OUT OF SERVICE SHUTTING DOWNSTARTING UP STOPPED IN SERVICE OUT OF SERVICE SHUTTING DOWNSTARTING UP STOPPED SHUTTING DOWNSTARTING UP STOPPED IN SERVICE 1111 44 66 55 99 8 1010 7 Figure 9Component Manager Dynamic Model Table 7 ComponentManager State Definitions and Query Table State Definition Query for State viaNOT REGISTERED Component is not registered with a factoryand is not connected to the system.boolean isNotRegistered ( ); sent to the instanceof ComponentManager returns TRUE.REGISTERED Component is registered with a factory and isconnected to the system.boolean isRegistered ( ); sent to the instance ofComponentManager returns TRUE.STOPPED Component is not able to provide services. boolean isStopped ( ); sent to the instance ofComponentManager returns TRUE.STARTING UP Component is performing a startup sequence. boolean isStartingUp ( ); sent to the instance ofComponentManager returns TRUE.IN SERVICE Component is capable of interacting withother components.boolean isInService ( ); sent to the instance ofComponentManager returns TRUE.SHUTTING DOWN Component is performing shutdownsequence.boolean isShuttingDown ( ); sent to the instanceof ComponentManager returns TRUE.OUT OF SERVICE Component is not able to provide services. None.

&lt;!-- Page 22 --&gt;

SEMI E97-0200A © SEMI 2000 42 Table 8 ComponentManager State Transitions # Current State Trigger New State Action Comment1 Non Existent No CIM Frameworktrigger necessary.NOTREGISTEREDInstance creation is doneby the specialization.ComponentManager isan abstract inheritedinterface designed toprovide commonbehavior forspecializations.2 NOTREGISTEREDmakeRegistered() sentto the instance ofComponentManager. REGISTERED Component managerregisters with a Factoryinstance via Trader. None. 3 REGISTERED makeNotRegistered()sent to the instance ofComponentManager. NOTREGISTEREDComponent managerremoves registration fromthe Factory via Trader. None. 4 Unknown makeStartingUp() sentto the instance ofComponentManager. STARTINGUPComponent manager isrequested to startup.Implementation canuse startup() ormakeStartingUp()services.5 STARTING UP Internal to component. IN SERVICE Report to Factory thatComponent is able toprovide services, viaevents. Component managerhas finished its startupsequence. 6 STARTING UP Internal to component. STOPPED None. Component Managercould not completestartup procedure andis stopped for furthercorrective action.7 IN SERVICE makeStopped() sent tothe instance ofComponent Manager. STOPPED Component will also goout of service.ComponentManager isstopped and it may beresumed as needed.8 STOPPED makeInService() sent tothe instance ofComponent Manager. IN SERVICE Component Manager hasresumed operations and isin service for execution. None. 9 STOPPED makeShuttingDown()sent to the instance ofComponentManager. SHUTTINGDOWNAs an action it reports tothe Factory that resourcesand material are broughtto a safe state. The componentmanager receivesshutdown normalmessage.10 IN SERVICE makeShuttingDown()sent to the instance ofComponentManager. SHUTTINGDOWNAs an action it reports tothe Factory that resourcesand material are broughtto a safe state. The componentmanager receivesshutdown normalmessage.11 SHUTTINGDOWNmakeNotRegistered()sent to the instance ofComponent Manager. Non Existent The Component Manageris unregistered.None.

&lt;!-- Page 23 --&gt;

SEMI E97-0200A © SEMI 200043 APPENDIX 1FULL IDL SPECIFICATION NOTE: The material in this appendix is an official part of SEMI E97 and was approved by full letter ballot procedures onOctober 21 and December 15, 1999 by the North American Regional Standards Committee. module CIMFW &#123;#ifndef \_CIMFW\_GLOBAL\_#define \_CIMFW\_GLOBAL\_module Global &#123;typedef string Identifier;typedef unsigned long Flags;struct NamedValue&#123;Identifier name;any argument;long len;Flags arg\_modes;&#125;;typedef NamedValue NameValue;typedef sequence NameValueSequence;typedef string PropertyName;struct Property&#123;PropertyName Property\_name;any Property\_value;&#125;;typedef sequence Properties;typedef sequence StringSequence;typedef string Unit;typedef string Units;typedef sequence anySequence;typedef sequence longSequence;enum PriorityOfEvent &#123; Low,Medium,High,Alarm &#125;;enum LifecycleState &#123; Undefined,Created,Deleted,Moved,Copied &#125;;enum ReservationState &#123; UndefinedReservationState,Reserved,UnReserved &#125;;enum E10State &#123; E10Productive,E10Standby,E10Engineering,E10ScheduledDowntime,E10UnscheduledDowntime,E10NonscheduledTime &#125;;

&lt;!-- Page 24 --&gt;

SEMI E97-0200A © SEMI 2000 44 struct ulonglong&#123;unsigned long low ;unsigned long high ;&#125; ;typedef ulonglong TimeT ;typedef TimeT TimeStamp;typedef sequence TimeStampSequence;struct IntervalT &#123;TimeT lower\_bound;TimeT upper\_bound;&#125;;typedef IntervalT TimeWindow;typedef TimeT Duration;struct ResourceSchedule &#123;TimeStamp plannedStartTime;TimeStamp plannedEndTime;TimeStamp actualStartTime;TimeStamp actualEndTime;&#125;;typedef sequence ResourceScheduleSequence;exception NotFoundSignal &#123; string errorMessage; &#125;;exception DuplicateIdentifierSignal &#123;string errorMessage;string duplicateIdentifier; &#125;;exception InvalidStateTransitionSignal &#123;string errorMessage; &#125;;exception SetValueOutOfRangeSignal &#123;string errorMessage; &#125;;exception TimePeriodInvalidSignal &#123;string errorMessage; &#125;;exception InvalidPropertyNameSignal &#123;&#125;;exception PropertyNotFoundSignal &#123;&#125;;exception UnsupportedPropertySignal &#123;&#125;;exception ReadOnlyPropertySignal &#123;&#125;;exception FrameworkErrorSignal &#123;string errorMessage;unsigned long errorCode;any errorInformation;&#125;;const unsigned long NOT\_IMPLEMENTED = 0;const unsigned long IMPLEMENTED\_BY\_SUBCLASS = 1;const unsigned long UNKNOWN\_EXCEPTION = 2;const unsigned long COMPLETION\_UNKNOWN = 3;&#125;; // module Global#endif // \_CIMFW\_GLOBAL\_module EquipmentTracking &#123;interface Machine &#123;&#125;; // Stub

&lt;!-- Page 25 --&gt;

SEMI E97-0200A © SEMI 200045 typedef sequence MachineSequence;exception MachineDuplicateSignal &#123; &#125;;exception MachineNotAssignedSignal &#123; &#125;;exception MachineRemovalFailedSignal &#123; &#125;;&#125;; // module EquipmentTrackingmodule Labor &#123;interface Person &#123;&#125;; // Stubtypedef sequence PersonSequence;exception PersonDuplicateSignal &#123; &#125;;exception PersonNotAssignedSignal &#123; &#125;;exception PersonRemovalFailedSignal &#123; &#125;;&#125;; // module Labor#ifndef \_CIMFW\_ABSTRACT\_IF\_#define \_CIMFW\_ABSTRACT\_IF\_module AbstractIF &#123;interface Resource;interface Material;interface MaterialGroup;interface JobSupervisor;interface Job;interface JobRequestor;typedef sequence ResourceSequence;typedef sequence MaterialSequence;typedef sequence MaterialGroupSequence;typedef sequence JobSequence;typedef sequence JobSupervisorSequence;interface NamedEntity &#123;void setName (in string name)raises (Global::FrameworkErrorSignal);string getName ( )raises (Global::FrameworkErrorSignal);boolean isNamed (in string testName)raises (Global::FrameworkErrorSignal);&#125;; // NamedEntityinterface OwnedEntity : NamedEntity &#123;void setOwner (in NamedEntity owner)raises (Global::FrameworkErrorSignal);NamedEntity getOwner ( )

&lt;!-- Page 26 --&gt;

SEMI E97-0200A © SEMI 2000 46 raises (Global::FrameworkErrorSignal);&#125;; // OwnedEntityinterface Resource : OwnedEntity &#123;typedef sequence ResourceSequence;void startUp ( )raises (Global::FrameworkErrorSignal);void shutdownNormal ( )raises (Global::FrameworkErrorSignal);void shutdownImmediate ( )raises (Global::FrameworkErrorSignal);string resourceLevel ( )raises (Global::FrameworkErrorSignal);string nameQualifiedTo (in string resourceLevel)raises (Global::FrameworkErrorSignal);ResourceSequence subresources ( )raises (Global::FrameworkErrorSignal);boolean isInService ( );boolean isOutOfService ( );&#125;; // Resourceinterface Material : NamedEntity &#123;string getIdentifier ( )raises (Global::FrameworkErrorSignal);void setIdentifier (in string identifier)raises (Global::FrameworkErrorSignal,Global::DuplicateIdentifierSignal);MaterialGroupSequence materialGroups ( )raises (Global::FrameworkErrorSignal);boolean isMemberOf (in MaterialGroup aMaterialGroup)raises (Global::FrameworkErrorSignal);&#125;; // Materialinterface MaterialGroup : NamedEntity &#123;exception DuplicateMaterialSignal &#123;Material aMaterial;&#125;;exception DuplicateMaterialGroupSignal &#123;MaterialaMaterialGroup;&#125;;exception MaterialRemovalFailedSignal &#123;Material aMaterial;&#125;;exception MaterialGroupRemovalFailedSignal &#123;MaterialGroup aMaterialGroup;&#125;;string getIdentifier ( )raises (Global::FrameworkErrorSignal);void setIdentifier (in string identifier)raises (Global::FrameworkErrorSignal,Global::DuplicateIdentifierSignal);void addMaterials (in MaterialSequence aMaterialSequence)raises (Global::FrameworkErrorSignal,

&lt;!-- Page 27 --&gt;

SEMI E97-0200A © SEMI 200047 DuplicateMaterialSignal);void addMaterial (in Material aMaterial)raises (Global::FrameworkErrorSignal,DuplicateMaterialSignal);void removeMaterial (in Material aMaterial)raises (Global::FrameworkErrorSignal,MaterialRemovalFailedSignal,Global::NotFoundSignal);MaterialSequence removeAllMaterials ( )raises (Global::FrameworkErrorSignal);void addMaterialGroup (in MaterialGroup aMaterialGroup)raises (Global::FrameworkErrorSignal,DuplicateMaterialGroupSignal);void removeMaterialGroup (in MaterialGroup aMaterialGroup)raises (Global::FrameworkErrorSignal,MaterialGroupRemovalFailedSignal,Global::NotFoundSignal);MaterialSequence allMaterials ( )raises (Global::FrameworkErrorSignal);MaterialGroupSequence allMaterialGroups ( )raises (Global::FrameworkErrorSignal);long size ( )raises (Global::FrameworkErrorSignal);&#125;; // MaterialGroupinterface JobSupervisor : Resource &#123;typedef Global::NameValueSequence Results;exception JobRejectedSignal &#123; string errorMessage; &#125;;exception JobNotFoundSignal &#123;string errorMessage;string missingJobName; &#125;;const string JobLifecycleSubject=/JobSupervision/JobSupervisor/JobLifecycle;struct JobLifecycleFilters &#123;Global::Property name;Global::Property lifecycle;&#125;;struct JobLifecycleEvent &#123;string eventSubject;Global::TimeStamp eventTimeStamp;JobLifecycleFilters eventFilterData;Global::Properties eventNews;Job aJob; // on Delete, aJob is nil&#125;;Job requestJob (in Global::Properties aJobSpecification,in JobRequestor aJobRequestor)raises (Global::FrameworkErrorSignal,JobRejectedSignal);Results runJob (in Global::Properties aJobSpecification)raises (Global::FrameworkErrorSignal,JobRejectedSignal);

&lt;!-- Page 28 --&gt;

SEMI E97-0200A © SEMI 2000 48 boolean canPerform (in Global::Properties aJobSpecification)raises (Global::FrameworkErrorSignal);void pauseAllJobs ()raises (Global::FrameworkErrorSignal);void resumeAllJobs ()raises (Global::FrameworkErrorSignal);void abortAllJobs ()raises (Global::FrameworkErrorSignal);void stopAllJobs ()raises (Global::FrameworkErrorSignal);void removeFinishedJob (in Job aJob)raises (Global::FrameworkErrorSignal);Job findJobNamed (in string jobName)raises (Global::FrameworkErrorSignal,JobNotFoundSignal);Job findQueuedJobNamed (in string jobName)raises (Global::FrameworkErrorSignal,JobNotFoundSignal);Job findActiveJobNamed (in string jobName)raises (Global::FrameworkErrorSignal,JobNotFoundSignal);Job findCancelledJobNamed (in string jobName)raises (Global::FrameworkErrorSignal,JobNotFoundSignal);Job findFinishedJobNamed (in string jobName)raises (Global::FrameworkErrorSignal,JobNotFoundSignal);JobSequence allJobs ( )raises (Global::FrameworkErrorSignal);JobSequence allQueuedJobs ( )raises (Global::FrameworkErrorSignal);JobSequence allCanceledJobs ( )raises (Global::FrameworkErrorSignal);JobSequence allActiveJobs ( )raises (Global::FrameworkErrorSignal);JobSequence allExecutingJobs ( )raises (Global::FrameworkErrorSignal);JobSequence allPausingJobs ( )raises (Global::FrameworkErrorSignal);JobSequence allPausedJobs ( )raises (Global::FrameworkErrorSignal);JobSequence allStoppingJobs ( )raises (Global::FrameworkErrorSignal);JobSequence allAbortingJobs ( )raises (Global::FrameworkErrorSignal);JobSequence allFinishedJobs ( )raises (Global::FrameworkErrorSignal);JobSequence allStoppedJobs ( )

&lt;!-- Page 29 --&gt;

SEMI E97-0200A © SEMI 200049 raises (Global::FrameworkErrorSignal);JobSequence allAbortedJobs ( )raises (Global::FrameworkErrorSignal);JobSequence allCompletedJobs ( )raises (Global::FrameworkErrorSignal);&#125;; // JobSupervisorinterface Job : OwnedEntity &#123;const string JobStateChangedSubject =/JobSupervision/Job/StateChanged;enum JobState &#123;JobUndefined,JobCreated,JobQueued,JobActive,JobExecuting,JobNotPaused,JobPausing,JobPaused,JobNotStopping,JobStopping,JobNotAborting,JobAborting,JobFinished,JobCanceled,JobCompleted,JobStopped,JobAborted &#125;;struct JobStateChangedFilters &#123;Global::Property name;Global::Property previousState;Global::Property newState;&#125;;struct JobStateChangedEvent &#123;string eventSubject;Global::TimeStamp eventTimeStamp;JobStateChangedFilters eventFilterData;Global::Properties eventNews;Job aJob;&#125;;const string JobDeadlineCannotBeMetSubject =/JobSupervision/Job/DeadlineCannotBeMet;struct JobDeadlineCannotBeMetFilters &#123;Global::Property name;Global::Property deadline;&#125;;struct JobDeadlineCannotBeMetEvent &#123;string eventSubject;Global::TimeStamp eventTimeStamp;JobDeadlineCannotBeMetFilters eventFilterData;Global::Properties eventNews;Job aJob;&#125;;const string JobDeadlineChangedSubject =/JobSupervision/Job/DeadlineChanged;struct JobDeadlineChangedFilters &#123;Global::Property name;Global::Property previousDeadline;

&lt;!-- Page 30 --&gt;

SEMI E97-0200A © SEMI 2000 50 Global::Property newDeadline;&#125;;struct JobDeadlineChangedEvent &#123;string eventSubject;Global::TimeStamp eventTimeStamp;JobDeadlineChangedFilters eventFilterData;Global::Properties eventNews;Job aJob;&#125;;exception InvalidPropertyNameSignal &#123;&#125;;exception PropertyNotFoundSignal &#123;&#125;;exception UnsupportedPropertySignal &#123;&#125;;exception ReadOnlyPropertySignal &#123;&#125;;JobRequestor getJobRequestor ()raises (Global::FrameworkErrorSignal);Global::Property getJobProperty (in Global::PropertyName aPropertyName)raises (Global::FrameworkErrorSignal,InvalidPropertyNameSignal,PropertyNotFoundSignal);void setJobProperty (in Global::Property aProperty)raises (Global::FrameworkErrorSignal,Global::SetValueOutOfRangeSignal,InvalidPropertyNameSignal,UnsupportedPropertySignal,ReadOnlyPropertySignal);boolean areJobResultsAvailable()raises( Global::FrameworkErrorSignal);JobSupervisor::Results getJobResults()raises( Global::FrameworkErrorSignal);void makePaused ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);void makeExecuting ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);void makeCanceled ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);void makeStopped ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);void makeInService ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);void makeAborted ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);boolean isAborting ( )raises (Global::FrameworkErrorSignal);boolean isAborted ( )

&lt;!-- Page 31 --&gt;

SEMI E97-0200A © SEMI 200051 raises (Global::FrameworkErrorSignal);boolean isActive ( )raises (Global::FrameworkErrorSignal);boolean isCanceled ( )raises (Global::FrameworkErrorSignal);boolean isCompleted ( )raises (Global::FrameworkErrorSignal);boolean isExecuting ( )raises (Global::FrameworkErrorSignal);boolean isFinished ( )raises (Global::FrameworkErrorSignal);boolean isPausing ( )raises (Global::FrameworkErrorSignal);boolean isPaused ( )raises (Global::FrameworkErrorSignal);boolean isQueued ( )raises (Global::FrameworkErrorSignal);boolean isStopping ( )raises (Global::FrameworkErrorSignal);boolean isStopped ( )raises (Global::FrameworkErrorSignal);Global::Duration timeRemaining ( )raises (Global::FrameworkErrorSignal);&#125;; // Jobinterface JobRequestor &#123;void informJobStateChange (in Job aJob,in Job::JobState oldState,in Job::JobState newState)raises (Global::FrameworkErrorSignal);&#125;; // JobRequestor&#125;; // module AbstractIF#endif // \_CIMFW\_ABSTRACT\_IF\_#ifndef \_CIMFW\_FACTORY\_OPERATIONS\_#define \_CIMFW\_FACTORY\_OPERATIONS\_module FactoryOperations &#123;interface ComponentManager;interface Area;typedef sequence ComponentManagerSequence;typedef sequence  AreaSequence;exception AreaNotFoundSignal &#123;Area requestedArea;&#125;;exception AreaDuplicateSignal &#123; &#125;;exception AreaNotAssignedSignal &#123; &#125;;exception AreaRemovalFailedSignal &#123; &#125;;

&lt;!-- Page 32 --&gt;

SEMI E97-0200A © SEMI 2000 52 interface MESFactory : AbstractIF::Resource &#123;const string MESFactoryStateChangedSubject =/Factory/MESFactory/StateChanged;enum MESFactoryState &#123; FactoryUndefined,FactoryStartingUp,FactoryOperating,FactoryGoingToStandby,FactoryStandby,FactoryShuttingDownImmediately,FactoryShuttingDownNormally,FactoryOff &#125;;struct MESFactoryStateChangedFilters &#123;Global::Property name;Global::Property previousState;Global::Property newState;&#125;;struct MESFactoryStateChangedEvent &#123;string eventSubject;Global::TimeStamp eventTimeStamp;MESFactoryStateChangedFilters eventFilterData;Global::Properties eventNews;MESFactory aMESFactory;&#125;;struct RegistrationChangedFilters &#123;Global::Property MESFactoryName;Global::Property componentManagerName;Global::Property newState;&#125;;struct ComponentManagerRegistrationChangedEvent &#123;string eventSubject;Global::TimeStamp eventTimeStamp;RegistrationChangedFilters eventFilterData;Global::Properties eventNews;MESFactory aMESFactory;ComponentManager aComponentManager;&#125;;Area addArea (in Area anArea)raises (AreaDuplicateSignal,Global::FrameworkErrorSignal);Area removeArea (in Area anArea)raises (Global::FrameworkErrorSignal,AreaRemovalFailedSignal,AreaNotAssignedSignal);AreaSequence allAreas ( )raises (Global::FrameworkErrorSignal);EquipmentTracking::MachineSequence allMachines ( )raises (Global::FrameworkErrorSignal);ComponentManagerSequence allComponentManagers ( )raises (Global::FrameworkErrorSignal);void informComponentManagerIsOperating (in ComponentManageraComponentManager)raises (Global::FrameworkErrorSignal);void informComponentManagerIsStopped (in ComponentManageraComponentManager)raises (Global::FrameworkErrorSignal);

&lt;!-- Page 33 --&gt;

SEMI E97-0200A © SEMI 200053 void makeStartingUp ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);void makeOperating ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);void makeStandby ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);void makeShuttingDownNormaly ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);void makeShuttingDownImmediately ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);void makeOff ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);boolean isOff ( )raises (Global::FrameworkErrorSignal);boolean isStartingUp ( )raises (Global::FrameworkErrorSignal);boolean isOperating ( )raises (Global::FrameworkErrorSignal);boolean isShuttingDownNormaly ( )raises (Global::FrameworkErrorSignal);boolean isShuttingDownImmediately ( )raises (Global::FrameworkErrorSignal);boolean isGoingToStandby ( )raises (Global::FrameworkErrorSignal);boolean isStandby ( )raises (Global::FrameworkErrorSignal);&#125;; // MESFactoryinterface Area : AbstractIF::OwnedEntity &#123;const string AreaConfigurationChangedSubject =/Factory/Area/AreaConfigurationChanged;enum AreaChangeType &#123;MachinesChanged,PersonsChanged,SubAreaChanged &#125;;struct AreaConfigurationChangedFilters &#123;Global::Property name;Global::Property changeType;&#125;;struct AreaConfigurationChangedEvent &#123;string eventSubject;Global::TimeStamp eventTimeStamp;AreaConfigurationChangedFilters eventFilterData;Global::Properties eventNews;Area anArea;&#125;;

&lt;!-- Page 34 --&gt;

SEMI E97-0200A © SEMI 2000 54 Area getSuperArea ( )raises (Global::FrameworkErrorSignal);string getAreaIdentifier ( )raises (Global::FrameworkErrorSignal);Area addSubArea (in Area anArea)raises (Global::FrameworkErrorSignal,AreaDuplicateSignal);void removeSubArea (in Area anArea)raises (Global::FrameworkErrorSignal,AreaNotAssignedSignal,AreaRemovalFailedSignal);void setAreaIdentifier (in string identifier)raises (Global::FrameworkErrorSignal,Global::DuplicateIdentifierSignal);AreaSequence subAreas ( )raises (Global::FrameworkErrorSignal);EquipmentTracking::Machine addMachine (inEquipmentTracking::Machine aMachine)raises (Global::FrameworkErrorSignal,EquipmentTracking::MachineDuplicateSignal);void removeMachine (in EquipmentTracking::Machine aMachine)raises (Global::FrameworkErrorSignal,EquipmentTracking::MachineNotAssignedSignal,EquipmentTracking::MachineRemovalFailedSignal);Labor::Person addPerson (in Labor::Person aPerson)raises (Global::FrameworkErrorSignal,Labor::PersonDuplicateSignal);void removePerson (in Labor::Person aPerson)raises (Global::FrameworkErrorSignal,Labor::PersonNotAssignedSignal,Labor::PersonRemovalFailedSignal);EquipmentTracking::MachineSequence machines ( )raises (Global::FrameworkErrorSignal);Labor::PersonSequence persons ( )raises (Global::FrameworkErrorSignal);&#125;; // Areainterface ComponentManager : AbstractIF::Resource &#123;const string ComponentManagerStateChangedSubject =/FactoryOperations/ComponentManager/ComponentManagerStateChanged;enum ComponentManagerState &#123; ComponentManagerUndefined,ComponentManagerStopped,ComponentManagerStartingUp,ComponentManagerShuttingDown&#125;;struct ComponentManagerStateChangedFilters &#123;Global::Property name;Global::Property previousState;Global::Property newState;&#125;;struct ComponentManagerStateChangedEvent &#123;

&lt;!-- Page 35 --&gt;

SEMI E97-0200A © SEMI 200055 string eventSubject;Global::TimeStamp eventTimeStamp;ComponentManagerStateChangedFilters eventFilterData;Global::Properties eventNews;ComponentManager aComponentManager;&#125;;const string ComponentManagerRegistrationChangedSubject =/Factory/ComponentManager/ComponentManagerRegistrationChanged;enum RegistrationState &#123;RegistrationUndefined,Registered,NotRegistered &#125;;void makeRegistered (in MESFactory aFactory)raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);void makeNotRegistered (in MESFactory aFactory)raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);void makeStartingUp ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);void makeShuttingDown ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);void makeStopped ( )raises (Global::FrameworkErrorSignal,Global::InvalidStateTransitionSignal);boolean isStopped ( )raises (Global::FrameworkErrorSignal);boolean isStartingUp ( )raises (Global::FrameworkErrorSignal);boolean isShuttingDown ( )raises (Global::FrameworkErrorSignal);boolean isNotRegistered ( )raises (Global::FrameworkErrorSignal);boolean isRegistered ( )raises (Global::FrameworkErrorSignal);&#125;; // ComponentManager&#125;; // module FactoryOperations#endif // \_CIMFW\_FACTORY\_OPERATIONS\_&#125;; // module CIMFW NOTICE: SEMI makes no warranties or representations as to the suitability of the standard set forth herein for anyparticular application. The determination of the suitability of the standard is solely the responsibility of the user.Users are cautioned to refer to manufacturers instructions, product labels, product data sheets, and other relevantliterature respecting any materials mentioned herein. These standards are subject to change without notice.The users attention is called to the possibility that compliance with this standard may require use of copyrightedmaterial or of an invention covered by patent rights. By publication of this standard, SEMI takes no positionrespecting the validity of any patent rights or copyrights asserted in connection with any item mentioned in thisstandard. Users of this standard are expressly advised that determination of any such patent rights or copyrights, andthe risk of infringement of such rights, are entirely their own responsibility. Copyright by SEMI® (Semiconductor Equipment and MaterialsInternational), 3081 Zanker Road, San Jose, CA 95134. Reproduction ofthe contents in whole or in part is forbidden without express writtenconsent of SEMI.

&lt;!-- Page 36 --&gt;

SEMI E98-1102 © SEMI 2000, 20021 SEMI E98-1102PROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENTMODEL (OBEM) This provisional standard was technically approved by the Global Information and Control Committee and isthe direct responsibility of the North American Information and Control Committee. Current editionapproved by the North American Regional Standards Committee on November 27, 2001. Initially availableat www.semi.org December 2001; to be published March 2002. Originally published February 2000;previously published March 2002.NOTICE: The designation of SEMI E98 was updated during the 1102 publishing cycle to reflect revisions toSEMI E98.1. 1 Purpose1.1 Purposes of the Object-Based Equipment Modelinclude the following: Define a standard model for interfacing to multi-process equipment and other complex equipment. Define standard equipment components so thatcommunications can discuss component-relatedissues. Provide an equipment model that can be easilyintegrated with SEMI E81 CIM Frameworksystems by connecting an OBEM-compliantequipment to a Machine object.1.2 The purpose of the Object-Based Equipment Model(OBEM) standard is to provide definitions, services,and behavior, as seen through communications with thefactory, for the common types of physical and logicalobjects of which equipment is typically composed,including the equipment itself. The definition ofstandardized objects allows the equipment to describeits makeup to the factory and provides the factoryvisibility into the equipment. 2 Scope2.1 This is a provisional standard that defines con-cepts, behavior, and services to support the integrationof production equipment within a semiconductor fac-tory. The scope of this standard includes all semicon-ductor manufacturing equipment that provides an inter-face to the factory host systems. Some services maynot be applicable to some material handling systems.2.2 Sections that must be completed in order for theprovisional status of OBEM to be removed include thefollowing:1. Section 11.2  Access Management2. Section 14  OBEM Compliance 2.3 Detail standards will also be added in the future tospecify OBEM mappings to different protocols such asSECS-II, CORBA IDL, and DCOM.2.4 This standard does not purport to address safetyissues, if any, associated with its use. It is theresponsibility of the users of this standard to establishappropriate safety and health practices and determinethe applicability of regulatory limitations prior to use. 3 Limitations3.1 This standard is not intended to define theattributes, behavior, or services of systems that areaggregates of equipment, such as cells.3.2 The decomposition of equipment into differentobjects is chosen by the equipment supplier to map thephysical equipment to the characteristics of the objectsdefined by this standard.3.3 Object-oriented technology is not required forimplementations of OBEM. However, object-orientedimplementations should be compatible with OBEM. 4 Referenced Standards4.1 This section lists documents referenced by thisstandard.4.2 SEMI StandardsSEMI E5  SEMI Equipment CommunicationsStandard 2 Message Content (SECS-II)SEMI E10  Standard for Definition and Measurementof Equipment Reliability, Availability, andMaintainability (RAM)SEMI E15  Specification for Tool Load PortSEMI E15.1  Provisional Specification for 300 mmTool Load PortSEMI E30  Generic Model for Communications andControl of Manufacturing Equipment (GEM)SEMI E39  Object Services Standard: Concepts,Behavior, and Services

&lt;!-- Page 37 --&gt;

SEMI E98-1102 © SEMI 2000, 2002 2 SEMI E40  Standard for Processing ManagementSEMI E41  Exception Management (EM) StandardSEMI E42  Recipe Management Standard:Concepts, Behavior, and Message ServicesSEMI E53  Event ReportingSEMI E54  Sensor/Actuator Network StandardSEMI E58  Automated Reliability, Availability, andMaintainability Standard (ARAMS): Concepts,Behavior, and ServicesSEMI E81  Provisional Specification for CIMFramework Domain ArchitectureSEMI E87  Provisional Specification for CarrierManagement (CMS)SEMI E90  Specification for Substrate TrackingSEMI E94  Provisional Specification for Control JobManagementNOTE 1: As listed or revised, all documents cited shall be thelatest publications of adopted standards. 5 Terminology5.1 Abbreviations and Acronyms5.1.1 AGV  Automated Guided Vehicle5.1.2 AMHS  Automated Material Handling System5.1.3 APC  Advanced Process Control5.1.4 ARAMS  Automated Reliability, Availability,and Maintainability Standard (SEMI E58)5.1.5 CIM  Computer Integrated Manufacturing5.1.6 CJM  Control Job Management5.1.7 CMS  Carrier Management Standard5.1.8 FDC  Fault Detection Control5.1.9 FIMS  Front-Opening Interface MechanicalStandard (reference SEMI E62)5.1.10 FOUP  Front-Opening Unified Pod5.1.11 FPD  Flat Panel Display5.1.12 OBEM  Object-Based Equipment Model5.1.13 OSS  Object Services Standard (SEMI E39)5.1.14 PGV  Personal Guided Vehicle5.1.15 R2R  Run-to-Run Control5.1.16 RMS  Recipe Management Standard (SEMIE42) 5.1.17 SMIF  Standard Mechanical Interface (SEMIE19)5.1.18 STS  Specification for Substrate Tracking

&lt;!-- Page 38 --&gt;

SEMI E98-1102 © SEMI 2000, 20023 5.2 Definitions5.2.1 abstract object type  an object supertype that isnot instantiated directly but only through one of itssubtypes.5.2.2 actuator  an analog or digital output devicethat is used to affect changes in the physicalenvironment. Examples of actuators include mass flowcontrollers (MFCs) and open/closed valves.5.2.3 advanced process control (APC)  techniquescovering both feedforward and feedback control andautomated fault detection, applied both by theequipment (in situ) and by the factory (ex situ).5.2.4 Automated Material Handling System (AMHS) a factory system used to transport and store carriers.AMHS has two major types of components: anautomated transport system and one or more storagesystems (stockers).5.2.5 automated transport system  the component ofAMHS used to transport carriers between stockersand/or production equipment.5.2.6 carrier  a container with one or more fixedpositions at which material may be held.NOTE 2: Positions within a carrier may be considered asmaterial locations owned by the carrier. 5.2.7 clock  a device that is used to provide real-timedate and time information.5.2.8 container  a durable that is used to hold othermaterial, including other containers, for transport,storage, or shipping. Types of containers includecarriers and boxes.5.2.9 dry run (mechanical dry run)  a completeequipment cycle that allows the material handling andsoftware capabilities of the equipment to be exercisedwithout requiring full facilities hookups and withoutchanging the physical state of the wafer. Environ-mental control subsystem (e.g., vacuum, nitrogenpurge, particle detection) should not be affected by adry run, and process consumables are not used.5.2.10 durable  a type of material used to facilitatemanufacturing but not normally consumed in theprocess that is removable, reusable, and trackable.Examples include containers, reticles, and pellicles.5.2.11 environmental subsystem  a subsystem ofequipment with the purpose of monitoring ormaintaining one or more specific environmentalconditions or used to handle product or durables.Environmental subsystems include vacuum systems,particle detection systems, and nitrogen purge systems. 5.2.12 equipment  equipment (manufacturing equip-ment) performs one or more of the following manufac-turing functions in the factory: material process,material transport, or material storage. Equipment ismade up of various parts: modules, subsystems andsensors/actuators. Equipment has at least one carrierport. Equipment communicates with the factory.5.2.13 equipment element  a component of theequipment that behaves as a unit, performs work, andmay or may not contain lower-level components.5.2.14 equipment module (module)  a majorcomponent of equipment that contains at least onematerial location and performs some task on material.Equipment modules may be aggregates of equipmentsubsystems, i/o devices, and other modules.5.2.15 fault detection  analysis of data for earlydetection of process faults before yield loss becomessignificant.5.2.16 Front-Opening Unified Pod (FOUP)  a front-opening pod with an integrated (non-removable)cassette.5.2.17 implementation  the internal view of a type,class, or instance, including any non-public propertiesand behavior. The specific code and functionality thatimplements an interface. (See SEMI E81.)5.2.18 interface  the external view of an object type,class, or object that defines its public properties andservices without regard to the internal structure andinternal behavior. (See also SEMI E81.)5.2.19 interface inheritance  the construction of aninterface by incremental modification of other interfa-ces (see implementation inheritance). (See SEMI E81.)OBEM specifies interface inheritance but notimplementation inheritance.5.2.20 I/O device  a general term for any type ofsensor or actuator or aggregation of sensor and/oractuator.5.2.21 linked equipment  two or more equipment thatare physically and logically connected and function as asingle installation of equipment. In this case, theindividual component equipment are modeled as high-level modules of the linked equipment.5.2.22 load port  The physical interface provided forthe exchange of carriers with an agent of the factory(operator or automated material handling system).(Reference SEMI E15.)5.2.23 Manufacturing Execution System (MES)  thefactory system responsible for managing the manufac-turing process, including logistics and process flow.

&lt;!-- Page 39 --&gt;

SEMI E98-1102 © SEMI 2000, 2002 4 5.2.24 material  (1) any material used in, or requiredby, the manufacturing process. Material is classified asconsumable, durable, or product. (2) an abstraction ofthe various types of things used during manufacturing,such as wafers, carriers, and chemicals, which requiresome management.5.2.25 material location  a reference to a placewithin the equipment or an equipment component thatcan hold material, such as the top surface of an indexeror substrate chuck or the end effector of a substratehandler.5.2.26 measured value  a value representing ameasurement, with a numerical value, measurementunits, and a valid range.5.2.27 measurement equipment  equipment whoseintended function is to measure or inspect the productand to report results. Measurement of the product is thefactorys means of gaining feedback on themanufacturing process.5.2.28 Object-Based Equipment Model  a model ofequipment, its components, behaviors, attributes, andservices, as defined by this document.5.2.29 object type  a declaration (specification) thatdescribes the common properties and behavior for acollection of objects. Types classify objects accordingto a common interface; classes classify objectsaccording to a common implementation. (See alsoSEMI E39 and E81.)5.2.30 object specifier  designates a logical pathpointing to a specific instance of an object through ahierarchy of owners. See SEMI E39.5.2.31 Personal Guided Vehicle (PGV)  a manuallyguided and operated vehicle capable of placing andremoving carriers to and from a carrier port.5.2.32 pod  as used in this document, a containerproviding environmental control, such as a SMIF orFIMS pod1.5.2.33 production equipment  process equipment andmeasurement equipment.5.2.34 process durable  a specialized durable usedby process equipment and specified by the user as partof the process, such as a reticle or burin-in board.5.2.35 process equipment  equipment whoseintended function is to process product, adding value tothe product.5.2.36 product  (1) from the equipments perspec-tive, product is a synonym for substrate, and includes 1 The term pod was originally defined as a bottom-opening podwith a SMIF interface. non-product substrates such as test substrates and send-ahead substrates; (2) from the factory perspective,product is the material being processed and producedby the factory.5.2.37 run-to-run control  techniques for varyingsettings in one run based on analysis of either incomingproduct (feed-forward) or product from an earlier run.5.2.38 sensor  a component that responds to changesin the physical environment and provides an analog ordigital input value.5.2.39 sensor/actuator device  a device consisting ofone or more sensors and/or actuators on the physicaltool. See SEMI E54 for a precise definition of sensoror actuator and for a description of the internalstructure of an sensor/actuator network CommonDevice Model definition.5.2.40 setup  1. (verb) the performance of one ormore steps that puts the equipment into a known state inwhich it is ready to perform a specific process; 2.(noun) the state of the equipment once it has beensetup.5.2.41 standardized object  an object that is formallydefined and compliant to SEMI E39, Object ServicesStandard (reference SEMI E42).5.2.42 storage equipment (stocker)  equipmentwhose intended function is primarily to provide storage,either short-term or long-term, for carriers.5.2.43 subassembly  a component of equipment thatprovides some limited functionality.5.2.44 substrate  basic unit of material on whichwork is performed to create a product. Examplesinclude wafers, die, plates used for masks, flat panels,circuit boards, and leadframes.5.2.45 subsystem  a subsystem is an intelligentaggregate that behaves as a unit. A subsystem is madeup of sensors and/or actuators and may containmechanical assemblies. Subsystems may be shared bymultiple modules.5.2.46 subtype  an object type that is based on(derived from) another type and adds some specializa-tion or overrides some properties or services. The typefrom which the subtype is derived is the supertype. Foradditional detail, see SEMI E39, Object ServicesStandard.5.2.47 supertype  an object type which is used as abasis from which specializations are derived. Thederived types are called subtypes. For additional detail,see SEMI E39.5.2.48 transport equipment  equipment whoseintended function is primarily to move material from

&lt;!-- Page 40 --&gt;

SEMI E98-1102 © SEMI 2000, 20025 one location in the factory to another location.Transport equipment may also provide short-termstorage for material. (See also AMHS.)5.2.49 virtual sensor (synthetic sensor, derived sensor) one or more calculated measured values that arebased on one or more sensor readings. This mayinclude results based on neural nets, statistical analysis,etc. or may be based on a single sensor value.5.2.50 work  a group of one or more substrates thatundergo processing in a factory. Something that may bework in one kind of factory, such as reticles andleadframes, may have a different role in other types offactories. Work includes, but is not limited to, materialintended as product. For example, it may includeproduct substrates, test substrates, and filler substrates.5.2.50.1 From the point of view of the equipment,work is either new (processing has not started),completed (all intended processing has been performed,terminated, or aborted, including rejected and resortedwork, and no further processing is to be done) orincomplete (work in progress, on hold). 6 Conventions6.1 This section defines the conventions followed bythis document.6.2 Object Conventions  This document conforms tothe conventions for objects established by SEMI E39,including object diagrams, object terminology, and re-quirements for standardized objects. Accordingly, not-ation is based on Object Modeling Technique (OMT) asdescribed in Object Oriented Modeling Design.2 6.2.1 Formal Name of an Object  The text capitalizesformal object name references. Similar to the waycapitalization is normally used when discussing entities.When describing something in the general (like cities)lower case is used, but when a specific entity is ofinterest (New York City), then first letters arecapitalized.6.2.2 Components of Complex Attributes  The namesof object attributes defined in tables are left-justified.The individual elements of complex attributes are right-justified in order of appearance below the complexattribute. 2 Rumbaugh, James, et al, Object Oriented Modeling Design,Prentice Hall, Englewood Cliffs, NJ, c1991.

&lt;!-- Page 41 --&gt;

SEMI E98-1102 © SEMI 2000, 2002 6 6.2.3 Names of OBEM Objects  The names of abstract object types start with the word Abstract and are notintended to be directly implemented. All other objects defined in OBEM are concrete types that may be directlyimplemented.6.3 State Model Conventions6.3.1 This document uses the Harel state chart convention for describing dynamic operation of defined objects. Theoutline of this convention is described in an attachment of SEMI E30. The official definition of this convention isdescribed in State charts: A Visual Formalism for Complex Systems3.6.3.2 The Harel convention has not the concept of state models of creation and extinction for expressing atemporary entity. The job described in this document is such an entity, and a copy of the same state model is usedfor an independent job newly created. In this document, a circle with a black circle inside is used for expressingextinction of an entity. A filled black circle denotes the entry to the state model (the entity creation).6.3.3 Transition tables are provided in conjunction with the state diagrams to explicitly describe the nature of eachstate transition. A transition table contains columns for Transition number, Previous State, Trigger, New State,Actions, and Comments. The trigger (column 3) for the transition occurs while in the previous state. Theactions (column 5) includes a combination of:1. Actions taken upon exit of the previous state.2. Actions taken upon entry of the new state.3. Actions taken which are most closely associated with the transition. 6.3.3.1 No differentiation is made between these cases.Num Previous State Trigger New State Actions Comments 6.4 Service Message Representation  Services are functions or methods that may be provided by either theequipment or the host. A service message may be either a request message, which always requires a response, or anotification message, that does not require a response.6.4.1 Service Definition6.4.1.1 A service definition table defines the specific set of messages for a given service resource, as shown in thefollowing table: Message Service Name Type Description 6.4.1.2 Type can be either N = Notification or R = Request & Response.6.4.1.3 Notification type messages are initiated by the service provider (e.g., the equipment) and the provider doesnot expect to get a response from the service user. Request messages are initiated by a service user (e.g., the host).Request messages ask for data or an activity from the provider. Request messages expect a specific responsemessage (no presumption on the message content).6.4.2 Service Parameter Dictionary6.4.2.1 A service parameter dictionary table defines the description, format and its possible value for parametersused by services, as shown in the following table: Parameter Name Description Format: Possible Value 6.4.2.2 A row is provided in the table for each parameter of a service. 3 D. Harel, State charts: A Visual Formalism for Complex Systems, Science of Computer Programming 8, 1987.

&lt;!-- Page 42 --&gt;

SEMI E98-1102 © SEMI 2000, 20027 6.4.3 Service Message Definition6.4.3.1 A service message definition table defines the parameters used in a service, as shown in the following table: Parameter Req/Ind Res/Cnf Comment 6.4.3.2 The columns labeled REQ/IND and RSP/CNF link the parameters to the direction of the message. Themessage sent by the initiator is called the Request. The receiver terms this message the Indication or the request.The receiver may then send a Response which the original sender terms the Confirmation.6.4.3.3 The following codes appear in the REQ/IND and RSP/CNF columns and are used in the definition of theparameters (eg., how each parameter is used in each direction):M Mandatory Parameter  Must be given a valid value.C Conditional Parameter  May be defined in some circumstances and undefined in others. Whether a value isgiven may be completely optional or may depend on the value of the other parameter.U User-Defined Parameter.- The parameter is not used.= (For response only.) Indicates that the value of this parameter in the response must match that in the primary (ifdefined). 6.5 OBEM Standard Structure6.5.1 The remaining part of this document is organized as follows:6.5.1.1 Section 7 contains background information to provide a context for the Object-Based Equipment Model.6.5.1.2 Sections 8 provides an overview of two major views of the equipment: the functional view and the internalcomposition view.6.5.1.3 Section 9 introduces the OBEM object model: the interface inheritance hierarchy and the rules ofaggregation that together form the foundation of the OBEM model of equipment.6.5.1.4 Section 11 defines the requirements for the component objects within the equipment interface hierarchy: andother related objects of significance not defined elsewhere.6.5.1.5 Section 12 defines the message services used in OBEM that are not defined in other standards.6.5.1.6 Section 13 defines the services that are required of the user (factory system, remote access, and operator).6.5.1.7 Section 14 specifies the minimum requirements and optional capabilities for compliance to the OBEMstandard.6.5.1.8 Section 15 provides scenarios showing typical message flows during operation.6.5.2 Additional sections are provided as related information: examples and additional material that are not part ofthe standard itself. These include models for linked litho, 300 mm equipment, the relationship of OBEM and theCIM Framework, and representations of date and time. 7 Background7.1 Both modern manufacturing processes and modern manufacturing equipment are increasingly complex. Asingle installation of equipment may have hundreds or thousands of sensors and actuators. In order to manage thiscomplexity, better methods of referencing the internal components of equipment are needed. Use of the objectparadigm provides a means for the equipment to describe its internal composition to the factory in a natural way.7.2 Definition of standardized objects allows the factory to be specific about its requirements and its need forinformation.

&lt;!-- Page 43 --&gt;

SEMI E98-1102 © SEMI 2000, 2002 8 7.3 Computer Manufacturing Integration BusinessGoals7.3.1 The intent of this section is to provide a contextfor, and insight into, those requirements of industriessuch as semiconductor and flat panel display (FPD)manufacturing businesses that affect the object-basedequipment model.7.3.2 The primary purpose of computer integratedmanufacturing (CIM) technologies is to improvefactory productivity. 4 Other inter-related secondaryCIM business goals are listed below. Maximize product yields (line/mechanical yield). Maximize device yields (electrical/functionalyield). Maximize total factory product substratethroughput. Increase individual equipment product substratethroughput. Reduce product variability. Reduce process variability. Optimize ability to center processes in a sweetspot. Reduce the use of non-product substrates. Reduced time to utilization for equipment (i.e., thetime to install, qualify, characterize and rampproduction). Increase the usability, accuracy, and reliability ofdata used for metrics. These business goals can be met by addressingcertain concrete objectives, which are listed below.7.4 OBEM Functional Objectives7.4.1 OBEM will standardize specific functionalcapabilities to be implemented on semiconductor/FPDand other manufacturing equipment, providing ahierarchical view of equipment for effective factoryintegration.7.4.2 The OBEM functional objectives are as follows: Manage material into and through the equipment. Manage the association of the process instructionswith the material. 4 For a more detailed discussion and list, see the Guidance andGuideline documents athttp://www.sematech.org/public/docubase/abstract/tech-30.htm  Report data associated with the equipment, theprocess, and the material. Facilitate equipment performance monitoring.7.4.3 These OBEM functional objectives, individuallyand collectively, can be shown to directly address theoverall business goals:7.4.4 The Object Based Model objective directlyaffects the ability to implement most of the otherobjectives, especially in the case of highly modularequipment.7.4.5 Equipment performance monitoring has the effectof improving product variability, device yield and canreduce the need for non-product test substrates. It canalso provide a means of targeting a specific processwindow to improve device characteristics such asspeed.7.4.6 Management of the association of processinstructions with the material can reduce scrap due tomisprocessing, thus improving product yield. Thematerial management objectives impact on thethroughput of individual equipment and the totalfactory throughput.7.5 Relevant Factory Environment  Equipment mustsupport a variety of different factory environments.This is necessary because factory business practices andfactory configurations vary not only from company tocompany but also from one facility within a company toanother. Items will be added to this section as theirrelevance becomes apparent.7.5.1 Material Handling Systems  Material may beloaded and unloaded manually by a fab technician or itmay be loaded and unloaded using semi-automated andautomated transport systems. Types of systemsinclude: Automated Guided Vehicles (AGV), Personal Guided Vehicles (PGV), Overhead Transport Systems (OTS), includingOverhead Hoist Transport (OHT), and Fixed Arm Robots.7.5.2 Containers  Containers may be open (e.g.,cassettes) or closed (pods, including reticle pods). Podsmay be bottom-opening (SMIF), with a removablecassette, or front-opening (FIMS), which may haveeither a removable cassette or an integrated (non-removable) cassette (FOUP).7.5.3 Factory Interface  The equipment must be ableto support different levels of automation, including:

&lt;!-- Page 44 --&gt;

SEMI E98-1102 © SEMI 2000, 20029  stand-alone (with no connection to the factorysystems), fully on-line and operated locally (by the operator), fully on-line and operated remotely (by the factorysystems), and fully on-line and able to support and coordinateinteractions from multiple factory users andsystems at the same time. 8 Equipment Overview8.1 The Object-Based Equipment Model defines theobjects that are generic components of equipment aswell as the object representing the equipment itself.OBEM does not dictate the makeup of equipment.Through support of OBEM, the equipment is able todescribe its own makeup to the factory. However,OBEM does require certain visibility and access tothose parts of the equipment that control and/or monitorthe environment or the location of the product.8.2 Two view areas are of importance: the functionalview of the equipment and the internal compositionview of the equipment.8.3 Functional View of Equipment  From afunctional view, equipment is internally composed oflogical subsystems with different areas of responsibilitythat are at different levels within a control hierarchy, asillustrated in Figure 1. There are three general levels.Equipment Control is at the highest level, both respon-sible for, and representing, the equipment as an inte-grated whole. The middle level provides managementof specific areas, while the lowest level of functionalityhas specific time-critical responsibilities and handles alldirect interaction with the equipments I/O (sensors andactuators). The third level is below the factory level ofvisibility and is discussed here for completeness.NOTE 3: This is not intended to represent the design of anactual implementation. 8.3.1 The functional areas are discussed below inalphabetical order.8.3.2 Access Management  Access Management isresponsible for communications with the factory,including factory computers, local and remote oper-ators, third party systems, and alternate users (desktopaccess by process engineers, maintenance personnel,supplier remote diagnostics, etc.) Communicationswith the local operator include input devices (such as keyboards, wands, buttons, and optical character read-ers) and display devices (console, light pole, and LCDpanel) as well as interpretation of operator requests.8.3.3 Communications Link  Communications Linkis responsible for low-level communications, includingestablishing a connection with a communicationspartner, sending messages, and receiving messages.8.3.4 Date/Time Management  Date/Time Manage-ment is responsible for maintaining an accurate dateand time-of-day, and for providing current date/timeinformation to the rest of the system. This may includemaintenance of regular time-based scheduling.8.3.5 Environment Control  Environment Control isresponsible for maintaining the internal environmentaccording to the equipments specifications. WhileProcess Control is specific to a process and recipe,other monitoring activities may be required regardlessof whether the equipment is processing or idle. Suchactivities include monitoring for particles, humidity, ortemperature.8.3.6 Equipment Control  Equipment Control is thesupervisory level with overall high-level control.Equipment Control represents the entire equipment asan integrated whole to the factory and represents thedecision-making authority within the equipment.8.3.7 Event Management  Events continually occurin all equipment states. A variety of these events are ofinterest to the factory, including those events thatgenerate a change of state in any standardized object.The factory requires notification when selected eventsoccur, and in many cases, requires reports of the valuesof specified information at the time that the eventoccurred. Event Management is responsible fortracking those events and the reports associated withthose events.8.3.8 Exception Management  Exception Manage-ment is responsible for determining the proper responseto an action or operation that the equipment was unableto perform which raised an exception condition. Itprompts notification to all affected components,including internal components and currently connectedusers. In some cases, the proper action may have to beresolved by the user. Exception Management is a highlevel activity that is in addition to underlying hardwareand software interlocks.

&lt;!-- Page 45 --&gt;

SEMI E98-1102 © SEMI 2000, 2002 10 EquipmentControl FacilitiesInterface MaterialI/OManagement RecipeManagementOperationsManagementRecipeExecution ExceptionManagement MaterialManagement ProcessExecution PerformanceManagement AccessManagementEventManagement ObjectManagement Date/TimeManagement EnvironmentControlCommunicationsLink JobManagement InformationManagementMaterialMovementControl Figure 1Functional View of Equipment 8.3.9 Facilities Interface  The Facilities Interface isresponsible for managing the physical interfaces(hookups) to the factory. This includes bulk fill,continuous chemical services, factory vacuum, factoryexhaust, and the electrical environment of theequipment.8.3.10 Information Management  InformationManagement is responsible for the information and datastored by the equipment, including information requiredfor the user as well as various internal event and datalogs.8.3.11 Job Management  Job Management isresponsible for all jobs, including process jobs, jobqueues, and job execution. 8.3.12 Material I/O Management  The MaterialInput/Output (I/O) Management is responsible forloading and unloading material to and from the factory.This includes the AMHS interface (parallel I/O), podinterface, carrier management, and carrier-relatedservices such as reading, writing, and slot mapping(identifying unoccupied, correctly occupied, andincorrectly occupied slots in a carrier).8.3.13 Material Management  Material Managementis responsible for tracking all material, includingcarriers, product, and consumables, within or used bythe equipment. This includes providing historicalinformation required for product history.8.3.14 Material Movement Control  MaterialMovement Control consists of low-level control of

&lt;!-- Page 46 --&gt;

SEMI E98-1102 © SEMI 2000, 200211 internal subsystems, subassemblies, and i/o devicesused in moving material within the equipment, such asrobots, location sensors, proximity sensors, motors,centering and alignment systems, and material identifierreaders.8.3.15 Object Management8.3.15.1 Object Management consists of managementof OBEM objects, their attributes, and internalcommunications. It includes all elements ofconfiguration definition, both fixed and user-configurable, that pertain to the equipment.Configuration settings consist of those attributes thataffect the global behavior of the equipment and aregenerally static and change only on request. They arein effect at all times regardless of the current recipe(s)and/or processing states. They control activities thatmaintain the environment when not processing.8.3.15.2 Configuration settings shall be retained innon-volatile storage. Some elements of configurationmay be distributed. For example, individual processchambers may have their own configuration elements.8.3.15.3 Elements of configuration managementinclude: configuration of individual physical chambers, and configuration of individual logical objects.8.3.16 Operations Management  OperationsManagement is responsible for the overall operation ofthe equipment in all operational modes: automatic,semi-automatic, and manual.8.3.17 Performance Management  PerformanceManagement is responsible for managing informationand operations related to the performance of theequipment and equipment modules. This includesoversight for manual mode operations performed whenthe equipment and equipment modules are out ofservice. For implementations of ARAMS, this alsoincludes ARAMS state changes and data as well asoversight for manual mode operations performed duringdowntime and non-scheduled time.8.3.18 Process Execution  Process Execution coversthose fixed algorithms and procedures that are notreachable or changeable by the user. This includes anyembedded control and sequence algorithms notcontained in recipes. It consists of low-level control of subsystems, sensors, and actuators not covered byMaterial Management Control, such as, chemicalcontrol (valves, exhaust), motion control (rotational,acceleration, positional) and the control of theenvironment during processing of the product(temperature, etc.). It also includes productenvironment control and any fixed embedded faultdetection classification, and/or fixed low-level in-siturun-to-run control for advanced process control.8.3.19 Recipe Execution8.3.19.1 A recipe represents the pre-planned andreusable set of instructions, algorithms, and settings thatare used by process execution to control process,including variable in situ process control algorithms.Recipes are created by the user, and in some cases bythe equipment as well. Recipes may be of a variety oftypes, such as flow sequence, metrology, models, abort,and load maps, as well as etch, clean, etc.8.3.19.2 Recipe Execution is responsible for the properand safe execution of recipes, including loading therecipe into the execution area, verification of the recipe,validation of recipes (ensuring the recipe does notconflict with the current equipment configuration), andinitiation of process execution based on recipeinstructions (SEMI E42).8.3.20 Recipe Management  Recipe Managementconsists of the management of stored recipes. This isdifferentiated from short-term storage of recipes and theselection and execution of recipes performed by RecipeExecution (SEMI E42). Recipes are classified(organized) according to their primary applicationfunction: process, environment, service (maintenance),etc.8.4 Relationships with Other Standards8.4.1 Only those functional areas in the middle inFigure 1 are of interest to the host. The top level ofEquipment Control represents all of the functionalitybelow it, while the functional areas at the bottom areconsidered to be low level and proprietary to theequipment supplier.8.4.2 Table 1 shows those functional areas that aredefined by OBEM and those that are defined by otherSEMI standards. In some cases, OBEM may extend orlimit the functionality defined elsewhere.

&lt;!-- Page 47 --&gt;

SEMI E98-1102 © SEMI 2000, 2002 12 Table 1 Functional Area DefinitionFunctional Area Where Defined CommentsAccess Management SEMI E98 (OBEM) Defines different kinds of user control.Date/Time Management SEMI E98 (OBEM) Addresses timestamp, date/time synchronization.Event Management SEMI E53 (ERS) SEMI E53 may be required for SECS-II implementations.Exception Management SEMI E41 (EMS) Required for reporting alarms and exceptions.Material I/O Management SEMI E87 (CMS) Required for Carrier Management.Material Management SEMI E90 (STS) Required for Substrate Tracking.Object Management SEMI E39 (OSS) RequiredOperations Management SEMI E98 (OBEM) Overall coordination.Performance Management SEMI E58 (ARAMS) Optional for EquipmentModule and Equipment. Not usedfor lower level components.Job Management SEMI E40 (PM),SEMI E94 (CJM)Process Managment and Control Job Management Recipe Execution SEMI E42 (RMS) Required for processing by EquipmentModule.Recipe Management SEMI E42 (RMS) Required for long-term storage by Equipment. 8.5 Internal Composition View of the Equipment  The physical makeup of equipment is of interest to the factory,particularly for equipment that is complex, multi-module, and/or multi-process. Productivity and maintenancetracking, for example, requires that the factory be able to specify individual subsystems and/or modules formaintenance activities, where it is possible to do so without removing the entire equipment from manufacturingscheduling. For example, one or more baths in a wet bench may be down for maintenance even though the wetbench itself continues to process. 1+1+ held at interacts with EquipmentClock ProcessModuleMaterialHandlingSubsystemI/O Device User Carrier LoadPort 1+ Figure 2An Example of Equipment Internal Composition9 OBEM Object Model9.1 OBEM defines generic component objects of Equipment, and the Equipment object itself. Equipment is madeup of elements (units or parts) of different levels of intelligence and complexity, such as modules, subsystems, andI/O devices. Each of these elements may itself be made up of several smaller elements, some of which may also beintelligent, and this allows the complexity of the equipment to be distributed to smaller functional units. Many of

&lt;!-- Page 48 --&gt;

SEMI E98-1102 © SEMI 2000, 200213 these elements may be of interest to the factory. In particular, process modules, which are intelligent and may beindependently operable, are very interesting to the factory, since these are the units where the product is actuallyprocessed. The factory requires processing modules to be highly visible and individually addressable and to supportcertain of the same remote commands that are required of the equipment. Other elements of interest includesubsystems for material handling, alignment, and measurement.9.2 The equipment is responsible for all communications at all times, including messages directed to a specific partof the equipment. Service requests directed to components of the equipment shall be managed by the equipment toensure equipment integrity. EquipmentModule Equipment EquipmentSubsystem AbstractEquipmentElementEquipmentIODevice AbstractEquipmentSubsystem AbstractEquipmentModule User 1+ Figure 3Equipment Object Model 9.3 In Figure 3, two hierarchies are shown. On the left is an inverted interface inheritance hierarchy, and on theright the concrete subtypes where rules of aggretation are shown. The interface inheritance shows the objects thatdefine the attributes, state models, and services of the subtype objects as viewed externally. These are presentedupside down from the usual presentation so that they may be directly related to the aggregation hierarchy on theright. In both cases, the simpler objects are below the more complex objects.9.4 Those object types starting with the word Abstract are abstract objects not intended to be implementeddirectly. Their purpose is solely to define the inherited attributes, state models, and services for those objects usedto build an OBEM model of equipment. The remaining objects shown in Figure 3 are concrete objects. All rules ofaggregation are defined for concrete objects only.

&lt;!-- Page 49 --&gt;

SEMI E98-1102 © SEMI 2000, 2002 14 9.5 OBEM Object Requirements  By definition,subtypes of objects inherit the properties (attributes,services, and relationships) of their supertypes. In somecases, properties of the subtype may be furtherspecialized.9.5.1 Object Services Requirements  All objectsformally defined by this standard shall be compliant tothe fundamental requirements of SEMI E39 (OSS). AllOBEM-defined objects that are aggregates, containers,or managers of other objects shall comply with theadditional OSS requirements for object owners.According to OSS, an owner is any aggregate,container, or manager of one or more other objects. Anowner is required to respond to queries about the typesof objects that it owns. Owners have additionalresponsibilities, as specified in OSS.9.5.2 Object Non-volatility9.5.2.1 All objects defined by OBEM shall bepersistent. The individual object persists acrosspowerdown and powerup conditions, and all currentvalues of static attributes (attributes that do not changedynamically indicating the object's status) shall bemaintained and restored upon powerup. It may beimportant to maintain other critical values as well,depending upon the object and the implementation.When the equipment is powdered on or reset5, all statemodels are restored. Following initialization, the objectis considered to be operational. Figure 4 shows thisconvention for a generic OBEM object. However,since the state model can not be accessed by the useruntil the object is operational, the default entry state fora specific state model is considered to be within theOperational state. (Persistent OBEM Object)OPERATIONAL POWERDOWN INITIALIZATION Figure 4Persistence of OBEM Objects 5 For a more detailed discussion of powerdown, reset, and soft reset,see SEMI E58. 9.5.2.2 POWERDOWN and INITIALIZATION arecommon to all OBEM objects. Therefore, they are notspecific to any object and are not generally shown.When operational, the OBEM object is capable ofmaintaining state information. From the user view, aninstantiation of an OBEM object shall follow thebehavior or state model as shown in Figure 4. Theequipment representation, which consists of anaggregation of OBEM objects, shall also reflect thestate model shown here.9.5.2.3 The equipment is responsible for managing theexchange of any of its component parts, including partsexchanged during powerdown. This may beaccomplished through use of intelligent componentsthat are able to identify themselves or through the userinterface.9.5.3 Shared Resources  When two (or more) objectscooperate in using the services provided by a thirdobject, then the third object should not be modeled as acomponent of either of the first two objects. If the twocooperating objects have a common owner, eitherlogical or physical, then the shared resource objectshould belong to the common owner.9.5.4 Object Factory Communications  OBEMobjects other than the Equipment object are neitherrequired nor expected to communicate directly with thefactory. Factory communications are handled by theEquipment instantiation.9.5.5 Object Event Reporting9.5.5.1 Event reporting allows a user to receivenotification of events together with related data ofinterest. OBEM compliance requires that the equipmentprovide a standard mechanism for reporting events ofinterest to the user, together with the current values ofuser-selectable data.9.5.5.2 All transitions in state models are of interest tothe user and reportable unless otherwise stated in thestate model definition.9.6 OBEM Interface Inheritance Hierarchy9.6.1 An interface inheritance hierarchy begins with asimple interface at the highest (most abstract) level, andlower levels within the hierarchy represent addedfunctionality (specialization). A subtype of an objectinherits the attributes, behavior, relationships, andservices of the supertype and adds to and/or modifies(overrides) them.

&lt;!-- Page 50 --&gt;

SEMI E98-1102 © SEMI 2000, 200215 AbstractEquipmentElement Equipment AbstractEquipmentModule AbstractEquipment-Subsystem Figure 5Object Interface Hierarchy Concept 9.6.1.1 The physical view shown in Figure 2 isconcerned with the relationships between differentobjects. In that view, the equipment is at the highestlevel and owns (is responsible for) the lower levelobjects of which it is made up. A process chamber isconsidered to be at a higher level than subsystems suchas substrate handlers.9.6.1.2 From the view of the object interface hierarchy,this order is reversed, with AbstractEquipmentElementappearing at the top level as shown in Figure 5. Fromthe view of an object interface  the interface to anobject  the higher the level, the more simple theinterface. This is because of inheritance, where thechild object inherits all of the attributes, behavior,and services of the parent object and at the same timeadds some degree of specialization that will be reflectedin either additional attributes, behavior, or services, orin restrictions on the more general object.9.6.1.3 All objects represent the view as seen by thefactory, not the internal view of equipment control.From this view, the information and services requiredfor an equipment part such as a pod door opener isrelatively simple. The view of a module such as aprocess chamber is more complex but contains all theelements of the view provided for the simpler part(functional description, immutable id, etc.). The viewof the equipment is the most complex and includes allof the attributes and services of the equipment element,equipment subsystem, equipment module, and theequipment itself.9.6.1.4 The object model of equipment presented to thefactory is based on SEMI E39 (OSS). OSS servicesallow the factory to discover the actual physical makeup and aggregation hierarchy of the physical viewof equipment illustrated in Figures 2 and 3.9.6.1.5 Each object is defined in terms of itsrequirements, attributes, behavior (state models), andthe services that it is required to support. Theequipment owns all of the objects that it is made of andis responsible for providing the required behavior.9.6.1.6 All objects in OBEM inherit the attributes andservices defined for the Top Object as specified in theObject Service Standard (OSS). This allows the factoryto use object services to request the equipment todescribe its physical view by reporting which objectsthat it owns.9.6.1.7 Note that equipment support for an OBEMinterface to the factory does not imply or require directaccess from the factory to any equipment element. 10 OBEM Object Definitions10.1 OBEM objects are defined in this section.10.2 AbstractEquipmentElement Object  Thesupertype object of the interface hierarchy isAbstractEquipmentElement, which is an abstraction ofany equipment component that can perform work.AbstractEquipmentElement is an abstract type that isnot implemented directly. There are two subtypes ofAbstractEquipmentElement: AbstractEquipmentSub-system, and EquipmentIODevice. AbstractEquipment-Element is an abstract type, so that implementations areof one of the subtypes.10.2.1 AbstractEquipmentElement Requirements10.2.1.1 Object Exception Management10.2.1.1.1 SEMI E41 defines a model for ExceptionConditions. An Exception Condition may be either anAlarm Condition or an Error Condition. ErrorConditions may, in some cases, have a set of associatedRecovery Actions that can be performed by theAbstractEquipmentElement to attempt to recover fromthe abnormal situation.10.2.1.1.2 An OBEM object shall comply with thefundamental requirements of SEMI E41, Section 10.4.Exception Condition objects shall be provided inconformance with SEMI E41 and shall be accessiblethrough services defined in SEMI E39. TheAbstractEquipmentElement owns all exceptions that itgenerates. Therefore, it shall report all of its ExceptionCondition objects through OSS services.10.2.2 AbstractEquipmentElement Subtypes  TheAbstractEquipmentElement has two subtypes, theEquipmentIODevice and the AbstractEquipment-Subsystem.