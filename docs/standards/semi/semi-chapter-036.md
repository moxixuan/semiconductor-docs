---
title: "E42-0704 - ¬© SEMI 1995, 2004..."
description: "SEMIÊ†áÂáÜÊñáÊ°£"
sidebar_label: "E42-0704 - ¬© SEMI 1995, 2004..."
sidebar_position: 36
tags: ['SEMI', 'Standard']
custom_props:
  source_type: 'pdf'
  source_file: 'semi-chapter-036.pdf'
  chapter: 36
  page_count: 50
---

import PdfDownloadCard from '@site/src/components/PdfDownloadCard';
import PdfViewer from '@site/src/components/PdfViewer';

<PdfDownloadCard
  pdfLink="/pdfs/semi/036.pdf"
  pdfSize="N/A"
  title="E42-0704 - ¬© SEMI 1995, 2004..."
  description="SEMIÊ†áÂáÜÊñáÊ°£ÔºåÂÖ±50È°µ"
/>

---

## üìñ Êü•ÁúãPDFÂéüÊñáÊ°£ÔºàÂåÖÂê´ÂÆåÊï¥ÂõæË°®ÂíåÊ†ºÂºèÔºâ

<PdfViewer pdfPath="/pdfs/semi/036.pdf" />



&lt;!-- Page 1 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 20 for namespace and class, and there are rules fordetermining the appropriate version.The recipe name must always be specified.For external references within a recipe, the defaultclass is the class of the recipe making the reference.The proper class is determined when the recipe islinked (see Section 3.2.4.1.3).Where a recipe version is unspecified, the recipe of thatclass and name having the highest approval level willbe used. Where several recipes are found with the sameapproval level, the one with the highest version will beused. Where the version is unspecified in an externalreference, the correct version is determined when alinked recipe set is built by the link operation.For references with managed recipes, if no namespaceis specified, the default is namespace of the referringrecipe. 3.2.4 Advanced Recipe Capabilities3.2.4.1 Multi-Part Recipes  Use of multi-part recipesis often dictated by the recipe executor, which mayrequire a set of recipes of different classes for itsprocess. In addition, support for multi-part recipes canbe helpful for the user, in particular where recipes areotherwise long. The recipe language may define use ofsubrecipes analogous to that of subroutines in ordinaryprogramming languages. This enables better re-usewhere a high degree of similarity exists betweendifferent recipes.Where recipes of more than one class are required, it isconvenient to allow one recipe to reference another. Arecipe in the PROCESS class, for example, may refer torecipes in other classes to ensure that an entire set ofrecipes is executed together.It is also convenient to allow one recipe to referenceother recipes within the same class, where a substantialset of instructions and/or settings are common to avariety of other recipes.A reference within the body of one recipe to a differentrecipe is called an external reference. The exact syntaxin which this is done is determined by the recipelanguage used. An external reference may also specifyvalues for variable parameters defined in thereferenced recipe or in one of its subrecipes. 3.2.4.1.1 Subrecipes  When one recipe referencesanother recipe, both recipes are required for execution.The starting recipe is called the main recipe.Subrecipes are those recipes that are referenced by themain recipe, or by another subrecipe of the main recipe.A recipe that references other recipes is a parent recipeto the referenced subrecipes. A parent recipe is not necessarily a main recipe. A main recipe must not bereferenced by any of its subrecipes.External references to recipes within the samenamespace may or may not be explicit. That is,references to the current class (i.e., the class of therecipe being verified) may be implicit, and versionsmay be left to the rules for determining the defaultversion at link-time.A recipe may also reference recipes in anothernamespace. This occurs either when a recipe is to bedelegated or when a recipe in a namespace accessed bymultiple agents must reference a hardware-dependentor other agent-specific recipe kept in a defaultnamespace. The default namespace of a recipeexecutor is always referenced within a recipe as thenamespace named "Default". This name is interpretedby the recipe executor at execution time, based on itsattribute DefaultNamespace (see Section 6.3).When specified in a text string within a recipe with thesubrecipe's identifier, the identifier is preceded by thevalue of the namespace's identifier, followed by agreater-than symbol "&gt;". This is called the recipespecifier. For a recipe ETCH version 5 in a namespacenamed "NS-MOM", this would be specified asNS-MOM&gt;/PROCESS/ETCH;5.According to the rules of OSS, object type may beomitted when it may be otherwise determined. In RMS,determination is made according to order. 3.2.4.1.2 Delegated Recipes  A recipe may referencerecipes in another namespace that are to be executed bya component agent and are termed delegated recipes.Although referenced by another recipe, delegatedrecipes are not considered as subrecipes of the parent(referencing) recipe as they are to be executed by adifference agent and are themselves required to be amain recipe. A reference to a delegated recipe is theequivalent to an automated "select" and "start"sequence of commands from the supervisor. As such,they are generally subject to the constraints of a selectoperation.Delegated recipes may or may not require the name ofthe executing agent (recipe executor), depending on therules of the particular implementation. For example, asupervisor may be able to determine the appropriateexecuting agent at run-time, based on the namespacespecified. However, the ability to specify a particularexecuting agent is important to the user, as processresults may be sensitive to a particular equipmentinstallation. Therefore, recipe languages that supportdelegation shall allow specification of the particularexecuting agent to be used. The text format of the fullrecipe specifier in this case is:

&lt;!-- Page 2 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200421 Agent-Name&gt;Namespace-Name&gt;CLASS/Name;Version.The required order of identifiers within the specifier is:agent, namespace, recipe. 3.2.4.1.3 Linked Recipe Sets  Where one recipereferences another, a set of recipes to be executedtogether is formed by starting at the main recipe andcollecting the external references to identify all themembers of the set. This set is called a linked recipeset, and the operation of collecting the references is thelink operation.3.2.4.2 Variable Parameters  Variable parametersare variables that can be assigned values from outsidethe recipe itself. Variable parameters allow recipes touse variables rather than constants for such actions assetting temperature setpoints, time delay intervals, anddata-set names. This capability greatly extends the re-usability of a recipe.A parameter first is formally defined within a recipebody and given a unique parameter name, aparameter initial value (default value) for use whenthe recipe is selected for execution, unless overridden.Where applicable, the definition also includes aparameter restriction that represents one or moreconditions that any value assigned to that parameter isrequired to satisfy to be valid.The syntax for parameter definitions in recipe bodiesremains unspecified, so long as it conforms to thesyntax of the recipe language and contains the requiredelements. Other restrictions concerning the use ofvariable parameters may be imposed by the recipeexecutor's supplier through the specification of therecipe language.The parameter domain is the set of all possible valuesof a given form (see Section 1.4.3) that fulfill theconditions of the parameter restriction (if any).The form need not be included in the parameterdefinition declared within the recipe body, but rathermay be derived by the recipe executor during theverification process from the way in which theparameter is applied within the recipe. If temperature ismaintained internally as an unsigned integer, forexample, those parameters that are used in the recipe toassign temperature setpoints and ranges would typicallybe required by the supplier of the executing agent torepresent unsigned integers as well. The supplier shalldocument the forms and valid domains for each of theparameters that may be used as a variable parameter.NOTE: The parameter's value may be changed fromits initial (default) value within the text of a recipe, andit may also be set as an "argument" passed to asubrecipe. These capabilities are a function of therecipe language and are beyond the scope of RMS. Two categories of parameters are defined: numericand non-numeric. 3.2.4.2.1 Numeric Parameters  Numeric parametersinclude all parameters that can take on any numericvalue for its format type between a parameter lowlimit and parameter high limit.The parameter restriction for a numeric parameter inany of the attributes that store parameter definitionsshall be a text string that conforms to one of thefollowing:  "(a,b) UNITS" the domain of numbers x such thata

&lt;!-- Page 3 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 22 Text strings are restricted to the character set definedabove to represent the low and high limits of the domainand shall convert to a numeric value within thatdomain. 3.2.4.2.2 Non-Numeric Parameters  A non-numericparameter is any parameter other than a numericparameter, including parameters whose domains aresets of discrete numbers that cannot be represented by asingle mathematical interval, and strings that representnames. Non-numeric values may or may not placerestrictions on the replacement value. A parameter thatcontains the name of a wafer map, for example, cannotbe easily restricted by a general rule7, whereas aparameter that contains a string identifyingthermocouple type can be restricted to one of a defined,unordered set of valid strings. Restrictions for non-numeric parameters might also consist of, or include,logical expressions that shall evaluate to TRUE before avalue may be used.If a recipe language has been defined for thecorresponding class of recipes, the syntax for therestriction is taken directly from the formal definitionof that parameter within the body of a source formrecipe (and therefore conforms to the specification forthat recipe language). Otherwise, the restriction isexpressed in a syntax defined by the recipe executor'ssupplier specifically for parameter attributes.For example, the parameter for a furnace recipe mayspecify which set of PID values should be used, wheresets A-F exist on the equipment. The automaticrestriction on the value for such a parameter, asspecified by the recipe executor's supplier, might be"&#123;A,B,C,D,E,F&#125;" with the default for the valuespecified as the character "C" with a format type of"ASCII string of length 1".In another example, a restriction might be that the valuebe taken from the enumerated set&#123;cassette, lot , batch &#125;. 3.2.4.2.3 Agent-Specific Parameters  In order to"tune" a recipe so that it produces the same result on allrecipe executors of the same type, it may be necessaryto provide a different initial value for the parameter ora different parameter restriction for individualexecuting agents. A special editing facility may beprovided by the recipe manager to allow the originalvalue and/or restriction of a parameter to be modifiedfor a specific executing agent. 7 Typically, the validity of parameters which are unrestricted namescan only be established at run-time. NOTE: Agent-specific parameter definitions replacethe corresponding original definitions in the recipe thatis downloaded to the recipe executor. At run-time, theyare superseded by parameter values specified for therecipe executor's select operation. 3.2.5 Attributes  The name of an attribute is a textstring required to be unique for its object. The names ofthe attributes defined in this document are reserved fortheir standard use.Identification attributes are those used to identify theobject in OSS. These attributes are available throughOSS, but in RMS, services are handled separately fromthe other attributes and are not transferred in parametersfor "recipe attributes".Attributes other than identification attributes andmandatory attributes discussed below always have adefined default value. Attributes with a default valuenot otherwise specified are considered to have a nullvalue corresponding to their form as their default value.The null value for a text string is a zero-length string.The null value for a numeric form is zero. The nullvalue for a boolean form is FALSE. The null value foran empty list or structure is an empty (zero-length) list.The manner of representing null values is left to theprotocol.An attribute is cleared or reset by setting its value tothe default value.Mandatory attributes are attributes that are required toalways have a non-default value.Certain attributes are required, including all mandatoryattributes. A required attribute is one that shall besupported with a non-default value. For example, theBodyFormat attribute is required. This means thatobject form recipes (for which BodyFormat has a non-default value) shall be supported by a namespace.Any attribute defined in this standard shall only bemodified according to the rules specified for thatattribute.Attributes of the managed recipe and the executionrecipe may be accessed through Object Services.However, only certain of the attributes may be setthrough Object Services.For purposes of OSS, all attributes defined in RMSshall be recognized. That is, a response to a GetAttrservice request that references any attribute of an objectdefined in RMS for that object shall not return an"invalid attribute" error. If the attribute is not supportedby the application, then it shall show the value of thatattribute as having the null value appropriate for itsform, and it shall deny attempts to set its value throughthe SetAttr service.

&lt;!-- Page 4 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200423 3.2.5.1 Descriptors  Two types of mandatoryattributes of particular importance are the timestampand length attributes. These are provided for the body,for each agent-specific dataset, and for the set ofattributes of the recipe object itself, including thetimestamp and length attributes of the body.A descriptor contains the length and timestampattributes (in that order) of one or more of the aspects ofa recipe: its attributes, its body, or an agent-specificdataset. Descriptors are used to compare two recipesstored in different namespaces or in a namespace and inthe recipe execution area of a recipe executor. NOTE: Provision of a real-time clock or other devicecapable of counting time in centiseconds greatlyimproves the value of the timestamps for thiscomparison. 3.3 Full and Minimal Recipe Models  Figure 3.5contains an object model for the managed andexecution recipes supporting all of the standardattributes defined in RMS. Non-identifier attributes areshown in alphabetical order. Many of these attributesare not required for minimal applications. Minimalmodels for the managed and execution recipes areshown in Sections 3.4.2.3 and 3.5.2, respectively. Figure 3.5Full Recipe Object Model

&lt;!-- Page 5 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 24 3.4 Managed Recipes  This section defines themanaged recipe and its attributes.3.4.1 Generic Attributes  For clarity, the attributes ofthe managed recipe are sometimes called genericattributes to distinguish them from agent-specificattributes or attributes of the execution recipe.Attributes that are not specifically defined in thisstandard may be defined by an application or by theuser. Attributes that are defined by a namespace or by arecipe executor for its own use shall be changed onlyby rules specified and documented by the originator ofthe attribute.To prevent conflict between non-standard attributenames and names which may become standard in thefuture, non-standard attribute names shall start with theprefix "UD\_" (the two characters "U" and "D" followedby the underline character). It is the responsibility of theoriginator to provide unique attribute names. Whenusing other RMS services, non-standard attributes shallfollow all standard attributes.It is desirable that a method be provided for the user todefine new attributes. 3.4.1.1 Timestamp Attributes  Timestampinformation (date and time of the last change) isimportant to recipe management. Timestamp attributesare maintained by the recipe namespace and may not bechanged otherwise.A timestamp attribute shall always contain the date andtime that the particular aspect of the recipe was lastchanged. This attribute is a text string of the form"yyyymmddhhmmsscc" for the year yyyy, the monthmm, the day dd, the hour hh, the minutes mm, theseconds ss, and the centiseconds cc.The timestamp of the body is called EditTime and is setwhen a recipe is first created and updated whenever thebody is modified in any way.Because a recipe's attributes may be changed withoutchanging the body, both the recipe's generic attributesand each set of agent-specific attributes themselveseach have a timestamp attribute. For the genericattributes, the timestamp attribute is calledAttrChgTime. The set of agent-specific attributes (of anagent-specific dataset) has its own timestamp attribute,called AgentSpec\_ChgTime. 3.4.1.2 Length Attributes  There are three lengthattributes, one which contains the length of body, onethat contains the length of the generic attributes, andone that contains the length of the agent-specificattributes. Length attributes are calculated withoutregard to either protocol overhead or storage overhead,such as proprietary formats used for internal storage that may change from one implementation to another.This preserves the length across different conventionsused for recipe storage and different communicationsprotocol.The length attribute of the body, BodyLength, containsthe length of the body in bytes. The length of the bodyis calculated as the number of bytes it will require whentransferred, excluding any overhead, such as that whichmight be required for protocol format information.The length of an individual attribute is calculated as thesum of the lengths of the attribute name and theattribute value.The length of a set of attributes shall be calculated asthe sum of the lengths of the individual attributes thatare set to a non-default value at the time the calculationis performed, including the length attribute itself. Allattributes set to their default value, at the time thelength is calculated, are excluded from the calculation.This is because only the attributes with a non-defaultvalue are transferred when a recipe is moved into or outof a namespace. It also results in a more significantchange to value of the length attribute when an attributeis set to a non-default value. 3.4.1.3 Descriptors  The descriptors of the managedrecipe are the body descriptor (BodyLength andEditTime), the generic attribute descriptor(AttrLength and AttrChgTime), and the agent-specificdescriptor (AgentSpec\_AttrLength andAgentSpec\_ChgTime). The recipe descriptor for amanaged recipe consists of the attribute descriptor, thebody descriptor (in that order), followed by descriptorsof any existing agent-specific datasets.3.4.2 Managed Recipe Object Attribute Definitions This section provides the formal definitions for therecipe's generic attributes. For Object Services, a recipeis considered as the owner of its components, anyagent-specific datasets. The body may not be accessedthrough Object Services.Attributes in Tables 3.1 and 3.2 are presented in thefollowing order:  identification attributes, including object type andidentifier, appearing above the heavy line in Tables3.1 and 3.2, mandatory attributes and the other requiredattributes, in the order in which they are to appearwhen a recipe is transferred, optional attributes in alphabetical order, and non-standard attributes, which are transferred last.

&lt;!-- Page 6 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200425 When transferring a recipe with RMS services, identification attributes are not included in the list of attributes, andrequired attributes are sent, in order, before optional attributes. Non-mandatory attributes having their default valueare not transferred, since their absence indicates their value, but they are always available through Object Services.Order of optional attributes is not dictated. 3.4.2.1 Generic Attribute Definitions  Table 3.1 provides the formal definition of the generic attributes of themanaged recipe.Table 3.1 Managed Recipe Attribute DefinitionAttribute Name Definition Access Rqmt FormIdentification AttributesObjType The object type. RO Y Text: "MRcp"ObjID An identifier derived from Class, Name, andVersion. No part of a recipe's identifier shall bechanged except through renaming. RO Y Formatted text. Name A logical name assigned by the user when the recipeis created or renamed.RO Y Text. Class The recipe's class (e.g., "/PROCESS/" or"/PROCESS/LOADER/").RO Y Formatted text:"CLASS/CLASS/../CLASS/"Version The version of the recipe. RO Y Text.Mandatory AttributesAttrLength The total length of the generic attributes, in bytes.Mandatory.RO Y Unsigned integer. AttrChgTime Timestamp of the last change to a generic attribute.Mandatory.RO Y Formatted text. BodyLength Length of the recipe's body, in bytes. Mandatory. RO Y Unsigned integer.EditTime Timestamp of when the body was created or lastupdated. Mandatory.RO Y Formatted text. Timestampformat.Required AttributesBodyFormat Indicates the form and format of the recipe's body.Default is zero.RO Y Enumerated unsignedinteger:0 = source,1 = object,&gt; 1 reserved.Verified Indicates whether the recipe's body is syntacticallycorrect. Reset when the recipe is created or updated.Default is FALSE. RO Y Boolean. Linked Indicates whether the recipe is linked. Reset whenthe recipe is originated, verified, or unlinked.Default is FALSE. RO Y Boolean. Optional AttributesApprovalLevel Indicates the level of approval assigned by anauthorized user. Default is zero. Reset when therecipe is originated or linked. For a linked recipe,may not be higher than any of its subrecipes. RW N Unsigned integer. Comments User comments. RW N Text. Maximum length is 80characters.EditedBy The name of the person who last edited the recipe. RO N Text. Maximum length is 40characters.EstRunTime The nominal or estimated execution (run) time of therecipe, in seconds. Reset when the recipe is createdor updated. Set when the recipe is verified. May be RW N Unsigned integer.

&lt;!-- Page 7 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 26 Attribute Name Definition Access Rqmt Formrecalculated to total time for a main recipe whenlinked. Used for scheduling purposes. Algorithm forcalculation shall be documented. Default is 0.ExecChgCtrl Specifies change control requirements for recipe.(See Section 6.5.)RW N Binary. Bitwise (MSB =8\*\*).1 - The recipe body may bechanged,2 - Change notification isrequired,3 - Recipe may be selectedafter change,4 - Most recent parametersettings shall be saved.ExtRef A list of all recipe specifiers as referenced within therecipe. Explicit versions not required. Reset whenthe recipe is created, updated, and verified. RO N List of formatted text. LinkList A complete list of recipe specifiers found in theExtRef attribute of a main recipe and all of its sub-recipes, with duplicates removed and all versionsexplicitly determined. Set for the main recipe whenlinked. Reset when the recipe is originated orverified. Required for multi-part recipe support. RO N List of formatted text. LinkParam A list of all variable parameter definitions containedin the Parameters attribute of a main recipe and all ofits subrecipes, with duplicates removed. Reset whenthe recipe is created, updated, or verified. Set whenthe recipe is linked. Required for variable parametersupport. RO N Structure composed ofparameter name, initial value,and restrictions. Parameters A list of variable parameter definitions contained inthe recipe. Reset when the recipe is created,updated, and verified. Set when the recipe isverified. Required only for variable parametersupport. RO N Structure composed ofparameter name, initial value,and restrictions. SrcRcpID Identifier of the source form recipe from which aderived object form recipe is derived. Valuedetermined by the verifier of the recipe. Requiredonly for support of derived object form recipes. RO N Formatted text. VerificationID Identification code set by the verifier of the recipe.May be used to determine out-of-date formats thatneed to be reverified. RO N Text. Maximum length is 40characters. UD\_\* Non-standard attribute defined by supplier or user.Asterisk indicates the part of the attribute name thatis provided in this definition. Shall be preservedexactly except by the entity that defined it. RO N Varies with definition. Textform is limited to 80characters. \*\* NOTE: SEMI E4 and E5 number bits 18, where Bit 8 = MSB (most significant bit).3.4.2.2 Agent-Specific Attribute Definitions  The names of user-defined attributes shall start with the prefix"AgentSpec\_UD\_" and shall be preserved without modification from transferred recipes. These attributes follow allstandard attributes when transferred.An agent-specific dataset exists only if an agent-specific attribute other than the timestamp and attribute-lengthattributes of the dataset itself have been set.

&lt;!-- Page 8 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200427 Table 3.2 defines the attributes of the agent-specific dataset object.Table 3.2 Agent-Specific Dataset Object Attribute DefinitionAttribute Name Definition Access Rqmt FormObjType The object type. RO Y Text = "MRcpASDS"ObjID The object's identifier. Contains the value inAgentSpec\_Agent.RO Y Text. AgentSpec\_Agent The name of the executing agent to which the otherattributes in the dataset apply. Mandatory.RO Y Text. AgentSpec\_AttrLength The length of the agent-specific attributes, in bytes.Mandatory.RO Y Unsigned integer. AgentSpec\_ChgTime Timestamp of when an agent-specific attribute was lastchanged. Mandatory.RO Y Formatted text. AgentSpec\_Comments Comments specific to the agent entered by the author. RW N Text. Maximum lengthis 80 characters.AgentSpec\_LinkParam A list of variable parameter definitions modified fromthe list in LinkParam. Valid only for a linked mainrecipe. Parameter name and form may not be changed. RO N List of Structurecomposed parametername, value, andrestrictions.Certified The certification-level for the specific agent, assignedby an authorized user. Reset whenAgentSpec\_LinkParam is modified. Required forcertification support. RW N Unsigned integer. AgentSpec\_UD\_\* Non-standard attribute defined by the supplier or user.Asterisk indicates the part of the attribute name that isprovided in this definition. Must be preserved exactlyexcept by the defining entity. RO N Varies with definition.Text form is limited to80 characters. 3.4.2.3 Minimal Managed Recipe  The minimal model for a managed recipe is shown in Figure 3.6. Onlyrequired attributes are supported in this model. This model can only be used for single-part recipes in the dedicatednamespace, such as the default namespace required for stand-alone equipment. There are no agent-specific datasets. Figure 3.6Object Model for Minimal Managed Recipe

&lt;!-- Page 9 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 28 3.5 Execution Recipes  The type of recipe handled bya recipe executor is called an execution recipe. Thistype of recipe has attributes and a body but does nothave an agent-specific dataset. Most of the genericattributes of the managed recipe, and certain of theagent-specific attributes, are also attributes of theexecution recipe, while in other cases, a genericattribute and an agent-specific attribute are merged andplaced in a new execution recipe attribute.A managed recipe is converted to an execution recipewhen the recipe is downloaded to the recipe executor,and correspondingly, an execution recipe is convertedto a managed recipe when uploaded from the recipeexecutor.The execution recipe is defined in detail in Section 6.3. 4 Recipe NamespaceThis section defines the basic conceptual model for therecipe namespace, a logical domain for recipe storageand management, within which the identifier of a recipeis guaranteed to be unique. The model in the currentsection is applicable to implementations withcentralized storage. Section 5 defines an extension ofthe basic model for a distributed recipe namespace.In general, the term "namespace" refers to a domain ofunique identifiers. The issue of namespace boundariesexists for all object types, particularly in a distributedenvironment, and is not unique to recipes. However,within the context of RMS, namespace is used as asynonym for recipe namespace. 4.1 Motivations  A recipe's identifier may not beunique across different namespaces or throughout afactory. (That is, a given identifier may be used byinternally different recipes except within a singlenamespace.) A primary role of a namespace is to definean area within which the uniqueness of any given recipeidentifier may be guaranteed.The requirements for Recipe Management that areaddressed in this section include:  to define the boundaries of specific areas whererecipes may be uniquely identified, stored, andretrieved, to define the attributes and operations for themanagement domain of recipes, including recipeprotection and recipe operations,  to allow control of removable media, to allow stand-alone equipment to execute recipes, to facilitate smooth integration of stand-aloneequipment into on-line factory systems, to allow integrated equipment to continue toexecute recipes when communications have beenlost, and to provide the basis for the distributed model inSection 5, which allows a supervisor to use andmanage the storage capacity of its subordinateagents.4.2 Namespace Model  The namespace model servestwo major purposes. First, it provides a common set ofmanagement rules. Second, it allows a set of recipes tobe shared among a group of executing agents that havea common process type, common functionality, and acommon recipe language.Figure 4.1 shows the basic namespace model with fourobjects: the recipe, the namespace itself, a namespacecomponent called recipe namespace segment, and arecipe namespace manager.The recipe namespace manager (or manager)represents the interface for the namespace to theexternal world and the internal decision authoritywithin the namespace. All services for the namespaceand its recipes are provided by the manager. Thenamespace itself is passive. While it has importantattributes, the namespace has no operations, and itprovides no services.The recipe namespace segment (or segment)represents both the internal storage element and theactual manipulation of recipes within the namespace,under the supervision of the manager. In the basicmodel, it also provides no public services. Therelationship between the segment and the manager inthis model is presumed to be internal to an application.Figure 4.1 represents a namespace with centralizedstorage. However, it can easily be extended to thedistributed recipe namespace, which may havemultiple segments, each provided by a different externalagent. For that case, the manager and segment mustprovide public services for one another.

&lt;!-- Page 10 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200429 Figure 4.1Recipe Namespace ModelAll operations performed on a recipe through Recipe Management services are performed within the namespace by,or under the supervision of, the namespace manager, with two exceptions. A namespace manager is not required tounderstand the syntax of the recipe languages. For this reason, recipe editing (modifying a recipe's body) is not partof the namespace definition, and verification shall be provided by a recipe executor of an appropriate executingagent (see Section 6). These two activities require an in-depth understanding of the particular recipe languages used.Their separation from the other activities allows generic namespace capabilities to be provided. 4.3 Namespace Specifications  The combination of the recipe namespace, its segment component, and itsmanager provides storage, retrieval, and management of recipes conforming to RMS.A namespace manager is responsible for maintaining the integrity of the namespace, the integrity of the recipeswithin the namespace, and the integrity of the recipe identifiers. It understands the rules regarding recipes, theirattributes, and their components, and it is responsible for enforcing those rules. It will not allow a read-only recipeto be changed or deleted, for example. Therefore, it will not accept a recipe with an identifier already used by aread-only recipe.A namespace has no restrictions on the read access of a recipe as a whole or of its attributes, nor is it concernedwith the uses to which they might be put outside the namespace. The ability for multiple agents to share the samerecipes is determined solely by the ability of the agents to access the same namespace. Issues of security andauthentication are beyond the scope of RMS.The term recipe namespace, or namespace, is used inclusively to refer to those attributes, operations, and otherrequirements common to both the namespace described in this section and to its distributed subtype. The termcentralized namespace is used in references to an instance (implementation) of the basic model and to clarifystatements that do not apply to instances of the distributed subtype.A centralized namespace is analogous to a single directory of files, where duplicate file names are not allowed. Itmay exist in several different configurations that are incidental to namespace requirements.It is possible to provide a namespace that uses removable media for its physical storage. Recipes may then betransferred to and from this namespace to any other namespace.In no case shall it be possible to transfer recipes into a namespace except according to the requirements fornamespace management. For example, a read-only recipe may not be replaced.The centralized namespace may be applied several ways. An agent with execution capabilities that may be operatedin stand-alone mode shall provide itself with a centralized namespace to be used when operating in stand-alonemode. Other agents, such as diskless process modules in a cluster, may expect to rely upon the namespacecapabilities provided by the cluster supervisor.

&lt;!-- Page 11 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 30 4.4 Member Agents  A namespace that containsrecipes used by multiple agents is called shared.Otherwise, it is called dedicated or non-shared. Figure4.2 illustrates two dedicated namespaces, one providedby an etcher and one by its host. This terminology isintroduced for clarification and descriptive purposesonly. Figure 4.2Host Backup of Equipment NamespaceThe Members attribute of the namespace contains thenames (object identifiers) of the agents that use therecipes in the namespace, and these agents are calledmember agents (members) of the namespace. Thenamespace manager uses this information as it mayrequire assistance from a member agent to verify arecipe.If the Members attribute of the namespace containsmultiple agent names, then the namespace is shared.Otherwise, it may be non-shared or not yet completelyset up. If it is empty (null), the namespace has not beencompletely set up and is not fully functional, as certainoperations, including recipe verification, require it tohave content. 4.5 Illustrations  This section provides illustrationsof several possible configurations of a centralizednamespace.Figure 4.2 illustrates an etcher that has its own localnamespace and that communicates with its supervisorover an RS-232 line. The supervisor in this examplemaintains a separate namespace, providing backup forrecipes of particular significance.Figure 4.3 illustrates a supervisor with four disklesssubordinates. In this configuration, the supervisorprovides recipes for all four subordinates from acentralized namespace. Figure 4.3Namespace Provided by SupervisorFigure 4.4 illustrates four executing agents on acommon network with a supervisory agent and a sixthagent providing a centralized namespace. Eachexecuting agent is able to access the namespaceindependently of the supervisor. Figure 4.4Shared Network AccessFigures 4.3 and 4.4 both represent examples of sharedcentralized namespaces. 4.6 Attribute Definition Tables  Table 4.1 defines theattributes of the recipe namespace.

&lt;!-- Page 12 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200431 Table 4.1 Recipe Namespace Attribute DefinitionAttribute Name Definition Access Rqmt FormObjType The object type. RO Y Text = "RNS"ObjID The name of the namespace. RO Y Text. A name of "Default" isprohibited.RecipeReadOnly-LevelThe level of approval at which recipes are read-only. RW Y Unsigned integer. Members The names of agents capable of verifying and executingthe recipes in the namespace.RW Y List of agent names(identifiers).SynchOn Level of synchronization (see Section 9.5). Required ifsynchronization is supported.RW N Unsigned integer:Either 0 = Disabled, or anycombination (sum) of:1 = changes in body2 = new execution recipe8 = changes in last value16 = new derived objectform execution recipeSynchFail Specifiers for execution recipes for which an attempt tosynchronize failed. Required if synchronization issupported. RW N List of formatted text. Table 4.2 defines the attributes of the recipe namespace manager objects. The name (identifier) of the manager isnot generally of interest, as the namespace specifier is more commonly used. However, it is important for themanager to be accessible through Object Services.Table 4.2 Recipe Namespace Manager Attribute DefinitionAttribute Name Definition Access Rqmt FormObjType The object type. RO Y Text = "RNS\_Mgr"ObjID The manager's name. RO Y Text.NamespaceName The name of the namespace managed. RO Y Text. 5 Distributed Recipe NamespaceA distributed recipe namespace is a recipe namespace that utilizes the storage capacity of multiple agents forrecipe storage. Recipes are stored in special recipe namespace segments provided by the different agents. Thesesegments are distributed recipe namespace segments and are supervised by the distributed recipe namespacemanager.This section defines the different objects that together provide the distributed recipe namespace capability: thedistributed recipe namespace, the distributed recipe namespace manager, the distributed recipe namespacesegment, and the distributed recipe namespace recorder. Detailed descriptions of operations are contained inSection 10.Throughout this document, the acronym DRNS refers to the term "distributed recipe namespace" and is usedprimarily to differentiate a DRNS subtype object from its supertype. 5.1 Motivations  The distributed recipe namespace capability provides a method for using the storage capacity ofmultiple agents, as illustrated in Figure 5.1. This reduces the storage requirements of a centralized factory system,improves performance by allowing recipes to be used by those agents, and provides a centralized management of thenamespace to ensure that the uniqueness of the recipe identifier is properly maintained.

&lt;!-- Page 13 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 32 Figure 5.1 illustrates a distributed recipe namespace with four segments, each provided by a different agent, andeach agent also having a local namespace. Figure 5.1Illustration of Agents, Segments, and Local Namespaces

&lt;!-- Page 14 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200433 5.2 Overview  The DRNS object model (Figure 5.2) is a specialization of the model introduced in Section 4. Thedistributed recipe namespace, the DRNS segment, and the DRNS manager are subtypes of the recipe namespace, therecipe namespace segment, and the recipe namespace manager respectively. Each inherits the attributes andoperations of its corresponding supertype. Only those attributes and operations that are specific to the DRNS typesare shown in object representations. Figure 5.2Distributed Recipe Namespace Model The namespace supertype has exactly one segment of storage. Where storage is centralized, the segment is internaland private to the namespace. However, in the case of the distributed recipe namespace, there may be multipleDRNS segments, each provided by a separate agent. For this reason, the DRNS segment is a standardized object.The distributed recipe namespace separates the management of recipes within a specific recipe storage area from themanagement of the entire namespace. The management of individual recipes within a specific storage area isdelegated to the distributed recipe namespace segment. The distributed recipe namespace manager manages thevarious segments and the namespace itself. The manager is responsible for knowing the identifiers of all recipesstored in the entire namespace. It requires a knowledge of the structure of the recipe's identifier and the significanceof the version in differentiating between recipes of the same name and different versions.The DRNS recorder provides a backup facility for information required to automate the rebuilding of a distributedrecipe namespace. It is external to the DRNS namespace and to its DRNS manager.

&lt;!-- Page 15 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 34 5.3 Distributed Recipe Namespace Issues  Thissection introduces issues that are applied to more thanone object within the distributed recipe namespacecapability.5.3.1 Object Services  Attachment is a relationshipbetween a managed object and its manager that isdefined in OSS (SEMI E39). One object may beattached, detached, and reattached to a manager. Whenattached, the managed object is able to recognize thatcertain critical services have been requested by itsmanager. The segment and recorder objects shallcomply with requirements for the operations andservices defined in SEMI E39 (OSS) to attach, detach,and reattach to and from a DRNS manager. They shallalso allow their manager to modify specified attributesthat are otherwise read-only.The ability to create and delete a segment or recorder isoptional.The authorized user may request a DRNS manager toattach or detach a specified segment or recorder. 5.3.2 Logical Recipe  A logical recipe is defined asa recipe with a specific body and a specific set ofgeneric attribute values. Every managed recipe storedis an instance of a logical recipe.In a distributed recipe namespace, it is normal forinstances (copies) of a given logical recipe to exist inmore than one DRNS segment at any time. In otherwords, multiple duplicate copies of a recipe with thesame identifier may co-exist within the distributedrecipe namespace. To retain the integrity of thenamespace, this can be allowed if, and only if, eachcopy of a recipe with a given identifier is an instance ofthe same logical recipe. It is the responsibility of theDRNS manager to ensure this logical identity ismaintained.Agent-specific datasets are not included in thedefinition of the logical recipe because multiple agent-specific datasets may exist independently of oneanother, and only the dataset specific to the agentproviding the DRNS segment is normally kept in thatsegment. 5.3.3 Change Requests  A change request occurswhenever a user, an external application, or an attachedDRNS segment requests the DRNS manager to make, orpermit, any change in a recipe. Information concerningchange requests is kept in the form of logical changerequest records. Once a change request is made, achange request record is created and maintained untilthe change has been either completed or discarded.Because the information represented by change requestrecords is publicly available, they provide a degree ofdiagnostic capability. The change request record is not a formal orstandardized object, but it represents the informationthat is available through services.Change management is the most critical issue of theDRNS capability and is discussed in detail in differentsections below. 5.4 Distributed Recipe Namespace Segment  Thedistributed recipe namespace segment (Figure 5.3) isresponsible for all of the activities that directlymanipulate recipes, including storage, retrieval,deletion, and operations that change a recipe's attributesor body. This requires a micro-level knowledge of therecipe's identifier, its structure, the inter-relationshipsbetween the various recipe attributes, how the recipe isstored, and how it is transferred. It also includes amacro-level knowledge of all of the identifiers of therecipes that it has stored. The DRNS segment shallensure that only one recipe with a given identifier existswithin that DRNS segment. The contents of anunattached DRNS segment shall be read-only.A DRNS segment and its storage are provided by anagent, which could be equipment, an independentrecipe server, or other factory systems. Figure 5.3Distributed Recipe Namespace Segment 5.4.1 Master and Dedicated Segments  A mastersegment is a specialization of a DRNS segment that iscapable of storing multiple agent-specific datasets perrecipe. Master segments are not dedicated to a singleequipment and are used to store a full copy (includingall existing agent-specific datasets) of all logicalrecipes within the namespace. It is required that every

&lt;!-- Page 16 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200435 distributed recipe namespace manager be capable ofsupporting at least one attached master segment.Additional master segments may be desirable forfurther backup protection.The term dedicated segment is used to refer tosegments that are not master segments. Dedicatedsegments store at most one agent-specific dataset perrecipe. Because a DRNS segment provided byequipment would not expect to keep agent-specificdatasets for other equipment, equipment normally doesnot provide master segment capability.Master and dedicated segments have the sameattributes and support the same message services, butthey respond differently to agent-specific datasets andare used for different purposes. A master segmentrequires approval prior to changing an agent-specificdataset. 5.4.2 Change Restrictions  The DRNS segment mayprovide access to recipes within its storage to the othercomponents of the agent providing the storage.However, neither the generic attributes nor the body ofrecipes stored by the segment shall be changed exceptwith the explicit approval of the distributed recipenamespace manager.Dedicated DRNS segments that are attached to a DRNSmanager may change the contents of an agent-specificdataset without first asking permission. However, theyare required to notify the manager of any change assoon as it occurs.The attribute RecipeReadOnlyLevel is set by the DRNSmanager to the value of the corresponding namespaceRecipeReadOnlyLevel attribute when the segment isfirst attached and whenever the namespace attribute ischanged. This attribute has the same function as thenamespace attribute and allows the segment to prohibitchanges based on a recipe's approval level as defined inSection 8.2.5. For example, the segment shall denyrequests to modify a write-protected recipe.The DRNS segment is prohibited from changing itscontents whenever it is unattached. However, recipesand recipe attributes may be read at any time by otherentities, including other components of the owneragent.Any changes to a logical recipe stored by the DRNSsegment shall first be approved by the DRNS managerbefore the change is made. This includes any changes tothe body or to any generic attribute. This is required fortwo reasons. First, two different DRNS segments mayattempt to change a recipe at the same time, and thisactivity must be coordinated. Second, to protect theintegrity of the recipe identifier where multipleinstances of a recipe exist, the distributed recipe namespace is required to ensure that all such instanceshave been updated appropriately with that changebefore other changes to the same recipe are allowed.NOTE: The prohibition against unauthorized changedoes not preclude the saving of such changes externalto the DRNS segment while waiting for authorization.However, changes made by other DRNS segments,subsequent to such changes and prior to authorization,may invalidate these changes.Communications between the different components ofan agent that do not require or use the formal servicesdefined by RMS are considered as proprietary to theagent and are neither covered nor excluded by RMS,subject to the above restrictions against change. Figure 5.4Distributed Recipe Namespace Recorder 5.5 Distributed Recipe Namespace Recorder  Thedistributed recipe namespace recorder provides amethod of externally storing and retrieving informationcritical to automated rebuilding of a damageddistributed recipe namespace. It contains two types ofinformation: a list of the DRNS segments that areattached to the DRNS manager and the current changerequest record in process per recipe.A DRNS recorder may be attached and detached from aDRNS manager, and reattached to that manager.Information that it contains is available to anyone butmay only be changed by its manager.The DRNS recorder is able to store the DRNS segmentspecifiers (the object specifiers) of the attached DRNSsegments in its Segments attribute. This informationallows a distributed recipe namespace to beautomatically rebuilt in the event that the namespace, or

&lt;!-- Page 17 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 36 the DRNS manager, is damaged and its informationbecomes lost or unavailable.The DRNS recorder is also used to store the currentchange request per recipe, to delete a change request,and to return the set of change requests for one or morerecipes. The attribute LockedRecipes provides a list ofidentifiers for recipes with change requests.The DRNS manager shall use the services of a DRNSrecorder when one is attached to the namespace by aservice user. However, use (attachment) of a recorder isoptional for the user. The DRNS recorder is providedfor remote storage of critical information and is notintended as a general source of information for the user.It is not able to provide inactive change requestinformation. Figure 5.5Distributed Recipe Namespace 5.6 Distributed Recipe Namespace ManagementInformation  The DRNS management informationobject is private and proprietary to the DRNS manager.It is included in Figure 5.2 as an emphasis on theimportance of the information that a DRNS managerrequires for management. This includes, but is notlimited to, the recipe identifiers stored in each attachedsegment and all existing change request records.The DRNS manager is required to know the contents ofall of its attached segments at all times. It shall be ableto uniquely identify each instance of a recipe within thedistributed recipe namespace. It is responsible fortracking the current status of each instance of a logicalrecipe within the distributed recipe namespace when achange to a recipe within one segment is being updatedto other segments. The DRNS management informationis important for these purposes. 5.7 Distributed Recipe Namespace  The distributedrecipe namespace has three additional attributes, as shown in Figure 5.5, that are read-only, set by theDRNS manager. The attribute Segments contains a listof the object specifiers of the DRNS segments currentlyattached. The attribute Recorder contains the objectspecifier of an assigned DRNS recorder. The attributeLockedRecipes contains a list of recipe identifiers ofrecipes with existing change request records.5.8 Distributed Recipe Namespace Manager  Thedistributed recipe namespace manager (Figure 5.6) isresponsible for ensuring that the distributed recipenamespace and DRNS segments operate together andfor maintaining namespace integrity as a whole. It isrequired to know the identities of its attached DRNSrecorder and DRNS segments and the contents (recipeidentifiers) of each attached DRNS segment at all times. Figure 5.6Distributed Recipe Namespace ManagerThe current attachments of the DRNS manager aremaintained in the DRNS namespace attributes Recorderand Segments and through the services of the DRNSrecorder described in Section 5.5. Whenever a DRNSsegment is attached, the DRNS manager shall add thesegment specifier to the namespace attribute Segmentsand to the current list maintained by the DRNSrecorder. Whenever a DRNS segment is detached, theDRNS manager shall remove its specifier from theSegments attribute and from the DRNS recorder's list.The DRNS manager is able to know which recipes arestored in each DRNS segment through use of ObjectServices provided for or by the individual DRNSsegments. It shall maintain the integrity of thenamespace through ensuring that an identifier of anyrecipe stored within the namespace represents exactlyone logical recipe. This is achievable because themanager must give explicit approval of any change oflogical recipes (generic attributes or body) stored by theDRNS segments.

&lt;!-- Page 18 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200437 Figure 5.7Change Request Record 5.8.1 Change Management  A change request occurswhenever a user or an attached segment requests thedistributed recipe namespace manager to make, orpermit, a specific type of change. A change requestrecord (Figure 5.7) contains information about whorequested what type of change. This allows laterdiagnostics when necessary.A change request record is created for a recipewhenever an attached DRNS segment requests a changeand is deleted when the requested change has beencompleted or discarded. A change request is eitherinactive or active. Once a change request is made, it isconsidered as inactive until the change has beenapproved by the DRNS manager. Once approved, it isconsidered as active.The change request record is not a standardized objectand is not accessed directly through public services.However, the information represented by the changerequest record shall be available, upon request, fromthe DRNS manager for all inactive and active changerequests. For this reason, it is convenient to model thechange request record as an object.A recipe for which a change request exists is calledlocked. Otherwise, it is unlocked.The DRNS manager is responsible for ensuring thatonly one change request per recipe is active at anytime. The results of each approved change request shallbe updated appropriately to each of the other DRNSsegments with a copy of the same logical recipe beforea subsequent change to the recipe is approved. 5.9 Building a Distributed Recipe Namespace  Adistributed recipe namespace is built up in severalstages. The distributed recipe namespace and itsassociated DRNS manager are created separately in thefirst stage. The individual DRNS segments are firstcreated and then attached to the DRNS manager. At least one DRNS segment must be attached to the DRNSmanager before it can accept recipes, as the distributedrecipe namespace has no other means of storage. Figure5.8 illustrates the attachment relationship. Figure 5.8The Attachment RelationshipThe attached DRNS segments may later be detachedfrom the namespace and then either attached again tothe same namespace or to a different namespacewithout affecting the recipes stored within the DRNSsegment.NOTE: When a DRNS segment with existing recipes isdetached and then attached to a different namespace, itsrecipe identifiers fall within the domain of the newnamespace. This may require some recipes to berenamed before the attach process is complete. 5.10 Rebuilding a Damaged Distributed RecipeNamespace  A distributed recipe namespace, or itsmanager, may become damaged or unavailable. If aDRNS recorder was attached to the damaged name-space, then rebuilding the namespace can be automated.A new distributed recipe namespace and new DRNSmanager are created, assigning the old namespacename as the object identifier ObjID for the newnamespace. The new DRNS manager should beassigned a different identifier, however, as a securitymeasure. The user may then request the new DRNSmanager to rebuild the namespace with the old DRNSrecorder. A namespace may also be rebuilt without arecorder if the list of segment specifiers can beprovided by the user. However, the user is not expectedto provide the information retained through changerequest records. 5.11 Object Attribute Definition Tables  This sectioncontains the formal attribute definitions for thedistributed recipe namespace capability. Except for theobject identifier attributes, attributes are listedalphabetically. DRNSManager DRNSSegment DRNSRecorder is attached to is attached to

&lt;!-- Page 19 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 38 Objects that are subtypes of objects introduced in Section 4 inherit the attributes of the supertype objects. Theseattributes are not repeated in this section. 5.11.1 Distributed Recipe Namespace Segment Attribute Definition  Table 5.1 defines the attributes required for adistributed recipe namespace segment, and Table 5.2 defines the attributes of the subtype master segment.Table 5.1 Distributed Recipe Namespace Segment Attribute DefinitionAttribute Name Description Access Rqmt FormObjType The object type. RO Y Text = RNSDSegmentObjID The object name (identifier). RO Y Text.Namespace The name (ObjID) of the namespace to which thesegment belongs. May be set by the manager.RO Y Text. NamespaceManager Identifies the distributed recipe namespace manager.May be set by the manager.RO Y Text. RecipeReadOnlyLevel Used to track the corresponding attribute of thenamespace to which the segment belongs. May be setby the manager. RO Y Unsigned integer. Table 5.2 Distributed Recipe Namespace Master Segment Attribute DefinitionAttribute Name Description Access Rqmt FormObjType The object type. RO Y Text = RNSDMasterObjID The object name (identifier). RO Y Text. 5.11.2 Distributed Recipe Namespace Recorder Attribute Definition  Table 5.3 defines the attributes required fora distributed recipe namespace recorder.Table 5.3 Distributed Recipe Namespace Recorder Attribute DefinitionAttribute Name Description Access Rqmt FormObjType The object type. RO Y Text = RNSDRecorderObjID Text. RO Y Text.LockedRecipes List of identifiers of recipes with existing changerequest records.RO Y List of formatted text. Namespace Identifies the namespace to which the recorder isattached. May be set by the manager.RO Y Text. NamespaceManager Identifies the distributed recipe namespace manager.May be set by the manager.RO Y Text. Segments List of specifiers of currently attached segments. RO Y List of formatted text. 5.11.3 Distributed Recipe Namespace Attribute Definition  Table 5.4 defines the attributes required for adistributed recipe namespace.Table 5.4 Distributed Recipe Namespace Attribute DefinitionAttribute Name Description Access Rqmt FormObjType The object type. RO Y Text = RNSDObjID Text. RO Y Text.LockedRecipes A list of identifiers of all recipes with existing changerequest records.RO Y List of formatted text. Recorder The recorder specifier of the attached distributedrecipe namespace recorder.RO Y Text. Segments A list of specifiers of the distributed namespacesegments attached to the namespace.RO Y List of formatted text.

&lt;!-- Page 20 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200439 5.11.4 Distributed Recipe Namespace Manager Attribute Definition  Table 5.5 defines the attributes required fora distributed recipe namespace manager.Table 5.5 Distributed Recipe Namespace Manager Attribute DefinitionAttribute Name Definition Access Rqmt FormObjType The object type. RO Y Text = RNS\_MgrDObjID The managers name. RO Y Text. 6 Recipe ExecutorThis section describes the basic concepts for the recipe executor and the execution recipe that it stores.The recipe executor is the component of an executing agent that reads and comprehends the contents of a recipe (itsbody) and puts into effect its instructions, settings, and/or other data. The object model of the recipe executor isshown in Figure 6.1. Figure 6.1Recipe ExecutorThe recipe executor is able to temporarily store recipes for execution purposes, and it may also be able to storeexecution recipes for later execution.The execution process is beyond the scope of RMS. 6.1 Motivations  Specification of the recipe executor and the execution recipe that it stores is necessary tocomplete the management of recipes in the factory. The recipe executor provides limited storage for recipes andminimum capability to manage them. The storage provided is intended to be temporary only.Some recipe executors have the ability to purposefully change a recipe's body or create new recipes. To ensure thatexecution recipes remain synchronized with the managed recipes in a recipe namespace, additional rules arerequired for such cases.The requirements for RMS that are addressed by the recipe executor include the following:  The ability to create, edit, and change recipes outside the executing agents that execute them, The ability for executing agents to use recipes developed externally, The ability to share recipes among equipment of the same type, Protection of stored execution recipes and of currently selected recipes from unexpected or unauthorizedchange,

&lt;!-- Page 21 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 40  Execution of recipes without errors, includingerrors detected during verification and validationerrors caused by improper settings or parametersor incompatibility with the current configuration, The ability to change a recipe's parametersbetween runs in a systematic way without changingthe recipe itself, The ability to dynamically connect and disconnectthe executing agent from the communicationsenvironment, and The ability of standalone equipment to executerecipes without a communications link.6.2 Description  The recipe executor is able toreceive a downloaded execution recipe and temporarilystore it. The executor can verify the recipe body(Section 11.2.2) both at the time of the download andafter the recipe has been stored. It is able to store atleast as many recipes as it requires for a single processcycle, which is determined by its own requirements.Recipes stored by the recipe executor may bedownloaded from more than one namespace. Toprevent ambiguity or conflict between recipe identifiersfrom different namespaces, the name of the namespacefrom which the recipe was originally downloaded isretained in the identifier of the execution recipe.The recipe executor selects one or more specifiedrecipes by validating them and preparing them forexecution. This may include moving the recipes into aseparate recipe execution area to create an executablecopy recipe. The executable copy recipe, if it existsseparately, shall be protected from inadvertent changecaused by other activities, such as downloading a newrecipe. The executable copy recipe is not otherwiseaddressed by RMS. If a separate copy is selected, thestored execution recipe shall be protected from change.Protection from change and permission to change arediscussed in Section 6.6.Validation of a recipe consists of checking the values ofits settings and variable parameters against existingsupplier-defined and/or user-defined restrictions, andensuring the recipe, or the linked recipe set, is valid forthe current configuration of the executor (e.g.equipment or attached module).Additionally, the recipe executor is able to calculate theamount of available storage, to delete recipes from itsstorage to make room for new recipes, to de-selectrecipes by preventing them from being re-executedwithout another explicit select, to rename an executionrecipe, and to provide requested information about itself and its stored execution recipes, in conformancewith OSS. 8 The recipe executor may wish to rewrite source formrecipes into a proprietary derived object form that ismore efficient for execution or storage purposes. Wherethis type of recipe is to be stored for re-use, a newidentifier is required for the object form, as described inSection 3.2.2.1.2. Derived object form recipes arediscussed in detail in Section 11.2.2.1. 6.3 The Execution Recipe  An execution recipe is atype of recipe, as shown in Section 3, Figure 3.5. Therecipe executor stores recipes as execution recipes.Execution recipes are created in one of two ways: theyare either downloaded from a recipe namespace, orthey are created by the recipe executor.6.3.1 Comparison of Managed and Execution Recipes An execution recipe differs from a managed recipein two ways: its attributes and its lack of agent-specificdatasets.The differences in attributes between a managed recipeand an execution recipe consist of:  The addition of Namespace as an identificationattribute of the execution recipe, The intermediate parameters, ExtRef andParameters, of a verified managed recipe, requiredfor the namespace link operation, are not used bythe recipe executor and are not retained in theexecution recipe, The attributes LinkParam and AgentSpecLinkParam of the managed recipe are merged intothe single attribute ExecLinkParam, The attributes of the remaining agent-specificdataset are absorbed into the attributes of theexecution recipe, and The addition of the attribute length ExecAttrLengthand attribute timestamp ExecAttrChgTimeattributes, and The additional attribute ChangedBody, which isrequired for execution recipes where the recipeexecutor is capable of changing the recipe body orof creating new recipes and is not otherwise used.The conversion of a managed recipe to and from anexecution recipe is the responsibility of the namespacemanager and is discussed in Sections 9.4.8 and 9.4.9.Most of these differences are invisible for an unverifiedrecipe or minimal recipe implementations. For an 8 SEMI E39 (Object Services Standard)

&lt;!-- Page 22 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200441 unverified recipe, all of the above attributes are clearedto their default value and are not transferred with therecipe. Attributes needed for multi-part recipes andvariable parameters are not required for minimalimplementations. Figure 6.2 provides a model of theminimal implementation of an execution recipe to meetRMS requirements. Figure 6.2Object Model for Minimal Execution Recipe6.3.2 Downloaded Recipes  To download a recipefrom a namespace, the namespace manager isresponsible for first converting the attributes of thespecified managed recipe into those of the executionrecipe. The recipe executor stores the downloadedrecipe as an execution recipe. The body of the recipe isunchanged by the download operation and may be insource form or object form, including the derived objectform. (See Section 11.2.2.1.)The namespace manager may optionally request thatthe recipe being downloaded replace any pre-existingrecipe with the same identifier. Otherwise, if such arecipe exists, the download request is denied.Upon request, the recipe executor shall verify a recipethat it has previously stored and return to the requestorthe information required for recipe management.Attributes of the execution recipe that have the sameattribute name as either a generic attribute or an agent-specific attribute of the managed recipe are not changedexcept in specific cases.The attributes giving the timestamp and length of theattributes of the execution recipe are different fromthose of the managed recipe. This allows the genericand body descriptors of a managed recipe to becompared with the corresponding attributes of anexecution recipe for traceability. The timestamp of theexecution recipe's attributes is ExecChgTime, and thelength of its attributes is ExecAttrLength. These arecalculated by the recipe executor at the time the execution recipe is stored and updated whenever otherattributes of the recipe change. 6.3.3 Execution Recipe Identifier  The identifier ofan execution recipe, in addition to the recipe name,class, and version of the managed recipe, also containsthe name of the originating namespace. Theoriginating namespace is the namespace from whichthe recipe was originally downloaded. For recipesnewly created within the storage of the recipe executor,this is the namespace to which the recipe will beuploaded.The full identifier of an execution recipe is identical tothat used within recipes to indicate the recipe is externalto that of the referencing recipe (see Section 3.2.4.1.1)and has the form:Namespace Name&gt;/CLASS/.../CLASS/name; version. 6.3.4 Execution Recipe Descriptor  The descriptorsof the execution recipe consist of the execution attributedescriptor (ExecAttrLength and Exec-AttrChgTime),the generic attribute descriptor (AttrLength andAttrChgTime), and the body descriptor (BodyLengthand EditTime). The execution recipe descriptorconsists of the execution attribute descriptor, thegeneric attribute descriptor, and the body descriptor, inthat order.6.3.5 Execution Recipe Attribute Definitions  Table6.1 provides the formal definition of the attributes ofthe execution recipe. Attributes in Table 6.1 areclassified as identification attributes, mandatory andother required attributes, optional attributes, and non-standard attributes. Identification attributes are not usedin RMS services as recipe attributes and are usedsolely to specify one or more execution recipes.Support for all required attributes is necessary for RMScompliance. Support for the remaining attributes is notrequired.The execution recipes attribute length and timestampattributes are transferred first when a recipe attributesection (Section 14.1) is uploaded.Attributes that are described as preserved aremaintained without change from a downloaded recipe.For recipes that are first created by the recipe executor,such as hardware-specific recipes, they are set to theirappropriate values. Default values have been added forattributes that cannot be determined.Attributes in Table 6.1 are presented in the followingorder:  Identification attributes, including object type andidentifier, the first six listed in the table,

&lt;!-- Page 23 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 42  Mandatory attributes and the other requiredattributes, in the order in which they are to appearwhen a recipe is transferred. Optional attributes in alphabetical order, and  Non-standard attributes, transferred last.Default values for non-mandatory attributes are shownin the last column. Null values (indicated by NULL)are dependent upon the particular form (see Section3.2.5). Table 6.1 Execution Recipe Attribute Definition Attribute Name Definition Access Rqmt Form Default ValueIdentification AttributesObjType The object type. RO Y Text: ERcp ERcpObjID An identifier derived fromNamespace, Class, Name, andVersion RO Y Formatted text. - Namespace The name of the originatingnamespace.RO Y Text. NULL Name A logical name assigned by the userwhen the recipe is created.RO Y Text. - Class The recipes class(e.g., /PROCESS/ or/PROCESS/LOADER/). RO Y Formatted text:CLASS/CLASS/../CLASS/ - Version The version of the recipe. RO Y Text. -Mandatory AttributesExecAttrLength The length attribute for the attributesof the execution recipe. Calculatedwhen the recipe is downloaded andwhenever an attribute changes. RO Y List of formatted text. - ExecChgTime The timestamp of a change to theattributes of the execution recipe.RO Y Formatted text,timestamp format.- AttrLength Preserved. RO Y Unsigned integer. 0AttrChgTime Preserved. RO Y Formatted text. NULLRequired AttributesBodyLength Preserved unless recipe is modified.Length of the recipes body, inbytes. RO Y Unsigned integer. - EditTime Preserved unless recipe is modified.Timestamp of when the body wascreated or modified. RO Y Formatted text.Timestamp format.- BodyFormat Indicates the form and format of therecipes body.RO Y Enumerated unsignedinteger:0 = source,1 = object,&gt; 1 reserved. 0 Verified Indicates whether the recipes bodyis syntactically correct.RO Y Boolean. FALSE Linked Indicates whether the recipe islinked.RO Y Boolean. FALSE ChangedBody Set to TRUE if the recipe body haschanged without a subsequentupload to the originating namespace.NOTE: This attribute is neveruploaded to a namespace. Requiredonly if recipe can be changed orcreated. RO Y Boolean. FALSE

&lt;!-- Page 24 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200443 Attribute Name Definition Access Rqmt Form Default ValueExecChgCtrl Preserved. Specifies change controlrequirements for recipe.RO Y Binary.Bitwise (MSB=8):1 - The recipe bodymay be changed,2  Changenotification required,4 - Recipe may beselected after change,8 - Most recentparameter setting shallbe saved. 0 Optional AttributesAgentSpecComments Copied from the original agent-specific attribute when downloaded.Set by the user. RO N Text. Maximumlength is 80characters. - ApprovalLevel Indicates the level of approvalassigned by an authorized user.RW N Unsigned integer. 0 Certified Preserved from the agent-specificattribute as downloaded. May beused as control for production-worthy recipes. RO N Unsigned integer. 0 Comments User comments. Preserved from thegeneric attribute as downloaded.RO N Text. Maximumlength is 80characters. - EditedBy Preserved unless recipe is modified.The name of the person or executingagent who last modified the recipe. RO N Text. Maximumlength is 80characters. - EstRunTime The nominal or estimated execution(run) time of the recipe, in seconds.Used for scheduling purposes.Preserved from the generic attributeas downloaded. RO N Unsigned integer. 0 ExecLinkParam Preserved unless last value ischanged (Section 6.6.4). Containsthe list of parameter definitions,including any agent-specificmodifications. Required for variableparameter support. RO N Structure composed ofparameter name,initial value, andrestrictions. NULL LinkList Preserved. A complete list of recipespecifiers for a linked recipe set.Required for multipart recipesupport. RO N List of formatted text. NULL SrcRcpID For a derived object form recipe,contains the recipe identifier of theoriginal source form recipe.Required only for derived objectform recipes. RO N Formatted text. NULL VerificationID Identifier code used by the verifierof the recipe. May be used todetermine out-of-date formats thatneed to be reverified. RO N Text. Maximumlength is 40characters. NULL Non-Standard AttributesAgentSpec- UD \* Preserved from the original agent-specific attributes as downloaded.RO N Defined by supplier oruser. Text limited to80 characters. -

&lt;!-- Page 25 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 44 Attribute Name Definition Access Rqmt Form Default ValueUD \* Non-standard attribute defined bysupplier or user. Asterisk indicatesthe part of the attribute name that isprovided in this definition. Shall bepreserved exactly, except by theentity that defined it. RO N Varies with definition.Text form is limited to80 characters. - 6.4 Default Namespace  The default namespace is a dedicated centralized namespace (see Section 4.4) that isused for all agent-specific recipes. A recipe executor that uses agent-specific recipes, such as thermocouplecalibration tables, shall be provided with a namespace for such recipes. Equipment that may be operated in a stand-alone mode, and that requires agent-specific recipes, shall also provide a local namespace to be used for thispurpose. A single namespace shall be used to satisfy both requirements.The recipe executor shall provide a user-settable attribute DefaultNamespace that contains the name of the defaultnamespace. The default namespace shall be available on power-up for stand-alone operation. For executing agentsintended to operate only in a supervised configuration, such as cluster process modules, the default namespace maybe provided by the supervisor.A recipe in a default namespace is referenced within a recipe body by specifying a namespace named Default.This allows controlled specification by namespace role for hardware-specific recipes.6.5 Recipe Storage  Discussion of types of storage used by the recipe executor is provided to clarify terminology.Storage is generally assumed to consume space in some form, and the amount of space available for recipes isassumed to be finite, so that adding recipes reduces the amount of space available and deleting recipes increases theamount of space available. These assumptions are based on current technologies and are not requirements.The recipe executor may have one or more types of storage area for recipes, shown in Figure 6.3. The storage areaused for the current process cycle is called the recipe execution area. This is the minimum storage capacityrequired. Executable copy recipes in the recipe execution area may or may not be transformed for executionpurposes but shall retain the attributes of the execution recipe. The recipe execution area shall be protected from allinadvertent and unintentional change, including change resulting from transferring a recipe to or from a recipenamespace or from editing a recipe. Figure 6.3Object Model for Recipe ExecutorExtra storage area, for additional recipes that are notcurrently selected, when provided, is called theexecution recipe storage. A separate intermediate area for temporary storage ofunverified downloaded recipes may also be provided.This area is the verification area. The separation ofthis area provides protection for the executable copyrecipes and the execution recipes. Recipes that fail

&lt;!-- Page 26 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200445 verification, or that have been requested to be discardedwithout storage after verification, may be removed fromthis area more easily when it is separate.A recipe temporarily placed in a verification area shallbe immediately either discarded or else moved toexecution recipe storage following a successfulverification.The term stored recipes in this section refers to recipesin execution recipe storage.The storage areas of the recipe executor may or maynot be volatile. The verification area, recipe executionarea, and the execution recipe storage are not requiredto be physically separate, so long as recipes in eachlogical area are protected from change caused byactivities in the other areas. 6.6 Change Control  Storage provided by the recipeexecutor is intended as temporary, and only minimummanagement capability is required, such as the abilityto rename or delete recipes.Some recipe executors may choose to provideadditional capabilities, such as the ability to create newrecipes, to edit existing recipes, to build a compressedderived object form recipe, to modify existing recipesthrough the execution process itself, and/or to save thelast value used for variable parameter settings. Certainrestrictions apply to these activities. Each differentcapability provided for creating and changing recipesshall be explicitly documented by the supplier.In general, change is controlled by the user through theattribute ExecChgCtrl. ExecChgCtrl specified fourseparate types of control related to change, includingpermission to subsequently select or re-select a changedrecipe and a requirement that the originating recipe benotified of all protected changes to the recipe.The recipe executor is prohibited from setting theLinked attribute of any recipe to TRUE.The recipe executor is responsible for ensuring theuniqueness of the identifiers of the recipes that it stores.Detailed requirements governing the creation of newrecipes and the changes protected by ExecChgCtrl aredefined in Section 11.6.6.1 Recipe Creation  Certain recipe executors maybe able to create recipes. This capability is allowed tocover the hardware-dependent recipes and the provisionof editing services. Mechanisms for creating andchanging recipes are beyond the scope of RMS. Changenotification is required for all newly created recipes.6.6.2 Recipe Compression  A source form recipemay be compressed to obtain a derived object formrecipe, described in Section 3.2.2.1.2. This is not considered as a newly created recipe, as the source formand derived object form recipes achieve the identicalprocess results. For this reason, most of the attributes ofthe source form recipe, including the Linked andExecChgCtrl attributes, are passed to the derived objectform. A change notification requirement for the sourceform recipe extends to the derived object form as well,including notification when the derived object form isbuilt. Requirements for the derived object form recipeare defined in detail in Section 11.2.2.1.6.6.3 Changes to Stored Recipes  The recipeexecutors may be able to change an existing recipe bychanging its body. Certain hardware-dependent recipesmay sometimes be changed by, or as a result of, theexecution process itself. Recipes also may be changedthrough an editing activity, including interactiveteach and automated self-teach operations providedby some systems. Except where expressly grantedpermission to change an existing recipe through theExecChgCtrl attribute, the bodies of all recipes instorage shall be protected from change. This is not thesame as the write-protection of the namespace in thatexecution recipes may be deleted and renamed by anauthorized user and by the manager of the originatingnamespace.Depending upon the value of the ExecChgCtrl attributeof the recipe, permission to change the execution recipe(stored in the execution recipe storage) is granted ordenied in advance and allows case-by-case granularity.Unless explicitly granted permission, a changed recipemay not be subsequently selected or re-selected.Purposeful change during the execution process forhardware-dependent recipes is included in theExecChgCtrl attribute permission to change the recipebody. For example, furnaces may be able to update aprofile recipe during a normal process cycle. Recipeschanged purposefully by the execution process areassumed to represent the best, most up-to-date, andmost valid version of a hardware-dependent class ofrecipe. Suppliers of recipe executors with thiscapability shall provide complete documentation of theclass of recipe changed and the circumstances underwhich it is changed.The ExecChgCtrl attribute of a recipe may require thatthe originating namespace be notified of change.Change notification consists of a notification messagesent to the originating namespace that alerts thenamespace manager that a recipe has been changed ororiginated. Where change notification is requiredthrough ExecChgCtrl, the namespace manager isresponsible for subsequently uploading the recipe,assigning it a new identifier if necessary, and requestingthe renaming of the execution recipe as necessary toremain synchronized.

&lt;!-- Page 27 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 46 6.6.4 Last Value  Some recipe executors may alsowant to save the last value set by the user for eachvariable parameter and use it as the new initial value ofthat parameter when the same recipe is rerun.This is useful when internal conditions drift in aconsistent manner over time, the parameters areoccasionally modified to compensate for such drift, andthe last setting used is, therefore, a better default thanthe one specified in the recipe itself.Permission to save the last value may be expresslygranted by the user in the recipe attribute ExecChgCtrl.Care should be taken to prevent unintentionalmodifications.6.7 Production  Equipment utilizations states aredefined by SEMI E10 (Standard for Definition andMeasurement of Equipment Reliability, Availability,and Maintainability (RAM)). These states include thePRODUCTIVE and STANDBY states used by thefactory for normal production work. The attributesProdApprove and ProdCertify are defined as requiredonly for equipment supporting states defined in thisdocument. To ensure that only recipes authorized for productionare executed while the executing agent is in thePRODUCTIVE state, or are selected while in theSTANDBY state, the authorized user may set thevalues of the attributes ProdApprove and/or ProdCertifyto non-zero values. Non-zero values in ProdApprove orProdCertify represent minimums for a recipe'sApprovalLevel and Certified attributes, respectively.The recipe executor is responsible for comparing thecorresponding recipe attributes ApprovalLevel andCertified. When a recipe is selected for execution(implicitly or explicitly) while either of thePRODUCTIVE or STANDBY states is active, thevalue of ApprovalLevel is required to be equal to orgreater than the value in ProdApprove, and the value inCertified is required to be equal to or greater than thevalue in ProdCertify. Otherwise, the select shall fail.6.8 Recipe Executor Attributes  The recipe executoris owned by the agent that provides a recipe executionresource. The recipe executor in turn owns the recipesthat it has stored. It shall support Object Services for itsowned object types and for itself.Table 6.2 defines the attributes of the recipe executor inalphabetical order. Table 6.2 Recipe Executor Attribute DefinitionAttribute Name Definition Access Rqmt FormObjType The object type. RO Y Text = "RcpExec"ObjID Text. RO Y Text.DefaultNamespace The name of an executing agents namespaceused for all hardware-dependent and otheragent-specific recipes. RW Y Text. ProdApprove The minimum value of a recipes approvallevel accepted during productive and standbystates. Required for SEMI E10 support only. RW N Unsigned integer. ProdCertify The minimum value of a recipes certificationlevel accepted during productive and standbystates. Required for SEMI E10 support only. RW N Unsigned integer. RunCycleUnit The process unit on which the calculation of theestimated value of the recipe generic attributeEstRunTime is based. RO N Case-sensitive formatted textcomposed of a unit ofmeasure and an optionalnumeric suffix. Compliantwith SEMI E5, Section 9.RecipeSelectID A list of recipe identifiers for the currentlyselected recipes.RO Y List of formatted text. RecipeSelect-ParametersA list of all parameter definitions in effect forthe i th recipe identifier in RecipeSelectID. Themaximum value for i is determined by theequipment supplier as the maximum number ofrecipes which may be selected at the same time.Required if variable parameters are supported. RO N List of structures composedof parameter name, parametervalue, parameter restriction.

&lt;!-- Page 28 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200447 7 AgentsThis section describes the agent and resources as they are used in Recipe Management. The concept of agent isintroduced to cover the different types of RMS implementations and to provide a context for the other specificobject types introduced in RMS. 7.1 Definitions  A resource is an owned entity that has an active role in factory operations. A factory has manydifferent kinds of resources. Some resources, such as valves, may be primarily physical. A software application is atype of resource not generally considered as physical. The factory itself is a resource for the corporation.An agent is a system in a factory  a type of resource that includes both hardware and software components, atleast some of which are also resources. Intelligent equipment that provides recipe namespace capability, forexample, would be an agent with a recipe namespace resource, as well as a computer platform, operating system,and electro-mechanical components, some or all of which represent other types of resources. An agent may be acomponent of another agent, and it may also contain other agents as components. For example, a cluster module is acomponent of a cluster and may itself contain intelligent subsystems as components.Agents may, in some cases, share certain resources with other agents. An example is a docking station that connectstwo clusters.Services defined by RMS may be provided at various levels within the factory. The generic term agent may beapplied at any of these levels as appropriate. Typical agents that use and provide Recipe Management servicesinclude equipment, clusters, cluster modules, cells, and independent recipe namespace servers9 . The term agentapplies equally well to each of these.A service resource is a set of services within a particular area of specialization. Service resources of interest toRMS are the recipe namespace resource, the recipe execution resource, and the Object Services Resource. Theservice resource object, illustrated in Figure 7.1, allows a group of message services defined by a service standard(such as RMS) to be represented by a single object, one of the subtypes of the service resource. However, thisconcept is introduced for clarification only. The service resource object is not a standardized object. Figure 7.1Examples of Service Resource Subtypes An agent is introduced as a standardized object that provides one or more service resources. Figure 7.1 shows anexample of an agent composed of different service resources. Also, an agent may supervise subordinate agents orbe supervised by a superior agent, each of which in turn will possess their own service resources. 9 A recipe namespace server is an agent whose primary function is to provide recipe namespace capabilities.

&lt;!-- Page 29 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 48 Agents interact with one another collaboratively and/orhierarchically, through the service resources that theyprovide, to perform work in the factory. 7.2 RMS Resources  The service resources definedby RMS are the recipe namespace resource and therecipe execution resource.A recipe namespace resource consists of the set ofmessage services defined in Section 12, correspondingto the namespace operations defined in Sections 8 and9. All services required for operations designated asrequired are fundamental and shall be provided for anRMS-compliant recipe namespace resource.A recipe execution resource consists of the set ofmessages defined in Section 14 corresponding to therecipe executor operations defined in Section 11. Allservices required for operations designated as requiredare fundamental and shall be provided for an RMS-compliant recipe execution resource. 7.3 Agent Attributes  Table 7.1 defines the publicattributes of agents that are required for recipemanagement.Table 7.1 Agent Attribute DefinitionAttributeName Definition Access Reqt FormObjType Agent objecttype.RO Y Text:AgentObjID The agent'sname, assignedby anauthorizeduser. RO Y Text. 8 Recipe Management OperationsThere are two important kinds of operations involvingrecipes within a namespace. Those that change arecipe's attributes or body are called recipemanagement operations. Those that affect the set ofrecipe identifiers within a namespace are part of recipenamespace management operations. A few operationsqualify as both recipe management and namespacemanagement and are discussed in their different aspectsunder both topics.A third type of operation is informational only andrequires reading but not changing recipe attributes.Operations of this type that require knowledge of theattributes of the namespace or of more than one recipeare discussed in Section 9.This section describes recipe management operations.Requests for recipe operations are always directed tothe namespace where the recipe is stored. Recipemanagement operations are delegated by the namespace manager to the namespace segment, which isconsidered as the recipe manager. This is invisible fora centralized namespace and explicit for a distributedrecipe namespace.Operations may be invoked by the operator or throughnamespace services defined in Section 12. In manycases, service scenarios consist of a single messagerequest from the service user and a correspondingresponse from the namespace manager. This case isillustrated in Section 12.2, Figure 12.1. Operationsrequiring additional messages are discussed in Section8.2.The service user is responsible for proper authorizationof the user prior to requesting an operation that isrestricted to authorized users through RMS services. 8.1 Recipe Lifecycle  A typical production recipegoes through various stages in its development within anamespace. These stages are shown below in a typicalorder through their associated operations. The attributesconcerning the body are provided by the initiator of theoperation.create  The create operation enters a recipe bodyinto the namespace.Editing is expected, but not required, to be performedoutside the namespace. Where provided by themanager, the same requirements concerning creating orupdating a recipe are to be followed.update  A recipe is updated when a body (typically,a modification of the original body) is entered into thenamespace to replace the body of an existing recipe thatis not write-protected. The attributes concerning thebody are provided by the initiator of the operation.verify  The verify operation is used to build a recipe.Checks for semantic correctness may also be performedat this time but are not required. The recipe body is readand checked for syntactical correctness, and all externalreferences and variable parameter definitions arecollected. The verification operation may be delegatedto a recipe executor, which returns the requiredinformation.write-protect  At some point during its development,an authorized user needs to be able to prevent theaccidental deletion or modification of a recipe andrequests to have it be write-protected. A write-protected (read-only) recipe may not be updated,renamed, deleted, unlinked, or relinked.link  The link operation is used to signify that therecipe is ready for execution. If the recipe has externalreferences, linking also builds a linked recipe set bycollecting the external references and variableparameter definitions and saving them for quick access

&lt;!-- Page 30 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200449 in the main recipe's attributes. Linking resolves allidentifiers explicitly for recipes that are within thenamespace.unlink  At times it may be desirable to undo the linkoperation. The unlink operation clears those attributesset by the last link operation. A write-protected recipemay not be unlinked.approve  The factory uses the recipe's approval levelto indicate the level of its authorization. For example,approval levels of 1, 2, and 3 may indicate write-protected, authorized for engineering, andauthorized for production, respectively.modify variable parameters  The variableparameter definitions of a linked recipe may beadjusted for a specific executing agent to achieve thedesired result. For example, a generic parameter fortime may be incremented repeatedly for a specificfurnace until it goes out of range, which indicates that itneeds to be cleaned. If the recipe did not previouslyhave an agent-specific dataset for this agent, thisoperation causes one to be created.certify  An authorized user (typically by the processengineer who developed the recipe) assigns it acertification-level to indicate that it achieves thedesired result on a specific executing agent. The factorymay require certain certification levels for production.de-certify  the certification level of the recipe is resetto zero.unprotect  Before a recipe can be updated, deleted,renamed, re-linked, or unlinked, the recipe must beunprotected.delete  Deleting a recipe causes it to be removedfrom the namespace. 8.2 Description of Operations  Operations thatrequire additional messages are of two types:operations that may be performed on more than onerecipe (such as certify recipe) and operations that mayrequire interactions with a recipe executor to complete(verify recipe). The scenario for verify recipe is shownin Section 9.4.7.The remaining operations that require additionalmessages are invoked with the namespace serviceRMNAction, where multiple recipes are specified forthe operation. Operations such as these may requiremore time to complete. The initial response to themessage service request only indicates the intent toperform the operation. In this case, the scenario isillustrated by Figure 8.1 and Figure 12.2, Section 12.2.The namespace manager performs the operation foreach recipe, in the order specified, and upon thecompletion of each operation, sends the notification message RMNComplete with the results for thatoperation. (See Sections 12.15 and 12.17 for additionaldetails.) Figure 8.1Message Flow with Completion NotificationRecipe management operations are categorized intothree types: recipe origination, recipe building, andrecipe authorization.Recipe origination includes those operations thatcreate or modify an entire recipe. Recipe buildingincludes the verification, link, unlink, and modifyvariable parameter operations. Recipe authorizationincludes the write-protect, unprotect, approve, andcertify operations.Except for those operations that only provideinformation, recipe management operations change thestate of the recipe. Section 8.3 contains the completestate model, and a table of transitions is given in Table3.1. Substates of this model are provided for illustrationin sections defining the operations that affect thesesubstates. 8.2.1 General Requirements  The generic length andtimestamp attributes AttrLength and AttrChgTime shallbe updated whenever any other generic attributechanges value.An agent-specific dataset for a specific agent existsonly when a non-required attribute is given a non-default value, such as whenever a recipe is certified fora given agent. If the non-required attributes are allcleared, the agent-specific dataset is removed and nolonger exists. Otherwise, the agent-specific length andtimestamp attributes for an agent-specific dataset shallbe updated whenever one of its attributes changesvalue. 8.2.2 Recipe Origination  A recipe may be originatedby the create recipe operation and by the copy recipeoperation. The copy recipe operation creates a duplicateof an original recipe and assigns it a new identifier. All

&lt;!-- Page 31 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 50 of the attributes of the original are copied directly.These operations are included in NamespaceManagement in Section 9.4.1.8.2.2.1 Create Recipe  A recipe is created when arecipe body is first entered into a namespace andassigned a new identifier. The recipe's mandatoryattributes are set. All other attributes take on theirdefault values. The values for the attributesBodyLength, EditTime, and EditedBy are required to beprovided by the initiator of the create operation. Theattribute BodyFormat is also provided at this time if it isnot in source form (i.e., if BodyFormat has a non-default value).A newly created recipe has an active state model(Figure 8.7). The recipe is in the UNVERIFIED,UNLINKED, UNAPPROVED, UNPROTECTED, andUNCERTIFIED states.The create recipe operation is invoked with theRMNCreate service. 8.2.2.2 Update Recipe  The update operation isidentical to that of create except that an unprotectedrecipe with the specified identifier already exists, andthe new body replaces the existing body. Attributesconcerning the body are provided by the initiator of therequest, as for the create operation. All non-mandatoryattributes are cleared (reset to their default values).Any existing agent-specific datasets are discarded.The update recipe operation is invoked with theRMNUpdate service. 8.2.3 Recipe Building  Building a recipe is a two-stepprocess. First the recipe is verified and then linked.8.2.3.1 Verify Recipe  The verify operation is theonly time it is necessary to parse the contents of therecipe body until the recipe is executed. The primarypurpose of this process is to ensure that the syntacticaland lexical structure of the body is correct. One or morechecks for semantic correctness may also be performedas part of the verification operation, but this is notrequired.Actual verification is performed by a member agent'srecipe executor at the request of a namespacemanager. For this reason, this operation is alsodiscussed under namespace management in Section9.4.7.Recipes may be stored in a namespace in an incompleteor unfinished form. For recipes in source form, theverification procedure shall be performed only at therequest of the user. It shall not be performedautomatically. There are four attributes affected by the verificationoperation: Verified, EstRunTime, ExtRef, andParameters.The boolean generic attribute Verified is used toindicate the recipe's state with respect to this procedure.Verified is cleared when a recipe is first created andwhenever it is updated. Verified is set TRUE only whenthe recipe passes the verification by a recipe executor.A recipe is considered to be verified if, and only if, theVerified attribute is TRUE. Figure 8.2 illustrates therecipe's VERIFICATION state. For a description of thetransitions, see Table 8.1 in Section 8.3. Figure 8.2 Verification State ModelThe values for the attributes EstRunTime, ExtRef,Parameters, and VerificationID are returned (where set)by the recipe executor when the verification has beensuccessful. If the operation is unsuccessful, they shallbe cleared.ExtRef contains a list of all external references foundwithin the body of the recipe by the recipe executor.These references may be explicit or implicit, leavingthe class and/or version unspecified.The verify recipe operation is invoked with theRMNAction service. 8.2.3.2 Link Recipe  The link operation is a requiredoperation that may be requested at any time by theoperator or supervisor. Successful completion of thelink operation indicates that the recipe is ready forexecution. For single-part recipes without variableparameters, linking consists only of setting the generic

&lt;!-- Page 32 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200451 attribute Linked to TRUE. Figure 8.3 illustrates theLINKAGE state of the recipe. For a description of the transitions, see Table 8.1 in Section 8.3. Figure 8.3Link State ModelFor multi-part recipes, this operation also collectsexternal references and variable parameter definitionsinto the LinkList and LinkParam attributes, to be usedby the recipe executor at run-time.External references contained within multi-part recipesare not required to specify the class of the subrecipewhen the class is the same as that of the parent recipe.Where class is omitted in a recipe identifier in theExtRef attribute, the link operation is responsible foradding the class of the parent recipe in the identifieradded to the LinkList parameter, as the parent/childrelationship cannot be derived from the final contents ofLinkList.External references are assumed to refer to recipeswithin the same namespace and are not required to giveexplicit versions unless they specify a differentnamespace. This ensures that the user will be able tolink together the best choice subrecipes. The exactvalue of versions of such references is determined onlyat the time the main recipe is linked.The link operation is performed on a main recipe. Thatis, it only modifies attributes of the main recipe. Itresolves all external references within that recipe andwithin any of its subrecipes according to well-definedrules for determining default versions at the time of thelink. At the same time, variable parameter definitionsare collected. The resulting explicit references are placed in the LinkList attribute, variable parameterdefinitions are placed in LinkParam, the ApprovalLevelattribute is cleared, the Linked attribute is set to TRUE,and the main recipe is then said to be linked.Subrecipes are not affected by this operation.Subrecipes of a main recipe have no knowledge ofparents or of linkages. As a result, it is possible todelete or change a subrecipe with an unintendeddetrimental impact on a linked recipe set. Factorypolicy may designate certain levels of approval to meanthis recipe is used by (linked into) one or moreprotected recipes.For multi-part recipes, linking starts at the main recipeand works through all chains of referenced subrecipesto determine the complete set of identifiers that willcomprise the recipe as a whole. The link operation is amechanical procedure that may be performed at anytime.Successful linking implies that all referenced subrecipeshave been located and parsed for further referencesuntil all references are exhausted. The link operationshall fail when any recipe or subrecipe within thenamespace either is unverified or cannot be located.If the same parameter name is used to define aparameter in more than one recipe of a set of recipesthat are linked together, the name shall represent thesame parameter and have the same parameterdefinition in all recipes in the set, to avoid ambiguity.Parameters with the same parameter name anddiffering definitions shall cause, at a minimum, awarning to the user when the link operation completes.For purposes of comparison of results, the order ofreferences in LinkList and LinkParam at the completionof the link operation shall conform to the results whenthe following sequence is used:1. Copy the contents of ExtRef from the main recipe toLinkList, resolving class and version to each recipeidentifier as needed. For support of variableparameters, also copy the contents of Parameters toLinkParam. If ExtRef is empty, then LinkList is alsoempty and the parsing process is complete.2. If LinkList is not empty, begin with the firstreference in LinkList as the link target reference.3. If the link target reference lies within the samenamespace, resolve the class and version ifnecessary. (Note: the referenced recipe must bealready present within the namespace at the time thelink is performed, or else the link fails.) If the linktarget reference specifies a different namespace, goto Step (6)  the link operation of this chainterminates (without error) without an attempt tolocate the actual recipe or its ExtRef attribute. If the

&lt;!-- Page 33 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 52 recipe is located, then it is called the link targetrecipe.4. Determine the contents of the Verified attribute ofthe link target recipe. If Verified is FALSE, the linkoperation fails immediately.5. Determine the contents of the ExtRef attribute ofthe link target recipe. Remove any references thatduplicate those already contained in LinkList,resolve class and version as needed, and append theresult to LinkList. If variable parameters aresupported, also determine the contents ofParameters in the link target recipe, removeparameters already defined in LinkParam, andappend the result to LinkParam.6. Set the link target reference to the next reference inLinkList and repeat steps (3) through (6) until allreferences in LinkList have been processed.For recipes with no external references, the LinkListlist will be empty. Similarly, for recipes with novariable parameters, the LinkParam list will be empty.The effect of allowing incomplete recipe versions to bespecified within a recipe body, and determined onlywhen the main recipe is linked, means that a linkedrecipe set (the set of recipes linked together) producedon one occasion may not be the same as those producedon a different occasion. Therefore, it is necessary toprotect the contents of the LinkList attribute frominadvertent change.For this reason, the link operation cannot be performedon a read-only recipe with the Linked attribute alreadyset from a previous link. Any attempt to link an alreadylinked read-only recipe either shall be denied or a newcopy of that recipe shall be generated with a newidentifier, which may then be automatically approvedand linked.The link recipe operation is invoked with theRMNAction service. 8.2.3.3 Unlink Recipe  A linked recipe that is notwrite-protected may also be unlinked. The unlinkoperation clears the generic attributes Linked,LinkList, and LinkParam. If the recipe has agent-specific datasets, the attributes Certified and AgentSpecLinkParam are cleared. If no other non-required agent-specific attributes have a non-default value, the agent-specific dataset is removed.The unlink recipe operation is invoked with theRMNAction service. 8.2.3.4 Modify Variable Parameters  The recipeattributes Parameters, LinkParam, andAgentSpec\_LinkParam each consist of a list ofparameter definitions. Each parameter definitioncontains the parameter name, parameter initial value,and the parameter restriction (if any) specified for thatparameter by a formal definition within the recipebody.In order to tune a recipe so that it produces the sameresult on all executing agents of the same type, it maybe necessary to provide a different initial value or adifferent parameter restriction for one or moreparameters for individual executing agents. The agent-specific attribute AgentSpec\_LinkParam is used toprovide this capability.AgentSpec\_LinkParam is an optional agent-specificattribute that contains a list of alternate parameterdefinitions for one or more of the variable parametersincluded in the definitions in the generic attributeLinkParam of a linked recipe. A special editing facilitymay be provided to allow an authorized user to add,delete, or modify parameter definitions toAgentSpec\_LinkParam.Parameter definitions initially are added individually toAgentSpec\_LinkParam by copying the definition forthat parameter from LinkParam. The initial value orrestriction then may be modified by the user, subject tothe absolute restrictions, such as minima and maxima,imposed by the executing agent's supplier. The initialvalue may be changed to any value within theparameter domain.Any modification of the restriction shall cause thecertification level to be cleared in the Certifiedattribute. This is required because of the potentialimpact on fab operations of a change in the restriction.The UNITS in the restriction of a numeric parametermay be modified within constraints imposed by the useof the parameter and the executing agent's supplier. Forexample, a two-byte unsigned integer named WaitTimethat is used to set a variable time delay period maypermit units of either min (minutes) or s (seconds).It is desirable, but not required, that suppliers ofexecuting agents support different options forspecifications of UNITS. The possible options for eachpotential variable parameter shall be documented bythe supplier.

&lt;!-- Page 34 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200453 The modify variable parameter operation consists ofadding, deleting, or modifying a specific parameterdefinition to a list of definitions inAgentSpec\_LinkParam for a specific agent.A definition is added when it is copied directly fromthe LinkParam attribute to the AgentSpec\_LinkParam attribute without modification. A definitionshall only be added if there is currently no definition fora parameter with the same parameter name in theAgentSpec\_LinkParam attribute.A definition is deleted when it is completely removedfrom the list of definitions in AgentSpec\_LinkParam.A definition is modified when the value or restrictionof an existing definition is replaced inAgentSpec\_LinkParam.The modify variable parameters operation is invokedwith the RMNVarPar service. 8.2.4 Recipe Authorization  Recipe authorizationoperations include those that allow an authorized userto change the value in the generic attribute Approval-Level or the agent-specific attribute Certified.The de-certify operation is invoked with the serviceRMNAction. 8.2.4.1 Approve Recipe  Recipe managementprovides two different methods of controlling how arecipe is applied: through the generic attributeApprovalLevel and through the agent-specific attributeCertified. The recipe's approval level (the valuecontained in ApprovalLevel) is also used to protect itfrom change.A recipe goes through different stages during itslifecycle. After a recipe has been initially created, itwill typically go through a dynamic period while it istested and adjusted until it produces the desired results.ApprovalLevel is an unsigned integer used to designatethe different stages in a recipe's life cycle. It is set tozero (its default value) whenever a recipe is created,updated, or linked.The approval operation allows an authorized user toset ApprovalLevel to a non-zero value. Otherwise, itmay not be set externally.A recipe is said to be approved whenever Approval-Level is non-zero. An example of a factory'simplementation of approval levels is given in theappendix, Section 8.3. Figure 8.4 illustrates the recipe'sAPPROVAL state. For a description of the transitions,see Table 8.1 in Section 8.3. Figure 8.4Approval State Model A subrecipe may be approved independently from anyrecipes which reference it.A linked recipe may not be approved to a level higherthan the lowest approval level of any of its subrecipes.Therefore, all subrecipes referenced in the attributeLinkList of a linked recipe must be located prior togranting an approval level other than zero. TheApprovalLevel attribute of the subrecipes must beincreased to a value equal to, or greater than, therequired level by an authorized user before the higherapproval level of the linked recipe is accepted.The restriction on the approval level of the linkedrecipe requires the user to purposefully change theapproval level in order to protect the entire linkedrecipe set as a unit from unexpected change, as it is bythe main recipe identifier that the recipe as a whole willbe known. It should be noted that approval of a linkedrecipe is not the same as approval of the individualparts, as a subrecipe which is appropriate in one recipemay be inappropriate in another.The approve recipe operation is invoked with theRMNAction service. 8.2.4.2 Certify  The certify operation sets the valueof Certified for a specific executing agent to a non-zerovalue specified by an authorized user. This operationaffects no other attributes (except the length andtimestamp attributes of the affected agent-specificdataset).

&lt;!-- Page 35 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 54 A recipe may be syntactically and procedurally correctbut, due to the differences between differentinstallations of agents with access to a namespace, maygive different results on these different installations.Recipe certification signifies that a linked recipeproduces the desired results on a specific installation.A recipe is considered certified for agent if thecertification-level contained in the agent-specificattribute Certified is non-zero. Otherwise, the recipe isuncertified. A certified recipe is de-certified when thecertification-level is set to zero.A recipe may be certified and de-certified only by anauthorized user. Figure 8.6 illustrates the recipe'sCERTIFICATION states. For a description of thetransitions, see Table 8.1 in Section 8.3. Figure 8.6Certification State ModelRecipes with variable parameters may be certified forspecific values and restrictions of some of thesevariables. If so, such values are stored in theAgentSpec\_LinkParam attribute.Only recipes with the Linked attribute set to TRUEmay be certified.The certify recipe operation is invoked with theRMNAction service. 8.2.4.3 De-certify  The de-certify operation clearsthe Certified attribute for a specific agent at the requestof an authorized user. A recipe may need to be de-certified after majormaintenance has been performed and later re-certifiedonly after testing its results. 8.2.5 Recipe Protection  The namespace attributeRecipeReadOnlyLevel is used as a threshold to governthe level of approval required for individual recipes tobe protected. A recipe is protected when the value inits ApprovalLevel attribute is equal to, or greater than,RecipeReadOnlyLevel. All recipes are protectedwhenever the namespaces RecipeReadOnlyLevelattribute is equal to zero. Figure 8.5 illustrates therecipe's PROTECTION states. For a description of thetransitions, see Table 8.1 in Section 8.3. Figure 8.5Protection State Model If the value of RecipeReadOnlyLevel is n, then recipeswith approval levels greater than, or equal to, n areread-only. The body of a read-only recipe may not bechanged in any way, including by over-writing ordeleting. The identifier of a read-only recipe may not berenamed. A linked recipe that is read-only may not bere-linked.The recipe protect operation sets the value ofApprovalLevel to the value in RecipeReadOnlyLevel. For linked recipes with subrecipes, theoperation is denied if the resulting approval level forthe main recipe would be higher than any subrecipe, asdescribed in Section 8.2.4.

&lt;!-- Page 36 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200455 If the value in RecipeReadOnlyLevel is zero, all recipeswithin the namespace are automatically write-protected, regardless of the support for theApprovalLevel attribute.The protect recipe operation is invoked with theRMNAction service. 8.2.6 Unprotect  The read-only status of a recipemay be changed either by changing its approval level toa value less than the value of RecipeReadOnlyLevel orby increasing the value in RecipeReadOnlyLevel.NOTE: If RecipeReadOnlyLevel is zero, all recipes arewrite-protected regardless of the value in approval-level.A protected recipe may be changed to unprotected atthe request of an authorized user. This operation clearsthe ApprovalLevel attribute.The unprotect recipe operation is invoked with theRMNAction service. 8.2.7 Informational Operations  Object Services areused to request the current value of one or more recipeattributes and to set one or more values. Certainattributes have restricted access and may not be setthrough RMS services. These attributes are identifiedas RO (read-only) in Tables 3.1 and 3.2 in the columnlabeled Access in Section 3.4.2. When attributes identified as RW (read-write) are set through ObjectServices, the appropriate attribute length and timestampattributes shall be updated appropriately.In addition to Object Services, the get descriptorsoperation provides important information. 8.2.7.1 Get Recipe Descriptors  The get recipedescriptor operation returns the descriptor of aspecified recipe: the generic descriptor, the bodydescriptor, and the agent-specific descriptors of anyexisting agent-specific datasets.A recipe descriptor may be used to determine if two ormore recipes are identical or which is most recent.The get recipe descriptors operation is invoked with theRMNGetDescriptor service. 8.3 Recipe State Model  An existing recipe hasdifferent states of interest to RMS. These are shown inFigure 8.7. The Recipe Available State Model in Figure8.7 combines the separate models for VERIFICATION,APPROVAL, PROTECTION, LINKAGE, andCERTIFICATION as AND substates of RECIPEAVAILABLE. Figure 8.7Recipe Available State Model These states have been discussed in previous sections and are associated with one or more of the recipe's attributes,as follows:VERICATION: Verified,APPROVAL: ApprovalLevel,

&lt;!-- Page 37 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 56 PROTECTION: the interaction of ApprovalLevel and the namespace attribute RecipeReadOnlyLevel,LINKAGE: Linked, andCERTIFICATION: Certified.The table of transitions is given in Table 8.1.Table 8.1 Table of Transitions# Current State Trigger New State Action Comment1 (entry to RecipeAvailable)Recipe is created. Recipe Available. Initialize genericattributes.None. 2 (default entry toVERIFICATION)Recipe is created. UNVERIFIED Verified reset. Newly created recipe isunverified.3 UNVERIFIED Requested verificationoperation is successful.VERIFIED Set Verified toTRUE.Verification is performedby the recipe executor.4 VERIFIED Requested verificationoperation, on previouslyverified recipe, fails. UNVERIFIED Reset Verified. Verification is performedby the recipe executor. 5 VERIFIED Recipe is updated. UNVERIFIED Reset Verified. Updated recipe must be re-verified.6 (default entry toLINKAGE)Recipe is created. UNLINKED Reset Linked,LinkList, andLinkParam. Newly created recipe isunlinked. 7 UNLINKED Authorized user requestedlink operation is successful.LINKED Set Linked to TRUE.Set LinkList andLinkParam. Single-part recipes setLinked only. 8 LINKED Recipe is updated. UNLINKED Reset Linked,LinkList, andLinkParam. Single-part recipes setLinked only. 9 LINKED Recipe is re-verified. UNLINKED Reset Linked,LinkList, andLinkParam. Single-part recipes setLinked only. 10 LINKED Authorized user requests theunlink operation.UNLINKED Reset Linked,LinkList, andLinkParam. Single-part recipes setLinked only. 11 (default entry toPROTECTION)Recipe is created. If RecipeRead-OnlyLevel is zero,new state isPROTECTED.Otherwise, it isUNPROTECTED. None. All recipes are read onlywhenRecipeReadOnlyLevel iszero. 12 UNPROTECTED Authorized user request toprotect the recipe.PROTECTED Set ApprovalLevel tothe value inRecipeReadOnly-Level. Recipe is protected whenapproval level =RecipeReadOnlyLevel. 13 UNPROTECTED Authorized user setsRecipeReadOnlyLevel tovalue greater than or equalto approval level. PROTECTED None. Recipe is protected whenapproval level greater thanor equal toRecipeReadOnlyLevel.14 PROTECTED Authorized user setsapproval level to a value lessthan RecipeReadOnlyLevel. UNPROTECTED None. Recipe is unprotected whenapproval level less thanRecipeReadOnlyLevel.15 PROTECTED Authorized user setsRecipeReadOnlyLevel to aUNPROTECTED None. Recipe is unprotected whenapproval level less than

&lt;!-- Page 38 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200457 value greater than approvallevel.RecipeReadOnlyLevel. 16 (default entry toAPPROVAL)Recipe is created. UNAPPROVED ResetApprovalLevel.Newly created recipe isunapproved.17 UNAPPROVED Authorized user sets non-zero approval level.APPROVED Set ApprovalLevel asspecified by the user.User assigns approval levelto a specific value.18 APPROVED Authorized user setsapproval level to zero.UNAPPROVED ResetApprovalLevel.User assigns a zero value asapproval level.19 APPROVED Recipe is linked. UNAPPROVED ResetApprovalLevel.User is required tospecifically approve anewly linked recipe set.20 APPROVED Recipe is updated. UNAPPROVED ResetApprovalLevel.A modified recipe isunapproved.21 (default entry toCERTIFICATION)Recipe is created. UNCERTIFIED None. Newly created recipe hasno agent-specific attributes.22 UNCERTIFIED Authorized user assignednon-zero certification level.CERTIFIED Create agent-specificdataset if necessary.Set Certified tospecified value. User assigns certificationlevel. 23 CERTIFIED Authorized user assignedzero certification level.UNCERTIFIED Reset Certified. Agent-specific dataset notrequired if there are noagent-specific attributes.24 CERTIFIED Authorized user changesagent-specific variableparameter restrictions. UNCERTIFIED Reset Certified. A change in restrictionsaffects performance ofrecipe.25 CERTIFIED Recipe is unlinked. UNCERTIFIED Reset Certifiedattribute.Agent-specific dataset notrequired if there are noagent-specific attributes.26 RECIPEAVAILABLEAuthorized user deletesunprotected recipe.(Undefined recipeno longer exists.)Storage occupied byrecipe becomesavailable. None. 8.4 Table of Operations  Table 8.2 lists the recipe management operations in the order presented in this section.The column labelled Rqmt is used to indicate those operations that are required for fundamental compliance toRMS.Table 8.2 Recipe Management OperationsOperation Description Rqmtcreate recipe\* A new recipe body is entered into the namespace. Yupdate recipe\* The body of an existing recipe is replaced. Yverify recipe Check the syntax or format of a recipe body for correctness. Ylink recipe A main recipe is linked. Yunlink recipe An unprotected linked recipe is unlinked. Nmodify variable parameters A linked recipe's parameter definitions are modified within an agent-specific dataset. Napprove recipe Set the recipe's approval level to a non-zero value. Nprotect recipe Set the recipe's approval level to the value in RecipeReadOnlyLevel. Nunprotect recipe Set the recipe's approval level to zero. Ncertify recipe A linked recipe's certification level is set to a non-zero value. Ndecertify recipe A linked recipe's certification level is set to zero. Nget recipe descriptor A recipe's descriptor is requested. Y\*This operation is also covered under Namespace Management Operations.

&lt;!-- Page 39 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 58 9 Namespace Management OperationsNamespace management operations includeoperations that affect the namespace itself in some wayand those operations that provide information about thenamespace or its manager, or that require knowledgeabout more than one recipe.Namespace operations defined in RMS are presented ingroups of similar functionality:  operations on the namespace (create, delete, andrename namespace), operations that provide information about thenamespace or its recipes (get available storage,check recipe status, and get best version), and operations on recipes that affect the set of recipeidentifiers within the namespace and/or moving arecipe as a whole (create, delete, store, retrieve,copy, and rename recipe), operations that always require interactions with arecipe executor (verify, download, and uploadrecipe).Namespace management operations may be invokedthrough namespace services defined in Section 12. Inmost cases, service scenarios consist of a singlemessage request from the service user and acorresponding response from the namespace manager.This case is illustrated in Section 12.1.Scenarios are shown only for operations that requireadditional messages. These operations are one of twotypes: operations that may be performed on more thanone recipe (such as delete recipe) and operations thatrequire interactions with a recipe executor to complete.Operations such as these may require more time tocomplete. The initial response to the message servicerequest only indicates the intent to perform theoperation. The namespace manager informs the serviceuser of the completion of each individual operation bysending the notification message RMNComplete. (SeeSection 12.1 for more detail.) 9.1 Applications of Object Services  A manager shallcomply with SEMI E39 (Object Services Standard(OSS): Concepts, Behavior, and Services)specifications for fundamental requirements and withthe requirements for Filters and Owner Objects.9.1.1 Object Specifiers  The owns/owned byrelationship is used by OSS to define the objectspecifier used for scope. Recipes within a namespaceare owned by the namespace in which they reside. Thenamespace in turn is owned by its manager. The agentthat provides the storage and services for a centralizednamespace owns both the manager and the namespace. An object specifier has the form of:type1 : id 1&gt;typen : id n&gt;where typei and id i represent the object type andobject identifier, respectively, of the ith object instancein the sequence, and where each object is owned by thepreceding object in the sequence and is the owner of thesucceeding object.A namespace specifier is an object specifier applied tonamespaces. A recipe specifier is an object specifierapplied to recipes.Object types in the object specifier may be omittedwhere they may be otherwise determined. For therecipe specifier, when omitted, they are determined bytheir relative positions, with the recipe identifier in thefinal position, preceded by a namespace identifier.Additional identifiers preceding that of the namespaceare those of agents.An example of a namespace specifier for a namespaceNS-MOM owned by an agent Etch01 would beAgent:Etch01&gt;RNS:NS-MOM&gt; or (where objecttypes can be otherwise determined) Etch01&gt;NS-MOM. A recipe specifier for recipe /PROCESS/ABC;5 stored in NS-MOM would be Agent:Etch01&gt;RNS:NS-MOM&gt;/PROCESS/ABC;5&gt;.Where the manager is to be used instead of thenamespace, the object type of the manager must beincluded.A recipe in a namespace also owns its components. Anagent-specific attribute is accessed through the recipeowner. 9.1.2 Required Object Services  A manager shallsupport operations for Get Attributes and Set Attributesfor the attributes of the namespace, the recipes withinthe namespace, and the manager itself. For a sharednamespace, access to different agent-specific datasetsshall be supported.When a recipes attributes are changed through the SetAttributes operation, the appropriate attribute timestampand length attributes shall be updated as well.A manager shall support the Get Type and GetAttribute Name operations for the object types ofnamespace, recipe, recipe components, and manager. 9.2 Namespace Operations  This section describesoperations that are performed on a namespace.9.2.1 Create Namespace  The create namespaceoperation is used to define a namespace and assign aname to be used as its identifier ObjID. The name isassigned only by an authorized user, except that a name

&lt;!-- Page 40 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200459 of Default is prohibited. Once created, thenamespace shall be ready to accept recipes.This is an optional capability that is not required if theowner agent that provides the namespace capabilitiesalso provides an installed default namespace (seeSection 6) that cannot be deleted. In this case, a meansof recreating the namespace shall be provided in theevent the namespace becomes damaged.The create namespace operation is invoked with themessage service RMNCreateNS. 9.2.2 Delete Namespace  The delete namespaceoperation is the inverse of the create namespaceoperation. A namespace that is not empty may not bedeleted. It is recommended that the default namespaceof a recipe executor should not be deleted. This is anoptional capability required only if the createnamespace operation is supported.The delete namespace operation is invoked by themessage service RMNDeleteNS. 9.2.3 Rename Namespace  The rename namespaceoperation allows an authorized user to change theidentifier of the namespace. It is recommended that thedefault namespace of a recipe executor should not berenamed. This is an optional capability required only ifthe create namespace operation is supported.The rename namespace is invoked by the messageservice RMNRenameNS. 9.3 Namespace Informational Operations9.3.1 Get Available Storage  The get availablestorage operation is used to determine the size of theremaining recipe storage capacity, in bytes. The valuereturned shall exclude any overhead requirements forstorage of one generic recipe. That is, it shall beassumed that sufficient storage exists for a single recipewith a combined generic attribute length and bodylength less than or equal to the returned value, andignoring possible space requirements for additionalagent-specific datasets. This is a required operation.The get available storage operation is invoked by themessage service RMNSpaceInquire. 9.3.2 Check Recipe Status  The check recipe statusoperation checks a recipe identifier and returns thestatus for existence and read-only (PROTECTED orUNPROTECTED state). It also returns the nextavailable numeric version. This is a required operation.This operation may be used to determine if a givenrecipe identifier will be accepted prior to sending it tothe namespace and to obtain an available version if theoriginal identifier is used for a read-only recipe. The check recipe status operation is invoked by themessage service RMNRecStatInquire. 9.3.3 Get Best Version  The get best versionoperation checks for the best default version of a recipewith a specified class and name and for an optionalspecific member agent. If a member agent is specified,then in addition to the rules for selection of a defaultversion defined in Section 3.2.3.4.1, the version withthe highest certification level for that agent is selected.This is a required operation.The get best version operation is invoked by themessage service RMNVersionInquire. 9.4 Namespace Recipe Operations  This sectiondescribes the recipe operations that affect the set ofrecipe identifiers within the namespace and/or involvemoving an entire recipe.9.4.1 Create Recipe  A recipe is created through thecreate recipe operation when a namespace is sent arecipe with an identifier, body, body descriptor, and theattributes BodyFormat and EditedBy only. Thisoperation sets the attributes AttrLength andAttrChgTime and clears the remaining genericattributes.This capability allows a recipe body that has beencreated off-line to be stored in a namespace. It isrequired of any namespace intended for use other thanas a default namespace for hardware-specific recipesonly10.The create recipe operation is invoked by the messageservice RMNCreate. 9.4.2 Delete Recipe  The delete recipe operation hasthe effect of deleting a recipe from the namespace.Complete physical erasure of the recipe is not required,but the recipe is no longer considered to be stored in thenamespace, is no longer accessible, and the storagespace that it used is freed.A read-only recipe may not be deleted.The delete recipe operation is invoked by the messageservice RMNAction. More than one recipe may bespecified by the service user. Figure 9.1 illustrates theflow of messages in this case. The namespace managerresponds to the initial request with an intent to complybefore performing any deletions. As each deletion iscompleted, the manager notifies the service user of theresults using RMNComplete. 10 In the case of the default namespace dedicated to hardware-specific recipes, the recipes may always be created initially by therecipe executor and uploaded to namespace.

&lt;!-- Page 41 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 60 Figure 9.1Delete Recipe Scenario 9.4.3 Store Recipe  The store recipe operation isused to store a complete recipe, including its body,generic attributes, and one or more agent-specificdatasets, in a namespace. Note: methods of storingrecipes are not specified by RMS.Storage shall be denied if the specified recipe identifieris already used by an existing read-only recipe or ifthere is insufficient storage available for the recipe.Otherwise, the recipe shall be accepted into thenamespace.The store recipe operation is invoked by the messageservice RMNStore. 9.4.4 Retrieve Recipe  The retrieve recipe requestspecifies the identifier of a recipe. If the recipe existswithin the namespace, the namespace manager returnsthe requested recipe. Otherwise, it shall deny therequest. This is a required operation.It is also possible to retrieve a recipe's genericattributes set to a non-default value and/or one or more of its agent-specific datasets without retrieving itsbody.The retrieve recipe operation is invoked by the messageservice RMNRetrieve. 9.4.5 Copy Recipe  The copy recipe operation causesa new copy of a recipe, with a different identifier fromthe original recipe, to be created within the namespace.If the identifier for the new copy is already in use by apre-existing read-only recipe, the namespace shall denythe request.The copy recipe operation is invoked by the messageservice RMNCopy. 9.4.6 Rename Recipe  The rename recipe operationcauses a recipe to be assigned a new identifier withinthe namespace. If the new identifier is already in use bya pre-existing read-only recipe, the namespace shalldeny the request. In this case, it may suggest a newversion according to the rules in Section 3.2.3.3.The rename recipe operation is invoked by the messageservice RMNRename. 9.4.7 Verify Recipe  A manager is not required tounderstand the syntax or semantics of the recipelanguage of a source recipe or to understand theinternal format of an object form recipe. To verify arecipe, the manager may require the services of a recipeexecutor, described in Section 6. In this case, themanager shall request verification from the recipeexecutor of one of the agents listed in its Membersattribute and shall return the resulting status and errorinformation to the initial requestor. (See Section 11 formore detail.) This is a required operation.

&lt;!-- Page 42 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200461 Figure 9.2Verify ScenarioThe verify recipe operation is invoked by the messageservice RMNAction. Figure 9.2 shows a typicalsequence of the message flow when the verify operationis requested for multiple recipes. The namespacemanager responds to the service request RMNAction(Verify) with an intent to perform the requestedoperations. Each recipe specified in the request isdownloaded to a recipe executor of an agent listed inthe namespace attribute Members. (Note: where thenamespace manager and recipe executor are providedby the same agent, formal RMS services are notrequired for communications between the two.) In thisexample, the recipe executor responds to thenamespace manager with an intent to comply, verifiesthe recipe, and returns the information required for thecompletion of the verify operation as described inSection 8.2.3.1. The namespace manager, in turn,returns the final status of the operation for that recipe inthe notification message RMNComplete.The recipe executor provides two operations forperforming verifications, download and verify andverify. The former operation does not typically re-verify already verified recipes. See Sections 11.2.1 and11.2.2 for detail.The verify recipe operation is invoked by the messageservice RMNAction. 9.4.8 Download Recipe  The download recipeoperation causes the namespace manager to downloada recipe to the recipe executor of a specified agent (seeSection 11.2.1). This operation differs from the verifyoperation, which results in a download to an unspecified recipe executor if the namespace manageris not able to perform the verification without help.The namespace manager is responsible for convertingthe form of a managed recipe to that of an executionrecipe for downloading. This is accomplished throughthe following steps:1. If the recipe is not verified, then no conversion isperformed. The attributes ExecAttrLength andExecAttrChgTime are set and maintained only by therecipe executor. These attributes are not sent with thedownloaded recipe.2. The generic attributes ExtRef and Parameters of theverified recipe are not sent with the downloaded recipe.3. If an agent-specific dataset exists that corresponds tothe destination recipe executor, and if the agent-specificattributes AgentSpec Comments and Certified are non-empty, they are included in the attributes of thedownloaded recipe.4. The execution recipe attribute ExecLinkParamcombines the contents of the generic attributeLinkParam and the agent-specific attribute AgentSpecLinkParam. If an agent-specific dataset exists thatcorresponds to the destination recipe executor, and ifthere are variable parameter initial values andrestrictions in the agent-specific attribute AgentSpecLinkParam, then they replace their correspondingelements in the generic attribute LinkParam, and theresults are placed in the ExecLinkParam attribute of thedownloaded recipe.

&lt;!-- Page 43 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 62 The download recipe operation is invoked by themessage service RMNAction. 9.4.9 Upload Recipe  The upload recipe operationcauses the manager to upload a recipe from the recipeexecutor of a specified agent (see Section 11.2.3). Thisoperation is the equivalent of a namespace-initiatedrecipe create (if the specified recipe identifier does notalready exist in the namespace) or a recipe update.The upload operation allows recipes that have beencreated or modified by the recipe executor to be placedunder management in a namespace. Such recipes arealways unlinked.In addition, it is possible to upload previouslydownloaded recipes. However, due to the differences inthe attributes, certain intermediate information availablein a managed recipe, such as ExtRef and Parameters,must be re-created for the uploaded recipe byrequesting the recipe executor to verify the recipe andsend the results.In the case of the derived object form recipe, where theoriginal source recipe identified in the SrcRcpIDattribute (common to both recipe types) exists withinthe namespace, most of the attributes of the derivedobject form recipe are identified to those of the original.The exceptions are the attributes AttrLength,AttrChgTime, BodyLength, BodyFormat, andEditTime, which are all set by the recipe executor at thetime the derived object form recipe is derived.The namespace manager is responsible for convertingthe uploaded execution recipe to a managed recipe forstorage in the namespace. This is accomplished throughthe following steps:1. If the recipe is not verified, then no conversion isperformed. The attributes ExecAttrLength andExecAttrChgTime, if uploaded, are discarded.2. The generic attributes ExtRef and Parameters of theverified recipe are not sent with the uploaded recipe.They must be obtained separately through the verify.3. If an agent-specific dataset exists that corresponds tothe destination recipe executor, then if the executionrecipe attributes AgentSpec Comments and Certifiedare non-empty, they are placed in the correspondingattributes of an agent-specific dataset for that recipeexecutor. If necessary, an agent-specific dataset iscreated.4. Any variable parameter initial values andrestrictions in the execution recipe attribute AgentSpec-LinkParam replace their corresponding elements in thecorresponding agent-specific attribute (if the dataset forthat agent exists) in the uploaded recipe. If it can bedetermined that the contents of AgentSpec LinkParam are not different from those of the generic attributeLinkParam (as in the case of a derived object formrecipe), then AgentSpec LinkParam should bediscarded. If necessary, an agent-specific dataset iscreated for the appropriate agent.The upload recipe operation is invoked by the messageservice RMNAction. 9.5 Synchronization  In addition to the explicitoperations that are invoked through specific messageservices, the recipe namespace manager may providethe optional capability of sychronization of themanaged recipes with execution recipes stored by therecipe executors of its member agents. This sectiondescribes the synchronization capability.The ExecChgCtrl attribute of a recipe is used to specifytypes of permitted changes in execution recipes. Therecipe executor is permitted to change the recipe bodyor to save the last settings used for variable parametersin the ExecLinkParam attribute of the execution recipeonly when expressly granted permission inExecChgCtrl.ExecChgCtrl may also require the recipe executor tosend a change notification message to the recipesoriginating namespace. The originating namespace iseither the namespace from which the recipe wasdownloaded or to which a new recipe will be uploaded.Change notification applies to both the explicitlypermitted changes (modification and saving the lastvalue) and to a derived object form recipe built from asource form recipe. Change notification informs thenamespace that a change of interest to the namespacehas occurred.Namespaces with synchronization capability providetwo additional attributes, SynchOn and SynchFail. Thefirst allows the user to disable synchronization or toselect the types of synchronization desired, and thesecond records execution recipe specifiers of recipes forwhich synchronization failed.Synchronization for a new or changed recipe, or a newrecipe form, consists of uploading the execution recipefor which a change notification has been received and,when necessary to protect a read-only recipe, assigningit a new version number and requesting the recipeexecutor to rename the corresponding execution recipe.Note that the recipe executor is required to denyattempts to rename a currently selected executionrecipe.The recipe executor saves the last value of a variableparameter in the execution recipe attribute Exec-LinkParam. Synchronization for a new last valueconsists of getting the value of this attribute from therecipe executor and updating the AgentSpec LinkParam

&lt;!-- Page 44 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200463 attribute of the agent-specific dataset for the recipeexecutors agent. Note that attributes of a recipe maychange without affecting the version number.Synchronization may fail either through failure toproperly upload an execution recipe, through failure toproperly retrieve the value of the execution recipesExecLinkParam attribute, or through failure tosuccessfully rename the recipe stored by the recipeexecutor. The attribute SynchFail contains a list ofrecipe specifiers of the execution recipes for whichsynchronization was attempted but failed to besuccessfully completed. A recipe specifier shall bedeleted from SynchFail if a later attempt at the failedoperation for that recipe is successful. The authorizeduser may also remove one or all recipe specifiers fromthis attribute.The attribute SynchOn is set by the user to indicate thetypes of changes for which synchronization shall beperformed. SynchOn may be set to specify synchroniz-ation for changes to the body, changes to the last value,creation of a new recipe, building a new derived objectform recipe from a source form, or any combination ofthese settings. A value of zero disables synchronization. SynchOn is an unsigned integer. Possible values areeither 0 (disabled) or any combination (sum) of one ormore of the following decimal values:0 = synchronization disabled1 = changes in body2 = new execution recipes8 = changes in the last value of one or morevariable parameters (i.e., to the ExecParamattribute of the execution recipe)16 = new derived object form execution recipesNOTE: Where possible, the values of SynchOn andExecChgCtrl address the same change issues. For thisreason, a value of 4 is not used, and a new value of 16is added. 9.6 Table of Operations  Table 9.1 lists all theoperations defined for namespace management.The column labeled Rqmt is used to indicate thoseoperations that are required for fundamental complianceto RMS as a recipe namespace resource. Table 9.1 Namespace OperationsOperation Description Rqmtcreate namespace A new namespace is created and assigned an identifier. Ndelete namespace A namespace is deleted. Nrename namespace The namespace identifier is re-assigned. Nget available storage Determine the amount of recipe storage available. Ycheck recipe status Determine the existence and read-only status of a recipe, and obtain the next numeric version. Yget best version Determine the default version for a given recipe class and name and for an optional agent. Ycreate recipe A new recipe body is entered into the namespace. Ydelete recipe A recipe's identifier is removed from the namespace. Ystore recipe A recipe is stored in a namespace. Yretrieve recipe A recipe is sent from the namespace. Ycopy recipe A new recipe is originated as a copy of an existing recipe. Nrename recipe A recipe is assigned a new identifier. Nverify recipe Check the syntax or format of a recipe body for correctness. Ydownload recipe A recipe is downloaded to a specified agent's recipe executor. Yupload recipe A recipe is created or updated by uploading a recipe body from a specified agent's recipeexecutor.N 9.7 Namespace Events  A user of recipe namespace services is potentially interested in any change that occurs toor within a namespace that was not initiated by the user itself. Two such events are defined: Recipe NamespaceChange and Recipe Change. A Recipe Namespace Change event occurs when a namespace is created, deleted, orrenamed, or when a recipe is created, deleted, copied, or renamed. A Recipe Change event occurs whenever thebody or any of the attributes, including agent-specific attributes, of an existing recipe is changed.

&lt;!-- Page 45 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 64 The selection of events to be reported, and themechanisms for reporting these events, are defined inSEMI E53 (Event Reporting). 10 Distributed Recipe NamespaceManagement OperationsThis section defines the operations required for thedistributed recipe namespace capability. Operations aredefined for the DRNS segment, the DRNS recorder, andthe DRNS manager, in that order. Support for thedistributed recipe namespace capability is not requiredfor RMS compliance. 10.1 Distributed Recipe Namespace SegmentOperations  This section defines the operations thatshall be supported by the distributed recipe namespacesegment.10.1.1 Object Services  The DRNS segment isconsidered to own the recipes that it stores.The segment specifier is the object specifier for aDRNS segment and has the form"type1:id1&gt;...&gt;type2:id2". An attached DRNS segmentis owned by the agent providing the DRNS segmentcapabilities, by the distributed recipe namespace ofwhich it is a component, and by the DRNS manager towhich it is attached, and shall be accessible by any ofthese three paths. An unattached DRNS segment isowned by the providing agent.An example of a segment specifier for a DRNS segmentnamed ABC\_Etch\_Seg, a component of a namespacenamed WetEtchA provided by an agent namedWetEtch003, is"Agent:WetEtch003&gt;RNSD:WetEtchA&gt;RNSDSegment:ABC\_Etch\_Seg".For a master segment Alpha provided by agentRecipeServer, this becomes"Agent:RecipeServer&gt;RNSD:WetEtchA&gt;RNSDMaster:Alpha."NOTE: The form of the specifier used for DRNSsegments and DRNS recorders will vary. For example,to specify a segment to be attached to a DRNS manager,the specifier must include the object type and identifierfor the agent providing the segment capability. Oncethe segment is attached, it may be specified through thenamespace hierarchy, as in the example above. 10.1.1.1 Attribute Read/Write  The DRNS segmentshall support the get attributes operation for itself andall recipes that it has stored.It shall support the set attributes operation for itsrecipes only according to the restrictions against changedefined in Section 5.4.2 and within Section 10.1. If requested to change read/write attributes, it shallrequest and receive permission to change attributesprior to making such change.A request to change either several generic attributes atthe same time, or several agent-specific attributes for aspecific agent-specific dataset at the same time, isconsidered for approval purposes as one change.However, changes to both generic and agent-specificattributes shall not be included in one change request orchange. 10.1.1.2 Create and Delete Operations  The segmentmay support both the create object and delete objectspair of operations. The authorized user who invokes thecreate object operation shall assign a name to be used asits name ObjID. The name "Default" is prohibited.Once created, the segment shall be attached to aspecific manager before it is permitted to acceptrecipes.The create and delete operations are optional if theowner agent that provides the distributed recipenamespace segment capabilities provides an installeddistributed recipe namespace segment that cannot bedeleted. In this case, a means of recreating the segmentshall be provided in the event the segment becomesdamaged. If one of these two operations is supported,both are required.The attributes Namespace, NamespaceManager, andRecipeReadOnlyLevel shall be set to null values at thetime the segment is created.A segment that is attached or that contains recipes (isnot empty) shall not be deleted. 10.1.1.3 Object Attachment Operations  Thesegment shall support the operations to attach andreattach to a DRNS manager, and also the operationsinvoked by its manager to detach itself from a DRNSnamespace manager. It shall also support the attach setattributes operation. Certain RMS operations shall beaccepted only when received from its manager, asindicated below.All requests for changes to recipes within the segmentshall be sent to the DRNS manager to which it isattached.The manager shall set the segment attributesNamespace, NamespaceManager, and RecipeRead-OnlyLevel when attaching or reattaching a segment. Itmay change these attributes for an attached segment atany time.The detach operation breaks the logical connectionbetween the segment and its manager. The segmentbecomes unattached, and the values of Namespace,NamespaceManager, and RecipeReadOnlyLevel are set

&lt;!-- Page 46 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200465 to a null value. All recipes and recipe attributes areconsidered as read-only during the time the segment isunattached.The reattach object operation is used in rebuilding adistributed recipe namespace. This operation sets thevalue of the attribute NamespaceManager to the nameof the new manager. The segment returns a new tokenvalue to the manager.The request to reattach itself serves to inform thesegment that any of its pending change requests notpreviously approved have now been forgotten. Thesegment should either discard the request or resubmit itto its new manager. 10.1.2 Segment Recipe Management Operations Within a distributed recipe namespace environment, allrecipe management operations (Section 8) andnamespace recipe operations (Section 9.4) areperformed by the DRNS segment. The DRNS segmentshall support all operations defined in these sections.Operations defined in Section 9.4 that involve a recipeexecutor, such as download and upload, shall beperformed only with a recipe executor that is eitherowned by the agent providing the DRNS segmentcapability or is owned by a component within theinternal hierarchy of that agent. For example, a DRNSsegment provided by a cluster tool may download to arecipe executor owned by a cluster module but not toequipment external to the cluster. Figure 10.1Segment-Initiated Change Request Message Flow 10.1.2.1 Requirements for Approval  Operations thatchange a recipe in any way shall be denied unless theDRNS segment is attached to a DRNS manager. Allchanges to logical recipes within a DRNS segment shallbe approved by the DRNS manager before the changesare made to the recipe stored within the DRNS segment.Changes to agent-specific datasets stored by attacheddedicated segments are pre-approved. This is possiblesince, at most, one dedicated segment has an agent- specific dataset for a specific agent for any givenrecipe. However, the segment shall notify its managerimmediately after any such change by sending theRMDNotify notification, which shall include theattribute AgentSpec\_Agent, to identify the agent-specific dataset, as well as all agent-specific attributesthat changed, regardless of whether they have beenreset to their default value or set to a non-default value.(Otherwise, the entire agent-specific dataset would berequired.)A master segment, however, is prohibited fromchanging an agent-specific dataset without explicitpermission from the manager.Requests for changes that are made with RMS servicesdefined in Section 12 may be sent from any serviceuser, including the DRNS manager. The DRNS segmentmay reject requests for invalid changes, such as arequest to modify a read-only recipe. Otherwise, theDRNS segment shall request approval from its DRNSmanager for each change (Section 10.3.5). Themanager responds by either approving, denying, orputting the request on hold.NOTE: Service requests sent directly to a DRNSsegment may not, in some circumstances, be fulfilled.If the change request is denied, then the change isprohibited immediately. If it is put on hold, the segmentshall retain the information necessary to effect thedesired change at a later time.If the change request is approved, the DRNS segmentshall proceed with the change and shall notify its DRNSmanager when the change is completed, either normallyor abnormally, through sending the notificationRMDComplete with the results, as illustrated in Figure10.1.The DRNS manager will put a change request on holdwhen another change request exists for the same recipeand the recipe is locked. In this case, the DRNSmanager responds to the segment's change request withan operation identifier that the manager uses later whensending a segment change approval request.

&lt;!-- Page 47 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 66 Figure 10.2Message Flow for Manager Approval of ChangeRequest 10.1.2.2 Segment Change Approval  The DRNSsegment may receive a segment change approvalrequest for an action that the DRNS segment had earlierrequested. This informs the DRNS segment that anearlier change request made by the DRNS segment hasnow been approved for immediate action or has beencompletely denied.The segment shall respond in one of three ways: It may reject the approval due to changes incircumstances since the original request was made(Figure 10.2(a). It may first fulfill the change request and thenrespond that the change request has now beencompleted, either successfully or unsuccessfully(Figure 10.2(a). It may first respond that it accepts the changerequest and then attempt to complete the change.When change request has been completed, normallyor abnormally, the segment shall notify the managerof the results with the RMDComplete notificationservice (Figure 10.2(b).Rejection of segment change approval shall be usedwhen the change is no longer desired. For example, aDRNS segment "S" may request to link a write-protected recipe, and the manager responds that therequest is on hold. Before the segment receives approval for that change, the same logical recipe islinked by a different attached DRNS segment, and theresults are updated to each DRNS segment having acopy of the logical recipe, including segment "S". Inthis case, the recipe may not be relinked.11 The segment change approval operation is invoked bythe message service RMDSApproveAction by thesegment's DRNS manager and is otherwise invalid. 10.1.2.3 Scenario of a Segment Change Request  Atypical scenario is illustrated in Table 10.3.In this scenario, a local operator wants to change thegeneric attribute EditedBy. The segment requestsapproval for a generic attributes change. However, anactive change request exists for this recipe. 11 Both the DRNS manager and the DRNS segment are responsiblefor compliance to RMS namespace requirements

&lt;!-- Page 48 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200467 Table 10.3 Typical Change Request ScenarioManager SegmentReceives request for attribute change from local operator.Requests change from manager.&lt;- RMDChangeRequest.req Manager already has an active change request to link that recipeand answers that the request is on hold:RMDChangeRequest.rsp -&gt;The active change request completes. The manager updates thechange to the segment:RMNStore.req -&gt;The segment responds that it will make the change and notifythe requestor when done.&lt;- RMNStore.rspThe segment requests approval to make the second change:&lt;- RMDChangeRequest.reqThe manager approves the second request immediately:RMDChangeRequest.rsp -&gt;The segment stores the generic attributes sent by its manager.&lt;- RMDComplete.nfyThe segment notifies the requestor of the second change (inthis case, its manager) that the change is complete.&lt;- RMNComplete.nfyWhen all other segments are similarly updated, the managernow approves the segments earlier request to change genericattributes:RMDSApproveAction.req -&gt;The segment makes the approved change to EditedBy and thenresponds:&lt;- RMDSApproveAction.rspThe segment sends notification to the operator making requestfor first change.change:&lt;- RMNComplete.nfyThe manager requests the new set of generic attributes:RMNRetrieve.req -&gt;The segment sends the generic attributes to any requestor:&lt;- RMNRetrieve.rsp 10.2 Distributed Recipe Namespace Recorder  This section defines the operations supported by the distributedrecipe namespace recorder.10.2.1 Object Services  The recorder specifier is the object specifier of the recorder. A recorder is owned by theagent providing the DRNS recorder capabilities. When attached to a DRNS manager, it is also owned by thatmanager. An example of the object specifier for a recorder named Recorder182 provided by agent RecorderServeris"Agent:RecorderServer&gt;RNSDRecorder:Recorder182&gt;".

&lt;!-- Page 49 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 2004 68 10.2.1.1 Attribute Read/Write  The DRNS distributedrecipe namespace recorder shall support the getattributes operation for its attributes. It shall denyattempts to set its attributes through the set attributesservice.10.2.1.2 Object Create and Delete Operations  Therecorder may support both the create object and deleteobject pair of operations. The authorized user whoinvokes the create object operation shall assign a nameto be used as its name ObjID. The name "Default" isprohibited.Once created, the recorder shall be attached to aspecific manager before it is ready to accept data. Oncecreated, the recorder shall set its attributes other thanObjID to null or empty values.The create and delete operations are not required if theowner agent that provides the distributed recipenamespace recorder capabilities provides an installeddistributed recipe namespace recorder that cannot bedeleted. In this case, a means of recreating the recordershall be provided in the event the recorder becomesdamaged. If either of these two operations is supported,both are required. 10.2.1.3 Object Attachment Operations  Therecorder shall support the operations to attach andreattach to a DRNS manager, and the detach and attachset attributes when invoked by the DRNS manager towhich it is attached.The recorder attributes Namespace and Namespace-Manager are set by the attach and reattach operations.The detach operation breaks the logical connection ofthe recorder to the namespace and managers by settingthe recorder attributes Namespace and Namespace-Manager to null values.NOTE: In the event that a distributed recipe namespacebecomes damaged, its recorder should be left attachedso that it may later be reattached to a new manager.The reattach operation is used in rebuilding adistributed recipe namespace. 10.2.2 Add Segment Record  The add segmentrecord operation adds a given segment (its objectspecifier) to the DRNS recorder's internal list of DRNSsegments. A request to add a DRNS segment that isalready in the list shall be denied.The add segment record operation is invoked by theservice RMDRAddSegRecord. 10.2.3 Delete Segment Record  The delete segmentrecord operation deletes a given segment specifier fromthe DRNS recorder's internal list of DRNS segments. A request to delete a segment not in the current list shallbe denied.The delete segment record operation is invoked by theservice RMDRDelSegRecord. 10.2.4 Add Change Request Record  The addchange request record operation adds a changerequest record to the DRNS recorder. The DRNSrecorder keeps, at most, one change request record perrecipe at any time. This is intended to represent achange currently approved and active for that recipe. Ifthe DRNS recorder already has a change request recordfor the specified recipe, the information in the newchange request replaces the previous information.The contents of the change request record are definedin Section 10.3.7.4.The add change request record operation is invoked bythe service RMDRAddChgRecord. 10.2.5 Delete Change Request Record  The deletechange request record operation removes a changerequest record for a specified recipe.The delete change request record operation is invokedby the service RMDRDelChgRecord. 10.2.6 Get Change Request Record  The get changerequest record operation returns the current changerequest record for a specified recipe or assignedsegment.The get change request record operation is invoked bythe service RMDRGetChgRecord and is available toany service user. 10.3 Distributed Recipe Namespace ManagementOperations  Operations defined in Sections 8 and 9shall be supported by the DRNS manager. This sectiondefines the additional operations provided by the DRNSmanager. Operations defined in Sections 8 and 9.4 aredelegated by the DRNS manager to an attached DRNSsegment.10.3.1 Object Services  The DRNS manager isconsidered to own the DRNS segments and any DRNSrecorder currently attached to the distributed recipenamespace. In addition to the object services requiredin Section 9, the DRNS manager shall support the gettype and get attribute name operations for its attachedobjects. The DRNS manager shall support objectservices directed to any of its attached objects and torecipes stored by specific DRNS segments.The DRNS manager is considered to own the recipesthat are owned through delegation by any of its attachedDRNS segments. The Get Attributes and Set Attributesoperations for a recipe may be directed to thedistributed recipe namespace.

&lt;!-- Page 50 --&gt;

SEMI E42-0704 ¬© SEMI 1995, 200469 The object specifier for an object owned by a DRNSmanager is formed by concatenating the object type andidentifier for either the manager or the namespace,followed by the object type and identifier of eachowned object in the ownership hierarchy. An exampleof the object specifier for a recipe XYZ;3 stored byDRNS segment ABC\_Etch\_Seg within the distributedrecipe namespace WetEtch003 would be:"RNSD:WetEtch003&gt;RNSDSegment:ABC\_Etch\_Seg&gt;MRcp:XYZ;3"If an agent or a DRNS segment is specified, then theDRNS manager shall delegate the operation to the thatsegment. Otherwise, the operation shall be delegated toa master segment.A request to set one or more read-write attributes of arecipe is treated by the DRNS manager as a changerequest. 10.3.2 Delete Distributed Recipe Namespace  Adistributed recipe namespace with attachments may notbe deleted.The delete distributed recipe namespace operation isinvoked by the service RMNDeleteNS defined inSection 9.2.2. 10.3.3 Attach and Detach Supervised Objects  Thissection defines the support required for the authorizeduser to request a DRNS manager to attach or detach oneor more segments or a recorder. The operations andservices are defined in detail in SEMI E39 (OSS).10.3.3.1 Attach Supervised Object  The attachsupervised object operation is invoked by anauthorized user to request the DRNS manager to attacha specified unattached segment or recorder.When a request to attach a supervised object isaccepted, the DRNS manager sends an attach or detachrequest to the specified object.The DRNS manager shall have the capability ofmanaging at least one attached dedicated and oneattached master segment at a time. At most, onerecorder shall be attached to a DRNS manager at anygiven time.Once attached, the segment or recorder becomes aformal part of the namespace and is owned by themanager.When adding attachments to a DRNS manager, therecorder should be added first, so that it may be used torecord the segments as they are subsequently attached.When the distributed recipe namespace managerreceives a request to attach a segment, it sends thatrequest to the specified segment. If the operation issuccessful, and if a recorder is attached, the manager requests the distributed recipe namespace recorder torecord the segment specifier (the object specifier for thesegment). If the agent providing the segment is notalready in the namespace attribute Members, it is addedat this time.The operation of attaching a recorder shall set thedistributed recipe namespace attribute Recorder to thevalue of the recorder's attribute ObjID. The operationof attaching a segment shall add the segment specifierto the Segments attribute of the distributed recipenamespace.When a recorder is attached, all subsequent operationsthat attach and detach segments shall update therecorder through its operations to add and remove arecord of the segment.Specifiers used in the namespace attributes Recorderand Segments, and segment specifiers stored in theDRNS recorder, shall use the form including thespecifier for the agent providing the capability for therecorder or segment. This is required for identificationoutside the scope of the current namespace. Forexample, if it later becomes necessary to rebuild thedistributed recipe namespace, then the segment must belocated through its agent owner rather than through thenamespace. 10.3.3.2 Detach Supervised Object  An attachedsegment or recorder may be detached at any time. Themanager forwards the request to the specified object.When a segment is detached, if a recorder is attached,then the manager requests the recorder to remove thesegment that is being detached.The user may request a DRNS manager to detach anattached recorder or segment at any time. When arecorder is detached, the distributed recipe namespaceattribute Recorder shall be set to a null value. When asegment is detached, its specifier is removed from anyattached recorder and from the Segments attribute ofthe distributed recipe namespace. 10.3.4 Change Request Management  A changerequest occurs whenever the DRNS manager receivesany request, from any source, to change a recipe or thecontents of the distributed recipe namespace as awhole. This includes requests to change the recipeidentifier, a generic attribute, an agent-specificattribute, or the body of an existing recipe. It alsoincludes all changes that affect the set of recipeidentifiers within the distributed recipe namespace.Requests for changes may come from a source that iseither internal or external to the namespace. 10.3.4.1 External Change Requests  The DRNSmanager may receive a request, through recipe