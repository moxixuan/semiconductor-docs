"use strict";(globalThis.webpackChunksemiconductor_docs=globalThis.webpackChunksemiconductor_docs||[]).push([[3613],{1575(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var i=t(8168),a=(t(6540),t(5680));t(2073);const o={title:"E40-0705 - \xa9 SEMI 1995, 2005...",description:"SEMI\u6807\u51c6\u6587\u6863",sidebar_label:"E40-0705 - \xa9 SEMI 1995, 2005...",sidebar_position:350,tags:["SEMI","Standard"],custom_props:{source_type:"pdf",source_file:"semi-chapter-035.pdf",chapter:35,page_count:50}},r=void 0,s={unversionedId:"standards/semi/semi-chapter-035",id:"standards/semi/semi-chapter-035",title:"E40-0705 - \xa9 SEMI 1995, 2005...",description:"SEMI\u6807\u51c6\u6587\u6863",source:"@site/docs/standards/semi/semi-chapter-035.md",sourceDirName:"standards/semi",slug:"/standards/semi/semi-chapter-035",permalink:"/semiconductor-docs/docs/standards/semi/semi-chapter-035",draft:!1,editUrl:"https://github.com/your-org/semiconductor-docs/tree/main/docs/standards/semi/semi-chapter-035.md",tags:[{label:"SEMI",permalink:"/semiconductor-docs/docs/tags/semi"},{label:"Standard",permalink:"/semiconductor-docs/docs/tags/standard"}],version:"current",sidebarPosition:350,frontMatter:{title:"E40-0705 - \xa9 SEMI 1995, 2005...",description:"SEMI\u6807\u51c6\u6587\u6863",sidebar_label:"E40-0705 - \xa9 SEMI 1995, 2005...",sidebar_position:350,tags:["SEMI","Standard"],custom_props:{source_type:"pdf",source_file:"semi-chapter-035.pdf",chapter:35,page_count:50}},sidebar:"standardsSidebar",previous:{title:"E38-1296 - \xa9 SEMI 1995, 199640...",permalink:"/semiconductor-docs/docs/standards/semi/semi-chapter-034"},next:{title:"E42-0704 - \xa9 SEMI 1995, 2004...",permalink:"/semiconductor-docs/docs/standards/semi/semi-chapter-036"}},c={},l=[],d={toc:l};function p({components:e,...n}){return(0,a.yg)("wrapper",(0,i.A)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,a.yg)("p",null,'PdfDownloadCard\npdfLink="/pdfs/semi/035.pdf"\npdfSize="0.49MB"\ntitle="E40-0705 - \xa9 SEMI 1995, 2005..."\ndescription="SEMI\u6807\u51c6\u6587\u6863\uff0c\u517150\u9875"\n/'),(0,a.yg)("h1",{id:"\u6587\u6863\u6807\u9898"},"\u6587\u6863\u6807\u9898"),(0,a.yg)("p",null,"SEMI E40-0705 \xa9 SEMI 1995, 2005 13\n1\nPROCESS JOB\nACTIVE\nEXECUTING\nSETTING UP\n3\n5\nPROCESSING\nWAITING FOR\nSTART\nPAUSE\n9\n10\n11\nPOST ACTIVE\n13\n15\n12\nH\n8\n4\n14\nPOOLED/\nQUEUED\nPAUSING\nPAUSED\nSTOPPING\nABORTING\nSTOPPED\nABORTED\n18\n16\n17\n6\n2\nPROCESS\nCOMPLETE\n7"),(0,a.yg)("p",null,"Figure 4\nProcess Job State Model"),(0,a.yg)("ol",{start:8},(0,a.yg)("li",{parentName:"ol"},"3.2.6  PAUSED  (PAUSE  Substate)  \u2014  While  the  PR  Job  is  in  the  PAUSED  substate  all  processing  resource\nactivity has ceased. The PR Job is awaiting a RESUME (or STOP or ABORT) command."),(0,a.yg)("li",{parentName:"ol"},"3.2.7  PAUSING  (PAUSE  Substate)  \u2014  While  the  PR  Job  is  in  the  PAUSING  substate,  the  processing  resource\ncontinues to the first safe, continuable pausing place and then ceases activity. The activity may only cease at points\nthat  allow  for  resumption  of  the  activity  such  that  material  integrity  is  maintained  and  the  processing  goals  are\naccomplished."),(0,a.yg)("li",{parentName:"ol"},"3.2.8  PROCESSING  (EXECUTING  Substate)  \u2014  While  the  PR  Job  is  in  the  PROCESSING  substate,  the\nprocessing resource is doing the actual material processing using the equipment recipe(s) specified by the PR Job."),(0,a.yg)("li",{parentName:"ol"},"3.2.9  PROCESS  COMPLETE  (POST  ACTIVE  Substate)  \u2014  While  the  PR  Job  is  in  the  PROCESS  COMPLETE\nsubstate  the  processing  resource  has  completed  processing  all  material  specified  by  the  PR  Job.  When  all  material\nremoved  from  the  processing  resource,  processing  resource  performs  any  required  post-conditioning.  Post-\nconditioning  includes  all  operations  in  the  processing  resource  after  material  departure,  which  are  required  by  the\nrecipe."),(0,a.yg)("li",{parentName:"ol"},"3.2.9.1  In  cases  where  the  process  job  is  superseded  by  another  process  job  on  the  same  material  and  post-\nconditioning  is  not  required,  the  first  job  terminates  successfully  while  the  material  is  still  present.  If  post-\nconditioning is required, the second job may not supersede and remains on the queue."),(0,a.yg)("li",{parentName:"ol"},"3.2.10  QUEUED/POOLED \u2014 While the PR Job is in the QUEUED/POOLED substate, the process job has been\naccepted  by  the  processing  resource  through  a  PR  Job  Create/Acknowledge  transaction  (such  as  PRJobCreate,\nPRJobCreateEnh,  and  PRJobMultiCreate)  and  is  awaiting  execution.  One  or  more  jobs  may  be  in  this  state\ndepending upon specific equipment capabilities. That is, if equipment does not support job queuing, then only one\nPR Job may be in this state at a time. If equipment does support job queuing, then the number of jobs that may be in\nthis  state  must  at  least  be  equal  to  the  number  of  load  ports  on  the  equipment.  Advanced  equipment  job  manage-\nment capabilities require multiple jobs (greater than two) be in this state per load port.")),(0,a.yg)("p",null,"SEMI E40-0705 \xa9 SEMI 1995, 2005 14\n8. 3.2.10.1  The order that jobs become active is dependent upon whether the equipment supports job queuing and/or\njob  pooling.  Example  methods  for  job  activation  include  FIFO  (first-in/first-out)  order,  material  arrival  order,  and\nhost  ordering  of  jobs  (provided  by  additional  services).  The  equipment  may  support  only  one  method  of  selecting\njobs  for  activation,  or  more  than  one  method  allowing  only  one  method  to  be  used  at  a  time  or  more  than  one\nmethod to be used at a time.\n8. 3.2.10.2  All  process  jobs  pass  through  this  state.  If  the  processing  resource  supports  queuing/pooling,  jobs  may\nremain  in  this  state  for  prolonged  periods.  In  any  case,  a  process  job  remains  queued/pooled  until  the  material\npositions (of the processing resource) needed for the process are available or are already occupied by the material to\nbe processed.\n8. 3.2.11  STOPPING (ACTIVE Substate) \u2014 While the PR Job is in the STOPPING substate, the processing resource\nis performing a stop procedure to terminate processing in an orderly manner. It is the responsibility of the processing\nresource to cease the current activity at the next safe, convenient point, preserving material integrity.  For processing\nequipment this may require sending all related substrates to its output destination.  This implies that each material is\nprocessed as specified in the recipe or not at all.\n8. 3.2.12  WAITING FOR START (EXECUTING Substate) \u2014 The substate WAITING FOR START is used only in\nmanual  start  process  jobs.  It  is  entered  once  SETUP  is  complete  and  a  PR  Job  Start  Process  has  not  yet  been\nreceived by the processing resource. Manual start is defined by the supervisor in PR Job Create.\n8. 3.2.12.1  The job remains in this state, ready to process the material, until the PR Job Start Process is received or\nAbort or Stop terminates the job.\n8. 3.2.13  POST  ACTIVE  \u2014  This  is  the  parent  state  of  those  states  that  refer  to  the  final  state  (completion)  of  the\nprocess  jobs.  Process  jobs  that  have  completed,  stopped  or  aborted  should  remain  in  this  state  until  the  trigger  to\ntransition to extinction is detected (see Table 1).  If there is no Control Job associated with the process job, as in the\ncase of the inline stepper/scanner, the process job should remain until all material associated with the process job has\nleft the equipment or a process job specifying the same material replaces it.\n8. 3.2.14  STOPPED  (POST  ACTIVE  substate)  \u2014  This  is  the  final  state  for  those  jobs  that  have  been  in  the\nSTOPPING state.\n8. 3.2.15  ABORTED  (POST  ACTIVE  substate)  \u2014  This  is  the  final  state  for  those  jobs  that  have  been  in  the\nABORTING state.\n8. 3.3  Process Job State Transitions \u2014 The detailed state definitions are defined in Table 1.\nTable 1  Process Job State Transition Table"),(0,a.yg)("h1",{id:""}),(0,a.yg)("h1",{id:"current--------state--------trigger----------------------------------new----------------------------------state----------------------------------actions"},"Current        State        Trigger                                  New                                  State                                  Action(s)"),(0,a.yg)("p",null,"1     (no state) The processing resource accepts a\nProcess Job create request.\nQUEUED/ POOLED    The job is placed the job queue/pool.\nAcknowledge the Process Job creation.\n2     QUEUED/\nPOOLED\nThe processing resource has been\nallocated to the Process Job.\nSETTING UP The job is removed from the queue/pool.\nPR Job Setup event is triggered.\nAll required resource preconditioning is\nperformed.\nWhen job material arrives all material\npreparation is performed.\n3     SETTING UP Job material is present AND the\nprocessing resource is ready to\nstart the process job AND\nPRProcessStart attribute is not set.\nWAITING FOR\nSTART\nPR Job Waiting for Start event is triggered.\n4     SETTING UP Material is present and ready for\nprocessing. PRProcessStart\nattribute is set.\nPROCESSING PR Job Processing event is triggered.\nMaterial is processed.\n5     WAITING     FOR\nSTART\nJob Start directive PROCESSING PR Job Processing event is triggered.\nMaterial is processed."),(0,a.yg)("p",null,"SEMI E40-0705 \xa9 SEMI 1995, 2005 15"),(0,a.yg)("h1",{id:"current--------state--------trigger----------------------------------new----------------------------------state----------------------------------actions-1"},"Current        State        Trigger                                  New                                  State                                  Action(s)"),(0,a.yg)("p",null,"6     PROCESSING Material processing completed. PROCESS\nCOMPLETE\nPR Job Processing Complete event is\ntriggered.\nThe processing resource performs all\nrequired resource post-conditioning.\nAwait material departure.\n7     Any     POST\nACTIVE sub-\nstate\nJob material departs from the\nequipment OR the process job\nbecomes extinct because the\nprocess job is replaced by another\nprocess job that specifies the same\nmaterial when no control job is\nused.\n(Extinction) PR Job Complete event is triggered. The\nprocess job is deleted.\n8     EXECUTING  The processing resource initiated a\nprocess pause action.\n(it received a PAUSE command or\ninitiated an internal pause)\nPAUSING The processing resource pauses at the first\nconvenient time.\n9     PAUSING The processing resource paused\nthe job.\nPAUSED                      None.\n10    PAUSE The processing resource resumed\nthe job.\nEXECUTING The processing resource resumes the\nactivity that was paused.\n11    EXECUTING The processing resource initiated a\nprocess stop action.\n(it received a STOP command or\ninitiated an internal stop)\nSTOPPING The processing resource stops the current\nexecution activity at the first convenient\ntime.\n12    PAUSE The processing resource initiated a\nprocess stop action.\n(it received a STOP command or\ninitiated an internal stop)\nSTOPPING The processing resource stops the current\nexecution activity at the first convenient\ntime.\n13    EXECUTING The processing resource initiated a\nprocess abort action.\n(it received an ABORT command\nor initiated an internal abort)\nABORTING The processing resource terminates the\ncurrent execution activity immediately.\n14    STOPPING The processing resource initiated a\nprocess abort action.\n(it received an ABORT command\nor initiated an internal abort)\nABORTING The processing resource terminates the\ncurrent execution activity immediately.\n15    PAUSE The processing resource initiated a\nprocess abort action.\n(it received an ABORT command\nor initiated an internal abort)\nABORTING The processing resource terminates the\ncurrent execution activity immediately.\n16    ABORTING The abort procedure is completed.\nFor some equipment, substrates are\nmoved out into a safe location as\npart of the error recovery.\nABORTED\n17    STOPPING The stop procedure is completed\nand all material is in a safe\ncondition.\nSTOPPED\n18    QUEUED/\nPOOLED\n\u201cCANCEL,\u201d \u201cABORT,\u201d or\n\u201cSTOP\u201d command received.\n(no state) Remove the process job from the\nqueue/pool.\nPR Job Complete event is triggered.\nDelete the process job."),(0,a.yg)("p",null,"SEMI E40-0705 \xa9 SEMI 1995, 2005 16\n9  Object Definitions\n9. 1  Processing management defines one standard object, the Process Job.\n9. 2  Process  Job  Object  Definition  \u2014  The  process  job  is  a  dynamic  object  created  by  the  processing  resource  as\nrequested by the supervisor. It tracks progress of the operations required and is deleted by the processing resource\nautomatically upon completion. The process job is uniquely identified by the PRJobID attribute. The object attribute\nnotation used in the table below is described in Conventions, \xb65.2.\n9. 2.1  The attributes in Table 2 shall be accessible using Object Services Standard (SEMI E39).\nTable 2  Process Job Attributes\nAttribute Name Definition Rqmt   AccessForm\nObjID An identifier for the service user. It is set when the\nprocess job is created.\nY         RO         Text\nObjType The object type. Y RO     Text:\n\u201cPROCESSJOB\u201d\nPauseEvent List of event identifiers that cause the equipment to\nautomatically transition to the PAUSING/PAUSED\nstates when one of the listed events is triggered.\nN         RO         List         of:\nEventID\nPRJobState A unique sub-state of the job according to the process\njob state model in Figure 4.\nY         RO         Enumerated:\nQUEUED/POOLED\nSETTING UP\nWAITING FOR START\nPROCESSING\nPROCESS COMPLETE\nPAUSING\nPAUSED\nSTOPPING\nABORTING\nSTOPPED\nABORTED\nPRMtlNameList List of identifiers of the material being processed. Y RO     List of:\nPRMtlName\nPRMtlType Identifies the type of material being processed. Y RO     Enumerated\nPRProcessStart Indicates that the processing resource start processing\nimmediately when ready.\nN         RO         Boolean:\nTRUE \u2014 Automatic start\nFALSE \u2014 Manual start\nPRRecipeMethod    Indication of recipe specification type, whether using\nis applied and which method is used.\nY         RO         Enumerated:\nRecipe only\nRecipe with Variable Tuning\nRecID Identifier of the recipe applied. Y RO     Text\nRecVariableList List of variables supporting a recipe method. N RO     List of: RecipeVariable"),(0,a.yg)("ol",{start:9},(0,a.yg)("li",{parentName:"ol"},"2.2  A number of the ProcessJob attributes are composite data types.  The constituent data is defined in Table 3.\nTable 3  Attribute Data Definitions\nData Itentifier Description Form\nPRMtlName Textual identifier of the material being processed. Text\nRecipeVariable Variables supporting a recipe method. Structure composed of:\nRecipeVarName\nRecipeVarValue\nRecipeVarName The name of the recipe variable. Text\nRecipeVarValue Value of the recipe variable. Depends on variable")),(0,a.yg)("p",null,"SEMI E40-0705 \xa9 SEMI 1995, 2005 17\n10  Messaging Services Detail\n10. 1  This section defines the messaging services required to implement the processing management concepts. The\nmessages  were  introduced  in  \xb68.1.  These  services  are  independent  of  the  messaging  protocol  used.  They  may  be\nmapped to SECS-II (SEMI E5) or to other comparable protocols.\n10. 1.1  These messaging services define the messages to be used, the nature of the parameters contained within the\nmessages,  and  data  type  of  the  parameters.  Not  defined  here  is  the  internal  structure  of  the  actual  messages  as\ntransferred, including order of the parameters and how various data structures and data types are represented.\n10. 1.2  The service message notation used in the tables below is described in Conventions, \xb65.3.\n10. 2  Service  List  \u2014  The  following  messages  are  exchanged  between  host  and  equipment  for  the  purpose  of\naccomplishing processing management tasks.\nTable 4  Service List\nMessage Name Type                                                                 Description\nPRGetAllJobs R Get a list of the jobs and their states for all jobs which have not completed.\nPRGetSpace R Get the number of jobs which can currently be created on the resource.\nPRJobAlert N Notification by the processing resource that the process job is setting up, processing,\ncompleted process, or that the job is completed.\nPRJobCommand                               R                               Command                               which                               affects the process job.\nPRJobCreate R Supervisor (service-user) request that a process job be performed.\nPRJobCreateEnh R User request for job to be done.  User assigns a unique job identifier.\nPRJobDequeue                                  R                                  Removes                                  (deletes)                                  process job(s) from the queue.\nPRJobEvent N Notification by the processing resource that a process-related event has occurred.\nPRJobMultiCreate R Create several jobs which may be dissimilar. User assigns unique job identifiers.\nPRJobSetRecipeVariable                  R                  User                  request for setting a new value to one of more recipe variable parameters.\nPRJobSetStartMethod R Create a set of similar process jobs. User assigns unique job identifiers.\nPRSetMtrlOrder R Request the service to use a specific methodology for processing order."),(0,a.yg)("ol",{start:10},(0,a.yg)("li",{parentName:"ol"},"3  Parameter Dictionary\nTable 5  Parameter Dictionary, Part 1\nParameter Name Definition Form: Possible Values\nCmdParameter Parameter supporting a command type. Structure composed of:\nCmdParmName\nCmdParmValue\nCmdParmName The name of the parameter. Text\nCmdParmValue Value of the parameter. Varies per parameter")),(0,a.yg)("p",null,"SEMI E40-0705 \xa9 SEMI 1995, 2005 18\nParameter Name Definition Form: Possible Values\nErrorCode Contains the code for the specific error found. Enumerated:\nPRJobCreate, PRJobCreateEnh,\nPRJobMultiCreate:\nParameters improperly specified\nInsufficient parameters specified\nUnsupported option requested\nBusy (no queueing or queue full)\nPRJobCreateEnh, PRJobMultiCreate:\nObject identifier in use\nPRJobCommand:\nParameters improperly specified\nInsufficient parameters specified\nUnsupported option requested\nCommand not valid for current state\nPRJobComplete:\nNo material altered\nMaterial partially processed\nAll material processed\nRecipe specification related error\nFailed during processing\nFailed while not processing\nFailed due to lack of material\nJob aborted\nJob stopped\nJob cancelled\nErrorText Text in support of the error code. Text\nPRAck Indicates whether the activity was successful. Boolean:\nTRUE \u2014 Successful\nFALSE \u2014 Unsuccessful\nPRCmdName            Indicates            which            process job command to perform. Text:\nABORT\nSTOP\nCANCEL\nPAUSE\nRESUME\nSTARTPROCESS\nPREventData Data related to the specific event. Varies per parameter reported\nPREventID Identifier of the specific event which occurred. Enumerated:\nUnique collection event ID for\nWaiting for Material and Process Job State\nChange events."),(0,a.yg)("p",null,"SEMI E40-0705 \xa9 SEMI 1995, 2005 19\nTable 6  Parameter Dictionary, Part 2\nParameter Name Definition Form: Possible Values\nPRJobID The unique identifier for a process job. It can be accessed as\nthe ObjID attribute of the process job. The host may provide\nthis identifier to the processing resource. In this case, the host\nmust guarantee uniqueness of job identifiers for all the\nprocess jobs in the PROCESS JOB STATE in the equipment.\nText\nPRJobList List of process job identifiers and their states. List of\nStructure\nPRJobID\nPRJobState\nPRJobMilestone        Process        job milestone. Enumerated:\nPR Job Setup\nPR Job Processing\nPR Job Processing Complete\nPR Job Complete\nPR Job Waiting for Start\nPRJobSpace Used to indicate the number of jobs that can currently be\ncreated for the processing resource.\nInteger\nPRJobState A unique state of the process job according to the process job\nstate model.\nEnumerated:\nQUEUED/POOLED\nSETTING UP\nWAITING FOR START\nPROCESSING\nPROCESS COMPLETE\nPAUSING\nPAUSED\nSTOPPING\nABORTING\nSTOPPED\nABORTED\nPRMtlName Textual identifier of the material being processed. Text:  Unique for each material with respect\nto the processing agent.\nPRMtlType Identifies the type of material being processed. Enumerated\nPRMtrlOrder Defines the order by which material in the process jobs\nmaterial list will be processed.\nEnumeration:\nARRIVAL \u2013 process whichever material\nfirst arrives.\nOPTIMIZE \u2013 process in an order that\nmaximizes throughput.\nLIST \u2013 follow the order in the list.\nPRPauseEvent Variable containing information which is transferred to the\ncorresponding PRJob attribute.  Shall conform to event\nidentifiers as defined in either SEMI E30 or E53.\n(list of)\ntext\nPRProcessStart Indicates that the processing resource start processing\nimmediately when ready.\nBoolean:\nTRUE \u2013 Automatic Start\nFALSE \u2013 Manual Start\nPRRecipe Specification of the process job recipe. Structure composed of:\nPRRecipeMethod\nRecID\n(List of) RecipeVariable\nPRRecipeMethod Indication of recipe specification type, whether tuning is\napplied and which method is used.\nEnumerated:\nRecipe only\nRecipe with VariableTuning"),(0,a.yg)("p",null,"SEMI E40-0705 \xa9 SEMI 1995, 2005 20\nParameter Name Definition Form: Possible Values\nPRStatus Reports the acceptance or rejection of a requested operation.   Structure composed of:\nPRAck\n(List of) Status\nRecID Identifier of the recipe applied. Text:\nUnique with respect to the processing agent.\nRecipeVariable Variables supporting a recipe method. Structure composed of:\nRecipeVarName\nRecipeVarValue\nRecipeVarName The name of the recipe variable. Text:\nDepends on recipe\nRecipeVarValue Value of the recipe variable. Depends on variable\nStatus Reports any errors found. Structure composed of:\nErrorCode\nErrorText\nTimestamp Event date and time. Text:\nyyyymmddhhmmsscc"),(0,a.yg)("ol",{start:10},(0,a.yg)("li",{parentName:"ol"},"4  Service  Detail  \u2014  The  tables  below  define  the  parameters  for  each  service.  In  some  cases,  parameters  have\nadditional detail which is defined in the parameter definition section."),(0,a.yg)("li",{parentName:"ol"},"4.1  PRJobCreate\nTable 7  PRJobCreate Service Detail\nPRJobCreate Service Detail Section\nParameter                    Req/Ind                    Rsp/CnfComment\nPRJobID - M The processing agent assigns the unique identifier which is used in all\nsubsequent process job communications.\nPRMtlType                                       M                                       -\n(List of) PRMtlName M - All material shall be of the same material type. This is an ordered list and\nindicates the order in which the process job should process the material, if\nit is single wafer processing equipment.\nPRRecipe                                          M                                          -\nPRProcessStart M - Indicates auto or manual start.\nPRStatus                                             -                                             M")),(0,a.yg)("p",null,"PRRecipe Parameter Detail Section\nPRRecipeMethod                              M                              -\nRecID M - The process job recipe identifier shall be unique within the domain of the\nprocessing agent.\n(List of) Recipe Variable C - Parameters required depend on the recipe method selected."),(0,a.yg)("p",null,"PRStatus Parameter Detail Section\nPRAck - M Indication of acceptance to perform the job.\n(List of) Status - C Error information, required if PRAck is unsuccessful."),(0,a.yg)("p",null,"SEMI E40-0705 \xa9 SEMI 1995, 2005 21\n10. 4.2  PRJobCreateEnh\nTable 8  PRJobCreateEnh Service Detail\nParameter  Req/Ind Rsp/Cnf Comment\nPRJobID M M User supplied Job ID. Must be unique among jobs known by the processing\nresource or else the resource shall reject the create request.\nPRMtlType M - May be NULL when no material is processed.\n(List of)\nPRMtlName\nM - An ordered list that associates a set materials with process conditions (process\nprograms or recipes).\nPRRecipe M - This is a structure.\nPRProcessStart M - Indicates auto or manual start.\nPRPauseEvent M - If null, then processing will not be automatically paused.\nPRStatus - M Indicates success or failure."),(0,a.yg)("ol",{start:10},(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"4.3  PRJobMultiCreate \u2014 This service creates multiple process jobs.  Each job can be created uniquely.\nTable 9  PRJobMultiCreate Service Detail\nParameter  Req/Ind Rsp/Cnf Comment\n(List of)\nPRJobMultiSpec\nM C An ordered list of job specifications as follows:\n(list of)\nStructure:\nPRJobID\nPRMtlType\n(List of) PRMtlName\nPRRecipe\nPRProcessStart\nPRPauseEvent\n(list of) PRJobID - M Shall be returned for process jobs specified in the request service\nthat the equipment created.\nPRStatus - M Indicates success or failure.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"4.4  PRJobDequeue \u2014 Remove one or more jobs from the queue. PRStatus shall indicate any jobs which could\nnot be removed because they either did not exist or were in the PR JOB ACTIVE state.\nTable 10  PRJobDequeue Service Detail\nParameter  Req/Ind Rsp/Cnf Comment\nPRJobList M M (List of) PRJobID\nIn the request, PRJobList specifies the jobs to be removed. In the reply,\nPRJobList indicates the jobs successfully removed.\nPRStatus - M Indicates success or failure.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"4.5  PRJobCommand \u2014 All of the process job commands described in Section 8.2.3 are communicated using the\nPRJobCommand service. The commands are Abort, Stop, Cancel, Pause, Resume, and Start Process. This standard\ndoes not specify any required parameters. Abort is the only command which is required to be supported.\nTable 11  PRJobCommand Service Detail\nParameter                    Req/Ind                    Rsp/Cnf                    Comment\nPRJobID M - Identifies the process job on which to perform the command.\nPRCmdName                                    M                                    -\n(List of) CmdParameter C - Dependent on the command selected."))),(0,a.yg)("p",null,"SEMI E40-0705 \xa9 SEMI 1995, 2005 22\nParameter                    Req/Ind                    Rsp/Cnf                    Comment\nPRStatus                                            -                                            M"),(0,a.yg)("ol",{start:10},(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"4.6  PRJobAlert \u2014 Notification of process job milestones achieved by the processing resource are communicated\nusing the PRJobAlert service. Process job milestones, which are described in \xb68.2.1, are events which are important\nto  the  control  and  tracking  of  the  process  job.  The  milestones  required  to  be  supported  are  PR  Job  Setup,  PR  Job\nProcessing, PR Job Processing Complete, and PR Job Complete. An additional milestone, PR Job Waiting for Start,\nis used with the manual start option.\nTable 12  PRJobAlert Service Detail\nParameter                    Req/Ind                    Comment\nTimestamp M\nPRJobID M Identifies the process job on which the milestone has been reached.\nPRJobMilestone                                M\nPRStatus M")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"4.7  PRJobEvent \u2014 Process job informational event notification, which is described in \xb68.2.2, is communicated\nusing  the  PRJobEvent  service.  These  are  defined  for  Waiting  for  Material  and  Process  Job  State  Change  events.\nSupport for informational events is not required.\nTable 13  PRJobEvent Service Detail\nParameter                    Req/Ind                    Comment\nPREventID M\nTimestamp                                        M\nPRJobID M Identifies the process job which generated the event.\nPREventData C")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"4.8  PRJobSetRecipeVariable  \u2014  Sends  a  request  to  change  the  settings  for  a  list  of  recipe  variable  parameters.\nImplementation of this service is optional.\nTable 14  PRJobSetRecipeVariable Service Detail\nParameter  Req/Ind Rsp/Cnf Comment\nPRJobID                                          M                                          -\nRecVariableList                              M                              -                              (list                              of)\nRecipeVariable\nPRStatus - M Indicates success or failure.  Failure is if a variable can\u2019t be set.  A\nList of variables which could not be set is returned in the status.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"4.9  PRJobSetStartMethod  \u2014  Sends  a  request  to  change  the  start  method  for  job(s).    This  request  will  fail  if  a\nspecified job is not in the QUEUED/POOLED state.  Implementation of this service is optional.\nTable 15  PRJobSetStartMethod Service Detail\nParameter  Req/Ind Rsp/Cnf Comment\nPRJobList M - (List of) PRJobID\nPRProcessStart M - Indicates auto or manual start.\nPRStatus - M Indicates success or failure."))),(0,a.yg)("p",null,"SEMI E40-0705 \xa9 SEMI 1995, 2005 23\n10. 4.10  PRGetAllJobs \u2014 This message shall return a list containing job identifiers and the associated states of those\njobs for all jobs which have not completed.\nTable 16  PRGetAllJobs Service Detail\nParameter                        Req/Ind                        Rsp/Cnf                        Comment\nPRJobList                                                  -                                                  M"),(0,a.yg)("ol",{start:10},(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"4.11  PRGetSpace  \u2014  This  message  shall  return  the  remaining  number  of  jobs  that  can  be  created  for  the\nprocessing resource.\nTable 17  PRGetSpace Service Detail\nParameter                       Req/Ind                       Rsp/Cnf                       Comment\nPRJobSpace                                             -                                             M")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"4.12  PRSetMtrlOrder \u2014 Request the Processing Management Service to use a specific strategy for the order in\nwhich materials are processed.\nTable 18  PRSetMtrlOrder Service Detail\nParameter                   Req/Ind                   Rsp/Cnf                   Comment\nPRMtrlOrder M - Sets the value for the strategy the service will use.\nPRAck - M Indicates success or failure.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"5  Mapping  of  Semantics  to  Syntax  \u2014  Table  20  provides  the  correspondence  between  the  message  semantics\ndefined in Section 8.2 and the syntax as defined in Section 10.4. The use of \u2018.req\u2019, \u2018.rsp\u2019, or \u2018.nfy\u2019 suffixes shows the\ndirection  of  message  flow.  \u2018.req\u2019  is  a  message  request  from  the  service  user  to  the  service  provider.  \u2018.rsp\u2019  is  a\nresponse message from the service provider to the service user. \u2018.nfy\u2019 is a notification from the service provider to\nthe service user.\nTable 19  Correspondence of Message Semantics to Syntax\nParameter                                                                                        Comment\nPR Job Create PRJobCreate.req\nPR Job Create Acknowledge PRJobCreate.rsp\nPR Job Setup PRJobAlert.nfy (PRJobMilestone = PR Job Setup)\nPR Job Processing PRJobAlert.nfy (PRJobMilestone = PR Job Processing)\nPR Job Processing Complete PRJobAlert.nfy (PRJobMilestone = PR Job ProcessingComplete)\nPR Job Complete PRJobAlert.nfy (PRJobMilestone = PR Job Complete)\nPR Job Waiting for Material PRJobEvent.nfy (PREventID = Waiting for Material)\nPR Job State Changes PRJobEvent.nfy (PREventID = Process Job State Change)\nPR Job Abort PRJobCommand.req (PRCmdName = ABORT)\nPR Job Stop PRJobCommand.req (PRCmdName = STOP)\nPR Job Cancel PRJobCommand.req (PRCmdName = CANCEL)\nPR Job Pause PRJobCommand.req (PRCmdName = PAUSE)\nPR Job Resume PRJobCommand.req (PRCmdName = RESUME)\nPR Job Waiting for Start PRJobAlert.nfy (PRJobMilestone = PR Job Waiting for Start)\nPR Job Start Process PRJobCommand.req (PRCmdName = STARTPROCESS)\nPR Job Start Acknowledge PRJobCommand.rsp (PRSatus.PRAck = TRUE)"))),(0,a.yg)("p",null,"SEMI E40-0705 \xa9 SEMI 1995, 2005 24\n11  Variable Data\n11. 1  The  purpose  of  this  section  is  to  define  the  list  of  variable  data  requirements  for  Processing  Management\ncompliant equipment.  Values of these variables are available to the host via collection event reports.\n11. 2  Variable Data Definitions \u2014 The identifier and all other attributes of the ProcessJob object shall be available\nfor  inclusion  in  event  reports  associated  with  it.  The  following  attributes  are  most  likely  to  be  used:  PRJobID,\nPRJobState, RecID, RecVariableList and PRMtlNameList.\n12  Compliance\n12. 1  Processing  management  defines  the  standard  services  available  to  achieve  job-based  material  processing  in\nequipment.  The  capabilities  supported  allow  flexible  management  of  automated  processing  encompassing  many\nprocess types. Only a subset of these capabilities may be needed for a particular implementation.\n12. 2  Fundamental   Requirements   \u2014   All   processing   agent   implementations   shall   support   the   fundamental\nrequirements. These have been indicated in the appropriate sections of the document and are listed together below:\n\u2022 Create and execute a single process job to completion, given:\n\u2022 a single material of the appropriate type, uniquely identified.\n\u2022 a unique recipe identifier for which the corresponding recipe can be found.\n\u2022 Detect and report the success or failure of the process job, indicating complete, partial, or non-processing of the\nmaterial.\n\u2022 Support Abort of the process job at all times, immediately ceasing activity and terminating the process job.\n\u2022 Maintain the data of required process job attributes indicated in Table 2.\n\u2022 Reject requests with incomplete or invalid parameters.\n\u2022 Reject requests for capabilities not supported.\n\u2022 Implement the services and messages with the exception of those required for the Optional capabilities.\n12. 2.1  Satisfying  fundamental  requirements  may  not  provide  sufficient  flexibility  or  performance  for  some\nequipment. In such cases, fundamental functionality should be supplemented by optional capabilities as appropriate\nto the needs of the system.\n12. 3  Additional Capabilities \u2014 Optional capabilities defined or enabled in this standard include:\n\u2022 Processing resource pre-conditioning and post-conditioning.\n\u2022 Stop, Pause, and Resume of a process job.\n\u2022 Manual process start.\n\u2022 Process job queuing and Cancel on a queued job.\n\u2022 Process tuning.\n\u2022 Processing of material groups.\n\u2022 Multiple concurrent process jobs.\n\u2022 Multiple consecutive process jobs in a single visit.\n\u2022 Process job with no material.\n\u2022 Notification of waiting for material.\n\u2022 Implement PRJobCreateEnh and PRJobMultiCreate.\n\u2022 Report the process job milestones:  Setup, Processing, Processing Complete, and Job Complete."),(0,a.yg)("p",null,"SEMI E40-0705 \xa9 SEMI 1995, 2005 25\n12. 3.1  The  services  are  defined  with  mechanisms  to  reject  unsupported  services  and  options  should  they  be\nrequested.  This  improves  robustness  and  enables  sophisticated  service-users  to  adjust  their  requests  to  the\ncapabilities of the particular processing agent.\n12. 4  Table 21 provides a checklist for Processing Management (PM) compliance.\nTable 20  PM Compliance Statement\nFundamental PM Requirements PM Section                    Implemented                    PM                    Compliant\nSingle Process Job Execution 8.2 \x86 Yes   \x86 No \x86 Yes   \x86 No\nProcess Job Failure Indication 8.2.1.7 \x86 Yes   \x86 No \x86 Yes   \x86 No\nAbort Command 8.2.3.2 \x86 Yes   \x86 No \x86 Yes   \x86 No\nProcess Job Object Implementation                                   8.3,                                   9                                   \x86 Yes   \x86 No \x86 Yes   \x86 No\nReject Invalid/Incomplete Parameters 8.2.1.2.1 \x86 Yes   \x86 No \x86 Yes   \x86 No\nReject Unsupported Capabilities 11.2 \x86 Yes   \x86 No \x86 Yes   \x86 No\nServices Implementation (not per Additional) 10 \x86 Yes   \x86 No \x86 Yes   \x86 No\nAdditional PM Capabilities PM Section                    Implemented                    PM                    Compliant\nProcess Job Milestones 8.2.1 (except 8.2.1.2,3) \x86 Yes   \x86 No \x86 Yes   \x86 No\nResource Pre/Post-conditioning  \x86 Yes   \x86 No \x86 Yes   \x86 No\nStop, Pause and Resume Commands 8.2.3.3,4,5 \x86 Yes   \x86 No \x86 Yes   \x86 No\nManual Process Start 8.2.3.9 \x86 Yes   \x86 No \x86 Yes   \x86 No\nProcess Job Queuing 8.3 \x86 Yes   \x86 No \x86 Yes   \x86 No\nProcess Tuning 7.5, 10.4.9 \x86 Yes   \x86 No \x86 Yes   \x86 No\nProcessing of Material Groups 7.6 \x86 Yes   \x86 No \x86 Yes   \x86 No\nMultiple Concurrent Process Jobs 7.7 \x86 Yes   \x86 No \x86 Yes   \x86 No\nMultiple Consecutive Process Jobs 7.8 \x86 Yes   \x86 No \x86 Yes   \x86 No\nProcess Job with No Material 7.9 \x86 Yes   \x86 No \x86 Yes   \x86 No\nEvent Notification 8.2.2 \x86 Yes   \x86 No \x86 Yes   \x86 No\nEnhanced Job Creation 10.4.2 \x86 Yes   \x86 No \x86 Yes   \x86 No\nMultiple Job Creation 10.4.3 \x86 Yes   \x86 No \x86 Yes   \x86 No"),(0,a.yg)("p",null,"NOTICE: SEMI makes no warranties or representations as to the suitability of the standards set forth herein for any\nparticular  application.  The  determination  of  the  suitability  of  the  standard  is  solely  the  responsibility  of  the  user.\nUsers  are  cautioned  to  refer  to  manufacturer\u2019s  instructions,  product  labels,  product  data  sheets,  and  other  relevant\nliterature respecting any materials mentioned herein. These standards are subject to change without notice.\nThe  user\u2019s  attention  is  called  to  the  possibility  that  compliance  with  this  standard  may  require  use  of  copyrighted\nmaterial  or  of  an  invention  covered  by  patent  rights.  By  publication  of  this  standard,  SEMI  takes  no  position\nrespecting  the  validity  of  any  patent  rights  or  copyrights  asserted  in  connection  with  any  item  mentioned  in  this\nstandard. Users of this standard are expressly advised that determination of any such patent rights or copyrights, and\nthe risk of infringement of such rights, are entirely their own responsibility."),(0,a.yg)("p",null,"Copyright   by   SEMI\xae   (Semiconductor   Equipment   and   Materials\nInternational), 3081 Zanker Road, San Jose, CA 95134. Reproduction of\nthe  contents  in  whole  or  in  part  is  forbidden  without  express  written\nconsent of SEMI."),(0,a.yg)("p",null,"SEMI E40.1-0705 \xa9 SEMI 1996, 2005 1\nSEMI E40.1-0705\nSECS-II SUPPORT FOR PROCESSING MANAGEMENT STANDARD\nThis  standard  was  technically  approved  by  the  global  Information  &  Control  Committee.    This  edition  was\napproved for publication by the global Audits and Reviews Subcommittee on April 7, 2005.  It was available\nat ",(0,a.yg)("a",{parentName:"p",href:"http://www.semi.org"},"www.semi.org")," in June 2005 and on CD-ROM in July 2005.  Originally published in 1995; last published in"),(0,a.yg)("h1",{id:"2004"},"2004"),(0,a.yg)("ol",{start:2004},(0,a.yg)("li",{parentName:"ol"},"1  Purpose"),(0,a.yg)("li",{parentName:"ol"},"1  This document maps the services and data of SEMI E40 to SECS-II streams and functions and data definitions.\n2  Scope"),(0,a.yg)("li",{parentName:"ol"},"1  This  is  the  standard  way  to  implement  the  Processing  Management,  which  provides  remote  control  of  wafer\nprocessing, using the SECS-II message protocol.\nNOTICE:  This  standard  does  not  purport  to  address  safety  issues,  if  any,  associated  with  its  use.    It  is  the\nresponsibility  of  the  users  of  this  standard  to  establish  appropriate  safety  and  health  practices  and  determine  the\napplicability of regulatory or other limitations prior to use.\n3  Referenced Standards and Documents"),(0,a.yg)("li",{parentName:"ol"},"1  SEMI Standards\nSEMI E5 \u2014 SEMI Equipment Communications Standard 2 Message Content (SECS-II)\nSEMI E40 \u2014 Standard for Processing Management\nNOTICE: Unless otherwise indicated, all documents cited shall be the latest published versions.\n4  Terminology"),(0,a.yg)("li",{parentName:"ol"},"1  None.\n5  Mapping of Processing Services\nTable 1  Processing Management Messages Mapping\nService Message Name Stream, Function SECS-II Name\nPRJobCreate request S16F3,F4 Process Job Create Request/Acknowledge\nPrJobCommand request S16F5,F6 Process Job Command Request/Acknowledge\nPRJobAlert notify If E30 style events:\nS6F11,F12\nIf E40 style alerts:\nS16F7,F8\nIf E53 style events:\nS6F11,F12\nS6F13,F14\nIf E30 style events:\nEvent Report Send/Acknowledge\nIf E40 style alerts:\nProcess Job Alert Notify/Confirm\nIf E53 style events:\nEvent Report Send/Acknowledge\nAnnotated Event Report Send/Ack\nPRJobEvent notify If E30 style events:\nS6F11,F12\nIf E40 style events:\nS16F9,F10\nIf E53 style events:\nS6F11,F12\nS6F13,F14\nIf E30 style events:\nEvent Report Send/Acknowledge\nIf E40 style events:\nProcess Job Event Notify/Confirm\nIf E53 style events:\nEvent Report Send/Acknowledge\nAnnotated Event Report Send/Ack\nPRSetMtrlOrder request S16F29,30 Process Job Set Material Order\nPRJobCreateEnh                                       S16F11/F12                                       PRJobCreateEnh\nPRJobMultiCreate                                     S16F15/F16                          PRJobMultiCreate")),(0,a.yg)("p",null,"SEMI E40.1-0705 \xa9 SEMI 1996, 2005 2\nService Message Name Stream, Function SECS-II Name\nPRJobDequeue                                          S16F17/F18                                          PRJobDequeue\nPRGetAllJobs                                            S16F19/F20                                            PRGetAllJobs\nPRGetSpace                                              S16F21/F22                                              PRGetSpace\nPRJobSetRecipeVariable                          S16F23/F24                          PRJobSetRecipeVariable\nPRJobSetStartMethod                               S16F25/F26                          PRJobSetStartMethod"),(0,a.yg)("p",null,"6  Mapping of Processing Parameter\nTable 2  Data Item Mapping\nService Parameter SECS-II Data Item\nPrJobID                                                                                           PRJOBID\nPRMtlType                                                                                     MF\nPRMtlName                                                                                    MID\nPRAck                                                                                            ACKA\nPRRecipeMethod                                                                            PRRECIPEMETHOD\nRecID                                                                                              RCPSPEC\nRecipeVarName                                                                             RCPPARNM\nRecipeVarValue                                                                             RCPPARVAL\nPRProcessStart                                                                               PRPROCESSSTART\nPRCmdName                                                                                  PRCMDNAME\nPRJobMilestone If E30 style events:\nCEID\nIf E40 style alerts:\nPRJOBMILESTONE\nIf E53 style events:\nCEID\nPRJobState                                                                                      PRSTATE\nTimestamp                                                                                      TIMESTAMP\nPREventID If E30 style events:\nCEID\nIf E40 style events:\nPREVENTID\nIf E53 style events:\nCEID\nCmdParmName                                                                              CPNAME\nCmdParmVal                                                                                  CPVAL\nPRMtrlOrder                                                                                   PRMTRLORDER\nErrorCode                                                                                       ERRCODE\nErrorText                                                                                        ERRTEXT\nPREventData V (SV, ECV, DVVAL)\nPRJobSpace                                                                                    PRJOBSPACE\nPRPauseEvent                                                                                PRPAUSEEVENT"),(0,a.yg)("p",null,"7  Variable Data Item Mapping\n7. 1  This  section  shows  the  specific  SECS-II  data  classes,  and  formats  needed  for  SECS-II  implementations  of\nSEMI  E40  variable  data.    According  to  SEMI  E40  \xa711,  all  ProcessJob  object  attributes  are  to  be  available  as\nvariables for Process Job state transition events.  These variables will be of SEMI E5 data item DVVAL."),(0,a.yg)("p",null,"SEMI E40.1-0705 \xa9 SEMI 1996, 2005 3\n8  Implementation Details\n8. 1  Use of Object Services \u2014 Several capabilities of the Processing Management Services are accessed through the\nObject Services Standard. Whan a Process Job has been created, (PRJOBID is valid), then its attributes can be read\nand written using the Object Services GetAttr and SetAttr messages.\n8. 1.1  E39 Object Services shall be used for access to ProcessJob attributes.  The GetAttr service may be used for all\nProcessJob attributes and the SetAttr service may be used on only those attributes whose Access is set to RW.\n8. 2  Multi-Block  Messages \u2014  Processing  Management  Services  is  protocol  independent  and  therefore,  makes  no\nmention  of  SECS-II  multi-block  access  and  grant  messages.  When  these  Service  use  the  SECS-II  protocol,  then\nS16F3,F5 shall be preceded by an S16F1/S16F2 access request/grant message exchange when the message will be\nmulti-block.\n9  SECS-II Attribute Definitions\n9. 1  Process  Job  Object  SECS-II  Attributes  Definitions  \u2014  The  following  are  the  SECS-II  structure  definitions  for\nthe E40 ProcessJob object.\nTable 3  Process Job SECS-II Attribute Definitions\nAttribute Name Attribute Data Form: SECS-II Structure\n\u201cObjID\u201d PRJOBID  (Conforms to the restrictions of ObjID as specified in SEMI E39.1, \xa76.)\n\u201cObjType\u201d                                           \u201cProcessJob\u201d\n\u201cPauseEvent\u201d L,n     n=number of collection events"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"CEID\n1")),(0,a.yg)("p",null,"...\nn. CEID\nn"),(0,a.yg)("p",null,"CEID restricted to format U()\n\u201cPRJobState\u201d                                       PRSTATE PRJobState\nPRSTATE enumerated as follows:\n51 (U1)\nEnumerations:\n0 \u2013 QUEUED/POOLED\n1 \u2013 SETTING UP\n2 \u2013 WAITING FOR START\n3 \u2013 PROCESSING\n4 \u2013 PROCESS COMPLETE\n5 \u2013 (Reserved)\n6 \u2013 PAUSING\n7 \u2013 PAUSED\n8 \u2013 STOPPING\n9 \u2013 ABORTING\n10 \u2013 STOPPED\n11 \u2013 ABORTED"),(0,a.yg)("p",null,"SEMI E40.1-0705 \xa9 SEMI 1996, 2005 4\nAttribute Name Attribute Data Form: SECS-II Structure\n\u201cPRMtlNameList\u201d                               When                               MF = 13 (0x0d) (carriers)\nL,n     n=number of carriers"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"L,2")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"CARRIERID\n1")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"L,j     j=number of slots")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"SLOTID\n1"))),(0,a.yg)("p",null,":\nj. SLOTID\nj"),(0,a.yg)("p",null,":\nn. L,2"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"CARRIERID\nn")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"L,k     k=number of slots")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"SLOTID\n1"))),(0,a.yg)("p",null,":\nk. SLOTID\nk"),(0,a.yg)("p",null,"When MF = 14 (0x0e) (substrate)\nL,n     n=number of material (substrate)"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"MID\n1\nsubstrate ID\n...\nn. MID\nn")),(0,a.yg)("p",null,"MID restricted to format A\n\u201cPRMtlType\u201d                                       MF\nMF restricted to format B\nMF Value Description\n13 (0x0d) carriers (e.g. FOUP, SMIF pod, cassette)\n14 (0x0e) substrate (e.g. wafer, mask, flat panel)\nother  not valid for E40 material\n\u201cPRProcessStart\u201d                                 PRPROCESSSTART\n\u201cPRRecipeMethod\u201d PRRECIPEMETHOD\n\u201cRecID\u201d                                               RCPSPEC\n\u201cRecVariableList\u201d L,n                n=number of recipe variables"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"L,2")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"RCPPARNM\n1")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"RCPPARVAL\n1"))),(0,a.yg)("p",null,"...\nn. L,2"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"RCPPARNM\nn")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"RCPPARVAL\nn"))),(0,a.yg)("p",null,"NOTICE: SEMI makes no warranties or representations as to the suitability of the standard set forth herein for any\nparticular  application.    The  determination  of  the  suitability  of  the  standard  is  solely  the  responsibility  of  the  user.\nUsers  are  cautioned  to  refer  to  manufacturer\u2019s  instructions,  product  labels,  product  data  sheets,  and  other  relevant\nliterature respecting any materials mentioned herein.  These standards are subject to change without notice.\nThe  user\u2019s  attention  is  called  to  the  possibility  that  compliance  with  this  standard  may  require  use  of  copyrighted\nmaterial  or  of  an  invention  covered  by  patent  rights.    By  publication  of  this  standard,  SEMI  takes  no  position\nrespecting  the  validity  of  any  patent  rights  or  copyrights  asserted  in  connection  with  any  item  mentioned  in  this\nstandard.  Users of this standard are expressly advised that determination of any such patent rights or copyrights, and\nthe risk of infringement of such rights, are entirely their own responsibility."),(0,a.yg)("p",null,"Copyright   by   SEMI\xae   (Semiconductor   Equipment   and   Materials\nInternational), 3081 Zanker Road, San Jose, CA 95134. Reproduction of\nthe  contents  in  whole  or  in  part  is  forbidden  without  express  written\nconsent of SEMI."),(0,a.yg)("p",null,"SEMI E41-95 \xa9 SEMI 19951\nSEMI E41-95\nEXCEPTION MANAGEMENT (EM) STANDARD\n1  Purpose"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"1   Interactive  exception  handling   enhances  the  error\nrecovery ability while maintaining automated control in\nthe      factory.      This      standard      addresses      the\ncommunications    needs    within    the    semiconductor\nmanufacturing  environment  with  respect  to  equipment\nexception handling."),(0,a.yg)("li",{parentName:"ol"},"2  This standard specifies capabil ities to be provided\nby   the   exception   agent   for   effective   reporting   and\ninteraction  with  respect  to  abnormal  situations  in  the\nequipment.   It   describes   the   concept   of   exception\nmanagement,  the  behavior of the equipment in relation\nto  interactive  exception  handling,  and  the  messaging\nservices which are needed to provide the functionality."),(0,a.yg)("li",{parentName:"ol"},"3   The  communications  services   defined  here  will\nenable  standards-based  interoperability  of  independent\nsystems.  They  shall  allow  application  software  to  be\ndeveloped  which  can  assume  the  existence  of  these\nservices  and  allow  software  products  to  be  developed\nwhich offer them."),(0,a.yg)("li",{parentName:"ol"},"4       Implementation      of      automated       exception\nmanagement  will  help  reduce  error  recovery  time  and\navoid  changing  from  automatic  to  manual  equipment\ncontrol   in   many   situations.   The   adoption   of   the\nstandards   described   will   greatly   reduce   the   effort\nrequired to integrate compliant equipment components.\nCompliance requires a specific set of standard services.\n2  Scope"),(0,a.yg)("li",{parentName:"ol"},"1   The  current  scope  of  this  stand ard  is  interactive\nexception handling within a cluster tool."),(0,a.yg)("li",{parentName:"ol"},"2  While the functionality provid ed may be applied to\nother  multi-resource  equipment,  it  may  not  provide  the\nflexibility   required   for   automated   management   and\ncommand by the factory of all types of equipment. It is\nanticipated   that   this   standard   will   be   extended   to\naccommodate management of exceptions in other types\nof  multi-resource  equipment  and  by  the  factory  of  all\ntypes of equipment."),(0,a.yg)("li",{parentName:"ol"},"3     This    standard    supports    excepti on    condition\nreporting,  including  alarms,  by  an  exception  agent  to  a\ndecision  authority.  The  exception  agent  also  has  the\nability   to   enable   and   disable   reporting   on   each\nexception condition."),(0,a.yg)("li",{parentName:"ol"},"4     Interactive    exception    handling     is    supported\nthrough  selection  by  the  decision  authority  of  recovery\nactions  in  certain  situations.  The  recovery  actions  are\nperformed  by  the  exception  agent  with  the  goal  of\nresolving  the  abnormal  situation  and  allowing  normal\nequipment operation to continue."),(0,a.yg)("li",{parentName:"ol"},"5    This   standard   presents   a   soluti on   from   the\nconcepts and behavior down to the messaging services.\nIt does not define the messaging protocol."),(0,a.yg)("li",{parentName:"ol"},"6   A  messaging  service  includes   the  identification\nthat a message shall be exchanged and definition of the\ndata  which  is  contained  in  that  message.  It  does  not\ninclude  information  on  the  structure  of  the  message,\nhow the data is represented within the message, or how\nthe  message  is  exchanged.  This  additional  information\nis contained within the message protocol."),(0,a.yg)("li",{parentName:"ol"},"7   The  defined  services  may  be  a pplied  to  multiple\nprotocols.  Information  on  the  mapping  of  exception\nmanagement  services  to  special  protocols  (e.g.,  SECS-\nII) are added as adjunct standards."),(0,a.yg)("li",{parentName:"ol"},"8      The     services     assume     a     commu nications\nenvironment  in  which  a  reliable  connection  has  been\nestablished  between  the  user  of  the  services  and  the\nprovider   of   the   services.   Establishing,   maintaining,\nreleasing  a  connection,  and  handling  communication\nfailures is beyond the scope of this standard.\n3  Referenced Standards"),(0,a.yg)("li",{parentName:"ol"},"1  SEMI Standards"),(0,a.yg)("li",{parentName:"ol"},"2   The  following  SEMI\n1")),(0,a.yg)("p",null,"standard   is  related  to  the\nException Management standard:\nSEMI    E5    \u2014    SEMI    Equipment    Communications\nStandard 2 Message Content (SECS-II)\n4  Definitions\nThe  following  definitions  are  arranged  in  alphabetical\norder.  Some are defined using terms defined elsewhere\nwithin  this  section.  No  references  beyond  this  section\nshould  be  necessary  for  a  basic  understanding  of  these\nterms.\nagent  \u2014  an  intelligent  system  within  a  factory  that\nprovides  one  or  more  service  resources  and  uses  the\nservices   of   other   agents.   A   generalization   of   host,\nequipment,    cell,    cluster,    cluster    module,    station\ncontroller,  work  station.  Agents  are  associated  with  a\nphysical  system  or  a  collection  of  physical  systems,\nincluding computer platforms."),(0,a.yg)("p",null,"1 These documents can be obtained from Semiconductor Equipment\nand Materials International, 3081 Zanker Road, San Jose, CA 95134,\n408. 943.6900."),(0,a.yg)("p",null,"SEMI E41-95 \xa9 SEMI 19952\nalarm  \u2014  an  alarm  is  related  to  any  abnormal  situation\nof the equipment that may endanger people, equipment,\nor material being processed.\nclearing   \u2014   exception   agent   to   decision   authority\nreporting   that   an   abnormal   situation   related   to   an\nexception condition is no longer apparent or relevant.\ndecision  authority  \u2014  an  entity  requiring  to  be  notified\nof  significant  exception  condition  changes  and  which\ndecides  how  to  proceed  to  resolve  abnormal  situations\nrelated  to  recoverable  error  conditions.  The  decision\nauthority    may    be    represented    by    a    supervisory\ncontroller   interacting   with   an   operator   who   may\nultimately choose the recovery action.\nerror  condition \u2014 an exception condition which is not\nan  alarm  and  which  may  support  recovery  actions\nrequested by a decision authority.\nexception  agent  \u2014  the  entity  which  manages  access  to\nand  reporting  of  information  on  abnormal  situations  in\nequipment.   It   achieves   this   by   defining   exception\nconditions,   each   related   to   a   significant   abnormal\nsituation.   It   may   provide   services   for   a   decision\nauthority to direct the recovery from certain situations.\nexception  condition  \u2014  a  condition  managed  by  an\nexception  agent  for  reporting  on  and  recovery  from  an\nabnormal situation in the equipment.\nform \u2014 type of data representing information contained\nin an object attribute or service message parameter. The\ndata types are detailed in Section 4.1.\nfundamental   requirements   \u2014   the   requirements   for\ninformation  and  behavior  that  must  be  satisfied  for\ncompliance with a standard. Fundamental requirements\napply   to   specific   areas   of   application,   objects,   or\nservices.\nposting  \u2014  all  exception  agent  to  decision  authority\nreporting  associated  with  an  exception  condition  while\nthe related abnormal situation is apparent and relevant.\nrecovery action \u2014 an operation associated with an error\ncondition   with   the   aim   of   resolving   the   abnormal\nsituation  detected.  It  may  supply  information  to  the\nexception   agent   or   request   the   exception   agent   to\nperform some activity.\nservice  \u2014  the  set  of  messages  and  definition  of  the\nbehavior  of  a  service  provider  that  enables  remote\naccess to a particular functionality.\nservice-provider  \u2014  the  software  control  entity  that  is\nthe provider of any of the related services.\nservice-user  \u2014  the  software  control  entity  that  is  the\nuser of any of the related services.\n4. 1  Data Type\nform \u2014 type of data:  positive integer, unsigned integer,\ninteger,   enumerated,   boolean,   text,   formatted   text,\nstructure, list, ordered list.\npositive  integer  \u2014  may  take  the  value  of  any  positive\nwhole number. Messaging protocol may impose a limit\non the range of possible values.\nunsigned integer  \u2014  may  take  the  value  of  any  positive\ninteger or zero. Messaging protocol may impose a limit\non the range of possible values.\ninteger  \u2014  may  take  on  the  value  of  any  negative  or\nunsigned  integer.  Messaging  protocol  may  impose  a\nlimit on the range of possible values.\nenumerated  \u2014  may  take  on  one  of  a  limited  set  of\npossible  values.  These  values  may  be  given  logical\nnames, but they may be represented by any single-item\ndata type.\nboolean  \u2014  may  take  on  one  of  two  possible  values,\nequating to TRUE or FALSE.\ntext  \u2014  a  text  string.  Messaging  protocol  may  impose\nrestrictions, such as length or ASCII representation.\nformatted  text  \u2014  a  text  string  with  an  imposed  format.\nThis could be by position, by use of special characters,\nor both.\nstructure \u2014 a complex structure consisting of a specific\nset of items, of possibly mixed data types, in a specified\narrangement.\nlist \u2014 a set of one or more items that are all of the same\nform (one of the above forms).\nordered list \u2014 a list for which the order in which items\nappear is significant.\n5  Conventions\n5. 1   Harel  State  Model  \u2014   This  doc ument  uses  the\nHarel  State  Chart  notation  to  describe  the  dynamic\nbehavior  of  the  objects  defined.  An  overview  of  this\nnotation is presented in an Appendix of SEMI E30. The\nformal definition of this notation is presented in Science\nof  Computer  Programming  8,  \u201cStatecharts:  A  Visual\nFormalism for Complex Systems,\u201d by D. Harel, 1987.\nTransition  tables  are  provided  in  conjunction  with  the\nstate  diagrams  to  describe  explicitly  the  nature  of  each\nstate   transition.   A   transition   contains   columns   for\nTransition   #,   Current   State,   Trigger,   New   State,\nAction(s).  The  \u201ctrigger\u201d  (column  3)  for  the  transition\noccurs   while   in   the   \u201ccurrent\u201d   state.   The   \u201cactions\u201d\n(column  5)  include  a  combination  of  (1)  actions  taken\nupon  exit  of  the  current  state,  (2)  actions  taken  upon\nentry  of  the  new  state,  and  (3)  actions  taken  which  are\nmost   closely   associated   with   the   transition.      No\ndifferentiation is made."),(0,a.yg)("p",null,"SEMI E41-95 \xa9 SEMI 19953\n5. 2   Object  Attribute  Representatio n  \u2014   The  object\ninformation  models  for  standardized  objects  will  be\nsupported   by   an   attribute   definition   table   with   the\nfollowing column headings:\nAttribute NameDefinitionAccessRqmtForm\nThe formal text\nname of the\nattribute\nDescription of\nthe information\ncontained\nRO or\nRW\nY or N(see\nbelow)\nThe Access column uses RO (Read Only) or RW (Read\nand Write) to indicate the access that service-users have\nto the attribute.\nA   \u2018Y\u2019   or   \u2018N\u2019   in   the   requirement   (Rqmt)   column\nindicates whether or not this attribute must be supported\nin   order   to   meet   fundamental   compliance   for   the\nservice.\nThe Form column is used to indicates the format of the\nattribute. (See Section 4.1 for definitions.)\n5. 3  Service Message Representatio n\n5. 3.1    Service   Resource   Definition   \u2014    A   service\nresource  definition  table  defines  the  specific  set  of\nmessages  for  a  given  service  group,  as  shown  in  the\nfollowing table:\nMessage Service NameTypeDescription\nMessage NameN or R   The intent of the service.\nType can be either N = Notification or R = Request.\nNotification  type  messages  are  initiated  by  the  service\nprovider,  and  the  provider  does  not  expect  to  get  a\nresponse from the consumer/subscriber.\nRequest messages are initiated by a service consumer or\nsubscriber. Request messages ask for data or an activity\nfrom  the  provider.  Request  messages  expect  a  specific\nresponse  message  (no  presumption  on  the  message\ncontent).\n5. 3.2    Service   Parameter   Dictionary    \u2014    A   service\nparameter  dictionary  table  defines  the  parameters  used\nin a service, as shown in the following table:\nParameterFormDescription\nParameter XData typeA parameter called X is B in A.\nA row is provided in the table for each parameter of the\nservice.  The  first  column  contains  the  name  of  the\nparameter.  This  is  followed  by  columns  describing  the\nform and contents of the corresponding primitive.\nThe  Form  column  is  used  to  indicate  the  type  of  data\ncontained   in   a   parameter.   (See   Section   4.1   for\ndefinitions.)\nThe   Description   column   in   the   Service   Parameter\nDictionary    table    describes    the    meaning    of    the\nparameter,    the    values    it    can    assume,    and    any\ninterrelationships with other parameters.\nTo   prevent   the   definition   of   numerous   parameters\nnamed \u201cXxxList,\u201d this document adopts the convention\nof  referring  to  the  list  as  \u201c(List  of)  Xxx.\u201d  In  this  case,\nthe  definition  of  the  variable  Xxx  will  be  given,  not  of\nthe list. The term \u201clist\u201d indicates a collection (or set) of\nzero or more items of the same data type.  Where a list\nis  used  in  both  the  request  and  the  response,  the  list\norder  in  the  request  is  retained  in  the  response.  A  list\nmust  contain  at  least  one  element  unless  zero  elements\nare specifically allowed.\n5. 3.3    Service   Message   Definition   \u2014    A   service\nmessage definition table defines the parameters used in\na service, as shown in the following table:\nParameterReq/IndRsp/CnfDescription\nParameter X   (see below)    (see below)   A description of the\nservice.\nThe  columns  labeled  Req/Ind  and  Rsp/Cnf  link  the\nparameters   to   the   direction   of   the   message.   The\nmessage  sent  by  the  initiator  is  called  the  \u201cRequest.\u201d\nThe receiver terms this message the \u201cIndication\u201d or the\nrequest.  The  receiver  may  then  send  a  \u201cResponse,\u201d\nwhich the original sender terms the \u201cConfirmation.\u201d\nThe following codes appear in the Req/Ind and Rsp/Cnf\ncolumns and are used in the definition of the parameters\n(e.g., how each parameter is used in each direction):\n\u201cM\u201d \u2014 Mandatory parameter \u2014 must be given a valid\nvalue.\n\u201cC\u201d  \u2014  Conditional  parameter  \u2014  may  be  defined  in\nsome circumstances and undefined in others. Whether a\nvalue  is  given  may  be  completely  optional  or  may\ndepend on the value of another parameter.\n\u201cU\u201d \u2014 User-defined parameter.\n\u201c-\u201d \u2014 The parameter is not used.\n\u201c=\u201d  \u2014  (for  Response  only)  Indicates  that  the  value  of\nthis  parameter  in  the  response  must  match  that  in  the\nprimary (if defined).\n6  Overview\nException     management     is     concerned     with     the\ninteractive handling of equipment exception conditions.\nThis  standard  defines  the  services  provided  by  which"),(0,a.yg)("p",null,"SEMI E41-95 \xa9 SEMI 19954\nabnormal  situations  are  reported  by  an  exception  agent\n(service-provider) to a decision authority (service-user).\nIn   the   case   of   recoverable   situations,   services   are\nprovided  for  a  decision  authority  to  choose  how  to\nproceed to resolve the abnormal situation.\nThe  exception  agent  is  the  equipment  entity  which\nmanages  access  to  and  reporting  of  information  on\nabnormal   situations.   It   achieves   this   by   defining\nexception   conditions,   each   related   to   a   significant\nabnormal situation. All services are defined in terms of\nthese exception conditions.\nException    management    allows    for    the    decision\nauthority   to   direct   the   resolution   of   an   abnormal\nsituation.  The  decision  authority  selects  a  recovery\naction  to  be  performed  to  resolve  the  situation  from\namong    the    options    supplied    with    the    exception\ncondition.  The  exception  agent  performs  the  requested\nrecovery  action,  which  may  or  may  not  resolve  the\nsituation.\nThe   services   are   fully   defined   in   terms   of   the\nfunctionality  provided  by  the  exception  agent  (service-\nprovider) and as such do not dictate the architecture of\nthe decision authority (service-user).\nThis  standard  describes  the  concepts  and  exception\ncondition   model   on   which   the   communications   are\nbased, followed by the detailed behavioral model used.\nIt  then  describes  the  standard  object  attributes  and\nmessage services in detail.\n6. 1   Compliance  \u2014  Compliance  wi th  this  standard\nincludes  adherence  to  all  stated  requirements  in  this\ndocument  where  implemented.  This  includes  defined\nmessage services and state models.\nThere are two levels of compliance defined. The first is\nalarm reporting support. The second extends support to\ninclude  interactive  handling  of  recoverable  exception\nconditions.     Required     capabilities     are     listed     in\nFundamental Requirements, Section 10.4.\n7  Concepts\n7. 1   Exception  Management  Model   \u2014   The  exception\nmanagement   model   describes   the   mechanism   for\ninteractive handling of equipment exception conditions.\nAn  exception  condition  is  a  condition  monitored  in\nequipment by an exception agent (service-provider) for\ndetecting  an  abnormal  situation.  Exception  conditions\nare  limited  in  this  standard  to  those  accessible  by  a\nremote decision authority (service-user).\nAn  exception  condition  is  persistent,  existing  whether\nor  not  the  abnormal  situation  currently  exists.  The\nabnormal   situation   is   indicated   by   the   exception\ncondition state becoming SET. An exception agent is an\nentity  which  manages  remote  decision  authority  access\nto any number of exception conditions. Each exception\ncondition  is  identified  by  a  name  which  is  unique  for\nthe exception agent.\nA  decision  authority  is  a  remote  entity  requiring  to  be\nnotified  of  exception  condition  information  and  which\ndecides  appropriate  actions  to  take  to  resolve  abnormal\nsituations.  The  decision  authority  may  be  represented\nby a supervisory controller interacting with an operator\nwho may ultimately choose the recovery action.\nThe  exception  agent  notifies  the  decision  authority  on\ndetection   of   an   abnormal   situation   related   to   an\nexception  condition  (i.e.,  state  is  SET)  and  again  when\nit  is  no  longer  apparent.  It  also  provides  access  to\nexception condition attribute data and for the execution\nof recovery actions requested by the decision authority.\nException  management  defines  two  types  of  exception\nconditions: alarms and error conditions.\nAn  alarm  is  related  to  any  abnormal  situation  on  the\nequipment  that  may  endanger  people,  equipment,  or\nmaterial  being  processed.  Alarms  do  not  provide  for\ndecision  authority  involvement  in  the  resolution  of  the\nabnormal situation.\nAn  error  condition  is  related  to  any  abnormal  situation\ndetected   which   is   made   accessible   to   a   decision\nauthority.  An  error  condition  may  supply  a  list  of\npossible   recovery   actions   from   which   the   decision\nauthority  can  select  to  attempt  to  resolve  the  abnormal\nsituation,  thereby  resulting  in  the  error  condition  state\nbecoming CLEARED.\nBeing  persistent,  exception  condition  attributes  may  be\nqueried  at  any  time,  and  reporting  of  changes,  such  as\nstate  SET/CLEARED,  can  be  disabled  by  the  decision\nauthority.\n7. 2  Posting and Clearing \u2014 Signi ficant changes in an\nexception   condition   are   reported   to   the   decision\nauthority  if  enabled.  The  major  significant  events  are\nthe transitioning of the exception condition state to SET\nor   CLEARED,   which   indicate   that   the   abnormal\nsituation  has  been  detected  or  is  no  longer  apparent,\nrespectively.\nAll  significant  information  is  sent  when  reporting  that\nthe  exception  condition  state  is  SET.  This  includes  the\nunique   identifier,   type,   a   message   describing   the\nabnormal situation, time and a list of possible recovery\nactions  where  appropriate.  It  is  important  to  keep  the\ndecision   authority   updated   on   exception   condition\ninformation    while    the    abnormal    situation    exists,\nespecially  with  respect  to  valid  recovery  actions.  All\nchanges  in  the  list  of  possible  recovery  actions  are\nreported  to  the  decision  authority  while  the  exception\ncondition state is SET."),(0,a.yg)("p",null,"SEMI E41-95 \xa9 SEMI 19955\nThe  term  posting  is  used  to  describe  all  reporting  the\ntransition  to  the  SET  state  and  while  an  exception\ncondition state is SET.\nClearing   is   the   reporting   of   the   occurrence   of   an\nexception condition state transition to CLEARED. Note\nthat  the  exception  agent,  not  the  decision  authority,\ntransitions      the      state      to      CLEARED.      Any\nacknowledgment  at  the  decision  authority  of  exception\ncondition  posting  (e.g.,  by  the  operator)  is  not  relevant\nto the exception agent.\nException    condition    changes    while    its    state    is\nCLEARED are not reported to the decision authority.\n7. 3     Enable/Disable    Reporting    \u2014     T he    decision\nauthority  may  enable  and  disable  posting  and  clearing\nfor  a  particular  exception  condition  by  setting  and\nresetting  its  enabled  attribute,  respectively.  Reporting\non an exception condition is enabled by default.\nNote  that  the  exception  condition  itself  is  not  being\nenabled  or  disabled,  but  the  reporting  of  its  state  is\nbeing enabled or disabled.\nPosting  of  an  exception  condition  shall  occur  upon\nbeing enabled if the exception condition state is SET.\n7. 4   Recovery  Actions  \u2014  Recovery   actions  provide  a\nmechanism   for   a   decision   authority   to   assist   in\nresolving    an    abnormal    situation    detected    in    the\nequipment.  This  is  generally  needed  to  resolve  failure\nor  conflict  where  information  is  required  beyond  the\ncapabilities of the system. By supplying options related\nto each error condition, error recovery is directed to the\nproblem area.\nOne  or  more  recovery  actions  may  be  associated  with\nan  error  condition.  A  recovery  action  is  any  operation\nwith   the   aim   of   resolving   the   abnormal   situation\ndetected.  It  may  supply  information  to  the  exception\nagent or request it to perform some activity.\nA  recovery  action  may  be  requested  by  the  decision\nauthority  only  when  the  error  condition  state  is  SET.\nOnly  recovery  actions  currently  valid  for  the  error\ncondition are accepted by the exception agent.\nThe  list  of  valid  recovery  actions  is  supplied  in  the\nposting  of  an  error  condition.  Changes  in  this  list  are\nnotified by re-posting. A decision authority may request\nany  of  the  supplied  recovery  actions  to  be  performed\nand  is  notified  of  acceptance  to  perform  the  recovery\nand, some time later, its completion. No more than one\nrecovery action may be in progress on a particular error\ncondition   and   it   may   be   aborted   by   the   decision\nauthority at any time.\nA  recovery  action  does  not  directly  change  the  error\ncondition  state  to  CLEARED.  It  performs  activities  or\nprovides  information  with  the  object  of  removing  the\nabnormal  situation  which  in  turn  changes  the  state  to\nCLEARED.  A  recovery  action  may  continue  after  the\nstate  has  transitioned  to  CLEARED,  until  the  activity\ninitiated has completed. A recovery action is rejected if\nreceived when the error condition state is CLEARED.\nSince   the   exception   agent   must   maintain   system\nintegrity  by  ensuring  that  incompatible  operations  are\nnot  performed  concurrently,  it  may  reject  any  recovery\naction requested.\n8  Behavior\nThis  section  provides  a  high-level  definition  of  the\ncommunications between the decision authority and the\nexception agent used in exception management. It does\nnot  define  the  message  detail,  concentrating  on  the\nconcepts.   The   message   detail   is   addressed   in   the\nMessaging Services section.\n8. 1  Exception Condition Commun ication\n8. 1.1   Exception  Report  Messaging  \u2014   The  message\nflow  for  exception  reporting  is  shown  in  Figure  1.  The\narrows represent significant information exchange.\nFigure 1\nException Reporting Message Flow\nA   detailed   description   of   each   message   used   in\nexception reporting follows:\nEX   Post   \u2014   The   exception   agent   has   detected   an\nabnormal situation which is monitored by an exception\ncondition.   It   changes   the   exception   condition   state\nattribute   to   SET.   The   exception   agent   notifies   the\ndecision   authority   using   the   EX   Post   notification,\nsupplying the following information:\n\u2022 identification of the exception condition,\n\u2022 type of exception,\n\u2022 time,\n\u2022 a message explaining the abnormal situation,\n\u2022 a list of possible recovery actions (where available\nwith error conditions)."),(0,a.yg)("p",null,"SEMI E41-95 \xa9 SEMI 19956\nEX  Post  is  re-sent  every  time  the  message  or  recovery\naction  information  changes  as  long  as  the  exception\ncondition state remains SET.\nThe  EX  Post  notification  is  not  sent  if  reporting  on  the\nexception  condition  is  disabled,  that  is,  if  the  enabled\nattribute is false. The EX Post notification is sent when\nan    exception    condition    becomes    enabled    if    the\nexception condition state is SET.\nUpon receipt of the EX Post, the decision authority has\nthe  information  needed  to  take  the  appropriate  action.\nThis  may  include  requesting  the  exception  agent  to\nperform one of the supplied recovery actions.\nEX  Cleared  \u2014   The  abnormal  situation  detected  by  the\nexception  agent  is  no  longer  apparent  or  relevant.  The\nexception  agent  changes  the  exception  condition  state\nattribute to CLEARED. It notifies the decision authority\nusing   the   EX   Cleared   notification,   supplying   the\nfollowing information:\n\u2022 identification of the exception condition,\n\u2022 type of exception,\n\u2022 time,\n\u2022 a message.\nThe EX Cleared message is not sent if reporting on the\nexception  condition  is  disabled.  That  is,  the  enabled\nattribute is false.\nUpon  receipt  of  the  EX  Cleared,  the  decision  authority\nknows   that   the   abnormal   situation   related   to   the\nexception condition is no longer apparent or relevant.\n8. 1.2   Recovery  Action  Messaging  \u2014   In  this  section,\nthe extended messaging of the recovery action is added\nto  the  reporting  messaging  described  above.  Recovery\nactions  are  not  available  for  alarms.  The  message  flow\nfor recovery actions is shown in Figure 2.\nFigure 2\nRecovery Action Message Flow\nA detailed description of each message used in recovery\nactions follows:\nEX Recover \u2014 The decision authority requests that the\nexception   agent   perform   a   recovery   action.   The\nparticular  recovery  action  selected  is  identified  in  the\nEX Recover request together with the related exception\ncondition  identifier.  It  shall  be  one  of  the  recovery\nactions  supplied  for  the  exception  condition  in  the  EX\nPost notification.\nUpon  receipt  of  the  EX  Recover  request  and  before\nacknowledging,  the  exception  agent  checks  that  the\nspecified recovery action is currently valid. The request\nshall  be  accepted  and  initiated  immediately  or  rejected\nby the exception agent.\nThe exception agent rejects a recovery action request if\nthere  is  already  a  recovery  action  in  progress  on  that\nexception condition.\nEX   Recover   Acknowledge   \u2014    The   exception   agent\nresponds  to  the  decision  authority  that  the  requested\nrecovery  action  is  accepted  or  rejected,  and  if  rejected,\nsupplies text reasons for failure.\nAcceptance  of  a  recovery  action  indicates  that  the\nexception   agent   has   initiated   the   operation.   The\noperation   continues   to   completion   without   further\nintervention  by  the  decision  authority.  The  recovery\naction may or may not result in the exception condition\nstate  changing  to  CLEARED  and  the  recovery  action\nmay continue after the state becomes CLEARED.\nThe  exception  agent  may  reject  a  requested  recovery\naction for a number of reasons, including:\n\u2022 unknown recovery for the exception condition,\n\u2022 recovery currently invalid,\n\u2022 busy with recovery for this exception condition,\n\u2022 currently  unable  to  perform  the  recovery  (e.g.,\nother conflicting activity or failure).\nEX Recovery Complete \u2014  The exception agent declares\nthe   recovery   action   to   be   complete   once   it   has\ncompleted  the  associated  operation.  This  message  is\nalso used when a recovery action ends abnormally. The\nmessage   indicates   whether   the   operation   completed\nnormally  and,  if  not,  supplies  text  reasons  for  the\nfailure.\nNote  that  normal  completion  of  a  recovery  action  does\nnot   indicate   that   the   abnormal   situation   has   been\nresolved.   That   is   indicated   by   the   EX   Cleared\nnotification.\nEX  Recovery  Abort  \u2014   The  decision  authority  may\ncommand the exception agent to abort a recovery action\nat  any  time.  The  goal  of  the  abort  command  is  to  end"),(0,a.yg)("p",null,"SEMI E41-95 \xa9 SEMI 19957\nthe  recovery  action  activities  as  quickly  as  possible.\nThe abort command terminates the recovery action.\n8. 2   Exception  Condition  State  Mo del  \u2014   The behavior\nrequired for exception management is fully specified by\nthe exception agent (service-provider) behavior. This is\ndescribed  by  the  exception  agent  exception  condition\nstate  model.  All  required  decision  authority  (service-\nuser) behavior is inferred by this model.\nMessage   flow   diagrams   presented   in   the   previous\nsection   are   useful   to   show   simple   situations.   The\nexception   condition   state   model   presented   in   this\nsection     provides     the     information     necessary     to\nextrapolate the message flow diagrams for all situations\nwithin the scope of this standard.\nThe  exception  condition  provides  for  exception  agent\nreporting on an abnormal situation in the equipment and\nmanagement  of  a  recovery  action  requested  by  the\ndecision  authority  to  resolve  the  situation.  Recovery  is\nrequested   in   the   context   of   a   particular   exception\ncondition  so  the  recovery  action  behavior  forms  a  part\nof the exception condition behavior.\nFigure  3  shows  the  state  diagram  for  an  exception\ncondition.   The   Harel   state   model   notation   used   is\ndescribed     in     Conventions,     Section     5.1.     The\ncorresponding state transition table is shown in  Table 1\non the following page.\nFigure 3\nException Condition State Model\nThe detailed state definitions follow:\nEXSTATE \u2014  When  created  by  the  exception  agent,  an\nexception  condition  enters  the  EXSTATE.  It  is  in  this\nstate   as   long   as   it   is   in   existence,   irrespective   of\nassociation  to  the  decision  authority.  The  exception\ncondition  has  two  concurrent  subsets,  which  together\nfully describe its state. These subsets are Reporting and\nRecovery.\nThe  exception  condition  initializes  to  the  SET  state  if\nthe    abnormal    situation    related    to    the    exception\ncondition   is   apparent   and   relevant;   otherwise,   it\ninitializes to the CLEARED state.\nReporting  \u2014   Reporting  is  one  concurrent  subset  of\nEXSTATE. It includes the substates describing whether\nthe    abnormal    situation    related    to    the    exception\ncondition  is  apparent  and  relevant,  and  whether  the\nlatest information on the situation has been reported.\nTable 1  Exception Condition Transition Table\n#Current StateTriggerNew StateAction(s)\n1    not EXSTATEThe exception agent creates the\nexception condition.\nEXSTATE\n2    not EXSTATEInitial creation and the abnormal\nsituation is either not apparent or\nirrelevant.\nCLEARED\n3    not EXSTATEInitial creation and the abnormal\nsituation is both apparent and\nrelevant.\nSET\n4    CLEAREDThe abnormal situation is detected.    SET\n5    not SETDefault entry into SET state.NOT POSTED\n6    NOT POSTEDReporting enabled.POSTED Send \u201cEX Post\u201d message.\n7   POSTEDChange in the list of possible\nrecovery actions.\nPOSTED Send \u201cEX Post\u201d message.\n8   SETThe abnormal situation is either no\nlonger apparent or has become\nirrelevant.\nCLEARED Send \u201cEX Cleared\u201d message."),(0,a.yg)("p",null,"SEMI E41-95 \xa9 SEMI 19958\n9   POSTEDReporting disabled.NOT POSTED\n10   not EXSTATEDefault entry into recovery\nconcurrent state at initial exception\ncondition creation.\nNOTRECOVERING\n11   NOTRECOVERING\u201cEXRecover\u201d  message received\nwhile in the SET state and accepted.\nRECOVERINGInitiate requested recovery action\nand execute to completion.\n12   RECOVERINGRecovery action completed.NOTRECOVERING   Send \u201cEX Recovery Complete\u201d\nmessage.\n13   RECOVERING\u201cEXRecoveryAbort\u201d  message\nreceived.\nABORTING-\nRECOVERY\nPerform the abort procedure to\nterminate the recovery action in\nprogress.\n14   ABORTING-RECOVERY   Abort procedure is complete.NOTRECOVERING   Send \u201cEX Recovery Complete\u201d\nmessage.\nCLEARED \u2014  The abnormal situation related to the exception condition is either not apparent or not relevant.\nSET \u2014  The abnormal situation related to the exception condition is apparent and relevant.\nThe  exception  agent  should  generate  a  collection  event  each  time  an  exception  condition  transitions  from\nCLEARED to SET and another from SET to CLEARED.\nNOT  POSTED  \u2014   The  latest  information  on  the  detected  abnormal  situation  has  not  yet  been  reported  by  the\nexception  agent.  This  may  be  transient  on  entering  the  SET  state  or  may  be  because  reporting  is  disabled.  NOT\nPOSTED is the default state when entering the SET state.\nPOSTED \u2014  The latest information on the detected abnormal situation has been reported by the exception agent to\nthe decision authority.\nRecovery \u2014  Recovery  is  one  concurrent  subset  of  EXSTATE.  It  includes  the  substates  describing  the  behavior  in\nrelation to exception condition recovery actions.\nNOTRECOVERING \u2014  In the NOTRECOVERING substate, there is no recovery action in progress directly related\nto the exception condition. NOTRECOVERING is the default state when an exception condition is initially created.\nRecovery actions may only be initiated when the exception condition is in the SET state.\nRECOVERING \u2014  A  recovery  action  related  to  the  exception  condition  is  in  progress  when  in  the  RECOVERING\nstate.\nABORTINGRECOVERY  \u2014  In  the  ABORTINGRECOVERY  substate,  the  abort  procedure  is  performed  to\nimmediately terminate the recovery action. It is the responsibility of the exception agent to cease physical activity as\nquickly as possible, having achieved a safe condition.\n9  Object Definitions\nException management defines one standard object, the Exception Condition.\n9. 1   Exception  Condition  Object  D efinition  \u2014   The  exception  condition  is  a  persistent  object  created  by  the\nexception  agent.  It  provides  the  decision  authority  with  reporting  on,  access  to,  and  the  possibility  to  direct\nresolution  of  an  abnormal  situation  detected.  It  also  tracks  progress  of  a  requested  recovery  action.  The  exception\ncondition is uniquely identified by the EXID attribute.\nThe object attribute notation used in Table 2 is described in Conventions, Section 5.2.\nTable 2  Exception Condition Attributes\nAttribute NameDefinitionRqmtAccessForm\nObjTypeThe object type.YROText:\n\u201cEXCEPTION\u201d\nObjIDException agent unique identifier for the\nexception condition.\nYROText:\nUnique with respect to the exception agent."),(0,a.yg)("p",null,"SEMI E41-95 \xa9 SEMI 19959\nEXTypeIdentifies the type of exception condition.YROEnumerated:\nAlarmError\nEXMessageText message describing the abnormal\nsituation monitored.\nYROText\nEXEnabledIndicates that reporting to the decision\nauthority on the exception condition is\nenabled.\nYRWBoolean:\nTRUE \u2013 Enabled\nFALSE - Disabled\nEXRecActListList of possible recovery actions.NROList of:\nText\nEXStateListAll concurrent sub-states of the exception\ncondition according to the state model in\nFigure 3.\nYROList of:\nText\nEXRecoveryAction  Recovery action which may be requested to\nresolve the abnormal situation.\nNROText\nEXStateA unique sub-state of the exception\ncondition according to the state model in\nFigure 3.\nYROText:\nEXSTATE/CLEARED\nEXSTATE/SET/NOTPOSTED\nEXSTATE/SET/POSTED\nEXSTATE/NOTRECOVERING\nEXSTATE/RECOVERING\nEXSTATE/ABORTINGRECOVERY\n10  Messaging Services Detai l\nThis  section  defines  the  messaging  services  required  to  implement  the  exception  management  concepts.  The\nmessages were introduced in Section 8.1. These services are independent of the messaging protocol used. They may\nbe mapped to SECS-II (SEMI-E5) or to other comparable protocols.\nThese  messaging  services  define  the  messages  to  be  used,  the  nature  of  the  parameters  contained  within  the\nmessages,  and  data  type  of  the  parameters.  Not  defined  here  is  the  internal  structure  of  the  actual  messages  as\ntransferred, including order of the parameters and how various data structures and data types are represented.\nThe service message notation used in the tables below is described in Conventions, Section 5.3.\n10. 1  Service List \u2014  The messages s hown in Table 3 are exchanged between service-provider and service-user for\nthe purpose of accomplishing exception management tasks.\nTable 3  Service List\nMessage NameTypeDescription\nEXPostNNotification by the exception agent that the abnormal situation related to the exception\ncondition has been detected or significant information has changed while the situation exists.\nEXClearedNNotification by the exception agent that the abnormal situation related to the exception\ncondition is no longer apparent or relevant.\nEXRecoverRDecision authority request that a particular recovery action be performed.\nEXRecoveryComplete    NNotification by the exception agent that a recovery action has completed.\nEXRecoveryAbortRDecision authority request that a recovery action be terminated immediately."),(0,a.yg)("p",null,"SEMI E41-95 \xa9 SEMI 199510\n10. 2  Parameter Dictionary\nTable 4  Parameter Dictionary\nParameter NameDefinitionForm: Possible Values\nErrorCodeContains the code for the specific error found.Enumerated:\nEXRecover:\nParameters improperly specified\nInsufficient parameters specified\nRecovery action currently invalid\nBusy with another recovery\nCurrently unable to perform the recovery\nEXRecoveryAbort:\nParameters improperly specified\nInsufficient parameters specified\nNo active recovery action\nEXRecoveryComplete:\nFailedRecovery aborted\nErrorTextText in support of the error code.Text\nEXAckIndicates whether the request was successful or the activity\ncompleted normally.\nBoolean:\nTRUE \u2013 Successful\nFALSE \u2013 Unsuccessful\nEXIDPersistent exception condition identifier.Text:\nUnique with respect to the exception agent.\nEXMessageMessage describing the situation related to an exception\ncondition.\nText\nEXRecoveryIdentifies a recovery action associated with an exception\ncondition.\nText\nEXRecoveryStatus    Reports the acceptance or rejection of a requested recovery\naction and whether completion was normal.\nStructure composed of:\nEXAck\n(List of) Status\nEXTypeIdentifies the type of exception condition.Enumerated:\nAlarm\nError\nStatusReports any errors found.Structure composed of:\nErrorCode\nErrorText\nTimestampEvent date and time.Text\nyyyymmddhhmmsscc\n10. 3  Service Detail \u2014  Tables 5 thro ugh 9 define the parameters for each service. Parameters have additional detail\nwhich is defined in the parameter dictionary, Table 4.\n10. 3.1   EXPost  \u2014   Detection  of  abnorm al  situations  by  the  exception  agent  is  communicated  using  the  EXPost\nservice,  as  described  in  Section  8.1.  This  notification  is  also  used  to  communicate  any  significant  changes  in\nexception condition information while its state is SET.\nTable 5  EXPost Service Detail\nParameterReq/IndComment\nTimestampM\nEXIDMIdentifies the exception condition which has detected the abnormal situation.\nEXTypeM\nEXMessageM\n(List of) EXRecoveryCList of possible recovery actions. Not available for alarms."),(0,a.yg)("p",null,"SEMI E41-95 \xa9 SEMI 199511\n10. 3.2   EXCleared  \u2014   Notification  tha t  an  abnormal  situation  is  no  longer  apparent  or  relevant,  as  is  described  in\nSection 8.1, is communicated using the EXCleared service.\nTable 6  EXCleared Service Detail\nParameterReq/IndComment\nTimestampM\nEXIDMIdentifies the exception condition which has detected the abnormal situation.\nEXTypeM\nEXMessageM\n10. 3.3  EXRecover \u2014 Recovery action  requests, described in Section 8.1, are communicated using the EXRecover\nservice. The recovery action services are not available for alarms.\nTable 7  EXRecover Service Detail\nParameterReq/IndRsp/CnfComment\nEXIDM-Identifies the exception condition on which to perform the recovery action.\nEXRecoveryM-The particular recovery action being requested.\nEXRecoveryStatus-M\n10. 3.4    EXRecoveryComplete   \u2014   Noti fication   of   recovery   action   completion   by   the   exception   agent   is\ncommunicated using the EXRecoveryComplete service. Recovery action completion, which is described in Section\n8. 1, is not directly linked to clearing the exception condition state, and successful completion indicates only that the\noperation performed completed normally.\nTable 8  EXRecoveryComplete Service Detail\nParameterReq/IndComment\nTimestampM\nEXIDMIdentifies the exception condition on which the recovery action was performed.\nEXRecoveryStatusM\n10. 3.5   EXRecoveryAbort   \u2014   Recover y   action   abort,   described   in   Section   8.1   is   communicated   using   the\nEXRecoveryAbort service.\nTable 9  EXRecoveryAbort Service Detail\nParameterReq/IndRsp/CnfComment\nEXIDM-Identifies the exception condition on which the recovery action is being performed.\nEXRecoveryStatus-M\n10. 4   Fundamental  Requirements  \u2014   Exception  management  defines  the  standard  services  available  to  achieve\nexception condition-based exception handling and error recovery in equipment.\nAll  exception  agent  implementations  shall  support  the  fundamental  requirements.  This  standard  provides  for  two\naspects  of  fundamental  requirements:  exception  reporting  and  interactive  exception  handling.  It  is  possible  to\nsupport  only  exception  reporting  in  systems  which  do  not  require  interactive  exception  handling.  Interactive\nexception handling requires that exception reporting be supported.\n10. 4.1   Exception  Reporting  \u2014   The  fu ndamental  requirements  of  the  exception  agent  for  exception  reporting  are\nbased on maintaining the decision authority updated on the exception conditions it is interested in. These are listed\nbelow.\n\u2022 Detect  and  report  the  occurrence  of  significant  abnormal  situations  by  setting  the  related  exception  condition,\nand posting it if reporting is enabled."),(0,a.yg)("p",null,"SEMI E41-95 \xa9 SEMI 199512\n\u2022 Detect  and  report  that  an  abnormal  situation  is  no\nlonger  apparent  or  relevant  by  clearing  the  related\nexception condition and reporting it if enabled.\n\u2022 Provide  for  enabling  and  disabling  reporting  on\neach exception condition.\n\u2022 Maintain  the  data  of  exception  condition  attributes\nindicated in Table 2.\n\u2022 Reject requests for capabilities not supported (such\nas recovery actions).\n10. 4.2     Interactive    Exception    Handlin g    \u2014     The\nfundamental  requirements  of  the  exception  agent  for\ninteractive   exception   handling   extend   the   exception\nreporting  to  allow  the  decision  authority  to  request\nrecovery  actions  to  be  performed  to  resolve  abnormal\nsituations. These are listed below.\n\u2022 Support    all    exception    reporting    fundamental\nrequirements specified above.\n\u2022 Supply  a  list  of  valid  recovery  actions  for  an\nexception condition when posting.\n\u2022 Execute   a   requested   recovery   action   for   an\nexception   condition   if   the   requested   recovery\naction  is  currently  valid.  The  exception  agent  may\nsupport  only  a  single  recovery  action  to  be  in\nprogress  at  a  time  and  reject  all  other  recovery\naction   requests   for   other   exception   conditions\nwhile it is busy.\n\u2022 Report the completion of the recovery action.\n\u2022 Support  Abort  of  the  recovery  action  at  all  times,\nimmediately     ceasing     recovery     activity     and\nterminating the recovery action.\n\u2022 Reject    requests    with    incomplete    or    invalid\nparameters.\n\u2022 Reject requests for capabilities not supported.\nOptional capabilities defined or enabled in this standard\ninclude the following:\n\u2022 Support  for  multiple  concurrent  recovery  actions.\nThe  standard  allows  only  one  recovery  action  in\nprogress for each exception condition.\n\u2022 Adjust  the  exception  condition  message  and  the\nvalid  recovery  action  list  as  appropriate  during  the\nerror recovery, and post the changes if reporting is\nenabled.\nThe  services  are  defined  with  mechanisms  to  reject\nunsupported   services   and   options   should   they   be\nrequested.   This   improves   robustness   and   enables\nsophisticated  service-users  to  adjust  its  requests  to  the\ncapabilities of the particular exception agent.\nNOTICE:  These  standards  do  not  purport  to  address\nsafety  issues,  if  any,  associated  with  their  use.  It  is  the\nresponsibility of the user of these standards to establish\nappropriate  safety  and  health  practices  and  determine\nthe  applicability  of  regulatory  limitations  prior  to  use.\nSEMI  makes  no  warranties  or  representations  as  to  the\nsuitability  of  the  standards  set  forth  herein  for  any\nparticular    application.    The    determination    of    the\nsuitability of the standard is solely the responsibility of\nthe user. Users are cautioned to refer to manufacturer\u2019s\ninstructions,  product  labels,  product  data  sheets,  and\nother    relevant    literature    respecting    any    materials\nmentioned   herein.   These   standards   are   subject   to\nchange without notice.\nThe  user\u2019s  attention  is  called  to  the  possibility  that\ncompliance   with   this   standard   may   require   use   of\ncopyrighted  material  or  of  an  invention  covered  by\npatent  rights.  By  publication  of  this  standard,  SEMI\ntakes  no  position  respecting  the  validity  of  any  patent\nrights  or  copyrights  asserted  in  connection  with  any\nitem  mentioned  in  this  standard.  Users  of  this  standard\nare  expressly  advised  that  determination  of  any  such\npatent rights or copyrights, and the risk of infringement\nof such rights, are entirely their own responsibility.\nCopyright   by   SEMI\xae   (Semiconductor   Equipment   and   Materials\nInternational),3081 Zanker Road, San Jose, CA 95134. Reproduction o\nf\nthe  contents  in  whole  or  in  part  is  forbidden  without  express  written\nconsent of SEMI."),(0,a.yg)("p",null,"SEMI E41.1-96 \xa9 SEMI 19961\nSEMI E41.1-0996\nSECS-II SUPPORT FOR EXCEPTION MANAGEMENT STANDARD\n1  Purpose\nThis document maps the services and data of its prime document, SEMI E41, to SECS-II streams and functions and\ndata definitions.\n2  Scope\nThis  is  the  standard  way  to  implement  the  Exception  Management  Standard,  which  provides  remote  control\ncommunication of exceptions and recovery, using the SECS-II message format.\n3  Referenced Documents\n3. 1  SEMI Standards\nSEMI E5 \u2014 SEMI Equipment Communications Standard 2 Message Content (SECS-II)\nSEMI E41 \u2014 Exception Management (EM) Standard\n4  Terminology\nNone.\n5  Mapping of Exception Ma nagement Messages\nTable 1  Exception Management Messages SECS-II Mapping\nService Message NameStream, FunctionSECS-II Name\nEXPost NotifyS5F9,F10Exception Post Notify/Confirm\nEXCleared NotifyS5F11,F12Exception Clear Notify/Confirm\nEXRecover RequestS5F13,F14Exception Recover Request/Acknowledge\nEXRecoveryComplete NotifyS5F15,F16Exception Recovery Complete Notify/Confirm\nEXRecoveryAbort RequestS5F17,F18Exception Recovery Abort Request/Acknowledge\n6  Exception Parameters Ma pping\nTable 2  Exceptions Data Item Mapping\nParameterSECS-II Data Item\nErrorCodeERRCODE\nErrorTextERRTEXT\nEXAckACKA\nEXEnabledEXENABLED\nEXIDEXID\nEXMessageEXMESSAGE\nEXRecoveryEXRECVRA\nEXStateEXSTATE\nEXTypeEXTYPE\nTimestampTIMESTAMP"),(0,a.yg)("p",null,"SEMI E41.1-96 \xa9 SEMI 19962\n7  Implementation Details\n7. 1   Several  capabilities  of  the  Exc eption  Management  Services  (EMS)  are  accessed  through  the  Object  Services\nStandard.  The  Exception  Objects  are  persistent.  An  Object  Services  compliant  implementation  of  EMS  will  allow\naccess to all the attributes specified in the SEMI E5 Object definition table for an Exception Object.\nAll implementations shall use Object Service\u2019s GetAttr and SetAttr to access:\nEXENABLED\nEXSTATE\nNOTE 1: EXSTATE is read-only.\nNOTICE: These  standards  do  not  purport  to  address  safety  issues,  if  any,  associated  with  their  use.  It  is  the\nresponsibility  of  the  user  of  these  standards  to  establish  appropriate  safety  and  health  practices  and  determine  the\napplicability of regulatory limitations prior to use. SEMI makes no warranties or representations as to the suitability\nof the standards set forth herein for any particular application. The determination of the suitability of the standard is\nsolely  the  responsibility  of  the  user.  Users  are  cautioned  to  refer  to  manufacturer\u2019s  instructions,  product  labels,\nproduct  data  sheets,  and  other  relevant  literature  respecting  any  materials  mentioned  herein.  These  standards  are\nsubject to change without notice.\nThe  user\u2019s  attention  is  called  to  the  possibility  that  compliance  with  this  standard  may  require  use  of  copyrighted\nmaterial  or  of  an  invention  covered  by  patent  rights.  By  publication  of  this  standard,  SEMI  takes  no  position\nrespecting  the  validity  of  any  patent  rights  or  copyrights  asserted  in  connection  with  any  item  mentioned  in  this\nstandard. Users of this standard are expressly advised that determination of any such patent rights or copyrights, and\nthe risk of infringement of such rights, are entirely their own responsibility.\nCopyright   by   SEMI\xae   (Semiconductor   Equipment   and   Materials\nInternational),3081 Zanker Road, San Jose, CA 95134. Reproduction o\nf\nthe  contents  in  whole  or  in  part  is  forbidden  without  express  written\nconsent of SEMI."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 1\nSEMI E42-0704\nRECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND\nMESSAGE SERVICES\nThis  standard  was  technically  approved  by  the  Global  Information  &  Control  Committee  and  is  the  direct\nresponsibility  of  the  Japanese  Information  &  Control  Committee.  Current  edition  approved  by  the  Japanese\nRegional  Standards  Committee  on  April  30,  2004.    Initially  available  at  ",(0,a.yg)("a",{parentName:"p",href:"http://www.semi.org"},"www.semi.org"),"  June  2004;  to  be\npublished July 2004. Originally published September 1995; previously published February 2000.\nCONTENTS\n1  Introduction"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"1        Purpose"),(0,a.yg)("li",{parentName:"ol"},"2        Scope"),(0,a.yg)("li",{parentName:"ol"},"3  Referenced Documents"),(0,a.yg)("li",{parentName:"ol"},"4        Definitions"),(0,a.yg)("li",{parentName:"ol"},"4.1        Objects"),(0,a.yg)("li",{parentName:"ol"},"4.2        Services"),(0,a.yg)("li",{parentName:"ol"},"4.3        Form"),(0,a.yg)("li",{parentName:"ol"},"4.4        Recipe    Management"),(0,a.yg)("li",{parentName:"ol"},"5  Conventions"),(0,a.yg)("li",{parentName:"ol"},"5.1        Text    String    Restrictions"),(0,a.yg)("li",{parentName:"ol"},"5.2  Harel State Model"),(0,a.yg)("li",{parentName:"ol"},"5.3        Objects"),(0,a.yg)("li",{parentName:"ol"},"5.3.1        OMT    Object    Information    Model"),(0,a.yg)("li",{parentName:"ol"},"5.3.2        Object    Attribute    Representation"),(0,a.yg)("li",{parentName:"ol"},"5.4        Service    Message    Representation"),(0,a.yg)("li",{parentName:"ol"},"6  Requirements"),(0,a.yg)("li",{parentName:"ol"},"7  Document Structure"),(0,a.yg)("li",{parentName:"ol"},"8  Applicable Documents\n2  Overview of RMS"),(0,a.yg)("li",{parentName:"ol"},"1  Recipe Management Models"),(0,a.yg)("li",{parentName:"ol"},"2  Major Objects in RMS"),(0,a.yg)("li",{parentName:"ol"},"2.1        Recipes"),(0,a.yg)("li",{parentName:"ol"},"2.2        Recipe    Namespace"),(0,a.yg)("li",{parentName:"ol"},"2.3  Recipe Namespace Manager"),(0,a.yg)("li",{parentName:"ol"},"2.4  Recipe Executor\n3  Recipes"),(0,a.yg)("li",{parentName:"ol"},"1  Motivations"),(0,a.yg)("li",{parentName:"ol"},"2  Basic Concepts"),(0,a.yg)("li",{parentName:"ol"},"2.1        Types    of    Recipes"),(0,a.yg)("li",{parentName:"ol"},"2.2  Recipe Structure"),(0,a.yg)("li",{parentName:"ol"},"2.2.1        Recipe    Body"),(0,a.yg)("li",{parentName:"ol"},"2.3  Recipe Identification"),(0,a.yg)("li",{parentName:"ol"},"2.3.1        Recipe    Name"),(0,a.yg)("li",{parentName:"ol"},"2.3.2        Recipe    Class"),(0,a.yg)("li",{parentName:"ol"},"2.3.3        Version"),(0,a.yg)("li",{parentName:"ol"},"2.3.4        Recipe    Identifiers"),(0,a.yg)("li",{parentName:"ol"},"2.4  Advanced Recipe Capabilities"),(0,a.yg)("li",{parentName:"ol"},"2.4.1        Multi-Part    Recipes"),(0,a.yg)("li",{parentName:"ol"},"2.4.2        Variable    Parameters"),(0,a.yg)("li",{parentName:"ol"},"2.5        Attributes"),(0,a.yg)("li",{parentName:"ol"},"2.5.1        Descriptors"),(0,a.yg)("li",{parentName:"ol"},"3  Full and Minimal Recipe Models"),(0,a.yg)("li",{parentName:"ol"},"4  Managed Recipes"),(0,a.yg)("li",{parentName:"ol"},"4.1        Generic    Attributes"),(0,a.yg)("li",{parentName:"ol"},"4.1.1        Timestamp    Attributes"),(0,a.yg)("li",{parentName:"ol"},"4.1.2        Length    Attributes"),(0,a.yg)("li",{parentName:"ol"},"4.1.3        Descriptors"),(0,a.yg)("li",{parentName:"ol"},"4.2  Managed Recipe Object Attribute\nDefinitions"),(0,a.yg)("li",{parentName:"ol"},"4.2.1        Generic    Attribute    Definitions"),(0,a.yg)("li",{parentName:"ol"},"4.2.2        Agent-Specific    Attribute    Definitions"),(0,a.yg)("li",{parentName:"ol"},"4.2.3  Minimal Managed Recipe\n4  Recipe Namespace"),(0,a.yg)("li",{parentName:"ol"},"1  Motivations"),(0,a.yg)("li",{parentName:"ol"},"2  Namespace Model"),(0,a.yg)("li",{parentName:"ol"},"3  Namespace Specifications"),(0,a.yg)("li",{parentName:"ol"},"4  Member Agents"),(0,a.yg)("li",{parentName:"ol"},"5        Illustrations"),(0,a.yg)("li",{parentName:"ol"},"6  Attribute Definition Tables")),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 2\n5  Distributed Recipe Namespace\n5. 1  Motivations\n5. 2        Overview\n5. 3  Distributed Recipe Namespace Issues\n5. 3.1        Object    Services\n5. 3.2        Logical    Recipe\n5. 3.3        Change    Requests\n5. 4  Distributed Recipe Namespace Segment\n5. 4.1  Master and Dedicated Segments\n5. 4.2        Change    Restrictions\n5. 5  Distributed Recipe Namespace Recorder\n5. 6  Distributed Recipe Namespace Management\nInformation\n5. 7  Distributed Recipe Namespace\n5. 8  Distributed Recipe Namespace Manager\n5. 8.1        Change    Management\n5. 9  Building a Distributed Recipe Namespace\n5. 10  Rebuilding a Damaged Distributed Recipe\nNamespace\n5. 11  Object Attribute Definition Tables\n5. 11.1  Distributed Recipe Namespace Segment\nAttribute Definition\n5. 11.2  Distributed Recipe Namespace Recorder\nAttribute Definition\n5. 11.3  Distributed Recipe Namespace Attribute\nDefinition\n5. 11.4  Distributed Recipe Namespace Manager\nAttribute Definition\n6  Recipe Executor\n6. 1  Motivations\n6. 2        Description\n6. 3  The Execution Recipe\n6. 3.1  Comparison of Managed and Execution\nRecipes\n6. 3.2        Downloaded    Recipes\n6. 3.3  Execution Recipe Identifier\n6. 3.4  Execution Recipe Descriptor\n6. 3.5  Execution Recipe Attribute Definitions\n6. 4  Default Namespace\n6. 5  Recipe Storage\n6. 6  Change Control\n6. 6.1        Recipe    Creation\n6. 6.2        Recipe    Compression\n6. 6.3  Changes to Stored Recipes\n6. 6.4        Last    Value\n6. 7        Production\n6. 8  Recipe Executor Attributes\n7  Agents\n7. 1        Definitions\n7. 2  RMS Resources\n7. 3  Agent Attributes\n8  Recipe Management Operations\n8. 1  Recipe Lifecycle\n8. 2  Description of Operations\n8. 2.1        General    Requirements\n8. 2.2        Recipe    Origination\n8. 2.2.1        Create    Recipe\n8. 2.2.2        Update    Recipe\n8. 2.3        Recipe    Building\n8. 2.3.3        Unlink    Recipe\n8. 2.3.4  Modify Variable Parameters\n8. 2.4        Recipe    Authorization\n8. 2.4.1        Approve    Recipe\n8. 2.5  Recipe Protection\n8. 2.6        Unprotect\n8. 2.7        Certify\n8. 2.8        De-Certify\n8. 2.9        Informational    Operations\n8. 2.9.1        Get    Recipe    Descriptors\n8. 3  Recipe State Model\n8. 4  Table of Operations\n9  Namespace Management Operations\n9. 1  Applications of Object Services\n9. 1.1        Object    Specifiers\n9. 1.2  Required Object Services\n9. 2  Namespace Operations"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 3\n9. 2.1  Create Namespace\n9. 2.2        Delete    Namespace\n9. 2.3  Rename Namespace\n9. 3  Namespace Informational Operations\n9. 3.1        Get    Available    Storage\n9. 3.2  Check Recipe Status\n9. 3.3  Get Best Version\n9. 4  Namespace Informational Operations\n9. 4.1  Create Recipe\n9. 4.2        Delete    Recipe\n9. 4.3        Store    Recipe\n9. 4.4        Retrieve    Recipe\n9. 4.5  Copy Recipe\n9. 4.6  Rename Recipe\n9. 4.7        Verify    Recipe\n9. 4.8        Download    Recipe\n9. 4.9        Upload    Recipe\n9. 5    Table of Operations\n9. 6  Namespace Events\n10  Distributed Recipe Namespace Management\nOperations\n10. 1  Distributed Recipe Namespace Segment\nOperations\n10. 1.1        Object    Services\n10. 1.1.1        Attribute    Read/Write\n10. 1.1.2  Create and Delete Operations\n10. 1.1.3        Object    Attachment Operations\n10. 1.2  Segment Recipe Management Operations\n10. 1.2.1  Requirements for Approval\n10. 1.2.2        Segment Change Approval\n10. 1.2.3  Scenario of a Segment Change Request\n10. 2  Distributed Recipe Namespace Recorder\n10. 2.1        Object    Services\n10. 2.1.1        Attribute    Read/Write\n10. 2.1.2        Object    Create and Delete Operations\n10. 2.1.3        Object    Attachment Operations\n10. 2.2        Add    Segment    Record\n10. 2.3  Delete Segment Record\n10. 2.4  Add Change Request Record\n10. 2.5  Delete Change Request Record\n10. 2.6  Get Change Request Record\n10. 3  Distributed Recipe Namespace Management\nOperations\n10. 3.1        Object    Services\n10. 3.2        Delete    Distributed Recipe Namespace\n10. 3.3  Attach and Detach Supervised Objects\n10. 3.3.1        Attach Supervised Object\n10. 3.3.2        Detach Supervised Object\n10. 3.4  Change Request Management\n10. 3.4.1  External Change Requests\n10. 3.4.2        Internal    Change    Requests\n10. 3.4.3        Allowable    Change    Requests\n10. 3.4.4  Change Request Record Definition\n10. 3.4.5        Change Request Lifecycle\n10. 3.4.6        Change Request Completion\n10. 3.4.7  Change Management Example\n10. 3.5  Segment Change Request\n10. 3.6  Segment Action Complete\n10. 3.7  Segment Notification\n10. 3.8  Get Change Requests\n10. 3.9        Rebuild    Distributed Recipe Namespace\n10. 4  Tables of Operations\n10. 4.1  Segment Operations Table\n10. 4.2        Recorder    Operations    Table\n10. 4.3        Manager    Operations    Table\n11  Recipe Executor Operations\n11. 1  Object Services Operations\n11. 1.1  Execution Recipe Specifier\n11. 2  Description of Operations\n11. 2.1        Recipe    Download and Verify\n11. 2.2        Recipe    Verify\n11. 2.2.1        Derived Object Form Recipes\n11. 2.2.2        Verification ID\n11. 2.3        Recipe    Upload\n11. 2.4        Recipe    Rename"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 4\n11. 2.5  Get Available Storage\n11. 2.6        Recipe    Delete\n11. 2.7        Recipe    Selection\n11. 2.7.1        Multiple    Selection\n11. 2.7.2        Validation\n11. 2.7.3        Delegation\n11. 2.7.4        Variable    Parameters\n11. 2.7.5        Message    Scenarios\n11. 2.7.6        Selected    Recipes\n11. 2.8        Recipe    Deselection\n11. 2.9  Get Execution Recipe Descriptor\n11. 2.10        Change    Control\n11. 2.10.1        Changing    Existing    Recipes\n11. 2.10.2        Creating    New    Recipes\n11. 2.10.3        Building    Derived    Form    Recipes\n11. 2.10.4        Saving    Last    Value\n11. 2.10.5        Change    Notification\n11. 3  Table of Operations\n11. 4  Recipe Executor Events\n12  Recipe Namespace Services\n12. 1  Recipe Management Message Parameter\nDictionary\n12. 2  Message Flow\n12. 3  RMNCreateNS\n12. 4  RMNDeleteNS\n12. 5  RMNRenameNS\n12. 6  RMNSpaceInquire\n12. 7  RMNRcpStatInquire\n12. 8  RMNVersionInquire\n12. 9  RMNCreate\n12. 10        RMNUpdate\n12. 11        RMNStore\n12. 12        RMNRetrieve\n12. 13        RMNCopy\n12. 14        RMNRename\n12. 15        RMNAction\n12. 16        RMNVarPar\n12. 17        RMNGetDescriptor\n12. 18        RMNComplete\n13  Distributed Recipe Namespace Services\n13. 1  Distributed Recipe Namespace Message\nParameter Dictionary\n13. 2  Distributed Recipe Namespace Segment\nServices\n13. 2.1        RMDSApproveAction\n13. 3  Distributed Recipe Namespace Recorder\nServices\n13. 3.1        RMDRAddSegRecord\n13. 3.2        RMDRDelSegRecord\n13. 3.3        RMDRAddChgRecord\n13. 3.4        RMDRDelChgRecord\n13. 3.5        RMDRGetChgRecord\n13. 4  Distributed Recipe Namespace Manager\nServices\n13. 4.1        RMDComplete\n13. 4.2        RMDNotify\n13. 4.3        RMDSegChange\n13. 4.4        RMDGetChangeRequests\n13. 4.5        RMDRebuild\n14  Recipe Executor Services\n14. 1  Recipe Executor Message Parameter Dictionary\n14. 2  Message Flow\n14. 3  RMEDnldVer\n14. 4  RMEVerify\n14. 5  RMEUpload\n14. 6  RMERename\n14. 7  RMESpaceInquire\n14. 8  RMEDelete\n14. 9  RMESelect\n14. 10        RMEDeselect\n14. 11        RMEGetDescriptor\n14. 12        RMEChange\n14. 13        RMEComplete"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 5\n15  Recipe Management Compliance\n15. 1  Areas of Compliance\n15. 2  Managed Recipe\n15. 3  Managed Recipe Compliance Table\n15. 4  Recipe Namespace Management\n15. 4.1        Recipe    Namespace\n15. 4.2  Recipe Namespace Manager\n15. 4.3  Recipe Namespace Management\nCompliance Table\n15. 5  Compliance for Distributed Recipe Namespace\nManagement\n15. 5.1        Distributed    Recipe    Namespace\n15. 5.2  Distributed Recipe Namespace Manager\n15. 5.3        Distributed    Recipe    Namespace\nManagement Compliance Table\n15. 6  Distributed Recipe Namespace Segment\n15. 6.1  Distributed Recipe Namespace Segment\nCompliance Table\n15. 7  Distributed Recipe Namespace Recorder\n15. 7.1  Distributed Recipe Namespace Recorder\nCompliance Table\n15. 8  Execution Recipe Compliance\n15. 8.1  Execution Recipe Compliance Table\n15. 9  Recipe Executor\n15. 9.1  Recipe Executor Compliance Table\n16  Glossary of Terms\nRelated Information 1\nR1-1  RMS Standardized Objects\nR1-2  RMS Requirement/Concepts Map\nR1-3  Background\nR1-3.1        Traceability\nR1-3.2  Recipe Life Cycle\nR1-3.3  Recipe Editing\nR1-3.4  Recipe Sharing\nR1-3.5  Protection and Process Control\nR1-3.6  Recipe Selection\nR1-4  Example of a Factory Implementation of\nApproval Levels\nR1-5  Examples of Variable Parameters\nR1-6  Applications of Object Services\nR1-6.1        Scope\nR1-6.2        Filter\nR1-6.3  Complex Attributes\nR1-7  Examples of RMS Application"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 6"),(0,a.yg)("p",null,"NOTES"),(0,a.yg)("p",null,"This page intentionally left blank."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 7\nSEMI E42-0704\nRECIPE MANAGEMENT STANDARD: CONCEPTS, BEHAVIOR, AND\nMESSAGE SERVICES\nE\nThis standard was editorially modified in September 1999 to conform to its non-provisional status. Changes\nwere made to Section 1.2.\n1  Introduction\nThis   standard   defines   the   concepts   required   for\nmanagement  of  recipes,  the  operations  or  behavior\nprovided  by  the  Recipe  Management  Standard  (RMS),\nand  the  messages  through  which  services  are  provided\nthrough  an  interface  between  the  provider  and  the  user\nof these services."),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"1  Purpose \xf3 The purpose of this standard is twofold:\n\u2022 To  enable  applications  software  to  be  developed\nthat can assume the existence of standard concepts,\nbehaviors,  and  message  services  that  collectively\nform  Recipe  Management  and  that  take  advantage\nof them.\n\u2022 To  enable  software  to  be  developed  to  offer  the\nRecipe Management capabilities."),(0,a.yg)("li",{parentName:"ol"},"2  Scope  \xf3 This  is  a  standard  that  defines  concepts,\nbehavior,  and  services  to  support  the  integration  of\nautomated  recipe  management  within  a  semiconductor\nfactory.  These  services  are  applicable  to  a  variety  of\nrelationships,          including          both          traditional\nhost/equipment   and   cluster   tool   controller/attached\nmodule communications and control.\nThe standard provides a set of communications services\nwhich  allows  such  systems  to  transfer  and  manage\nrecipes  to  ensure  the  correct  processing  of  material\nwithin   semiconductor   manufacturing   equipment and\nsystems.  RMS  also  requires  compliance  to  SEMI  E39\n(Object  Services  Standard  (OSS):  Concepts,  Behavior,\nand Services) for completeness.\nThis  document  describes  several  different  hierarchical\nrelationships:    supervisory  agents  and  their  supervised\nagents,  recipes  and  their  subrecipes,  and  recipe  classes\nand  their  subclasses.  Such  hierarchical  relationships\nprovide   a   natural   organizational   and   classification\nstructure  that  is  reflected  in  many  different  kinds  of\nsystems,   such   as   telephone   switching   systems   and\ndirectory trees. It is the intent of this standard to support\nlogical  hierarchical  relationships  rather  than  to  require\nthat  strict  hierarchical  relationships  be  implemented  in\nsystems architecture.\nRMS  places  no  restriction  on  where  the  set  of  defined\nservices is implemented."),(0,a.yg)("li",{parentName:"ol"},"3  Referenced Documents"),(0,a.yg)("li",{parentName:"ol"},"3.1  Semiconductor      Equipment      and      Materials\nInternational (SEMI)\n1")),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"3.1.1  SEMI       Equipment       Automation/Hardware\nVolume\nSEMI E10 \xf3 Standard for Definition and Measurement\nof      Equipment      Reliability,      Availability,      and\nMaintainability (RAM)"),(0,a.yg)("li",{parentName:"ol"},"3.1.2      SEMI     Equipment     Automation/Software     2\nVolume\nSEMI  E30  \xf3  Generic  Model  for  Communications  and\nControl of Manufacturing Equipment (GEM)\nSEMI   E39   \xf3   Object   Services   Standard:   Concepts,\nBehavior, and Services\nSEMI E53 \xf3 Event Reporting"),(0,a.yg)("li",{parentName:"ol"},"3.2  Other References\nJames  Rumbaugh,  Michael  Blaha,  William  Premerlani,\nFrederick   Eddy,   William   Lorensen,   Object-Oriented\nModeling  and  Design,  Englewood  Cliffs,  New  Jersey:\nPrentice-Hall, 1991.\nD. Harel, Statecharts: A Visual Formalism for Complex\nSystems, Science of Computer Programming 8, 1987."),(0,a.yg)("li",{parentName:"ol"},"4  Definitions    \xf3 Basic    definitions    for    objects,\nservices, and form are provided in SEMI E39, Sections"),(0,a.yg)("li",{parentName:"ol"},"1   through   4.4.   This   section   provides   additional\ndefinitions.\nDefinitions in Section 1.4.3 are specific to RMS."),(0,a.yg)("li",{parentName:"ol"},"4.1  Services\nservice provider \xf3 An application (a component of an\nagent) responsible for providing services to the service\nuser.\nservice  user  \xf3  (service  consumer)  An  application  that\nuses the services provided.")),(0,a.yg)("p",null,"1 Semiconductor Equipment and Materials International (SEMI), 805\nEast Middlefield Road, Mountain View, CA 94043, 650.964.5111,\nFAX 650.967.5375"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 8"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"4.2  Form\nbinary \xf3 A string of bit values (zeroes and ones), with\na format that is either left unspecified or specified by bit\nposition,  with  the  most  significant  bit  first.  The  total\nlength  of  the  string  is  a  multiple  of  eight.  Messaging\nprotocol may impose restrictions on length."),(0,a.yg)("li",{parentName:"ol"},"4.3  Recipe  Management  \xf3  This  section  introduces\nbasic   terminology   used   in   RMS.   Entries   are   in\nalphabetical     order.     Additional     definitions     and\nspecifications are provided in later sections.\nagent \xf3  An  intelligent  system  within  a  factory  that\nprovides  one  or  more  service  resources  and  uses  the\nservices  of  other  agents.  This  is  a  generalization  that\nincludes  host,  equipment,  cell,  cluster,  cluster  module,\nstation    controller,    and    work    station.    Agents    are\nassociated  with  a  physical  system  or  a  collection  of\nphysical systems, such as computer platforms.\nauthorized  user  \xf3  A  user  who  can  be  identified  to  an\nagent  as  having  the  level  of  authority  required  for  a\nparticular  activity,  such  as  certifying  a  recipe  for  that\nequipment.\ncollection  event  \xf3  A  detectable  occurrence  of  interest\nto a service user.\ncomponent  agent  \xf3  A  subordinate  agent  that  provides\nservices to a supervisory agent.\ndownload \xf3   An   operation   that   transfers   a   recipe\n(down) to an execution storage area.\nedit  \xf3  An  operation  which  creates  a  new  recipe  body\nor changes the body of an existing recipe.\neditor \xf3 A service which allows a user to edit a recipe.\nEditors are not specified in RMS.\nequipment\n2")),(0,a.yg)("p",null,"\xf3 An agent with associated hardware that\nprovides, at a minimum, recipe execution services.\nevent \xf3  A  detectable  occurrence  significant  to  an\nobject.\nexecution (recipe execution) \xf3 The process of reading\nthe  recipe  contents  and  implementing  its  instructions,\nprocess parameters, or other information required for its\nown processing.\nexecuting   agent   \xf3   An   agent   that   provides   recipe\nexecution capabilities.\nexecution area  \xf3  The  storage  location  of  the  recipe(s)\ncurrently selected (ready) for execution.\nhost \xf3  A  supervisory agent  that  represents  the  factory\nto its subordinates."),(0,a.yg)("p",null,"2 The term \"equipment\" is restricted in RMS to \"intelligent\nequipment.\"\nlogical  recipe  \xf3  A  recipe  with  a  particular  set  of\nattributes     and     a     particular     body,     considered\nindependently  from  its  physical  location.  A  logical\nrecipe may have multiple instances or copies.\nname \xf3 A text-based attribute of an object that may be\nused as all or part of its identifier.\nnamespace \xf3 In general, a domain within which object\nidentifiers  are  unique.  In  RMS,  the  term  namespace  is\nused   as   a   synonym   for   recipe   namespace,   unless\notherwise stated.\noperator  \xf3  The  user  who  interacts  locally  with  agent\nthrough the agent's interface.\nrecipe  \xf3  The  pre-planned  and  reusable  portion  of  the\nset   of   instructions,   settings,   and   parameters   under\ncontrol  of  an  agent  that  determines  the  processing\nenvironment  seen  by  the  manufactured  object  and  that\nmay  be  subject  to  change  between  runs  or  processing\ncycles.\nrecipe  class  \xf3  A  formal  grouping  of  recipes  with  a\ncommon language syntax and functionality.\nrecipe  executor  \xf3  The  component  of  an  executing\nagent that executes recipes.\nrecipe  namespace  \xf3  A  logical  management  domain\nwith the responsibility for the storage and management\nof  recipes,  the  ensurance  of  the  uniqueness  of  recipe\nidentifiers  within  that  domain,  and  the  provision  of\nservices pertaining to recipes stored within that domain.\nrecipe  parameter  \xf3  A  control  value  that  affects  the\nagent's process.\nselect \xf3 The act of preparing a recipe for execution.\nsetting \xf3 A static value accessible to the user, through\none  or  more  methods,  that  is  used  by  equipment  to\ncontrol its process. Settings include, but are not limited\nto,  setpoint  values.  Settings  typically  may  be  specified\nwithin a recipe.\nstorage  area  \xf3  An  area  where  objects  and  data  are\nstored.\nsubordinate  agent \xf3 An agent that is a component of,\nor managed by, another agent.\nsupervisory   agent   \xf3   An   agent   with   supervisory\nresponsibilities for one or more subordinate agents.\ntimestamp  \xf3  The  notation  of  the  date  and  time  of  the\noccurrence of an event.\nupload \xf3 An operation that transfers a recipe (up) from\nan execution storage area.\nuser  \xf3  A  person  interacting  with  an  agent  directly\nthrough   the   agent's human   interface   or   indirectly\nthrough the agent's supervisor."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 9\nvalidate  \xf3  The  action  of  checking  recipe  contents  to\nensure  that  parameter  type\nand  range  are  valid  for  the\nequipment  configuration  prior  to  execution.  ","[Note  that\nvalidation and verification are used in different ways.]","\nvariable  parameter  \xf3  A  formally  defined  variable\n(setting)  defined  in  the  body  of  a  recipe  permitting  the\nactual value to be supplied externally.\nverify \xf3 The operation of reading a recipe's contents to\nensure  that  it  is  syntactically  correct  and  identifying\nelements that must be made public.\nversion  \xf3  Part  of  a  recipe's  identifier  that  is  used  to\nshow its heritage."),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},'5  Conventions   \xf3   The   following   conventions   are\nused in this document:\n\u2022 To   highlight   terms   specific   to   RMS   (excluding\nterms  defined  in  Sections  1.4.1  through  1.4.3  that\nare common to multiple standards), a defined term\nappears  in  boldface  wherever  it  first  appears  and\nwherever  it  is  defined.  This  alerts  the  reader  to\nthose  terms  with  specific  meanings.  Except  for\nterms  that  are  very  common,  such  as  recipe,  host,\nand  equipment,  defined  terms  otherwise  are  in\nitalics wherever they appear.\n\u2022 Terms related to objects and object services are in\nconformance   with   SEMI   E39   (Object   Services\nStandard:  Concepts,  Behavior,  and  Services).  A\nbrief   discussion   of   objects   is   provided   in   the\nAppendix of that document.\n\u2022 Attribute names are underlined\n.\n\u2022 Attributes  called  "names"  in  RMS  are  generally\nintended  to  be  used  for  the  ObjID\nattribute  of  a\nstandardized object.\n\u2022 To  prevent  the  definition  of  numerous  message\nparameters named "XxxList," this document adopts\nthe  convention  of  referring  to  the  list  as  "(List  of)\nXxx".  In  this  case,  the  definition  of  the  parameter\nXxx  will  be  given,  not  of  the  list.  The  term  "list"\nindicates a collection (or set) of zero or more items\nof the same data type.\nFor  attributes  that  are  lists,  this  convention  is  not\nfollowed,  as  the  entire  attribute,  as  a  list,  must  be\nassigned a specific name.'),(0,a.yg)("li",{parentName:"ol"},'5.1   Text  String  Restrictions  \xf3  Text  strings  used  in\nattribute     names,     attribute     values,     or     message\nparameters,  are  subject  to  the  restrictions  defined  by\nOSS:    Text  in  ASCII  is  restricted  to  the  characters\nbetween 20\n16\nand 7D\n16\n, excluding the question mark "?"\n(3F\n16\n), the asterisk "*" (2A\n16\n), and the tilde "~" (7E\n16\n).\nText  strings  used  as,  or  within,  the  object  identifier\nObjID\nare additionally restricted to exclude the "greater\nthan"  symbol  ">"  (2E\n16\n)  and  the  colon  character  ":"\n(3A\n16\n) to conform with OSS requirements.'),(0,a.yg)("li",{parentName:"ol"},'5.2  Harel  State  Model  \xf3  This  document  uses  the\nHarel  State  Chart  notation  to  describe  the  dynamic\nbehavior  of  the  objects  defined.  An  overview  of  this\nnotation is presented in an Appendix of SEMI E30. The\nformal definition of this notation is presented in Science\nof  Computer  Programming  8,  "Statecharts:  A  Visual\nFormalism for Complex Systems," by D. Harel, 1987.\nThis   document   also   adopts   the   extension   of   Harel\nnotation  to  show  the  deletion  of  an  object  as  used  by\nRumbaugh, et al. (see Section 1.5.2.1).'),(0,a.yg)("li",{parentName:"ol"},"5.3  Objects \xf3 Standardized objects defined by RMS\nconform  to  the  requirements  of  SEMI  E39  (Object\nServices Standard:   Concepts, Behavior, and Services).\nRMS  adopts  the  convention  of  showing  standardized\nobjects  as  drawn  with  a  heavy  line  in  object  models.\nNon-standardized objects are used to illustrate concepts\nand  relationships  but  are  not  formally  defined  and\ncannot  be  accessed  through  Object  Services.  A  list  of\nstandardized  objects  defined  by  RMS  is  included  in\nRelated Information 1."),(0,a.yg)("li",{parentName:"ol"},"5.3.1   OMT  Object  Information  Model  \xf3  The  object\nmodels   are   presented   using   the   Object   Modeling\nTechnique,  developed  by  Rumbaugh  et  al.,  in  Object-\nOriented     Modeling     and     Design,     Prentice-Hall,\nEnglewood Cliffs, NJ, 1991. Overviews of this notation\nare  provided  in  an  appendix  of  SEMI  E39  (Object\nServices Standard:   Concepts, Behavior, and Services)."),(0,a.yg)("li",{parentName:"ol"},"5.3.2 Object  Attribute  Representation  \xf3  The  object\ninformation  models  for  standardized  objects  will  be\nsupported  by  an  attribute  definition  table  with  the\nfollowing column headings:")),(0,a.yg)("p",null,"Attribute\nName\nDefinition         Access         Rqmt         Form\nThe formal\ntext name of\nthe attribute.\nDescription of the\ninformation\ncontained.\nRO or\nRW\nY or N(see\nbelow)\nThe Access column uses RO (Read Only) or RW (Read\nand  Write)  to  indicate  the  access  that  users  of  the\nservice have to the attribute.\nA   'Y'   or   'N'   in   the   Requirement   (Rqmt)   column\nindicates  if  this  attribute  must  be  supported  in  order  to\nmeet fundamental compliance for the service.\nThe  Form  column  is  used  to  indicate  the  format  of  the\nattribute. (See Section 1.4 for definitions.)"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 10"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"5.4  Service Message Representation\nService Resource Definition\nA service  definition  table  defines  the  specific  set  of\nmessages for a given service resource, as shown in the\nfollowing table:")),(0,a.yg)("p",null,"Message Service Name       Type       Description\nMessage name N or R    The intent of the service."),(0,a.yg)("p",null,"Type can be either N = Notification or R = Request.\nNotification  type  messages  are  initiated  by  the  service\nprovider,  and  the  provider  does  not  expect  to  get  a\nresponse from the user.\nRequest   messages   are   initiated   by   a   service   user.\nRequest  messages  ask  for  data  or  an  activity  from  the\nprovider.  Request  messages  expect  a  specific  response\nmessage (no presumption on the message content).\nService Parameter Dictionary\nA   service   parameter   dictionary   table   defines   the\nparameters  for  one  or  more  services,  as  shown  in  the\nfollowing table:"),(0,a.yg)("p",null,"Parameter           Form           Description\nParameter X Data type     A parameter called X is B in\nA."),(0,a.yg)("p",null,'A row is provided in the table for each parameter of the\nservice.  The  first  column  contains  the  name  of  the\nparameter.  This  is  followed  by  columns  describing  the\nform and contents of the corresponding primitive.\nThe  Form  column  is  used  to  indicate  the  type  of  data\ncontained   in   a   parameter.   (See   Section   1.4   for\ndefinitions.)\nThe   Description   column   in   the   Service   Parameter\nDictionary    table    describes    the    meaning    of    the\nparameter,   the   values   it   can   take   on,   and   any\ninterrelationships with other parameters.\nTo   prevent   the   definition   of   numerous   parameters\nnamed "XxxList", this document adopts the convention\nof referring to the list as "(List of)Xxx". In this case, the\ndefinition  of  the  variable  Xxx  will  be  given,  not  of  the\nlist.  The  term  "list"  indicates  a  collection  (or  set)  of\nzero  or  more  items  of  the  same  data  type.  Where  a  list\nis  used  in  both  the  request  and  the  response,  the  list\norder  in  the  request  is  retained  in  the  response.  A  list\nmust contain at least one element, unless zero elements\nare specifically allowed.\nService Message Definition\nA service   message   definition   table   defines   the\nparameters used in a service, as shown in the following\ntable:'),(0,a.yg)("p",null,"Parameter      Req/Ind      Rsp/Conf      Description\nParameter X(see\nbelow)\n(see\nbelow)\nA description of the\nservice."),(0,a.yg)("p",null,'The  columns  labeled  Req/Ind  and  Rsp/Conf  link  the\nparameters   to   the   direction   of   the   message.   The\nmessage  sent  by  the  initiator  is  called  the  "Request".\nWhen  receiver  terms  this  message  the  "Indication"  or\nthe    "Request",    the    receiver    may    then    send    a\n"Response",   which   the   original   sender   terms   the\n"Confirmation".\nThe   following   codes   appear   in   the   Req/Ind   and\nRsp/Conf columns and are used in the definition of the\nparameters  (e.g.,  how  each  parameter  is  used  in  each\ndirection):\n"M"     \xf3     Mandatory parameter \xf3 must be given a\nvalid value.\n"C"     \xf3     Conditional  parameter  \xf3  may  be  defined\nin  some  circumstances  and  undefined  in  others.\nWhether   a   value   is   given   may   be   completely\noptional  or  may  depend  on  the  value  of  the  other\nparameter.\n"U"     \xf3 User-defined parameter.\n"-" \xf3 The parameter is not used.\n"="  \xf3  (for  Response  only)  Indicates  that  the  value\nof this parameter in the response must match that in\nthe primary (if defined).'),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"6  Requirements     \xf3     Requirements     for     recipe\nmanagement   are   varied.   For   example,   there   is   a\nfundamental   need   to   retain   information   about   each\nrecipe, to provide that information upon request, and to\ntransfer  it  with  the  recipe  so  that  it  remains  available.\nThere is a need to classify recipes, to reuse them, and to\nshare  them  with  multiple  installations  of  equipment.\nThe   need   for   sharing   recipes   introduces   a   new\nrequirement for safeguarding the relationship between a\nrecipe's identifier and its contents, to be able to protect\na  recipe  from  unauthorized  changes,  and  to  ensure  that\nthe  identifier  for  a  recipe  that  is  used  by  multiple\nequipment is in fact the same recipe.\nThe requirements for managing recipes in a factory are\ngiven in tabular form in Table 1.1, which presents them\naccording  to  their  functional  areas  and  the  specific\nissues  involved.  Table  R1-1,  in  Related  Information,\nshows the specific concepts defined in RMS to address\neach of these requirements.")),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 11"),(0,a.yg)("p",null,"Table 1.1  Requirements\nFunctional Areas Issue Requirements\nManagement of Recipes Identification Uniquely store, identify, and select recipes in a system.\nEasy and clear identification of a recipe.\nMultiple Access Share recipes among equipment.\nEnable synchronized change of shared recipes among equipment.\nHistory                                            and                                            Traceability                                            Capture                                            the history of recipe usage.\nCapture the history of recipe changes.\nLife Cycle Management Manage approval of recipes for process development and production.\nOperations                          Protection                           Protect                          recipes from unexpected changes.\nProtect recipes from mistakes in operations.\nPortability Create, edit, and change recipes outside the equipment which execute\nthem.\nReusability Change recipes for a specific piece of equipment.\nUse recipes developed on one piece of equipment for other equipment.\nShare recipes among the same kind of equipment by adjusting for\nindividual differences.\nExecution Safety Do not execute recipes that are not syntactically correct.\nExecute                                            the                                            specified                                            (selected) recipes without errors.\nProtect recipes being executed from inadvertent change caused by other\nactivities.\nFlexibility                                            Change                                            a                                            recipe's                                            parameters during or between runs in a systematic\nway.\nSystem Operation System Node Operation Dynamically connect and disconnect equipment to/from the\ncommunications network.\nStand-Alone Operation Execute recipes with no communications link.\nCreate and change recipes with no communications link.\nManage recipes moved between equipment or from off-line storage\nthrough removable media.\nEnable smooth integration of stand-alone equipment into on-line factory\nsystems."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 12"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"7  Document  Structure  \xf3  Figure  1.1  depicts  the  domain  of  the  Recipe  Management  Standard  as  consisting  of\nPurpose, Concepts, Behavior, and Message Services. This also reflects an underlying structure of the document.")),(0,a.yg)("p",null,"Figure 1.1\nRecipe Management Domain"),(0,a.yg)("p",null,"Purpose\nprovides     the     motivation     for     Recipe\nManagement  capabilities  and  is  addressed  in  Section"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("ol",{parentName:"li",start:6},(0,a.yg)("li",{parentName:"ol"},'Concepts\nprovide  a  detailed  introduction  to  the\nstandardized objects of RMS, their attributes, and their\nrelationships with other objects. Behavior\ndescribes the\noperations  that  are  performed  by,  or  on,  these  objects.\nFinally, message services\ndefine the messages and their\nparameters independently of the protocol in which they\nare implemented. Both concepts and behavior represent\nan "inside view" of an RMS application, while services\nprovide an interface from an external view.\n\u2022 Section 1: the formal introduction to RMS.\n\u2022 Section 2: an overview of the major objects of RMS\nand   their   relationships,   to   provide   a   general\ncontext for the technical detail that follows.\n\u2022 Sections    3-6:    concepts    for    recipes,    recipe\nnamespace,   distributed   recipe   namespace,   and\nrecipe executor.\n\u2022 Section  7:  the  concept  of  the  agent  and  of  service\nresources,  to  provide  a  more  complete  context  for\nRMS implementations.\n\u2022 Sections  8-11:  behavior  (operations)  for  recipe\nmanagement,  namespace  management,  distributed\nrecipe   namespace   management,   and   the   recipe\nexecutor.\n\u2022 Sections 12-14: definitions of message services for\nthe recipe      namespace,      distributed      recipe\nnamespace, and recipe executor service resources.\n\u2022 Section 15: RMS compliance.\n\u2022 Section  16:  a  glossary  of  terms,  provided  as  a\nconvenient reference.\n\u2022 Related      Information:      provides      background\ninformation  on  the  requirements  behind  RMS  and\nexamples of applications.'))),(0,a.yg)("li",{parentName:"ol"},"8  Applicable Documents\nISO/TR  8509:1987,  Information  Processing  Systems,\nOpen Systems Interconnection \xf3 Service Conventions.\n2  Overview of RMS\nThis  section  provides  an  introduction  to,  and  overview\nof, the major objects of RMS."),(0,a.yg)("li",{parentName:"ol"},"1    Recipe   Management   Models   \xf3   To   provide   a\nclearer  understanding  of  the  major  entities  or  areas  of\nfunctionality  specified  by  RMS,  they  are  portrayed  as\nobjects in RMS models, using OMT notation.\nRelationship  lines  in  the  object-based  models  do  not\nrepresent a direct communication link between objects,\nbut rather the knowledge and association that one object\nhas with respect to another.\nThe models do not indicate the relative location of two\nobjects.")),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 13\n2. 2  Major Objects in RMS \xf3 Recipe Management is concerned with the major areas of functionality illustrated in\nFigure  2.1:  recipes\n3\n, recipe  namespaces  providing  persistent  recipe  storage,  recipe  namespace  managers  that\nprovide management of the namespace and access to its recipes, and the recipe executor that executes recipes."),(0,a.yg)("p",null,"Figure 2.1\nMajor Objects of RMS"),(0,a.yg)("p",null,"3 The recipe object in Figure 2.1 is not itself a standardized object. However, two recipe subtypes defined in Section 3 are standardized objects.\n2. 2.1  Recipes     \xf3 Recipes     provide     a     flexible,\nmanipulatable,  and  re-usable  form  for  users  to  select\nsequencing  and  settings  to  effect  a  particular  result.\nEquipment  uses  recipes  in  a  variety  of  ways  to  control\nthe  processing  environment,  sometimes  using  several\ntypes of recipes together. Recipes may also be used for\nmaintenance activities, such as calibration or cleaning.\nRecipes   can   be   modified   and   copied   from   one\nenvironment  to  another.  Their  inherent  flexibility  as  a\nform   also   becomes   an   endless   source   of   problems\nunless     they     can     be     managed.     Misprocessing,\nunintentionally  running  the  wrong  recipe  for  a  given\nproduct, is prohibitively expensive for factories.\nRMS  defines  a  recipe  as  an  object  with  attributes  \xf3\ninformation about the recipe \xf3 as well as content. It is\nthe  attributes  of  the  recipe  that  allow  true  management\nof recipes, throughout their lifecycles, to occur.\n2. 2.2   Recipe  Namespace  \xf3  A recipe  namespace  in\nRMS   is   analogous   to   a   smart   file   directory.   The\nnamespace     provides     long-term     recipe     storage\ncapability.\nBasic     operations     are     part     of     the     namespace\nspecification.  For  example,  recipes  can  be  copied  from\none namespace to another, copied within a namespace,\nrenamed,  created,  updated,  and  deleted.  They  can  be\ndownloaded   to,   and   uploaded   from,   an   application\ncalled  a  recipe  executor.  Several  recipes  can  be  linked\ntogether to form a set.\nThe namespace also can serve as a recipe pool that can\nbe  shared  by  a  group  of  equipment  of  a  common  type.\nThe distributed  recipe  namespace  is  a  namespace  able\nto  utilize  and  manage  recipe  storage  provided  by  such\nan equipment group.\n2. 2.3    Recipe   Namespace   Manager   \xf3   The recipe\nnamespace itself is passive, a container for recipes. The\nrecipe  namespace  manager  (manager)  provides  the\ndynamic  element  that  manages  the  namespace.  The\nmanager  represents  the  interface  for  the  namespace  to\nthe  external  world  and  the  internal  decision  authority\nwithin the namespace."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 14\n2. 2.4  Recipe  Executor  \xf3  The  recipe  executor  (executor)  is  the  component  of  an  agent  that  understands  the\ncontents of a recipe and is able to verify their syntactical correctness and to validate that it can be executed under\nthe  current  configuration.  It  executes  a  recipe  by  reading  its  contents  and  applying  them  appropriately  in  order  to\nachieve a desired result.\nThe recipe  executor  also  may  provide  additional  limited  storage  capability,  but  it  is  restricted  from  modifying\nexisting recipes, except under special conditions, to prevent unexpected and/or unwanted change.\n2. 3  Agent \xf3 As used in RMS, an agent is a system, or subsystem, in a factory, that has a physical aspect. It consists\nof one or more applications that provide and/or use service resources, such as a recipe namespace manager and/or a\nrecipe executor, as illustrated in Figure 2.2."),(0,a.yg)("p",null,"Figure 2.2\nAn Example of an Agent and Component Applications\nAgent is a generalization that covers traditional equipment, supervisory or aggregate systems such as stations, cells,\nand clusters, and intelligent subsystems within equipment, such as process modules within a cluster. Other types of\nagents may also be implemented, such as those dedicated to recipe namespace management.\nAn agent  that  provides  a  recipe  executor  is  called  an  executing  agent. Equipment  is  an  executing  agent  with\nassociated hardware to which the recipe applies and which it uses to do work.\n2. 4  Implementations  \xf3  RMS  can  be  implemented  on  different  platforms  within  a  factory.  A  host  controller  may\nonly  provide  recipe  namespace  management,  while  a  diskless  cluster  module  may  provide  only  recipe  execution.\nTraditional equipment  capable  of  operating  in  stand-alone  mode  is  required  to  provide  a  recipe  namespace  that  is\navailable on powerup as well as a recipe executor component. Additional examples of implementations of RMS are\nprovided in Related Information 1.\nRMS  defines  the  services  provided  through  an  external  interface.  Communications  between  or  within  applications\nthat  are  internal  to  an  agent  are  not  covered  by  RMS,  so  long  as  the  attributes  and  operations  comply  with  RMS\nrequirements.\n3  Recipes\nThis section describes the concepts concerning recipes.\n3. 1  Motivations \xf3 Definitions of recipe structure, attributes, and operations address the following issues:\n\u2022 maintenance of recipe attributes for management and traceability,\n\u2022 provision of a standard method for transferring attributes separately, as well as with the recipe body,\n\u2022 reduction or elimination of the need for dedicated recipe editors,\n\u2022 support for applications requiring multiple recipe types, such as formats or language syntaxes,\n\u2022 run-to-run control,"),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 15\n\u2022 support   for   sorting   by   factory   approval   and\ncertification levels,\n\u2022 the  ability  to  tune  a  generic  recipe  for  a  specific\ninstallation of agent as well as the same agent over\ntime, and\n\u2022 the ability to share recipes across executing agents\nsupporting the same recipe syntax or language(s).\n3. 2 Basic  Concepts  \xf3  There  are  two  types  of  recipes\naddressed  by  RMS,  the  managed  recipe  that  is  stored\nin a recipe namespace and the execution recipe that is\nstored   in   recipe   execution   storage.   This   section\ndescribes  the  basic  concepts  concerning  both  types  of\nrecipes.\n3. 2.1   Types  of  Recipes  \xf3  There  are  three  types  of\nrecipe  objects  shown  in  Figure  3.1.  Most  of  Recipe\nManagement  is  concerned  with  the  management  of\nrecipes stored in a recipe namespace. These recipes are\ncalled managed recipes. Recipes are also stored by the\nrecipe  executor  in  the  recipe  execution  storage,  and\nthese are called execution recipes."),(0,a.yg)("p",null,"Figure 3.1\nRecipe Types\nThe  recipe  supertype  is  an  abstract  type  that  shows  the\ncommon elements and attributes of the managed recipe\nand  the  execution  recipe  and  their  differences.  The\nrecipe    supertype    is    not    itself    intended    to    be\nimplemented.   That   is,   recipe   object   types   formally\ndefined   in   RMS   are   either   managed   recipes   or\nexecution  recipes.  As  indicated  by  the  light  lines,  the\nsupertype is not a standardized object.\n3. 2.2   Recipe  Structure  \xf3  Both  the  managed  and  the\nexecution  recipe  have  a  body\n4"),(0,a.yg)("p",null,"and  a  set  of  attributes.\nThe body (contents) of the recipe contains the data used\nby  the  recipe  executor  for  its  execution  process.  The\nbody  is  also  not  a  standardized  object  and  may  not  be\naccessed through Object Services.\nFigure  3.2  illustrates  all  of  the  attributes  defined  by\nRMS that are common to both the managed recipe and\nthe execution  recipe.  Not  all  of  these  attributes  are\nrequired  for  a  minimum  implementation  of  RMS.  The\nrules   for   setting   the   values   of   certain   attributes,\nhowever,  are  different  for  the  managed  recipe  and  the\nexecution recipe."),(0,a.yg)("p",null,"Figure 3.2\nRecipe Supertype\nThe identification  attributes,  those  attributes  used  for\npurposes of identification, are discussed in Section 3.3.\nThe  other  attributes  are  discussed  in  later  sections\nspecific to each recipe type.\nThe managed   recipe   also   may   maintain   a   set   of\nattributes  that  are  specific  to  a  single  executing  agent.\nThe agent-specific  attributes  are  technically  attributes\nof the association between the recipe and the executing\nagent. In RMS, however, these attributes are treated as\nattributes of a component of the recipe called the agent-\nspecific dataset, in order to allow them to be managed\nwithin the namespace along with the other attributes of\nthe  recipe.  Agent-specific  attributes  allow  the  recipe  to\nbe  personalized  for  particular  executing  agents  (i.e.,\nparticular recipe executors)."),(0,a.yg)("p",null,"4 The recipe\xeds body corresponds to a \xecprocess program\xee in SEMI E5\nand SEMI E30."),(0,a.yg)("p",null,'SEMI E42-0704 \xa9 SEMI 1995, 2004 16\nBecause the managed recipe may be applied to multiple\nagents,  it  may  have  multiple  agent-specific  datasets.\nWhen a recipe is downloaded from a recipe namespace\nto a recipe executor, the managed recipe is transformed\ninto  an  execution  recipe  by  taking  the  agent-specific\nattributes of the agent-specific dataset for that agent (its\nrecipe executor) and merging them into the attributes of\nthe execution recipe.\nMethods  of  storing  a  recipe  or  the  components  of  a\nrecipe   are   not   dictated   by   RMS.   However,   the\nassociation  between  a  recipe\'s  body  and  its  attributes\nshall be carefully maintained.\n3. 2.2.1   Recipe  Body  \xf3  The  recipe  body  contains  the\nreusable  instructions,  settings, parameters,  and  other\ndata that the recipe executor reads to execute the recipe\nand control its operation.\nA  recipe  body  may  be  in  one  of  two  basic  forms:\nsource (text) or object. The purpose of the source form\nis  to  encourage  the  use  of human-readable and human-\neditable   text.   The   object   form   supports   the   types\nintended  only  to  be  read  and  applied  by  machines  and\nother  automated  systems,  such  as  those  produced  by\nvision systems or CAD programs, as well as proprietary\nformats created and used by the recipe executor.\n3. 2.2.1.1  Source  Form  \xf3 Recipes  that  are  created  and\nmodified  by  a  form  of  editor  should  be  available  in\nsource  form.  The  source  form  of  a  recipe  body  is\nequivalent  to  a  text  file,  such  as  ASCII  or  JIS-8,  that\ncan  be  created,  read,  printed,  or  modified  with  any\n"standard"  text  editor\n5\n.  The  executing  agent  is  not\nrequired  to  supply  such  a  text  editor,  but  its  recipe\nexecutor  should  be  able  both  to  read  and  write  recipes\nin source form. Editing is not covered by RMS.\nThe source  form  of  a  recipe  may  be  copied  from  one\nnamespace    to    another    namespace    and    from    a\nnamespace   to   a   recipe   executor\'s   recipe   execution\nstorage, and all recipe executors with access to a given\nnamespace   are   assumed   to   use   the   same   recipe\nlanguage and the same functionality.\nTwo  restrictions  are  placed  on  the  interpretation  of  the\ntext transferred between agents:\n\u2022 In  ASCII,  the  valid  characters  are  from  space\n(20\n16\n)  through  "~"  (7D\n16\n),  plus  the  tab  (09\n16\n),\nlinefeed  (0A\n16\n),  carriage  return  (0D\n16\n),  and  form\nfeed  (0C\n16\n)  characters.  The  space  and  tab  are'),(0,a.yg)("p",null,'5 The intent is not to specify the text editor, but rather to allow a user\nto modify text on the basis of clear guidelines and restrictions that\nmay apply. Source form recipes are highly desirable to reduce the\nproliferation of, and need for, proprietary editors that are dedicated\nand language-specific.\nconsidered  as  horizontal  whitespace  characters,\nand  the  carriage  return  and  form  feed  characters\nare considered vertical whitespace characters. The\nline-feed  character  is  used  to  define  the  end  of  a\nline of text (eol).\n\u2022 The  meaning  of  a  recipe  should  not  depend  on\nembedded     control     characters,     or     specific\nwhitespace    characters,    or    the    existence    of\nwhitespace   at   the   end   of   a   line.   Horizontal\nwhitespace  characters  should  be  treated  alike  for\npurposes   of   interpretation,   as   should   vertical\nwhitespace  characters.  All  other  characters,  aside\nfrom  those  specified  here,  are  discouraged  and,  if\nfound,  should  be  removed  from  the  text  prior  to\ntransfer.\nIn general, the recipe language and syntax used within a\nrecipe body    are    beyond    the    scope    of    recipe\nmanagement.  However,  to  reduce  arbitrary  variability\nfor the user, the following "rules" are recommended:\n\u2022 Case    is    not    significant    for    the    purpose    of\ncomparison  or  meaning  but  should  be  retained  as\nencountered,  since  it  is  often  used  to  enhance\nreadability.  For  example,  the  tokens  alarmlevel,\nALARMLEVEL,  and  AlarmLevel  should  all  have\nthe same meaning.\n\u2022 Comments  may  be  included  in  the  text  and  are\nignored   in   recipe   interpretation.   Two   types   of\ncomments  are  defined:  comments  that  begin  with\nthe  character  pair  "//"  continue  to  the  end  of  the\nline, while comments that begin with the character\npair "/',(0,a.yg)("em",{parentName:"p"},'" are terminated only by the character pair\n"'),'/".  A  comment  of  the  second  type  is  terminated\nby   the   first   character   pair   "*/"   that   follows.\nComments  may  not  be  nested.  Nested  comments\nare not honored and may generate a syntax error.\n\u2022 The  minimum  line  consists  of  a  single  line-feed\ncharacter.\nIn  addition,  recipe  languages  that  support  external\nreferences  to  other  recipes  should  use  the  text  form\ndefined  for  the  recipe  identifier  (Section  3.2.3.4)  and\nfor the recipe specifier (Section 3.2.4.1.2).\nThe   supplier   of   the   recipe   executor   shall   provide\ndocumentation    that    formally    defines    each    recipe\nlanguage   that   the   agent   supports.   Two   forms   are\nrequired,  one  for  the  user,  who  must  be  able  to  write\ncorrect recipes, and one that covers both the syntactical\nand  lexical  structures  of  the  language  using  a  formal\ndescriptive  protocol  such  as  the  Backus-Naur  Form\n(BNF).   The   second   form   of   documentation   allows\nparsers  to  be  built  that  are  capable  of  pre-checking  a\nrecipe  for  syntactic  and  lexical  correctness  prior  to\ndownloading  it.  Pre-checking  improves  efficiency  and'),(0,a.yg)("p",null,'SEMI E42-0704 \xa9 SEMI 1995, 2004 17\nperformance   by   reducing   the   demand   for   recipe\nchecking by the recipe executor.\nThe final responsibility for determining the correctness\nof a recipe shall belong to the recipe executor.\n3. 2.2.1.2    Object   Form   \xf3   Recipes   that   cannot   be\ntranslated   into   a   meaningful   source   form   include\ndatasets  derived  from  vision  systems  or  mechanical\nsystems  through  a  special  hardware-dependent  "teach"\noperation.  Such  recipes  may  remain  in  a  proprietary\nobject  form  and  may  or  may  not  be  applicable  to  other\nrecipe     executors     because     of     their     hardware\ndependencies.\nFor  greater  efficiency,  recipe  executors  may  rewrite\n(e.g., tokenize)    a    source    recipe    to    generate    a\nproprietary object form  of  the  recipe.  This  is  called  the\nderived object form, to distinguish it from object form\nrecipes  that  never  exist  in  source  form.  The  agent\'s\nmanufacturer  may  choose  to  make  this  form  available\nfor  transfer  as  well.  From  the  point  of  view  of  the\nsupervisor, the body of a recipe that is in object form is\nan  unstructured  binary  vector  or  string.  In  general,  it\ncannot  be  edited  on  a  supervisor,  and  the  source  form\nof  the  recipe  is  still  required.  Derived  object  form\nrecipes that cannot be used by multiple recipe executors\nshould  not  be  stored  in  recipe  namespaces  that  are\nshared.\nWhere both the source form and the derived object form\nexist,  the  identifier  for  the  object  form  of  the  recipe\nshall  be  different  from  that  of  the  source  form  in  some\nrecognizable  way.  The  supplier  of  the  recipe  executor\nshall  provide  a  documented  method  for  distinguishing\none  from  the  other  within  the  identifier.  This  method\nmust be such that the relationship of the derived object\nform  recipe  from  the  original  source  recipe  is  obvious\nto  the  user.  (See  Section  3.2.3.4  for  examples.)  An\nattribute  of  the  recipe,  SrcRcpID,  is  provided  to  retain\nthe relationship between the source form recipe and the\nderived object form recipe.\n3. 2.3  Recipe  Identification  \xf3 The  ability  to  properly\nand  unambiguously  identify  a  recipe  is  critical  to  both\nrecipe management and processing. It is also important\nfor  the  user  that  identification  be  logical.  RMS  defines\nthree elements used to uniquely identify a recipe within\nany recipe  namespace.  These  three  elements  are  the\nrecipe\'s  class, name,  and  version.  Each  element  is\nexpressed  as  a  text  string,  and  they  are  concatenated\ntogether  to  form  the  recipe  identifier  (see  Section\n3. 2.3.4).\n3. 2.3.1  Recipe  Name  \xf3  The  recipe  name  is  a  user-\ndefined  text  string  that  may  be  used  to  encode  the\ntechnology,   layer,   manufacturing   area,   and   other\ncharacteristics. The recipe name alone is not necessarily\nunique   within   either   a   given   class   or   a   given\nnamespace.\nThe recipe  name  is  subject  to  the  conventions  for  text\nas defined in Section 1.5.1.\n3. 2.3.2   Recipe  Class  \xf3  A recipe  class  is  a  formal\ngrouping of recipes that have a common syntax. A class\nmay  contain  subclasses  where  the  recipes  within  the\nsubclasses  operate  in  different  environments  or  have\ndifferent syntaxes from the parent class and/or from one\nanother.  A  subclass  is  itself  a  class  and  may  contain\nfurther subclasses.\nThe   overall   model   for   recipes   is   a   set   of   class\nhierarchies  or  "class  trees"  defined  by  the  supplier  of\nthe recipe executor. The major classes of recipes are the\nPROCESS class,  the  SERVICE class,  and  possibly\nother agent-specific  classes.  These  are  called  primary\nclasses. A primary class is a class that is not a subclass\nof another class.\nThe PROCESS class is a required primary class and is\ncomposed   of   recipes   whose   primary   purpose   is   to\nincrease   the   manufactured   value   of   the   production\nmaterial\n6\n.\nThe  SERVICE  class  is  an  optional  primary  class  used\nfor  recipes  whose  purpose  is  to  maintain,  prepare,\ncalibrate,  or  test  the  operation  of  equipment.  Typical\nsubclasses    of    the    SERVICE    class     might     be\nCALIBRATION  and  CLEANING.  SERVICE  recipes\nthat  use  the  same  recipe  language  as  normal  process\nrecipes  are  not  required  to  be  placed  into  a  separate\nprimary  class.  The  SERVICE  class  allows  separation\nand  use  of  a  different  syntax  for  special  non-process\npurposes.\nOther primary  classes  that  do  not  fit  the  PROCESS  or\nSERVICE  may  be  provided  by  the  supplier  of  the\nrecipe   executor.   Such   additional   classes,   and   their\nfunction, shall be documented.\nRecipes that are not in the PROCESS class or one of its\nsubclasses  shall  not  be  used  for  production  purposes.\nHowever,  recipes  within  the  PROCESS  class  may  be\nused for purposes other than production.\nFigures 3.3 and 3.4 show examples of object models of\npossible classes  and  subclasses  for  a  wire-bonder  and\nfor a furnace with an automatic boat-loader subsystem.'),(0,a.yg)("p",null,"6 Material handling systems, wafer metrology, wafer measurement,\nwafer inspection systems, as well as process equipment which\ndirectly changes the characteristics of the material, increase the value\nof the material in some way."),(0,a.yg)("p",null,"SEMI E42-0704 \xa9 SEMI 1995, 2004 18"),(0,a.yg)("p",null,'Figure 3.3\nWire-Bonder Recipe Classes\nThe  text  form  of  a  recipe  class  shall  conform  to  the  convention  for  text  (Section  1.5.1).  Within  the  text  form  of  a\nrecipe identifier,  a  class  is  delimited  on  both  ends  by  the  forward  slash  character  "/".  The  complete  class\nspecification  within  recipe  identifier  is  formed  by  the  concatenation  of  classes  and  subclasses,  starting  with  the\nprimary class and ending with the particular class of the recipe in question:\n\xec/PRIMARY CLASS/SUBCLASS\n1\n/SUBCLASS\n2\n/\xd6\xee.\nFor example, a recipe named DryOx, version 4, within the NORMAL CYCLE class in Figure 3.4., has an identifier\nof\n\xec/PROCESS/FURNACE/DIFFUSION/NORMAL CYCLE/DryOx;4\xee.'),(0,a.yg)("p",null,"Figure 3.4\nRecipe Classes for Furnace\nThe  complete  class  specification,  which  always  starts  with  the  primary  class,  shall  always  be  accepted.  If  class\nnames  within  a  namespace  are  all  unique,  however,  the  service  provider  may  also  accept  a  class  designator\nconsisting of a single class. The identifier in the example above then becomes\n\xec/NORMAL CYCLE/DryOx;4\xee."),(0,a.yg)("p",null,'SEMI E42-0704 \xa9 SEMI 1995, 2004 19\n3. 2.3.3  Version  \xf3 A  recipe  may  evolve  over  time  and\nexist in several versions. This allows the user to retain a\nrecipe name   over   multiple   versions   and   show   the\nrecipe\'s  heritage.  Different  versions  are  identified  by\nthe  version  portion  of  the  recipe\'s  identifier.  NOTE:\nMore  than  one  version  of  a  recipe  may  be  in  use  for\nproduction   at   the   same   time,   not   only   within   the\nfactory, but also within a single equipment.\nA version  is  a  text  string  consisting  of  at  least  one\ncharacter.    A    new    version    is    either    generated\nautomatically  by  the  recipe  namespace  or  is  assigned\nby the user. A user may assign any combination of text\ncharacters and punctuation marks to the version, except\nfor:\n\u2022 the characters prohibited by the convention for text\nusage and the object identifier (Section 1.5.1),\n\u2022 whitespace characters.\nIt  is  recommended,  but  not  required,  that  only  upper\ncase be used.\nNumeric  versions (version  numbers)  consist  only  of\nthe   digits   "0"   through   "9"   and   one   decimal   point\ncharacter "." and can be translated to a pure number. To\navoid  confusion  and  multiple  versions  with  the  same\nnumeric  value,  numeric  versions  are  further  restricted\nas follows:\n\u2022 whole  numbers  (with  no  decimal  point)  may  not\nstart with a zero "0" followed by another digit, and\n\u2022 decimal  numbers  (with  a  decimal  point)  may  not\nstart  or  end  with  the  decimal  point  or  end  with  a\nzero following the decimal point.\nFor  example,  version  numbers  "09",  "1.",  ".5",  and\n"1.670" are prohibited. The proper forms with the same\nnumeric values are "9", "1", "0.5", and "1.67". The user\nmay assign a version of "0" but not of "00".\nVersions that are assigned automatically have additional\nrestrictions:\n\u2022 They   shall   be   numeric   versions,   excluding   the\ndecimal point and with a minimum value of "1".\n\u2022 Versions  shall  be  assigned  incrementally.  When\nassigning a version for a recipe with a given class\nand name,  if  no  other  recipe  exists  within  the\nnamespace with that class and name, then a version\nof  "1"  is  assigned.  Otherwise,  the  highest  existing\nversion  already  in  use  for  that  class and name  is\ndetermined,  and  the  new  version  is  assigned  a\nvalue equal to that value plus 1. For example, if the\nhighest version  in  use  has  a  numeric  value  of  5,\nthen  the  next  version  assigned  would  be  "6".  To\ncompare two   versions,   they   are   converted   to\nupper-case and compared character by character.\n3. 2.3.4  Recipe  Identifiers  \xf3 The recipe  identifier  is\nformed  from  the  concatenation  of  the  recipe\'s  class,\nname, and version, in that order:\n\xec/CLASS\n1\n/CLASS\n2\n/\xd6/CLASS\nn\n/NAME;VERSION\xee\nwhere  CLASS\n1\nis  a  primary  class  and  CLASS\ni+1\nis  a\nsubclass  of  CLASS\ni\n.  The  recipe  name  follows  class.\nName and version are always separated by a semicolon\n";" (3B\n16\n).\nWhere   CLASS\nn\nis   a   unique   class   name,   the   form\nbecomes\n\xec/CLASS/NAME;VERSION\xee.\nThe   recipe   identifier   is   used   for   the   OSS-required\nattribute   ObjID\nand   shall   conform   to   restrictions\nimposed on ObjID\n(see SEMI E39). The total length of\nObjID\nmay have additional restrictions imposed by the\nprotocol.\nNOTE:  There  is  no  necessary  relationship  between  a\nrecipe\'s identifier  or  name  and  any  file  name(s)  under\nwhich the body and attributes may be stored internally.\nThe recipe identifier is a logical reference to the recipe\nthat    is    independent    of    specific    platforms    and\nimplementations. In particular, file services provided by\noperating  systems  may  have  naming  restrictions,  such\nas  length,  that  are  incompatible  with  the  requirements\nof  RMS.  A  recipe  may  be  stored  internally  in  different\nways, such as in a single flat file, a set of related files,\nor a database. Actual storage methods shall be invisible\nto RMS.\nWhere suppliers supporting recipes in source form also\nrewrite   them,   as   discussed   in   Section   3.2.2.1.2,   a\nmethod   based   on   the   recipe   identifier   (ObjID\n)   is\nrequired to both distinguish between the two forms and\nto   recognize   the   relationship   between   the   original\nsource  form  recipe  and  the  derived  object form  recipe.\nThe  method  may  use  any  of  the  three  elements  of  the\nidentifier  for  this  purpose.  For  example,  recipes  in\nobject form may be placed in a separate subclass called\n"/OBJ/", or a suffix such as ".obj" might be appended to\nthe user-defined name of the original recipe.\n3. 2.3.4.1   Default  Recipe  Identifiers  \xf3  It  is  always\npossible  to  reference  a  recipe  by  specifying  its  full\nidentifier (class, name, and version number). In certain\ncases,  described  in  Section  3.2.4.1.1,  it  may  also  be\nnecessary   to   specify   the   namespace   of   a   recipe.\nHowever,  it  is  not  always  necessary  to  specify  all\ncomponents  of  the  identifier.  Specifically,  class  and/or\nversion  may  be  omitted  when  a  recipe  is  selected  for\nexecution and within an external reference. Namespace\nis  not  normally  specified.  Rules  define  default  values'))}p.isMDXComponent=!0},2073(e,n,t){t.d(n,{A:()=>a});var i=t(6540);const a=function({pdfLink:e,pdfSize:n,title:t,description:a}){if(!e)return null;const o=e.startsWith("http"),r=(e=>{if(!e)return null;try{const n=new URL(e,o?void 0:window.location.origin);return n.pathname.split("/").pop()}catch{return e.split("/").pop()}})(e);return i.createElement("div",{className:"pdf-download-card"},i.createElement("div",{className:"pdf-download-card__header"},i.createElement("div",{className:"pdf-download-card__icon"},"\ud83d\udce5"),i.createElement("div",{className:"pdf-download-card__title"},i.createElement("h3",null,"\u4e0b\u8f7d\u5b8c\u6574PDF"),t&&i.createElement("p",{className:"pdf-download-card__doc-title"},t))),i.createElement("div",{className:"pdf-download-card__info"},i.createElement("div",{className:"pdf-download-card__meta"},i.createElement("span",{className:"pdf-download-card__label"},"\u6587\u4ef6\u5927\u5c0f:"),i.createElement("span",{className:"pdf-download-card__value"},"string"==typeof(s=n)?s:s<1048576?`${(s/1024).toFixed(1)}KB`:`${(s/1024/1024).toFixed(1)}MB`)),a&&i.createElement("div",{className:"pdf-download-card__description"},a),o&&i.createElement("div",{className:"pdf-download-card__notice"},i.createElement("span",{className:"pdf-download-card__notice-icon"},"\u2139\ufe0f"),i.createElement("span",null,"\u6b64\u6587\u4ef6\u6258\u7ba1\u5728GitHub Releases\uff0c\u53ef\u80fd\u9700\u8981GitHub\u8d26\u53f7"))),i.createElement("div",{className:"pdf-download-card__actions"},i.createElement("a",{href:e,className:"pdf-download-card__button pdf-download-card__button--primary",download:o?void 0:r,target:o?"_blank":void 0,rel:o?"noopener noreferrer":void 0},i.createElement("span",{className:"pdf-download-card__button-icon"},"\u2b07\ufe0f"),"\u4e0b\u8f7dPDF"),o&&i.createElement("a",{href:e,className:"pdf-download-card__button pdf-download-card__button--secondary",target:"_blank",rel:"noopener noreferrer"},i.createElement("span",{className:"pdf-download-card__button-icon"},"\ud83d\udd17"),"\u5728\u65b0\u7a97\u53e3\u6253\u5f00")));var s}},5680(e,n,t){t.d(n,{xA:()=>d,yg:()=>m});var i=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach(function(n){a(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function s(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=i.createContext({}),l=function(e){var n=i.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=l(e.components);return i.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},h=i.forwardRef(function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=l(t),m=a,u=h["".concat(c,".").concat(m)]||h[m]||p[m]||o;return t?i.createElement(u,r(r({ref:n},d),{},{components:t})):i.createElement(u,r({ref:n},d))});function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,r=new Array(o);r[0]=h;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var l=2;l<o;l++)r[l]=t[l];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}h.displayName="MDXCreateElement"}}]);