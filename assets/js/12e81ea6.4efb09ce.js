"use strict";(globalThis.webpackChunksemiconductor_docs=globalThis.webpackChunksemiconductor_docs||[]).push([[7346],{2073(e,n,t){t.d(n,{A:()=>i});var a=t(6540);const i=function({pdfLink:e,pdfSize:n,title:t,description:i}){if(!e)return null;const o=e.startsWith("http"),r=(e=>{if(!e)return null;try{const n=new URL(e,o?void 0:window.location.origin);return n.pathname.split("/").pop()}catch{return e.split("/").pop()}})(e);return a.createElement("div",{className:"pdf-download-card"},a.createElement("div",{className:"pdf-download-card__header"},a.createElement("div",{className:"pdf-download-card__icon"},"\ud83d\udce5"),a.createElement("div",{className:"pdf-download-card__title"},a.createElement("h3",null,"\u4e0b\u8f7d\u5b8c\u6574PDF"),t&&a.createElement("p",{className:"pdf-download-card__doc-title"},t))),a.createElement("div",{className:"pdf-download-card__info"},a.createElement("div",{className:"pdf-download-card__meta"},a.createElement("span",{className:"pdf-download-card__label"},"\u6587\u4ef6\u5927\u5c0f:"),a.createElement("span",{className:"pdf-download-card__value"},"string"==typeof(s=n)?s:s<1048576?`${(s/1024).toFixed(1)}KB`:`${(s/1024/1024).toFixed(1)}MB`)),i&&a.createElement("div",{className:"pdf-download-card__description"},i),o&&a.createElement("div",{className:"pdf-download-card__notice"},a.createElement("span",{className:"pdf-download-card__notice-icon"},"\u2139\ufe0f"),a.createElement("span",null,"\u6b64\u6587\u4ef6\u6258\u7ba1\u5728GitHub Releases\uff0c\u53ef\u80fd\u9700\u8981GitHub\u8d26\u53f7"))),a.createElement("div",{className:"pdf-download-card__actions"},a.createElement("a",{href:e,className:"pdf-download-card__button pdf-download-card__button--primary",download:o?void 0:r,target:o?"_blank":void 0,rel:o?"noopener noreferrer":void 0},a.createElement("span",{className:"pdf-download-card__button-icon"},"\u2b07\ufe0f"),"\u4e0b\u8f7dPDF"),o&&a.createElement("a",{href:e,className:"pdf-download-card__button pdf-download-card__button--secondary",target:"_blank",rel:"noopener noreferrer"},a.createElement("span",{className:"pdf-download-card__button-icon"},"\ud83d\udd17"),"\u5728\u65b0\u7a97\u53e3\u6253\u5f00")));var s}},5680(e,n,t){t.d(n,{xA:()=>d,yg:()=>u});var a=t(6540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach(function(n){i(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=a.createContext({}),l=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=l(e.components);return a.createElement(c.Provider,{value:n},e.children)},h={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef(function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=l(t),u=i,m=p["".concat(c,".").concat(u)]||p[u]||h[u]||o;return t?a.createElement(m,r(r({ref:n},d),{},{components:t})):a.createElement(m,r({ref:n},d))});function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=p;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var l=2;l<o;l++)r[l]=t[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},6346(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=t(8168),i=(t(6540),t(5680));t(2073);const o={title:"E95-1101 - \xa9 SEMI 2000, 20016...",description:"SEMI\u6807\u51c6\u6587\u6863",sidebar_label:"E95-1101 - \xa9 SEMI 2000, 20016...",sidebar_position:540,tags:["SEMI","Standard"],custom_props:{source_type:"pdf",source_file:"semi-chapter-054.pdf",chapter:54,page_count:50}},r=void 0,s={unversionedId:"standards/semi/semi-chapter-054",id:"standards/semi/semi-chapter-054",title:"E95-1101 - \xa9 SEMI 2000, 20016...",description:"SEMI\u6807\u51c6\u6587\u6863",source:"@site/docs/standards/semi/semi-chapter-054.md",sourceDirName:"standards/semi",slug:"/standards/semi/semi-chapter-054",permalink:"/semiconductor-docs/docs/standards/semi/semi-chapter-054",draft:!1,editUrl:"https://github.com/your-org/semiconductor-docs/tree/main/docs/standards/semi/semi-chapter-054.md",tags:[{label:"SEMI",permalink:"/semiconductor-docs/docs/tags/semi"},{label:"Standard",permalink:"/semiconductor-docs/docs/tags/standard"}],version:"current",sidebarPosition:540,frontMatter:{title:"E95-1101 - \xa9 SEMI 2000, 20016...",description:"SEMI\u6807\u51c6\u6587\u6863",sidebar_label:"E95-1101 - \xa9 SEMI 2000, 20016...",sidebar_position:540,tags:["SEMI","Standard"],custom_props:{source_type:"pdf",source_file:"semi-chapter-054.pdf",chapter:54,page_count:50}},sidebar:"standardsSidebar",previous:{title:"E92-0302 - E \xa9 SEMI 1999,...",permalink:"/semiconductor-docs/docs/standards/semi/semi-chapter-015"},next:{title:"E97-0200A - \xa9 SEMI 200021 const...",permalink:"/semiconductor-docs/docs/standards/semi/semi-chapter-055"}},c={},l=[],d={toc:l};function h({components:e,...n}){return(0,i.yg)("wrapper",(0,a.A)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,i.yg)("p",null,'PdfDownloadCard\npdfLink="/pdfs/semi/054.pdf"\npdfSize="0.40MB"\ntitle="E95-1101 - \xa9 SEMI 2000, 20016..."\ndescription="SEMI\u6807\u51c6\u6587\u6863\uff0c\u517150\u9875"\n/'),(0,i.yg)("h1",{id:"\u6587\u6863\u6807\u9898"},"\u6587\u6863\u6807\u9898"),(0,i.yg)("p",null,"SEMI E95-1101 \xa9 SEMI 2000, 20016\nJobsSystemRecipesSetup(Future)AlarmsHelp\nView 6View 5View 4View 3View 2View 1View 6View 5View 4View 3View 2View 1View 6View 5View 4View 3View 2View 1View 6View 5View 4View 3View 2View 1\nView 6View 5View 4View 3View 2View 1View 6View 5View 4View 3View 2View 1View 6View 5View 4View 3View 2View 1\nInformation\nPanel\nFunctional\nAreas\nFigure 6\nNetwork Navigation Model \u2014 Tab Sub-navigation\nJobsSystemRecipesSetup(Future)AlarmsHelp\nView 1View 2View 3View 4View 5View 6View 1View 2View 3View 4View 5View 6View 1View 2View 3View 4View 5View 6\nInformation\nPanel\nFunctional\nAreas\nView 1View 2View 3View 4View 5View 6\nView 6View 5View 4View 3View 2View 1View 6View 5View 4View 3View 2View 1View 6View 5View 4View 3View 2View 1\nSub-navigation Buttons\nFigure 7\nNetwork Navigation Model \u2014 Button Sub-navigation\n5. 3.5  Display LayoutDescription\n5. 3.5.1  The  display  layout  is  designed  for  ease  of  use  with  touchscreen  input  devices  and  does  not  require  a\nkeyboard   or   other   pointing   device.   By   dividing   the   screen   into   rectangular   panels,   provision   is   made   to\naccommodate the display and input of information organized by the tasks users must accomplish in managing and\nmonitoring processing, maintaining and repairing the equipment, and other relevant work.\n5. 3.6  Basic LayoutMandatory\n5. 3.6.1  The basic layout shall contain four panels as shown and oriented in Figure 8. At a minimum, the interface\nshall support the orientation of the command panel on the right-hand side, unless the enhanced layout (Section 5.3.7)\nis implemented."),(0,i.yg)("p",null,"SEMI E95-1101 \xa9 SEMI 2000, 20017\nTitle Panel\nInform ation Panel\nCommand Panel\nNavigation Panel\nFigure 8\nBasic Layout\n5. 3.6.2  All  the  panels  are  tiled  edge  to  edge  to  create  the  display,  and  only  the  relative  position  of  the  panels  is\nspecified in this standard. Panels may or may not display a visible border. For an interface that is the primary display\n(typically, but not always at the front of equipment), an outer window frame allowing window resizing, closing, or\npositioning shall not be shown or enabled. This is to prevent the user from mistakenly \u201closing\u201d the window, which\nmay result in a dangerous condition. If desired, a logged-in user with sufficient privileges may be allowed to resize,\nbut  not  minimize  or  close,  the  primary  display  window.  Secondary  instances  of  the  interface  (e.g.,  displayed  at  a\nmaintenance node or displayed at a remote node) may show and enable the outer window frame.\n5. 3.7  Enhanced LayoutRecommended\n5. 3.7.1  It is strongly recommended that left-handed users be allowed to change the location of the command panel\nto  the  left-hand  side  (see  Figure  9(b))  to  avoid  obscuring  the  screen  when  reaching  with  their  left  hand  to  make\nselections on the command panel when it is located on the right-hand side of the screen.\nTitle Panel\nInformation Panel\nCommand Panel\nNavigation Panel\nTitle Panel\nInformation Panel\nCommand Panel\nNavigation Panel\n(a)(b)\nFigure 9\nEnhanced Layout \u2013 Right and Left Command Panel Orientation"),(0,i.yg)("p",null,"SEMI E95-1101 \xa9 SEMI 2000, 20018\n5. 3.8  Title PanelDescription\n5. 3.8.1  The  title  panel  is  a  horizontal  area  above  the  information  and  command  panels,  at  the  top  of  the  interface\nwindow.  It  is  always  displayed  and  contains  the  host  communications  status  display  (if  host  communications  is\nsupported), date/time display, Login/Logout button (if security is supported), message display area, and the name of\nthe current view. It may optionally contain a corporate identifier or logo, a display of critical parameters, an audible\nalarm  silencing  button,  orientation  graphics,  a  light  tower  representation,  and  other  items  that  should  always  be\ndisplayed to ensure effective operation.\n5. 3.9  Title Panel Basic InformationMandatory\n5. 3.9.1  Shown  below  is  the  title  panel  with  the  mandatory  display  objects.  The  relative  positions  shown,  with  the\ntop portion of the title panel containing the date/time display at the left, the current view name to its right, and with\nthe message area below the top portion, are mandatory.\nDate/Time\nDisplay\nMessage Area\nCurrent View Name\nFigure 10\nTitle Panel\n5. 3.10  Title Panel with Conditional InformationConditional\n5. 3.10.1  Shown   below   is   the   title   panel   with   the   mandatory   display   objects,   plus   the   conditional   host\ncommunications status display and the conditional Login/Logout button. The relative positions shown, with the host\ncommunications status display left-most, and the Login/Logout button at the upper right, are mandatory.\nHost\nCommunication\nStatus\nLogin Here\nDate/Time\nDisplay\nMessage Area\nCurrent View Name\nFigure 11\nTitle Panel\n5. 3.10.2  Title Panel Host Communications StatusConditional\n5. 3.10.2.1  If the equipment supports host communication then status information shall be included in the title panel.\nInformation  such  as  communications  status  (i.e.,  whether  communications  is  active),  communications  state  (i.e.,\nconnected, disconnected, etc.), and whether the equipment is in a local or remote mode may be displayed here. The\ndisplay  of  specific  information  is  dependent  on  the  host  communication  protocol  which  may  impose  additional\nspecific requirements on what is displayed.\n5. 3.10.3  Title Panel Login/Logout ButtonConditional\n5. 3.10.3.1  The  Login/Logout  button  label  reads  \u201cLogin  Here\u201d  until  a  user  is  logged  in,  then  displays  a  user\nidentifier until the user logs out. User selection of the Login/Logout button invokes a dialog box where the user may\nenter  a  user  identifier  and  password,  or,  if  already  logged  in,  may  select  a  button  to  log  out.  If  required  by  the\nimplementation,  when  this  dialog  box  is  displayed,  all  other  functions  in  the  interface  window  may  be  disabled,\nincluding the navigation panel."),(0,i.yg)("p",null,"SEMI E95-1101 \xa9 SEMI 2000, 20019\n5. 3.11  Title Panel with Additional InformationRecommended\n5. 3.11.1  Shown below is an example of a layout for the title panel incorporating some recommended display objects\nand their relative positions.\nHost\nCommunication\nStatus\nLogin Here\nDate/Time\nDisplay\nMessage Area\nCurrent View Name\nCorporate\nIdentifier\nLight Tower\nDisplay\nCritical\nParameters,\nAlarm\nSilencing,\netc.\nFigure 12\nTitle Panel with Some Additional Display Objects\n5. 3.11.2  Title Panel Alarms ButtonRecommended\n5. 3.11.2.1  Although  not  recommended  for  new  designs,  the  title  panel  may  also  contain  an  Alarms  button  that\nallows the user to respond to cautions and severe alarms. In this case, the Alarms navigation button in the navigation\npanel  shall  be  omitted,  and  any  alarms  accessed  through  a  title  panel  Alarms  button  shall  be  displayed  in  a  dialog\nbox, not as an information panel and its command panel.\n5. 4  Navigation PanelMandatory\n5. 4.1  Navigation buttons shall have a text label. In addition, they may also include an icon to graphically represent\ntheir  function.  When  no  icon  is  present,  the  button  label  shall  be  centered  on  the  button.  If  an  icon  is  present,  the\nlabel shall be centered below the icon. Navigation buttons are arranged horizontally along the bottom of the display,\nin the navigation panel, which shall always be present.\n5. 4.2  Required Navigation FunctionsMandatory\n5. 4.2.1  At  a  minimum,  the  user  shall  always  be  able  to  immediately  access  and  respond  to  alarm  and  caution\nnotifications, even when a dialog box is displayed on the current view. Dialog boxes shall not obscure the navigation\npanel. Additionally, the user shall always be able to immediately access other parts of the interface if such access is\nrequired  to  ensure  the  safe  operation  of  the  equipment.  Only  when  prohibited  by  the  operating  system  or  other\nimplementation  limitations  such  that  a  displayed  dialog  box  cannot  be  maintained  during,  or  redisplayed  after\nnavigation,  it  is  allowed  that  such  access  may  be  accomplished  by  displaying  another  dialog  box  that  completely\ncovers the originally displayed dialog box. When the overlaying dialog box is dismissed, the underlying dialog box\nis  redisplayed,  in  the  same  state  it  was  in  prior  to  the  invocation  of  the  overlying  dialog  box  (i.e.,  given  the  stated\nprohibition  or  limitations,  it  is  not  mandatory  that  access  be  provided  through  navigation  using  the  navigation\npanel). Immediate access shall mean that the user shall not have to dismiss or otherwise interact with any displayed\ndialog  box  in  order  to  perform  the  required  access.  When  the  user  navigates  back  or  otherwise  returns  from  the\nrequired access, the last selected view shall be displayed, along with any dialog box that was displayed, in the same\nstate it was in. If no dialog box was displayed, the last selected view shall be displayed.\n5. 4.2.2  An  allowed  exception  is  a  login  and/or  logout  dialog  box  or  screen  if  an  implementation  requires  modal\noperation while logging in or out.\n5. 4.3  Conditional Navigation FunctionsConditional\n5. 4.3.1  Except  when  absolutely  prevented  by  the  operating  system  or  implementation  limitations,  the  navigation\npanel  shall  always  be  available  for  user  selection,  even  when  a  dialog  box  is  displayed  on  the  current  view.  This\nmakes it possible for the user to directly and immediately access any functional area from anywhere within the user\ninterface.  Immediate  access  shall  mean  that  the  user  shall  not  have  to  dismiss  or  otherwise  interact  with  any\ndisplayed dialog box in order to perform the required access. When the user navigates back to a functional area, the\nlast selected view is displayed, along with any dialog box that was displayed, in the same state it was in.\n5. 4.3.2  An  allowed  exception  is  a  login  and/or  logout  dialog  box  or  screen  if  an  implementation  requires  modal\noperation while logging in or out."),(0,i.yg)("p",null,"SEMI E95-1101 \xa9 SEMI 2000, 200110\n5. 4.4  Navigation Panel LayoutMandatory\n5. 4.4.1  The figure below shows the navigation panel, with three buttons labeled \u201c(Future)\u201d indicating the positions\nwhere  buttons  may  be  placed  if  required  by  the  specific  implementation  of  the  interface,  or  as  a  result  of\nmodifications  or  enhancements  in  future  releases  of  the  software.  It  is  recommended  that  the  navigation  panel\ncontain no more than ten buttons.\n5. 4.4.2  The  navigation  buttons  shall  be  sequenced  from  left  to  right  in  descending  order  of  expected  frequency  of\nuse.  The  most  frequently  selected  navigation  button  shall  be  left-most  within  the  navigation  panel;  and  the  least\nfrequently selected button shall be right-most.\nJobsSystemRecipesSetup(Future)(Future)(Future)AlarmsHelp\nFigure 13\nNavigation Panel\n5. 4.5  Navigation Panel Alarm and Help ButtonsConditional\n5. 4.5.1  The two exceptions to the above ordering are the Alarms and Help navigation buttons, which, when they are\nsupported in an implementation, shall be the next to right-most and right-most buttons, respectively. This placement\nensures  that  the  position  of  these  buttons  shall  remain  unchanged,  even  if  subsequent  interface  modifications  or\nenhancements  require  additional  buttons.  The  Alarm  button  shall  be  placed  so  that  the  spacing  between  it  and\nadjacent buttons is larger than the spacing between other buttons, to allow its selection quickly, and without error.\n5. 4.6  Navigation Button LabelsConditional\n5. 4.6.1  For  each  functional  area,  there  is  a  corresponding  navigation  button  identified  by  a  text  label  (mandatory)\nand icon (recommended) identifying the functionality and information provided. The table below shows text labels\n(conditional)  for  the  navigation  buttons,  a  description  of  each  functional  area,  and  some  recommended  alternative\nlabels.\nTable 1  Functional Areas\nNavigation Button LabelDescriptionAlternate Labels\nJobsOperations related to product processing, including\nany pre- and post-production equipment setup\nLot Operations, Operation,\nOperations, Processing, Main, Run\nSystemEquipment status, manual move, maintenance, service,\ncalibration, & other engineering-level functions\nOverview, Service, Status, System\nStatus, Maintenance\nRecipesRecipe management, including creation, editing,\nstoring, etc.\nNone\nDatalogData histories, event logs, SPC functions\n(If supported)\nHistory, Analysis, Logs, Data\nSetupUser account administration, host communications\ncontrol, user preferences, parameters, hardware\nconfiguration/options, light tower programming, etc.\nConfiguration, Options\nAlarmsAlarm and caution summary to acknowledge and clear\nposted alarms, current event log\nNone (see Section 5.4.5)\nHelpHelp files on operations, procedures, and the interfaceNone (see Section 5.4.5)\n5. 4.6.2  The top to bottom ordering of the table reflects the left to right ordering of navigation buttons. Also allowed,\nbut  not  recommended  for  new  designs,  is  a  left  to  right  ordering  of:  System,  Jobs,  Equipment  Setup,  Recipes,\nHistory,  Maintenance,  and  Configuration.  The  alternative  labels  specified  in  the  table  may  be  applied  to  this"),(0,i.yg)("p",null,"SEMI E95-1101 \xa9 SEMI 2000, 200111\nordering also. Additional buttons, if required for a particular implementation, shall be added between the Setup and\nAlarm button positions.\n5. 4.7  Navigation Panel SaliencesConditional\n5. 4.7.1  Only  one  navigation  button  at  a  time  shall  display  a  pressed  appearance.  Additionally,  navigation  buttons\nshall display colored salience coding for a number of purposes: 1, to indicate the user is viewing a functional area\n(medium  blue  salience);  2,  to  indicate  an  unfinished  task  (typically  an  open  dialog  box)  in  a  functional  area  not\ncurrently displayed (medium blue salience); and 3, to inform the user that there are new or unacknowledged cautions\nor alarms (saturated yellow or saturated red salience, respectively). The caution and alarm saliences are displayed on\nthe Alarms navigation button only. As an example, if the user has opened a dialog box in the Jobs functional area,\nand then selects the Recipes navigation button, the Recipes button shall display a pressed (down) appearance and a\nmedium blue salience, and the Jobs button shall display an unpressed (up) appearance and a medium blue salience\n(Figure  14).  This  reminds  the  user  that  there  is  an  open  dialog  box  in  the  Jobs  functional  area.  More  than  one\nnavigation button may display the unfinished task salience.\n5. 4.7.2  The Jobs button may also display a medium green salience (not shown) to notify the user that the equipment\nis  \u201cReady  to  Load,\u201d  \u201cReady  to  Unload,\u201d  \u201cReady  to  Run,\u201d  or  is  in  a  similar  state  such  that  the  user\u2019s  attention  is\nrequested  in  the  Jobs  functional  area.  This  is  useful  when  the  user  has  navigated  to  another  functional  area  of  the\ninterface. If there is an unfinished task, its medium blue salience shall remain displayed, even if the user\u2019s attention\nis requested.\nJobsSystemSetup(Future)(Future)(Future)AlarmsHelp\nMedium Blue Salience\nRecipes\nFigure 14\nNavigation Button Saliences\n5. 4.7.3  The Alarm navigation button, in addition to the medium blue salience, displays a saturated (bright) yellow\nsalience when there are new or unacknowledged cautions, or displays a saturated red salience when there are new or\nunacknowledged alarms. Only the severest level is displayed. That is, when there are both cautions and alarms, the\nred  alarm  salience  shall  be  displayed.  When  there  are  no  alarms  and  only  cautions,  the  caution  salience  shall  be\ndisplayed. The figures below show the same situation as Figure 14, with Figure 15 showing a caution salience, and\nFigure 16 showing an alarm salience. If there are no cautions or alarms, the Alarm button displays a medium blue\nsalience if the user is viewing the Alarms functional area, or if there is an unfinished task and another functional area\nis being viewed. If a caution or alarm occurs, the medium blue salience is replaced with the appropriate salience, and\nis only re-displayed when all cautions and alarms have been acknowledged or cleared.\nJobsSystemRecipesSetup(Future)(Future)(Future)AlarmsHelp\nBright Yellow SalienceMedium Blue Salience\nFigure 15\nWarning Salience"),(0,i.yg)("p",null,"SEMI E95-1101 \xa9 SEMI 2000, 200112\nJobsSystemRecipesSetup(Future)(Future)(Future)AlarmsHelp\nMedium Blue SalienceBright Red Salience\nFigure 16\nAlarm Salience\n5. 4.8  Sub-navigationConditional\n5. 4.8.1  When sub-navigation is supported it shall be by a single row of tabs or buttons in a sub-navigation panel as\nshown below.\n5. 4.8.2  Sub-navigation Layout A \u2014 Tabs\n5. 4.8.2.1  Shown  below  are  two  orientations  of  the  layout  (right-hand  and  left-hand  command  panels),  with  sub-\nnavigation using tabs. This is the preferred method for new designs where more than one view per functional area is\nneeded. User selection of a tab brings the tab to the front, displays its information and command panel, and allows\nthe user access to its display objects. Use of tabs in each functional area must be consistent throughout the interface,\neven if there is only one view in a functional area, and thus, one tab.\nTitle Panel\nInformation Panel\nCommand Panel\nNavigation Panel\nView 1View 2View 3View 4View 5View 6\nTitle Panel\nNavigation Panel\nCommand Panel\nInformation Panel\nView 1View 2View 3View 4View 5View 6\n(a)(b)\nFigure 17\nView Sub-navigation Using Tabs\n5. 4.8.3  Sub-navigation Layout B \u2014 Sub-navigation Panel With Buttons\n5. 4.8.3.1  Shown below are two orientations of the layout, with sub-navigation using view selection buttons in a sub-\nnavigation panel. The figure shows one possible relative location for a sub-navigation panel, but is not intended to\nrestrict  implementation.  Other  arrangements  are  allowed.  However,  if  a  sub-navigation  panel  is  used,  its  size  and\nlocation  in  each  functional  area  must  be  consistent  throughout  the  interface,  even  if  there  is  only  one  view  in  a\nfunctional area, and thus, no buttons in the panel."),(0,i.yg)("p",null,"SEMI E95-1101 \xa9 SEMI 2000, 200113\nTitle Panel\nInformation Panel\nCommand Panel\nNavigation Panel\nSubnav. Panel\nTitle Panel\nInformation Panel\nCommand Panel\nNavigation Panel\nSubnav. Panel\n(a)(b)\nFigure 18\nView Sub-navigation Using Buttons in Separate Panel\n5. 4.8.3.2  It  is  important  in  the  layout  to  separate  sub-\nnavigation  methods  from  the  global  commands  in  the\ncommand  panel.  This  limits  the  number  of  buttons\nneeded  in  the  command  panel;  and  reduces  or  elim-\ninates  the  need  for  multiple  columns  of  buttons,  which\nwould  alter  the  information  panel  display  aspect  ratio.\nIf an information panel has a different aspect ratio than\nthe others, its contents may appear to \u201cjump\u201d sideways\nwhen navigating, distracting the user. The separation of\nsub-navigation   from   commands   accomplishes   two\nimportant  objectives;  a)  users  do  not  become  confused\ntrying  to  differentiate  sub-navigation  from  commands,\nand  b)  the  aspect  ratio  of  the  information  panel  display\nis consistent for all views across all functional areas.\n5. 5  Information PanelMandatory\n5. 5.1  The  information  panel  displays  a  view  or  views\nof  the  information  and  graphics  for  each  functional\narea.  Graphics  and  other  display  objects  are  placed  in\nthis   panel   to   achieve   the   control   and   monitoring\ncapabilities  required.  If  necessary,  multiple  views  of\ninformation  may  be  displayed  within  a  functional  area,\none at a time, in the information panel.\n5. 5.2  When  any  functional  areas  have  more  than  one\nview,  the  user  must  be  able  to  switch  between  those\nviews while remaining within the context of the current\nfunctional  area.  The  ways  the  user  may  select  among\nmultiple views presented in this standard are called sub-\nnavigation   methods   to   distinguish   them   from   user\nnavigation    between    functional    areas    using    the\nnavigation panel.\n5. 6  Command PanelMandatory\n5. 6.1  The   command   panel   is   a   vertical   column   of\ncommand  buttons  located  to  the  right  of  the  infor-\nmation  panel  (to  the  left  if  switched  to  accommodate\nleft-handed  users).  Only  buttons  for  common  or  global\ncommands  related  to  the  current  view  displayed  in  the\ninformation  panel  shall  be  located  in  the  command\npanel.  If  there  are  no  common  commands  for  an  infor-\nmation  panel,  the  command  panel  shall  have  no  but-\ntons.  Each  view  in  a  functional  area  shall  have  its  own\ncommand panel. To limit the number of command but-\ntons needed in each command panel, user selection of a\ndifferent view shall display that view and its associated\ncommand panel, with commands that apply only to the\nselected view. A command panel may be used for more\nthan   one   view   if   it   is   suitable   for   that   purpose.\nCommand  buttons  or  other  display  objects  that  have  a\nmore  limited  scope  shall  be  located  in  the  information\npanel.    Restricting    locally-acting    commands    and\nfunctions  to  the  information  panel  makes  clear  to  the\nuser  that  only  general,  global  commands  are  located  in\nthe  command  panel.  Buttons  for  navigation  (i.e.,  that\ninvoke  the  display  of  another  view  in  the  information\npanel)  shall  not  be  located  in  the  command  panel.  It  is\nrecommended  that  multiple  columns  of  buttons  in  the\ncommand panel be avoided.\n6  Compliance Statement\n6. 1  In order to be compliant with this specification, the\ndocumentation  accompanying  an  equipment  shall  in-\nclude  a  Human  Computer  Interface  (HCI)  Compliance\nStatement that accurately indicates compliance with the\nindividual   requirements   defined   in   this   document.\nRequirements    and    recommended    capabilities    are\ndefined in Table 2.\n6. 2  In order to be compliant with HCI, equipment must\nmeet  all  requirements  in  each  of  three  categories,  as\nfollows:"),(0,i.yg)("p",null,"SEMI E95-1101 \xa9 SEMI 2000, 200114\n6. 2.1  Mandatory:    In  order  to  be  compliant  with  this\nstandard,  all  of  the  mandatory  requirements  shall  be\nboth  implemented  and  compliant  as  defined  in  this\nspecification.\n6. 2.2  Conditional:    In  order  to  be  compliant  with  this\nstandard,  each  conditional  requirement  shall  either  be\nimplemented  as  defined  in  this  specification  or  shall\nboth  not  be  implemented  in  the  user  interface  and  not\nbe supported in some other way by the equipment. (i.e.,\nno   conditional   capability   which   is   present   on   the\nequipment shall be implemented in a manner other than\nas defined in this specification).\n6. 2.3  Recommended:    Implementation  of  these  feat-\nures  is  at  the  discretion  of  the  implementers.  The  only\nrequirement  for  compliance  with  this  specification  for\nthese capabilities is that they be accurately documented\nin the compliance statement for the equipment.\n6. 3  Each requirement/capability shall be marked \u201cYes\u201d\nunder   \u201cImplemented\u201d   if   the   equipment   includes   a\nfeature  which  provides  equivalent  functionality  as  that\ndefined in this specification even if that feature appears\nin a different form. Otherwise it shall be marked \u201cNo\u201d.\n6. 4  Each requirement/capability shall be marked \u201cYes\u201d\nunder  \u201cHCI  Compliant\u201d  if  the  equipment  includes  a\nfeature    which    conforms    to    all    aspects    of    the\nrequirement  or  recommended  capability  as  defined  in\nthis specification. Otherwise it shall be marked \u201cNo\u201d.\nTable 2  HCI Compliance Statement\nHCI Compliance Statement\nMandatory RequirementsReferenceImplementedHCI Compliant\nButton Size5.2.2.1\x1f Yes   \x1f No\x1f Yes   \x1f No\nButton Behavior5.2.2.3\x1f Yes   \x1f No\x1f Yes   \x1f No\nButton Text5.2.2.4\x1f Yes   \x1f No\x1f Yes   \x1f No\nDialog Boxes5.2.5\x1f Yes   \x1f No\x1f Yes   \x1f No\nBasic Network Navigation Model5.3\x1f Yes   \x1f No\x1f Yes   \x1f No\nBasic Layout5.3.6\x1f Yes   \x1f No\x1f Yes   \x1f No\nTitle Panel Basic Information5.3.9\x1f Yes   \x1f No\x1f Yes   \x1f No\nNavigation Panel5.4\x1f Yes   \x1f No\x1f Yes   \x1f No\nRequired Navigation Panel Functions5.4.2\x1f Yes   \x1f No\x1f Yes   \x1f No\nNavigation Panel Layout5.4.4\x1f Yes   \x1f No\x1f Yes   \x1f No\nInformation Panel5.5\x1f Yes   \x1f No\x1f Yes   \x1f No\nCommand Panel5.6\x1f Yes   \x1f No\x1f Yes   \x1f No\nConditional RequirementsReferenceImplementedHCI Compliant\nSaliences5.2.3\x1f Yes   \x1f No\x1f Yes   \x1f No\nInformation Dialog Boxes5.2.6\x1f Yes   \x1f No\x1f Yes   \x1f No\nInput/Selection Dialog Box5.2.7\x1f Yes   \x1f No\x1f Yes   \x1f No\nMessage Dialog Box5.2.8\x1f Yes   \x1f No\x1f Yes   \x1f No\nNetwork Navigation Model with Sub-navigation5.3.4\x1f Yes   \x1f No\x1f Yes   \x1f No\nTitle Panel with Conditional Information5.3.10\x1f Yes   \x1f No\x1f Yes   \x1f No\nTitle Panel Host Communications Status5.3.10.2\x1f Yes   \x1f No\x1f Yes   \x1f No\nTitle Panel Login/Logout Button5.3.10.3\x1f Yes   \x1f No\x1f Yes   \x1f No\nConditional Navigation Panel Functions5.4.3\x1f Yes   \x1f No\x1f Yes   \x1f No\nNavigation Panel Alarm & Help Buttons5.4.5\x1f Yes   \x1f No\x1f Yes   \x1f No\nNavigation Button Labels5.4.6\x1f Yes   \x1f No\x1f Yes   \x1f No\nNavigation Panel Saliences5.4.7\x1f Yes   \x1f No\x1f Yes   \x1f No\nSub-navigation5.4.8\x1f Yes   \x1f No\x1f Yes   \x1f No\nRecommended CapabilitiesReferenceImplementedHCI Compliant\nButton Dimensions5.2.2.2\x1f Yes   \x1f No\x1f Yes   \x1f No\nEnhanced Layout5.3.7\x1f Yes   \x1f No\x1f Yes   \x1f No\nTitle Panel with Additional Information5.3.11\x1f Yes   \x1f No\x1f Yes   \x1f No\nTitle Panel Alarms Button5.3.11.2\x1f Yes   \x1f No\x1f Yes   \x1f No"),(0,i.yg)("p",null,"SEMI E95-1101 \xa9 SEMI 2000, 200115\n7  Related Documents\n7. 1  SEMATECH Documents\n1\nComputer Integrated Manufacturing (CIM) Application\nFramework Specification\nSCC User-Interface Style Guide\nNOTICE: SEMI      makes      no      warranties      or\nrepresentations  as  to  the  suitability  of  the  standard  set\nforth   herein   for   any   particular   application.      The\ndetermination of the suitability of the standard is solely\nthe  responsibility  of  the  user.    Users  are  cautioned  to\nrefer   to   manufacturer\u2019s   instructions,   product   labels,\nproduct   data   sheets,   and   other   relevant   literature\nrespecting   any   materials   mentioned   herein.      These\nstandards are subject to change without notice.\nThe  user\u2019s  attention  is  called  to  the  possibility  that\ncompliance   with   this   standard   may   require   use   of\ncopyrighted  material  or  of  an  invention  covered  by\npatent  rights.    By  publication  of  this  standard,  SEMI\ntakes  no  position  respecting  the  validity  of  any  patent\nrights  or  copyrights  asserted  in  connection  with  any\nitem mentioned in this standard.  Users of this standard\nare  expressly  advised  that  determination  of  any  such\npatent rights or copyrights, and the risk of infringement\nof such rights, are entirely their own responsibility."),(0,i.yg)("p",null,"1  SEMATECH, 2706 Montopolis Drive, Austin, TX, 78741-6499.\nWebsite: ",(0,i.yg)("a",{parentName:"p",href:"http://www.sematech.org"},"www.sematech.org"),"\nCopyright   by   SEMI\xae   (Semiconductor   Equipment   and   Materials\nInternational), 3081 Zanker Road, San Jose, CA 95134. Reproduction o\nf\nthe  contents  in  whole  or  in  part  is  forbidden  without  express  written\nconsent of SEMI."),(0,i.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 20011\nSEMI E96-1101\nGUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE\nThis  guide  was  technically  approved  by  the  Global  Information  and  Control  Committee  and  is  the  direct\nresponsibility  of  the  North  American  Information  and  Control  Committee.  Current  edition  approved  by  the\nEuropean Regional Standards Committee on June 11, 2001, and by the North American Regional Standards\nCommittee  on  July  19,  2001.    Initially  available  at  ",(0,i.yg)("a",{parentName:"p",href:"http://www.semi.org"},"www.semi.org"),"  August  2001;  to  be  published  November"),(0,i.yg)("h1",{id:"2001"},"2001"),(0,i.yg)("ol",{start:2001},(0,i.yg)("li",{parentName:"ol"},"Originally published February 2000.  This document replaces PR5-0699 in its entirety.\n1  Purpose"),(0,i.yg)("li",{parentName:"ol"},"1  This  guide  describes  technical  architecture  choices\nthat  enable  application  components  to  cooperate  in  a\nComputer   Integrated   Manufacturing   (CIM)   environ-\nment  and  reduce  the  effort  required  to  integrate  those\ncomponents  into  a  working  solution.  The  CIM  Frame-\nwork  technical  architecture  guide  builds  on  publicly\navailable  specifications  for  distributed  object  comput-\ning.   It   defines   manufacturing   production   systems\nrequirements for the technical infrastructure needed for\nimproved  component  interoperability,  substitutability,\nand  extensibility.  It  provides  guidance  for  specifying\ncomponents  and  addresses  options  for  using  an  under-\nlying distributed object communication infrastructure."),(0,i.yg)("li",{parentName:"ol"},"2  This  guide  provides  guidance  for  the  technical\nfoundation of the SEMI Computer Integrated Manufact-\nuring  (CIM)  Framework  standards.  It  discusses  a  com-\nponent-based   architecture   using   object-oriented   and\nframework technology that helps implementers achieve\ncomponent interoperability and substitutability, applica-\ntion  extensibility,  and  reuse.  It  establishes  the  role  of\ndistributed object communications infrastructure in pro-\nviding necessary support for the framework technology.\nSpecification  methods  for  mapping  a  CIM  Framework\nspecification  to  alternative  infrastructure  technologies\nare  also  addressed  by  this  technical  architecture.  How-\never,  these  mappings  are  not  intended  to  be  prescrip-\ntive. Further work may be required to define additional\nmappings  to  emerging  technologies.  Many  implement-\nation  issues  that  should  be  resolved  for  a  particular\nsoftware  implementation  are  outside  the  scope  of  this\nguide."),(0,i.yg)("li",{parentName:"ol"},"3  Adhering  to  this  guide  for  technical  architecture\nalone  does  not  provide  interoperability  between  appli-\ncations.  While  the  technical  architecture  provides  a\nfoundation   for   interoperability,   it   is   limited   by   the\nfollowing factors:\n\u2022 Multiple  infrastructure  implementation  choices  are\npossible, and interoperability across these environ-\nments is not guaranteed.\n\u2022 The  technical  architecture  intentionally  limits  its\nscope  to  only  the  most  fundamental  infrastructure\nrequirements,  leaving  additional  technical  issues\nfor  future  guide  upgrades  or  for  implementers\u2019\ndiscretion.\n\u2022 Conformance  to  a  specification  for  CIM  Frame-\nwork  Domain  Architecture  is  also  required  for\ninteroperability of domain components.\n\u2022 More   complete   semantics   (including   behavioral\nconstraints  and  collaboration  patterns)  for  compo-\nnents  are  needed  to  ensure  consistent  interactions\namong     components     developed     by     separate\nsuppliers."),(0,i.yg)("li",{parentName:"ol"},"4  A  guide  for  technical  architecture  is  a  necessary,\nbut  not  a  sufficient,  basis  to  achieve  the  goals  of  the\nCIM  Framework  specifications.  It  does  not  mandate\nspecific  solutions  to  address  the  identified  technical\nrequirements because there are multiple implementation\nchoices that meet these requirements.  Rather, the tech-\nnical   architecture   identifies   those   crucial   technical\nrequirements  that  should  be  considered  by  both  CIM\nsoftware  suppliers  and  consumers.    The  proposed  stan-\ndard  identifies  the  technical  capabilities  implement-\nations  should  provide,  but  leaves  the  implementation\noptions  open.  It  is  the  responsibility  of  suppliers  to\nprovide   and   explain   an   implementation   of   each\ncapability, and the responsibility of consumers to assess\nparticular implementations for use in their factories."),(0,i.yg)("li",{parentName:"ol"},"5  This   guide   provides   guidance   on   the   technical\ntradeoffs   for   services   provided   by   the   distributed\ncomputing  infrastructure  for  the  purpose  of  supporting\nand enabling the domain specifications of CIM Frame-\nwork components.  These areas are:\n\u2022 Distributed Object Communication \u2014 Provides the\nbasic     services     to     enable     implementations\nsupporting the CIM Framework interfaces to trans-\nparently  locate  other,  possibly  distributed  imple-\nmentations   and   exchange   messages   requesting\nstandard   CIM   Framework   operations.   Interface\nDefinition  Language  provides  a  formal  specifica-\ntion  of  the  CIM  Framework  interfaces  that  can  be\nautomatically  transformed  into  conformant  imple-\nmentations ready for integration and interoperation.\n\u2022 Exception  Declarations  \u2014  Identify  the  form  and\nstructure of return messages that inform requestors\nthat    a    requested    operation    resulted    in    an\nanticipated, but abnormal outcome.")),(0,i.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 20012\n\u2022 Event   Specification   \u2014   Establishes   the   delivery\nmechanism,  identification  conventions,  and  data\nstructures  for  reporting  the  occurrence  of  antici-\npated state changes to CIM Framework objects.\n\u2022 Distributed  Transactions  \u2014  Define  mechanisms\nneeded   to   coordinate   the   start,   completion   or\nrollback     of     units-of-work     that     cross     CIM\nFramework component boundaries.\n\u2022 Component   Manager   Support   \u2014   Identifies   the\ncomponent-level    operations    needed    to    create,\nlocate, or remove instances of objects (and manage\ncollections  of  those  objects)  that  support  the  CIM\nFramework specified interfaces.\n2  Scope\n2. 1  Intended Audience\n2. 1.1  This   document   is   intended   for   developers   of\ncomponents  and  applications,  and  integrators  of  MES\nsystems  that  adhere  to  the  CIM  Framework  speci-\nfications.  It  is  also  intended  for  system  architects  who\ncontribute  to  the  evolution  of  the  CIM  Framework\narchitecture and guides based on implementation exper-\nience.  A  guide  for  technical  architecture  is  focused  on\nthe  software  technologies  that  support  the  architectural\ngoals for the CIM Framework rather than on the manu-\nfacturing  domain  concepts  that  the  CIM  Framework\nencompasses.   The   technical   architecture   perspective\ncomplements SEMI E81.\n2. 2  Architectural Issues Not Covered\n2. 2.1  A  number  of  architectural  issues  are  not  covered\nwithin this document because they are beyond the scope\nof  the  CIM  Framework  standards  and  are  not  expected\nto  come  within  the  scope  of  the  standards  as  they  are\nrevised.  They  are  itemized  here  because  a  product\narchitecture  layered  on  the  CIM  Framework  Technical\nArchitecture      should      address      these      additional\narchitecture  issues.  In  these  cases,  other  more  general\nspecifications emerging in the infrastructure technology\nareas  are  expected  to  provide  these  needed  standards.\nThe  CIM  Framework  domain  specifications  do  not\nrequire  specific  conformance  in  these  areas  to  support\ncomponent specifications.\n2. 2.2  Persistence\n2. 2.2.1  Persistence  refers  to  the  ability  of  an  object  to\nmaintain a nonvolatile copy of its current state such that\nthe  object  could  recreate  the  state  during  a  future\ninitialization.  There  are  various  operations  for  object\npersistence,  and  problems  can  occur  if  objects  with\ncross-references   do   not   coordinate   their   persistence\nstrategies   and   mechanisms.   The   CIM   Framework\nexcludes persistence as an implementation mechanism.\n2. 2.3  System Performance\n2. 2.3.1  System performance is highly dependent on the\nselection   of   hardware   and   software   platforms   for\nsystem  execution.  Tests  should  be  performed  to  verify\nadequate  system  performance  and  scalability  for  the\nanticipated  operating  environment.  Performance  tuning\nmechanisms  or  measurement  tools  are  excluded  from\nthe  CIM  Framework  specifications  as  an  implement-\nation dependent mechanism.\n2. 2.4  Data Replication\n2. 2.4.1  Data  replication  is  a  technique  used  to  provide\nadditional  fault  tolerance  or  improve  system  perform-\nance   in   certain   situations.   The   CIM   Framework\nexcludes  specification  of  replication  strategies  as  an\nimplementation dependent mechanism.\n2. 2.5  Change Management\n2. 2.5.1  Change  management  is  the  ability  to  introduce\nand  control  changes  to  the  system  configuration.  The\nCIM  Framework  encompasses  change  management  in\nthe  domain  context  of  document  control,  but  the  CIM\nFramework  excludes  the  broader  treatment  of  change\nmanagement for the MES software configuration itself.\n2. 2.6  Externalization\n2. 2.6.1  Externalization  can  be  used  to  provide  a  form\nof  persistence  or  to  transfer  object  state  between  dis-\njoint implementations. The ability of an object to exter-\nnalize  its  data  and  state  supports  recovery  of  data  and\nstate  for  objects  that  terminated  from  memory.  The\nCIM    Framework    excludes    externalization    as    an\nimplementation dependent mechanism.\n2. 3  This  standard  does  not  purport  to  address  safety\nissues, if any, associated with its use.  It is the responsi-\nbility  of  the  users  of  this  standard  to  establish  appro-\npriate  safety  and  health  practices  and  determine  the\napplicability of regulatory limitations prior to use.\n3  Limitations\n3. 1  The  CIM  Framework  should  continue  to  evolve  to\nmeet the needs of a competitive and vital industry. The\ncontent   of   this   framework   represents   a   significant\namount of real development experience from a number\nof  commercial  software  suppliers  and  their  customers.\nThese specifications reflect the product architectures of\nthose  companies,  as  well  as  the  requirements  of  their\ncustomers.  This  evolution  process  should  continue  as\nmore   products   based   on   the   CIM   Framework   are\ndeveloped.\n3. 1.1  This     guide     acknowledges     the     following\ndeficiencies    that    should    be    addressed    in    future\nrevisions.   These   deficiencies   are   identified   in   the\nfollowing sections."),(0,i.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 20013\n3. 2  Mapping    to    Alternate    Distributed    Computing\nInfrastructures\n3. 2.1  The CIM Framework provides a specification for\nMES software components, specified in terms of gener-\nalized  manufacturing  production  systems  requirements,\nthat  may  be  implemented  using  a  variety  of  technical\ninfrastructure   foundations.   While   the   intent   of   this\nguide is to provide both rigor in specification and flexi-\nbility  to  make  infrastructure  implementation  choices,\nthese  goals  often  conflict.  The  use  of  mapping  tech-\nniques  complicates  the  task  of  integrating  applications\nacross technology boundaries.\n3. 2.2  While  it  is  anticipated  that  a  conformant  imple-\nmentation  using  either  CORBA\n\xae1\nor  the  Microsoft\n\xae2\nDistributed Component Object Model (DCOM) is feasi-\nble  by  mapping  the  specifications  to  the  implementa-\ntion,     it     is     recognized     that     cross-infrastructure\nintegration  is  significantly  more  difficult  (for  example,\nmerging  transaction  models).  The  mapping  described\nhere offers more diverse implementation choices, but it\ndoes not guarantee that all of those chosen technologies\neasily    work    together    in    a    single    heterogeneous\nimplementation.\n3. 2.3  Although    the    DCOM    mapping    provides    a\nstraightforward  transform  from  the  OMG\n\uf6da\nInterface\nDefinition  Language  (IDL)\u2122\n3\nspecifications  for  static\ninvocation,  the  Microsoft  OLE  Automation  interfaces\nmay be required for dynamic invocation. There appears\nto  be  greater  risk  in  being  able  to  successfully  map  the\nCIM  Framework  to  the  OLE  Automation  interfaces.\nThe  requirement  for  dynamic  invocation  should  be\nevaluated with this in mind.\n3. 2.4  Another  issue  with  DCOM  mapping  concerns\nexceptions.  DCOM  returns  exceptions  using  its  return\nvalue  HRESULT.  Many  CIM  Framework  operations\nalready  use  return  values  and  would  not  be  able  to\nreturn  a  HRESULT  without  restructuring  the  return\nmechanism for the operation results.\n3. 2.5  Finally, there has not yet been a detailed analysis\nof the CIM Framework interfaces to verify that they can\nbe     successfully     mapped     using     the     CORBA\nInterworking  Architecture.\n4\nThis  is  especially  true  of\nthe OLE Automation mapping resolution."),(0,i.yg)("p",null,"1 CORBA is a registered trademark of Object Management Group,\nInc. in the United States and other countries.\n2 Microsoft is a registered trademark of Microsoft Corporation, Inc.\nin the United States and other countries.\n3 OMG Interface Definition Language (IDL) is a trademark of Object\nManagement Group, Inc. in the United States and other countries.\n4 Object Management Group. The Common Object Request Broker:\nArchitecture and Specification, Revision 2.2, Object Management\nGroup, 492 Old Connecticut Path, Framingham, MA: Object\nManagement Group, 1998.\n3. 3  Business Rules\n3. 3.1  The  management  of  factory  objects  requires  the\nuse of a set of business rules; that is, procedures repre-\nsenting   common   business   practices   that   should   be\napplied  under  a  given  set  of  circumstances  in  response\nto  some  factory  event.  For  instance,  \u201cDo  not  assign  a\nprocess  job  to  a  machine  which  is  scheduled  for  main-\ntenance  within  24  hours.\u201d  Factory  systems  implement-\nations  typically  specify  business  rules  as  event-driven\nECA    (event-condition-action)    or    ECAA    (event-\ncondition-action-alternative action) rules. For example:\n\u2022 event \u2013\u2013 request to edit a process specification;\n\u2022 condition \u2013\u2013 invalid user access privilege;\n\u2022 action \u2013\u2013 deny access;\n\u2022 (alternative   action   \u2013\u2013   deny   access   and   report\nbreach of security).\n3. 3.2  Business   rules   can   also   be   embodied   in   the\nsequencing  logic  of  sequential  process  definitions.  In\nthis   case   the   business   rules   define   the   criteria   for\nmaking  sequencing  decisions  that  effect  the  flow  of\nwork through the factory.\n3. 3.3  Business  rules  are  intended  to  be  addressed  in\nfuture revisions of this guide.\n3. 4  Security and Access Control\n3. 4.1  The    management    of    sensitive    information\nregarding business processes and product specifications\nrequires     that     MES     implementations     (especially\ndistributed systems) provide some level of security and\naccess control services. Typically, such services:\n\u2022 identify and authenticate any factory object seeking\nsensitive information,\n\u2022 permit  access  to  information  or  operations  based\nupon identity and privilege,\n\u2022 provide security-related audit trails,\n\u2022 provide  secure  communications  (not  susceptible  to\nbeing   intercepted   nor   malicious   or   inadvertent\nmodification), and\n\u2022 administer an enterprise\u2019s security policy.\n3. 4.2  Security  and  access  control  is  intended  to  be\naddressed in future revisions of this guide.\n3. 5  Internationalization\n3. 5.1  Specifications  that  deal  with  issues  related  to\ninternationalization  are  emerging  from  several  sources,\nincluding  the  OMG.  This  guide  should  encompass  the\nneed   and   ability   to   incorporate   internationalization\nfeatures into the CIM Framework specifications."),(0,i.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 20014\n3. 5.2  Internationalization  are  intended  to  be  addressed\nin future revisions of this guide.\n3. 6  Object Properties\n3. 6.1  Object properties refers to a technique that allows\nadditional attributes (data) to be dynamically associated\nwith  an  object  without  changing  the  interfaces  of  the\nobjects to which the properties are attached. This can be\nused  as  a  convenient  dynamic  extensibility  mechanism\nthat  may  be  considered  in  future  CIM  Framework\nspecifications.\n3. 6.2  Object properties are intended to be addressed in\nfuture revisions of this guide.\n3. 7  Object Collections and Queries\n3. 7.1  Object   collections   and   queries   allow   flexible\naccess  to  aggregate  data  for  a  group  of  objects.  This\ncapability  may  be  a  candidate  to  replace  the  limited\noperations   for   collections   found   in   the   component\nmanager interface.\n3. 7.2  Object collections and queries are intended to be\naddressed in future revisions of this guide.\n4  Referenced Standard\n4. 1  SEMI Standard\nSEMI   E81   \u2014   Provisional   Specification   for   CIM\nFramework Domain Architecture\nNOTE 1: As listed or revised, all documents cited shall be the\nlatest publications of adopted standards.\n5  Terminology\n5. 1  Abbreviations and Acronyms\n5. 1.1  ACID \u2014    Atomicity    Consistency    Isolation\nDurability\n5. 1.2  CIM \u2014 Computer Integrated Manufacturing\n5. 1.3  ECA \u2014 Event-Condition-Action (rule)\n5. 1.4  ECAA \u2014    Event-Condition-Action-Alternative\nAction (rule)\n5. 1.5  ENS \u2014 Event Notification System\n5. 1.6  ERP \u2014 Enterprise Resource Planning\n5. 1.7  GUI \u2014 Graphical User Interface\n5. 1.8  MES \u2014 Manufacturing Execution System\n5. 1.9  ODL \u2014 Object Definition Language\n5. 1.10  OMA \u2014 Object Management Architecture\n5. 1.11  OTS \u2014 Object Transaction Service\n5. 2  Definitions\n5. 2.1  application    \u2014    1.    one    or    more    programs\nconsisting   of   a   collection   of   interoperating   objects\nwhich  provide  domain  specific  functionality  to  an  end\nuser  or  other  applications.  2.  functionality  provided  by\none  or  more  programs  consisting  of  a  collection  of\ninteroperating objects.\n5. 2.2  application interface \u2014 the interface provided by\nan application or application program.\n5. 2.3  application  object  \u2014  an  object  implementing  an\napplication interface.\n5. 2.4  architecture  \u2014  the  structure  of  the  components\nof   a   program/system,   their   interrelationships,   and\nprinciples  and  guidelines  governing  their  design  and\nevolution over time.\n5. 2.5  attribute  \u2014  an  identifiable  association  between\nan object and a value. An attribute may have functions\nto set and retrieve its value.\n5. 2.6  behavior \u2014 the effects of performing a requested\nservice,  including  its  results  (e.g.,  changes  in  the  state\nof an object).\n5. 2.7  binding    \u2014    a    specific    choice    of    platform\ntechnologies and other implementation-specific criteria.\n5. 2.8  class   \u2014   the   shared   common   structure   and\ncommon behavior of a set of object implementations.\n5. 2.9  client  \u2014  an  object  that  uses  the  services  of\nanother object by sending messages to it or referencing\nits state.\n5. 2.10  collection  \u2014  an  object  containing  references  to\n(collections    of)    other    objects    with    services    for\nmanaging  them  and  providing  access  to  them  as  a\nrelated group of objects.\n5. 2.11  component     \u2014     a     reusable     package     of\nencapsulated   objects   and/or   other   components   with\nwell-specified,  published  interfaces.  The  component  is\nthe  element  of  standardization  and  substitutability  for\nthe CIM Framework.\n5. 2.12  Computer   Integrated   Manufacturing \u2014   an\napproach   that   leverages   the   information   handling\ncapability   of   computers   to   manage   manufacturing\ninformation  and  support  or  automate  the  execution  of\nmanufacturing operations.\n5. 2.13  conformance \u2014  adherence  to  a  standard  or\nspecification   in   the   implementation   of   a   product,\nprocess, or service.\n5. 2.14  conformance  requirement  \u2014  identification  in\nthe    specification    of    behavior    and/or    capabilities\nrequired by an implementation for it to conform to that\nspecification."),(0,i.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 20015\n5. 2.15  conforming         implementation         \u2014         an\nimplementation   that   satisfies   all   relevant   specified\nconformance requirements.\n5. 2.16  event \u2014 an asynchronous message denoting the\noccurrence   of   some   incident   of   importance.   For\nexample, state change or new object created.\n5. 2.17  event  channel \u2014  the  intermediate  object  that\nforwards published events to interested subscribers.\n5. 2.18  exception  \u2014  an  infrastructure  mechanism  used\nto notify a calling client of an operation that an unusual\ncondition occurred in carrying out the operation.\n5. 2.19  extensibility    \u2014    the    ability    to    extend    or\nspecialize  existing  components  and  add  new  object\nclasses  or  components  while  preserving  architectural\nintegrity and component conformance to standards.\n5. 2.20  framework    \u2014    a    collection    of    classes    or\ncomponents that provide a set of interoperable services\nand functionality for a particular domain.\n5. 2.21  implementation  \u2014  the  internal  view  of  a  class,\nobject  or  module,  including  any  non-public  behavior.\nThe specific code and functionality that implements an\ninterface.\n5. 2.22  implementation   conformance   statement   \u2014   a\nstatement made by the supplier of an implementation or\nsystem    claiming    to    conform    to    one    or    more\nspecifications  and  stating  which  capabilities  have  been\nimplemented.   It   specifically   includes   the   relevant\noptional capabilities and limits.\n5. 2.23  infrastructure   \u2014   the   services,   facilities,   and\ncommunications mechanisms that support the collabor-\nation between and lifecycle of distributed objects.\n5. 2.24  inheritance \u2014 the  ability  to  derive  new  classes,\ntypes   or   interfaces   from   existing   classes,   types   or\ninterfaces.  For  example,  a  derived  class  (\u201csubclass\u201d)\ninherits  the  instance  variables  and  methods  of  the  base\nclass    (\u201csuperclass\u201d)    and    may    add    new    instance\nvariables   and   methods.   In   the   CIM   Framework,\ninheritance  applies  to  interfaces  and  their  specification\nof operations rather than implementations of classes.\n5. 2.25  instance  \u2014  a  software  entity  that  has  state,\nbehavior and identity. The terms instance and object are\ninterchangeable. An object is an instance of an interface\nif  it  provides  the  operations,  signatures,  and  semantics\nspecified  by  that  interface.  An  object  is  an  instance  of\nan  implementation  if  its  behavior  is  provided  by  that\nimplementation.\n5. 2.26  interface \u2014 the external view of a class, object,\nor  module  that  emphasizes  its  abstraction  while  hiding\nits   structure   and   internal   behavior.   An   interface\ndefinition  ideally  includes  the  semantics  of  attributes\nand operations.\n5. 2.27  interoperability     \u2014     the     ability     for     two\napplications or the parts of an application to cooperate.\nIn  the  CIM  Framework,  interoperability  requires  that\napplication  components  be  able  to  support  specified\nrelationships,  share  data,  invoke  each  others\u2019  behavior\n(operations), return exceptions, and exchange events.\n5. 2.28  lifecycle   \u2014   the  life  of  an  object,  including\ncreation, deletion, copy, and equivalence.\n5. 2.29  message \uf8e7   in   object   oriented   systems   a\nmessage  is  the  means  by  which  a  client  object  invokes\nthe  behavior  specified  by  an  operation  of  a  server\nobject.\n5. 2.30  message  bus  \u2014  a  software  infrastructure  that\nprovides distributed communication between objects in\ncomponent  implementations.  It  can  refer  to  an  Object\nRequest   Broker,   Microsoft   DCOM,   Java   Remote\nMethod Invocation or other infrastructure for conveying\nmessages between objects.\n5. 2.31  name-value   pair \u2014   a   data   structure   that\nassociates  a  name  with  an  arbitrary  value,  typically\nused   as   an   extensibility   mechanism   for   conveying\ninformation by name-based retrieval.\n5. 2.32  namespace \u2014   a   namespace   is   a   bounded\ncollection of names with a constraint to ensure that each\nname is unique within the collection.\n5. 2.33  object   \u2014   a   software   entity   that   has   state,\nbehavior,  and  identity.  The  terms  instance  and  object\nare  interchangeable.  An  object  is  an  instance  of  an\ninterface  if  it  provides  the  operations,  signatures,  and\nsemantics  specified  by  that  interface.  An  object  is  an\ninstance   of   an   implementation   if   its   behavior   is\nprovided by that implementation.\n5. 2.34  object services \u2014 interfaces for general services\nthat  are  likely  to  be  used  in  any  program  based  on\ndistributed objects.\n5. 2.35  operation  \u2014  an  operation  is  a  specification  en-\ntity, identified by an operation identifier, that denotes a\nservice  that  can  be  requested.  An  operation  has  a  sig-\nnature  that  describes  the  legitimate  values  of  request\nparameters    and    returned    results,    including    any\nexceptions.\n5. 2.36  persistent  object  \u2014  an  object  that  can  survive\nthe process or thread that created it.\n5. 2.37  productive   entity \uf8e7   productive   entity   is   an\nabstraction of a physical unit, which is involved in any\nway   in   a   production   process   (e.g.   production   or\nsupporting equipment). A productive entity has its own"),(0,i.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 20016\ninternal   logic   and   provides   a   software   interface   to\naccess this logic\n5. 2.38  query \uf8e7  a  message  sent  to  a  server  (e.g.  the\nproductive   entity)   by   a   client   interested   in   some\ninformation  from  the  server  (state  of  the  productive\nentity). A query may or may not have arguments and it\nalways has an answer. The semantics of a query is that\nsome  information  from  the  server  is  returned,  but  the\nquery  cannot  effect  any  change  to  the  state  of  the\nserver.\n5. 2.39  service \uf8e7  a  function  provided  by  a  service\nprovider   that   is   performed   through   an   operation\nspecified by the provider.\n5. 2.40  service  provider,  server \uf8e7  an  object  providing\nservices  to  other  objects  as  specified  by  its  published\noperations.\n5. 2.41  signature    \u2014    a    signature    is    the    name,\nparameters, return values, and exceptions for a specific\noperation.\n5. 2.42  substitutability  \u2014  the  ability  to  replace  a  given\ncomponent   from   one   supplier   with   a   functionally\nequivalent  component  from  another  supplier  without\nimpacting  the  other  components  or  its  clients  in  the\nsystem.\n5. 2.43  trader  service  \u2014 a  collection  of  names  with\nassociated  properties  of  features  for  each  name  and\nmethods     for     manipulating     and     inspection     that\ncollection.\n5. 2.44  type \u2014 a declaration that describes the common\nproperties  and  behavior  for  a  collection  of  objects.\nTypes  classify  objects  according  to  a  common  inter-\nface;  classes  classify  objects  according  to  a  common\nimplementation.\n6  Technical Architecture Guidance\n6. 1  The  computing  infrastructure  provides  the  distrib-\nuted   computing   environment   for   CIM   Framework\napplications.  This  infrastructure  includes  the  operating\nsystem,  networking  and  communications,  data  storage\nand  access,  user  interface  and  presentation  services,\nevent   distribution,   systems   management,   and   many\nother  elements.  Of  these  many  infrastructure  elements,\na  guide  for  technical  architecture  specifies  a  small\nsubset  of  key  services  that  need  to  be  standardized  in\norder  to  facilitate  and  streamline  system  integration\nbetween conformant CIM Framework implementations.\n6. 2  The  CIM  Framework  relies  on  publicly  available\nspecifications   to   define   the   use   of   infrastructure\nservices  wherever  such  published  specifications  exist.\nThe  largest  single  source  for  openly  defined  specifica-\ntions  for  distributed  object  services  is  the  Object  Man-\nagement Architecture.\n5\nReference to this guide does not\nimply  that  CIM  Framework  conformant  implement-\nations  should  implement  the  referenced  services.  The\nimplementations    that    realize    these    infrastructure\ntechnologies  are  outside  the  scope  of  this  guide.  The\ntechnology  choices  made  by  implementers  should  be\nkept  transparent  to  the  CIM  Framework  to  the  greatest\nextent possible.\n6. 3  Distributed Object Communication\n6. 3.1  The  CIM  Framework  documents  assume  the  use\nof  software  infrastructure  to  provide  distributed  com-\nmunication  between  objects  in  an  implementation.  The\nacronym  ORB  was  originated  by  the  OMG  to  describe\nits  distributed  object  communication  infrastructure,  but\nis sometimes used in a more general sense. In this doc-\nument ORB is used only to refer to the OMG specified\ntechnology and the more general term \u201cmessage bus\u201d is\nused for the diverse class of distributed communication\nmechanisms  for  communication  between  objects.  The\nmessage  bus  is  used  to  allow  objects  to  make  requests\nand receive responses from other objects. An object can\ncommunicate through the message bus with objects that\nare  local  or  remote.  Location  transparency  allows  the\nobject  to  remain  ignorant  of  the  actual  location  of  the\nobject with which it communicates.\n6. 3.2  A  primary  criterion  for  a  message  bus  imple-\nmentation is its ability to deliver all messages specified\nby  the  interfaces  of  the  CIM  Framework  components.\nTo accomplish this, the message bus should provide the\nability to support or map a specified interface, including\nits  inherited  features,  data  types,  operations,  object\nreferences,   and   exceptions   to   and   from   runtime\nmarshaled transport formats.\n6. 3.3  Alternate  message  bus  implementation  technolo-\ngies are supported by the CIM Framework by mapping\nthe OMG IDL for the CIM Framework interfaces into a\nspecific  message  bus  implementation.  The  Common\nObject Request Broker: Architecture and Specification\n4\ncontains   sections   that   define   this   mapping   from\nCORBA  to  COM  and  from  CORBA  to  OLE  Automa-\ntion. These sections, called the \u201cInterworking Architec-\nture,\u201d  cover  detailed  rules  for  mapping  OMG  IDL,\ntypes, and exceptions to compatible interfaces in COM\nand OLE Automation.\n6. 3.4  From  a  high  level  perspective,  the  DCOM  and\nCORBA  message  buses  are  comparable.  The  DCOM\ncapabilities are roughly equivalent to those of an ORB.\nHowever, with a lower level analysis, differences show\nup  in  data  types,  inheritance,  object  identity,  and  the\nhandling   of   exceptions.   The   CORBA   Interworking"),(0,i.yg)("p",null,"5 Object Management Group. The Object Management Architecture\nGuide, Revision 3.0, John Wiley and Sons, New York NY, 1995."),(0,i.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 20017\nArchitecture\n4\n(Chapter 15, \u201cInterworking Architecture,\u201d\nChapter 16, \u201cMapping COM to CORBA,\u201d and Chapter\n17,  \u201cMapping  OLE  Automation  to  CORBA\u201d)  defines\nmapping approaches covering:\nInterface Mapping,\nInterface Composition Mapping, and\nIdentity Mapping.\n6. 3.5  These  areas  should  be  addressed  in  order  to  pro-\nvide a mapping between the OMG IDL used to specify\nCIM  Framework  interfaces  and  the  message  bus  used\nfor implementation. If the mapping is not specific (i.e.,\ncan  occur  in  multiple  ways)  then  two  implementations\nmay  not  necessarily  be  able  to  communicate  even  if\nthey  use  the  same  message  bus  type.  Although  the\nCORBA   Interworking   Architecture   is   specific   to\nMicrosoft technologies, it could provide the foundation\nfor future interworking mappings.\n6. 3.6  The   current   CIM   Framework   interfaces   are\nspecified  in  OMG  IDL.  The  interfaces  can  be  directly\ncompiled  and  used  with  any  of  the  available  ORB\nimplementations on the market.\n6. 3.7  The  only  way  to  provide  such  a  direct  solution\nusing  Microsoft  DCOM  would  be  to  create  additional\nCIM   Framework   interface   specifications   in   DCOM\nMIDL and/or OLE Automation ODL. This would allow\ndirect   support   for   message   bus   functionality   using\nDCOM.  For  example,  the  CIM  Framework  memory\nmanagement requirement of \u201cin\u201d for parameter passing\n(see  Section  6.3.15)  would  be  directly  supported  by\nMIDL  and  DCOM  but  since  the  CORBA  exception\nmodel is significantly richer than the DCOM exception\nmodel,  mapping  CORBA  exceptions  to  COM  would\nrequire an additional protocol to be defined for DCOM.\n6. 3.8  The  CORBA  Interworking  Architecture  supports\nmapping the current CIM Framework interfaces defined\nin  OMG  IDL  to  DCOM  MIDL  or  OLE  Automation\nODL.  This  mapping  is  detailed  enough  that  the  map-\nping should always provide the same MIDL/ODL solu-\ntion.  Even  though  the  current  scope  does  not  include\ninteroperability  between  implementations  on  DCOM\nand CORBA (see Section 3.2), the issue of mapping the\ninterface  is  still  the  same.  This  would  also  provide  a\nstep   towards   true   interoperability   using   CORBA/\nDCOM  bridge  products  that  are  beginning  to  become\navailable.\n6. 3.9  Microsoft  also  provides  an  extension  called  OLE\nAutomation.  These  interfaces  are  described  in  Object\nDefinition Language (ODL). The OLE interfaces can be\ninvoked  dynamically  by  a  client  with  no  compile-time\ninterface  knowledge.  The  OLE  data  types  are  a  subset\nof  the  types  supported  in  DCOM,  and  there  is  no  sup-\nport  for  user-defined  constructed  types.  The  mapping\nsolution  differs  for  the  DCOM  and  the  OLE  Automa-\ntion. OLE Automation does not provide as clean a map-\nping  from  OMG  IDL  as  DCOM  does.  This  limitation\nmay  not  allow  some  of  the  interfaces  to  translate  com-\npletely  to  an  OLE  Automation  implementation.  Thus,\ncomponent  suppliers  using  an  OLE  Automation  imple-\nmentation should explain impact on interfaces that were\nnot fully supported due to the Automation restrictions.\n6. 3.10  The  CORBA  Interworking  Architecture  covers\nmapping  issues  for  the  major  areas  of  concern  for  the\nCIM  Framework.  The  areas  of  primary  importance  are\nthe  Interface  mapping,  Interface  composition  mapping,\nIdentity    mapping,    and    Exception    mapping.    The\nCORBA Interworking Architecture gives detailed map-\npings for each of these areas and deals with the DCOM\nand OLE Automation mappings separately. The follow-\ning five subsections summarize these mapping issues.\n6. 3.11  Interface Mapping\n6. 3.11.1  The  OMG  IDL  primitives,  constructed  data\ntypes, and object references map closely to DCOM. The\ninherited  CORBA  interfaces  may  be  represented  as\nmultiple DCOM interfaces. The CORBA attributes may\nbe   mapped   to   get   and   set   operations   in   DCOM\ninterfaces.\n6. 3.11.2  The   OMG   IDL   primitives   map   to   OLE\nprimitives except for special cases. The OLE interfaces\ndo  not  support  constructed  data  types  and  should  be\nmapped  to  specially  constructed  interfaces.  CORBA\nobject  references  map  to  OLE  Automation  interface\npointers.  There  are  difficulties  in  mapping  CORBA\nmultiple   inheritance   to   OLE   Automation   interfaces\ndocumented  in  the  CORBA  specification.\n4\nCORBA\nattributes  may  be  mapped  to  get  and  set  operations  in\nOLE Automation interfaces.\n6. 3.12  Aspects \uf8e7  The  total  behavior  of  a  piece  of  a\nproductive  entity  in  a  factory  can  be  viewed  as  the\nunion of distinct behaviors. Each such isolated behavior\n(or functional area) is called an aspect of the productive\nentity.\n6. 3.12.1  There  is  great  variety  in  productive  entity\nbehavior.  There  are  generic  aspects  that  are  shared  by\nall    or    most    productive    entities    (such    as    recipe\nmanagement   or   process   state   model   or   material\ntracking)  and  there  are  aspects  that  are  specific  to  one\nproductive  entity  type  or  to  a  particular  productive\nentity model. The behavior of each productive entity is\nthe  union  of  the  particular  aspects  of  that  productive\nentity.\n6. 3.12.2  Saying  that  two  pieces  of  productive  entities\nhave  a  certain  aspect  does  not  necessarily  mean  that\nthey  behave  absolutely  the  same  way.  There  are  two"),(0,i.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 20018\nways  by  which  behavioral  variation  within  an  aspect\ncan be modeled: Parameters and Variants.\n6. 3.13  Parameterized  Aspects \uf8e7  An  aspect  can  have\nparameters.  Differences  in  productive  entities  behavior\nare   modeled   by   assigning   different   values   to   the\nparameters.  For  example  if  a  physical  structure  aspect\nof  the  productive  entity  specifies  that  the  productive\nentity  has  a  material  buffer,  the  number  of  material\nunits  (buffer  size)  that  can  be  placed  on  the  buffer  is  a\npossible    parameter.    The    number    of    buffers    the\nproductive entity has can be another parameter.\n6. 3.14  Variants \uf8e7    While  parameterization  is  a  very\npowerful  tool,  there  are  variations  in  behavior  that\ncannot   be   simply   modeled   as   different   parameter\nvalues.  In  this  case  one  can  use  variants.  An  aspect  is\nsaid   to   have   variants   if   there   are   some   different\nbehaviors  related  to  the  same  aspect.  For  example  the\nprocess control aspect can have a discrete variant and a\ncontinuous    variant.    In    the    discrete    variant    the\nproductive  entity  processes  discrete  units  of  material\n(like  the  material  within  a  magazine  or  a  single  wafer\ncarrier),  while  in  the  continuous  variant  the  productive\nentity   processes   continuously   as   long   as      there   is\nmaterial to be processed.\n6. 3.14.1  Differences  between  productive  entities  are\nbest  modeled  as  parameters  when  possible  in  order  to\navoid  an  explosion  of  the  number  of  variants,  while  at\nthe  same  time  trying  to  maintain  the  clarity  of  the\nmodel.\n6. 3.14.2  A  complete  specification  of  the  behavior  of  a\npiece  of  productive  entity  should  specify  variants  for\nthese aspects that have them.\n6. 3.15  Where  do  aspects  and  variants  come  from?  \uf8e7\nThey  leverage  on  previous  work  done  by  the  industry.\nGEM  (Generic  Equipment  Model,  SEMI  E30)  is  a\nprimary source for identifying generic aspects. Various\nSEMs  (Specific  Equipment  Models)  are  a  source  for\nspecific  aspects  and  very  likely  for  variants.  Other\nSEMI    standards    like    SEMI    E-40    (Standard    For\nProcessing  Management)  cover  other  aspects  neglected\nby GEM.\n6. 3.16  Specifying   Productive   Entity   Interfaces   in   a\nFactory \uf8e7   In   order   to   specify   the   interface   of   a\nproductive  entity  it  is  necessary  first  to  identify  the\naspects  (or  variants  of  these  aspects)  supported  by  the\nproductive   entity,   then   to   specify   the   interfaces\nassociated   with   each   aspect.   The   productive   entity\ninterface  specification  is  then  the  sum  of  the  interface\nspecifications for all participating aspects.\n6. 3.16.1  The interface of an aspect (or variants of these\naspects)  is  the  sum  of  its  Queries,  Commands,  Event\nNotifications   and   Service   Requests   and   thus   the\nproblem   of   defining   productive   entity   interface   is\nreduced  to  the  problem  of  defining  the  interfaces  of\nindividual aspects (or variants of these aspects).\n6. 3.17  Architecture \uf8e7   The   productive   entity   in   a\nfactory  is  viewed  as  a  composition  of  its  aspects.  The\ntotal productive entity behavior is therefore represented\nby   the   sum   of   all   its   aspects   representing   these\nbehaviors.  Each  aspect  specifies  a  specific  behavior  of\nproductive    entity    and    provides    an    interface    for\nincoming messages (queries and commands).\n6. 3.17.1  An  aspect  has  a  name.  The  productive  entity\ncan  answer  a  reference  to  one  of  its  aspects  given  the\naspect name:\nAspectInterface aspectNamed(in string\naspectName);\n6. 3.17.2  An  AspectInterface  is  a  virtual  interface  that\nrepresents a generic aspect. All aspect interfaces inherit\nfrom  the  generic  AspectInterface.  When  an  aspect  has\nvariants, the aspect interface itself is virtual, and all its\nvariant interfaces inherit from it.\n6. 3.17.3  Additionally  the  productive  entity  answers  a\nlist of the names of all its aspects:\nStringList allAspectNames();\n6. 3.17.4  The  usual  scenario  for  a  client  is  to  acquire  a\nreference   to   the   productive   entity.   It   then   acquires\nreferences to the productive entity aspects of interest by\nquerying  the  productive  entity.  The  client  then  invokes\nmethods on the aspect interfaces as required.\n6. 3.17.5  The   client   only   needs   to   acquire   aspect\ninterfaces once when it first establishes communication\nwith  the  productive  entity.  From  then  on  it  caches  the\nproductive  entity  interface  as  well  as  the  references  to\nthe   productive   entity   aspects   for   further   use.   The\nprocedure  of  acquiring  references  needs  to  be  repeated\nonly  in  case  the  references  become  invalid  (due  to\nproductive entity restart for example).\n6. 3.18  How To Add A New Aspect \uf8e7 The definition of\nan   aspect   follows   the   following   aspect   definition\npattern. It includes the following items:\n6. 3.18.1  Aspect Name \uf8e7  Each aspect has a name that\nidentifies it.\n6. 3.18.2  Aspect Description \uf8e7  The aspect description\nexplains  the  productive  entity  behavior  covered  by  the\naspect.  If  the  aspect  has  been  derived  from  an  existing\nstandard,  the  description  includes  a  reference  to  this\nstandard.   It   explains   the   concepts   and   the   used\nterminology,   adds   state   models   and   state   transition\ndiagrams   if   required,   and   explains   the   interactions\nbetween  the  productive  entity  and  the  factory  elements\nrelated  to  the  aspect.  If  the  interactions  require  certain\nsequences  of  messages,  they  are  also  described  (as  use\ncases or interaction diagrams)."),(0,i.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 20019\n6. 3.18.3  The   description   also   includes   all   the   side\neffects  and  exceptions  that  can  occur  as  a  result  of  the\ninteractions related to the aspect.\n6. 3.18.4  If the aspect has any relation or effects related\nto other aspects, they are also described here.\n6. 3.19  Variants \uf8e7  If  the  aspect  has  variants,  each\nvariant is named and described.\n6. 3.19.1  IDL \uf8e7 Usually the IDL will include a special\nmodule  for  the  aspect.  The  module  includes  data  type\ndefinitions  specific  to  the  aspect  and  usually  a  single\ninterface    that    provides    the    various    queries    and\ncommands of the aspect. An aspect that has variants has\nan  interface  per  variant.  The  interfaces  for  the  variants\ncan   be   inherited   from   a   common   (abstract)   aspect\ninterface.\n6. 3.19.1.1  An  aspect  that  deals  with  service  requests\nshould also include an IDL definition for the server that\nprovides the services. Which is to be done in a separate\nmodule.\n6. 3.19.2  Aspect    Definition    Example \uf8e7    Here    the\nControl State Aspect has been chosen as an example for\naspect definition.\n6. 3.19.2.1  Aspect Name \uf8e7 Control State\n6. 3.19.2.2  Aspect  Description \uf8e7  The  definition  of  the\nControl  State  Aspect  is  based  on  Generic  Equipment\nModel (GEM) SEMI standard E30.\nNOTE 2: The state diagram presented here is simpler than the\none  in  SEMI  E30,  since  the  internal  sub-states  are  irrelevant\nto  the  productive  entity  interface,  and  the  concept  of  HOST\nOFFLNE is obsolete in a distributed factory environment\n6. 3.19.2.2.1  The  control  state  model  defines  the  level\nof  cooperation  between  the  productive  entity  and  the\nfactory.  It  also  specifies  how  the  operator  interacts  in\nthe different levels of factory control.\n6. 3.19.2.2.2  The   control   state   model   provides   the\nfactory  with  three  levels  of  control  over  the  productive\nentity:\n6. 3.19.2.3  OFFLINE \uf8e7    In    the    OFFLINE    state,\noperation   of   the   productive   entity   is   done   by   the\noperator.  In  the  OFFLINE  state  the  productive  entity\naccepts a query to find out the current control state and\nthe  command  to  change  its  control  state,  but  rejects  all\nother   queries   or   commands   (raising   the   rejected\nexception). While in the OFFLINE state the productive\nentity produces no events and no service requests.\n6. 3.19.2.4  LOCAL \uf8e7    In    the    LOCAL    state    the\nproductive entity is operated by the operator.\n6. 3.19.2.4.1  In  the  LOCAL  state  the  productive  entity\nanswers  all  queries  from  the  factory  and  allows  the\nfactory  to  execute  a  limited  set  of  commands.  The\ncommands  that  are  prohibited  are  those  that  cause\nmovement or directly affect the process. The productive\nentity  sends  events  and  asks  for  services  from  the\nfactory.\n6. 3.19.2.5  REMOTE \uf8e7   In   the   REMOTE   state   the\nproductive  entity  is  controlled  by  the  factory.  The\nfactory has full access to all the necessary commands to\noperate  the  productive  entity  through  the  full  process\ncycle    in    an    automated    manner.    The    degree    of\nautomation    can    vary    from    productive    entity    to\nproductive entity and from factory to factory. Generally\noperators  are  required  to  intervene  in  setup  operations,\noperator   assist   situations,   etc.   Therefore   when   in\nREMOTE  state,  even  though  theoretically  fully  under\ncontrol  of  the  factory,  the  productive  entity  should  not\nrestrict the operator from executing essential operations\nsuch  as  selecting  a  recipe,  pausing  or  resuming  the\nprocess,  operator  assists,  material  movement  to/from\nthe  productive  entity,  initiating  recipe  download  and\nother   productive   entity   specific   commands   on   a\ncommand  by  command  basis  as  needed.  At  the  very\nleast  the  operator  should  be  able  to  change  the  control\nstate,    actuate    an    emergency    stop    and    interrupt\nprocessing (stop, abort or pause).\n6. 3.19.2.6  The     following     diagram     depicts     the\nproductive entity Control State model.\nOFFLINE\nLOCALREMOTE\n123 4\n5\n6\nFigure 1\n6. 3.19.2.7  As  can  be  seen  from  the  diagram,  transition\nfrom any state is allowed to the two others. The aspect\nprovides  the  factory  methods  for  querying  the  current\nstate, for initiating a transition to any of the states, and\nfor events when state transitions occur."),(0,i.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 200110\nVariants : None\nIDL\nmodule ControlStateModule {\n// Type Definitions\nenum ControlState {OFFLINE, LOCAL,\nREMOTE);\ninterface ControlState {\n// Queries\nControlState getControlState()\nraises (EqBasicTypesModule::\nCommunicationFailure);\n// Commands\nvoid changeControlStateToOffline()\nraises (EqBasicTypesModule::\nCommunicationFailure);\nvoid changeControlStateToLocal()\nraises (EqBasicTypesModule::\nCommunicationFailure);\nvoid changeControlStateToRemote()\nraises (EqBasicTypesModule::\nCommunicationFailure);\n};\n};\n6. 3.19.2.8  The   control   state   aspect   can   post   the\nfollowing events:\nControlStateChangedToLocal\nControlStateChangedToRemote\ncontrolStateChangedToOffline\n6. 3.20  Interface Composition Mapping\n6. 3.20.1  The  DCOM  interfaces  do  not  support  multi-\nple  inheritance.  When  multiple  inheritance  is  used  to\nextend  functionality,  the  mapping  is  not  very  difficult.\nWhen multiple inheritance is used to \u201cmix in\u201d orthogo-\nnal  behavior  the  mapping  is  more  difficult.  The  CIM\nFramework  interfaces  that  only  use  single  inheritance\nprovide  the  most  reliable  mapping.  Interfaces  that  use\nmultiple inheritance should follow the detailed mapping\nrules     and     ordering     provided     in     the     CORBA\nInterworking Architecture.\n6. 3.20.2  OLE  Automation  also  has  problems  directly\nsupporting  the  multiple  inheritance  of  CORBA.  The\nCORBA  Interworking  Architecture\n4\nprovides  detailed\nmapping   rules   for   making   the   conversion   where\nmultiple inheritance is used.\n6. 3.21  Identity Mapping\n6. 3.21.1  CORBA  and  DCOM/OLE  Automation  have\ndifferent   notions   of   what   object   identity   means.\nCORBA defines an object as a combination of the state\nand   a   set   of   operations   that   explicitly   define   the\ninstance.  An  object  reference  is  defined  as  a  name  that\nreliably  and  consistently  denotes  an  instantiated  object.\nA   CORBA   object   exists   until   it   is   destroyed;   its\nlifecycle is controlled by the server.\n6. 3.21.2  DCOM does not provide the same mechanism\nfor  identifying  a  particular  object.  DCOM  objects  are\nusually  created  when  used  and  their  state  does  not\npersist as an object instance. DCOM objects exist while\nthey  are  referenced;  their  lifecycle  is  controlled  by  the\nclient. This is true of OLE Automation objects as well.\n6. 3.21.3  The     CORBA     Interworking     Architecture\nprovides  mapping  solutions  for  managing  the  object\nlifecycle. The lifecycle issues should be minimized with\nthe  CIM  Framework  use  of  component  managers  to\ncontrol    object    lifecycles.    The    implementation    of\nDCOM lifecycle mapping should be encapsulated in the\ncomponent manager.\n6. 3.22  Naming\n6. 3.22.1  As   a   mechanism   to   support   initialization\nbetween  collaborating  components,  the  name  of  each\ncomponent  manager  should  be  registered  in  a  publicly\navailable namespace along with the object reference for\nthe component manager. The same name may be reused\nunambiguously  as  long  as  all  occurrences  belong  to\ndistinct  namespaces.  Other  objects  should  be  able  to\nobtain  a  handle  (object  reference)  to  each  component\nmanager   by   utilizing   the   namespace   through   the\noperations  of  a  naming  service.  A  trader  service  may\nalso be used to perform lookup of component managers\nand  other  objects  based  on  well  documented  search\ncriteria. Additional objects may also be registered in the\nnamespace  or  trader  as  appropriate.  The  component\nmanager  serves  as  the  namespace  for  the  objects  it\nmanages,    providing    object    references    for    named\nobjects. Implementations should provide documentation\non  how  to  obtain  available  object  references  in  either\nthe namespace or the trader.\n6. 3.23  Memory Management\n6. 3.23.1  ORB   implementations\u2019   memory   allocation\nand  deallocation  services  should  handle  all  three  types\nof OMG IDL parameter passing:\n\u2022 in  \u2013\u2013  Memory  is  caller-allocated  and  read-only.\nThe caller is responsible for memory deallocation.\n\u2022 out   \u2013\u2013   Memory   deallocation   depends   on   the\nspecific usage of the argument.\n\u2022 inout   \u2013\u2013   Memory   allocation   and   deallocation\ndepend on the specific usage of the argument.\n6. 3.23.2  The  CIM  Framework  uses  only  the  in  para-\nmeter  passing  mechanism.  Within  operations  that  have\nhad  objects  passed  by  reference,  any  modification  of\nthe  object  occurs  by  using  the  in  parameter  as  a  refer-\nence.  Supplier  provided  extensions  to  the  CIM  Frame-\nwork that use either the out  or  inout parameter passing\nmechanism   should   document   the   caller   and   callee\nresponsibilities  with  respect  to  memory  allocation  and\ndeallocation."),(0,i.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 200111\n6. 3.24  Use   of   OMG   IDL   Module   Packaging   Con-\nstructs\n6. 3.24.1  All  IDL  statements  included  as  part  of  the\nspecification  of  SEMI  E81  should  be  contained  within\none or more CIM Framework defined modules.\n6. 3.24.2  CIMFW Module Conventions\n6. 3.24.2.1  Each  CIM  Framework  sub-document  that\nspecifies  IDL  declarations  should  provide  a  full  listing\nof the IDL statements in a compilable IDL file. This file\nmay  be  presented  as  an  appendix  to  the  specification\nprior  to  final  adoption  and  preparation  for  distribution\nwith  the  standard.  The  IDL  file  should  include  module\nstatements  to  enclose  all  IDL  declarations  for  that\nspecification.\n6. 3.24.2.2  IDL  files  (or  appendices)  should  begin  with\na comment identifying the correct name of the file that\ncontains  the  enclosed  IDL  specification.  The  following\nhypothetical   example   illustrates   the   form   of   this\ncomment.\n//File: CIMFactoryLabor.idl\n//Part of the CIM Framework for the\nFactory Labor Component\n6. 3.24.2.3  Every   IDL   appendix   should   contain   the\nfollowing  statement  identifying  the  top-level  module\nthat contains all CIM Framework declarations.\nmodule CIMFW{\n...\n};\n6. 3.24.3  Lower    Level    Modules    within    the    CIM\nFramework Module\n6. 3.24.3.1  The CIM Framework module should enclose\nsecond   level   modules   that   further   package   each\npartition   of   the   CIM   Framework   specification   as\ndefined in SEMI E81. All IDL declarations should thus\nbe scoped, first, to the CIM Framework, and second, to\nthe  specific  component  of  the  framework.  The  fol-\nlowing  example  illustrates  the  positioning  of  elements\nof  the  Factory  Labor  component  within  a  component\nmodule.\nmodule CIMFW{\nmodule FactoryLabor{\ntypedef ..., etc.\n};\n};\n6. 3.24.3.2  Subsequent  decomposition  of  CIM  Frame-\nwork specifications into a third level of module contain-\nment  may  be  necessary  in  some  places,  but  should  be\navoided  where  possible  to  keep  fully  qualified  names\nfrom getting to an unworkable length.\n6. 3.24.4  Conventions  for  CIM  Framework  Dependen-\ncies\n6. 3.24.4.1  Each   CIM   Framework   IDL   file   should\ninclude explicit statements identifying any other files in\nthe CIM Framework specification set that contain mod-\nules that are referenced.  These statements should be in\nthe  form  of  #include  statements.    In  order  to  avoid\ncircular  references  among  related  modules,  a  specifi-\ncation  may  need  to  partition  a  module  into  more  than\none  file  and  include  parts  of  the  module  at  different\npoints in the referencing file. This structure of IDL files\nis  dependent  on  the  specific  implementation  and  which\nparts of the CIM Framework it implements and may be\nadjusted as needed to achieve successful compiles. The\nIDL files distributed with the standard should suggest a\nfile   structure   to   achieve   a   successful   compile,   but\nshould not indicate that the file structure is specified as\na part of the standard. The following example illustrates\nan include statement.\n#include CIMGlobal.idl\nmodule CIMFW{ ...\n6. 3.24.4.2  All  references  to  elements  of  separate  mod-\nules will then need to be fully qualified with the module\nscoping.    For  example,  to  reference  a  type  defined  in\nthe  CIMGlobal  module,  the  reference  should  take  a\nform similar to the following hypothetical example:\n#include CIMGlobal.idl\nmodule CIMFW{\nmodule FactoryLabor{ ...\nGlobal::MachineSequence\nassignedMachines()\nraises\n(Global::FrameworkErrorSignal);\n};\n};\n6. 3.24.4.3  Fully    qualified    names    may    also    be\nautomatically   generated   if   the   target   programming\nlanguage  compiler  supports  the  \u201cnamespace\u201d  concepts.\nFor  example,  the  C++  standard  uses  namespace  and\nJava uses package to support namespaces.\n6. 3.24.5  Guard Statements\n6. 3.24.5.1  To  avoid  the  possibility  of  the  same  CIM\nFramework file being included more than once and thus\ncausing  multiple  definition  errors,  each  module  should\nbe preceded by the following type of guard statement."),(0,i.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 200112\n#ifndef ",(0,i.yg)("em",{parentName:"p"},"CIM_FACTORY_LABOR_IDL"),"\n#define ",(0,i.yg)("em",{parentName:"p"},"CIM_FACTORY_LABOR_IDL"),"\nmodule ...\n};\n#endif // ",(0,i.yg)("em",{parentName:"p"},"CIM_FACTORY_LABOR_IDL"),"\n6. 3.24.5.2  The guard name should be designated by the\nstring  that  begins  and  ends  with  an  underscore  and\nincludes   an   all   caps   version   of   the   filename   with\nembedded  underscores  to  separate  the  parts  of  the\nname.  The  guard  statement  should  be  documented  for\neach module.\n6. 3.24.6  Naming Modules and IDL Files\n6. 3.24.6.1  All   Module   names   for   CIM   Framework\nspecifications  are  scoped  within  the  CIMFW  module\nand need not use redundant prefixing of the name with\nCIMFW.  The  names  should  be  derived  as  closely  as\npossible   from   the   name   of   the   CIM   Framework\nspecification they represent.\n6. 3.24.6.2  All  Names  should  be  composed  of  one  or\nmore  words,  abbreviations  or  acronyms  concatenated\ntogether  with  capital  letters  used  as  delimiters  between\nparts.\n6. 3.24.6.3  Names  should  be  kept  as  short  as  possible\nwhile     still     providing     understandable     semantic\nassociations for the subject module.\n6. 3.24.6.4  IDL  File  names  should  be  based  on  the\nsecond  level  module  contained  within  the  CIMFW\nmodule.\n6. 4  Exception Declarations\n6. 4.1  Exceptions     provide     an     alternative     return\nmechanism  for  operations.  When  performing  a  normal\nreturn, control is returned to the point of invocation and\nthe  provided  return  values  and  output  parameters  are\nvalid.  Abnormal  operation  results  raise  an  exception,\nwhich causes control to return to the defined exception\nhandler   and   breaks   the   flow   of   control.   Any   data\ndefined  as  part  of  the  exception  and  provided  by  the\ncalled  operation  is  valid  and  available  to  the  exception\nhandler.  When  an  exception  is  raised,  normal  output\nparameters  defined  in  the  operation  signature  are  not\nvalid and are not available in the exception handler.\n6. 4.2  Exceptions  are  not  communicated  as  an  oper-\nation  return  code.  An  exception  signifies  that  the  post-\nconditions for successful operation completion have not\nbeen  satisfied.  If,  on  the  other  hand,  the  operation\nmerely  needs  to  communicate  which  one  of  multiple\npost-conditions  were  met,  then  the  operation  should\nprovide  this  information  in  a  return  code  or  return\nstructure as part of the normal operation completion.\n6. 4.3  Exception  declarations  in  OMG  IDL  follow  a  C\nstruct-like  data  structure  with  the  keyword  exception\ntaking the place of struct. It contains attributes that can\nbe   used   to   pass   information   about   an   exception\ncondition   to   a   service   requester.   An   exception   is\ndeclared  with  an  identifier  (ExceptionNameSignal,  the\nexception  name),  which  is  accessible  as  a  value  when\nthe exception is raised, allowing the client to determine\nwhich   exception   has   been   received.   Data   values\nassociated    with    the    exception,    if    declared,    are\naccessible  to  the  client.  The  keyword  raises  is  used  in\nthe  operation  definition  to  specify  that  a  user-defined\nexception  may  be  raised  (or  thrown  in  implementation\nterminology).    The    CIM    Framework    specifications\nassume  that  an  operation  may  raise  a  CORBA-defined\nstandard  system  exception,  thus  these  exceptions  are\nnot specified.\n6. 4.4  The    following    conventions    are    used    when\ndefining exceptions:\nExceptions    are    not    reserved    for    system    or\nprogramming  errors  or  failures,  but  should  be  included\nfor  any  abnormal  application  behavior  in  the  called\nservice.   This   is   consistent   with   CORBA   usage   of\nexceptions for application errors.\nException  descriptions  are  shown  as  OMG  IDL\ncomments similar to descriptions for services.\nReturn values should, if necessary, be implemented\nas fields in the exception definition.\nAll  state  transition  services  (e.g.,  makeXXX  ser-\nvices)  should  include  the  InvalidStateTransition-Signal\nexception in their list of raised exceptions.\nServices that perform a \u201cfind\u201d or \u201clookup\u201d function\nraise  an  appropriate  ObjectType  NotFound-Signal\nexception:  a  null  return  value  is  not  an  appropriate\nresponse.  However,  services  that  return  a  collection  of\nobjects  do  not  raise  an  exception  but  simply  return  an\nempty collection.\nServices   that   perform   \u201cadd\u201d   functions   raise   a\nObjectTypeDuplicateSignal  exception  for  the  case\nwhere  the  object  to  be  added  is  already  in  the  target\ncollection or logical set. The exception includes a field\ncontaining a reference to the currently existing object.\nServices  that  perform  \u201cremove\u201d  functions  raise  a\nObjectTypeNotAssignedSignal    exception    for    the\ncase  when  the  given  object  is  not  in  the  collection  it\nwas     to     be     removed     from     or     ObjectType\nRemovalFailedSignal  exception  if  the  object  could  not\nbe removed."),(0,i.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 200113\nBoolean   query   services   should   rarely   raise   an\nexception unless conditions are such that neither a true\nor false return value can be determined.\n6. 4.5  User-defined  exceptions  can  be  defined  for  any\noperation    specified    in    IDL.    Only    user-defined\nexceptions  that  are  defined  and  listed  in  the  raises\nclause  of  an  operation  should  be  thrown.  Interface-\ndefined  or  other  standard  system  exceptions  may  be\nthrown  without  using  a  raises  clause  on  an  operation.\nThe  data  contained  in  the  user  exception  should  help\nthe caller interpret and deal with the exception. Specific\ndata  can  be  defined  for  each  user  exception.  Any\nadditional    information    that    assists    in    debugging\nsituations should be sent to a tracing or logging facility.\n6. 4.6  Operations    should    throw    standard    system\nexceptions when an error condition clearly matches the\ndefined    exception.    This    ability    should    be    used\njudiciously as the receiver of the exception may not be\nable  to  distinguish  between  a  system-thrown  or  user-\nthrown   exception.   If   a   system   exception   does   not\nclearly  fit  the  situation  at  hand,  then  a  user  exception\nshould  be  defined.  Use  of  user-defined  exceptions  is\npart   of   the   binding   that   should   be   considered   for\ninteroperability and substitutability.\n6. 4.7  The   mapping   defined   for   exceptions   should\nsupport both the system exceptions and user exceptions.\nThe  CORBA  model  uses  the  concept  of  exceptions\nbeing  raised  to  report  error  information.  There  should\nbe    exception    specific    data    associated    with    the\nexception.     The     DCOM     model     provides     error\ninformation  by  returning  an  HRESULT  type.  There  is\nno facility for returning user-defined exception data.\n6. 4.8  The  CORBA  Interworking  Architecture  provides\na  mapping  for  the  CORBA  System  Exceptions  to  the\nDCOM  HRESULT  values.  The  additional  exception\ninformation  for  User  Exceptions  can  be  returned  in  an\nexception  structure  and  added  as  another  parameter  to\nmethods  that  include  the  raises  keyword.  The  OLE\nAutomation mapping provides for the use of a Pseudo-\nAutomation Interface called a pseudo-exception. This is\nincluded in the interface as an additional out parameter.\n6. 4.9  The  mapping  of  exceptions  from  CORBA  to\nDCOM   is   very   complex   and   requires   an   added\nparameter  on  many  of  the  interfaces.  The  complete\nmapping rules are defined in the CORBA Interworking\nArchitecture.\n6. 5  Event Specification\n6. 5.1  This  guide  uses  a  publish/subscribe  model  of\nevents.  Published  events  are  sent  to  subscribers  of  the\nevent  in  an  asynchronous  manner.  The  identity  and\nquantity  of  subscribers  are  not  known  by  the  publisher\nof   an   event.   The   publisher   is   also   known   as   the\n\u201csupplier\u201d and the subscriber known as the \u201cconsumer\u201d\nof the event. Although the receipt of an event can alter\nthe   flow   of   control   in   the   consumer,   they   should\ntypically be used primarily as an information broadcast\nmechanism. Direct operation requests to another object\nshould  be  used  when  affecting  changes  to  critical  flow\nof  control  to  ensure  message  receipt  by  the  intended\nrecipient.\n6. 5.2  This  guide  suggests  the  use  of  an  event  delivery\nmechanism called \u201cevent channels.\u201d Event channels can\nprovide  a  coarse  grain  filtering  capability  for  events.\nConsumers can subscribe to a specific event channel in\norder  to  receive  a  particular  event  type.  The  event\nbroker  specification  of  this  guide  extends  this  event\nchannel capability by adding features for locating event\nchannel, registering for event delivery, and filtering the\nevents  of  interest  to  minimize  performance  penalties\nwhen large numbers of events are present.\n6. 5.3  This    guide    supports    creating,    posting,    and\nsubscribing  to  events.  It  also  provides  the  mechanisms\nto  support  subject-based  addressing.  When  a  consumer\nsubscribes to events for a particular subject, it should be\nnotified whenever an event for the subject is posted by\nany supplier.\n6. 5.4  The  event  delivery  requirements  are  summarized\nas follows:\nSuppliers do not know who the consumers of news\nevents  are;  therefore,  suppliers  do  not  need  to  get  a\n\u201chandle\u201d for them.\nNo  response  or  answer  is  sent  back  from  the\nconsumer(s) to the supplier once the post is completed.\nMessage  delivery  is  based  entirely  on  message\ncontext (subject).\n6. 5.5  Event Content\n6. 5.5.1  The  specification  of  event  content  should  have\ntwo  parts:  a  header  and  a  body.  The  header  should\nconsist of information of a general nature regarding the\nevent,  such  as  the  name  of  its  subject  (a  subject  string\nused    for    identification);    an    aging    factor    (for\ndetermining   event   effectiveness   and   may   be   site\nspecific);    priority;    and    any    filtering    information\nrelevant to event delivery at a general level.  The event\nbody  should  contain:  the  actual  event  message;  the\noriginal time of the event; and data relevant to filtering\nby  the  consumer  of  the  event.  The  body  should  also\ncontain  any  information  required  by  the  consumer  not\nused in the filtering process (called \u201cNews\u201d). The body\nshould be extended with object references as required to\nfacilitate  communication  with  any  objects  associated\nwith the event."),(0,i.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 200114\n6. 5.5.2  The event header is constructed by the supplier\nof  the  event  and  is  used  by  an  Event  Notification\nSystem  (ENS)  to  route  the  event  to  any  consumer\nregistering interest in the event.  Note that the structure\nof the header may be specific to a particular ENS. The\nbody  of  the  event  is  constructed  by  the  event  supplier\nand   is   intended   for   use   by   the   event   consumer.\nConsumers  of  events  express  interest  in  an  event  type\nby  passing  the  subject  name  and  associated  filter  data\nalong   to   the   ENS.   The   ENS   returns   an   original\nconnection, called an event channel, to the consumer.\n6. 5.5.3  Name-value   pairs   are   one   mechanism   that\nshould  be  used  to  define  data  either  in  the  header  or\nbody.   Specific   information   within   the   body   varies\naccording  to  event  type;  issues  such  as  allocation  are\nimplementation dependent.\n6. 5.6  Subject String\n6. 5.6.1  The event subject string should be defined as a\nmulti-level  hierarchy  to  assist  in  event  classification\nand filtering. The levels designate the CIM Framework\nissuing   the   event   component,   the   issuing   interface\nwithin  that  component,  and  the  event  type.    Each  level\nshould  be  delimited  by  a  special  character  (e.g.,  a\nforward   slash:   \u201c/\u201d).   An   example   of   this   syntax   is\n/RecipeManagement/MachineRecipe/ParameterChanged.\n6. 5.7  Filter Data and News\n6. 5.7.1  Filter   data   are   attribute   names,   values,   and\noperators  that  are  specified  by  the  consumer  and  are\nused by the filter subsystem to further qualify an event.\nNews  consists  of  additional  attributes  and  values  that\nare  received  by  the  consumer  but  not  used  in  the\nfiltering  process  and  thus  are  not  specified  by  the\nconsumer.   The   consumer   specifies   the   attributes,\nvalues,  and  operators  upon  which  the  event  data  is\nfiltered.   The   actual   filtering   is   performed   after   the\nsupplier  sends  an  event  but  prior  to  the  consumer\nreceiving  the  event.  The  filterable  data  should  be  well\nknown  and  standardized.  News  may  be  used  by  the\nconsumer  to  further  filter  the  event,  but  the  attributes\nand  values  are  not  standardized.  Additionally,  news\nmay  be  used  to  convey  the  identity  of  the  object\ngenerating the event to any consumer of the event.\n6. 5.7.2  An   Event   Broker   is   required   to   support\nsubscription  to  an  event  channel  that  has  the  specified\nsubject   and   supports   filtering.   The   actual   filtering\nmechanism  is  an  implementation  dependency.  Filter\ndata  is  passed  to  the  Event  Broker  by  the  consumer  to\nqualify   the   particular   events   that   the   consumer   is\ninterested   in   receiving.   The   filter   data   specifies\nfilterable items in which the consumer is interested plus\noperators  and  operands  to  perform  the  filtering.  The\nfiltering sub-system should use the filter data to ensure\nthat  a  specific  event  is  passed  to  the  consumer.  The\ninterface   is   simple   and   does   not   try   to   construct\nadvanced  logic  to  build  the  filter.  The  results  of  the\nfiltering  are  anded  together,  such  that  the  passed  event\nshould  meet  all  of  the  filter  criteria.    The  need  to\nspecify logical operators (e.g., \u201cor\u201d) on the filter criteria\nor  the  use  of  query  languages  should  be  evaluated.\nExtensions  to  the  filter  structures  would  be  required  to\nsupport these additional capabilities.\nNOTE   2:   The   location   of   the   filtering   subsystem   is   an\nimplementation detail.\n6. 6  Distributed Transactions\n6. 6.1  Many  operations  defined  in  the  CIM  Framework\nare related to one another in complex ways that require\nmultiple  operations  to  be  treated  as  a  single  unit  of\nwork.  For  example,  grouping  operations  are  combined\nwith  the  ability  to  make  an  explicit  decision  to  commit\nthe aggregation of changes, or to abort all of the opera-\ntions  and  return  to  the  prior  state.  These  grouping  of\noperations are consistent with the familiar concept of a\ntransaction (most commonly encountered in the context\nof  database  management  systems).  CIM  Framework\nobjects  should  be  capable  of  participating  in  trans-\nactions as described below. However, the choice of how\nan  object  participates  is  implementation  specific.  For\nexample,  the  implementer  chooses  the  implementation\ntechnology  and  whether  a  change  in  object  state  is\nrecoverable  (that  is,  whether  a  change  in  state  can  be\nrolled back).\n6. 6.2  A  transaction  is  a  contract  between  two  or  more\nobjects to perform some action based upon one or more\nrequests   in   some   context   and   having   the   ACID\nproperties as follows:\n6\n\u2022 Atomicity  \u2013\u2013  State  changes  are  atomic;  either  all\nhappen  or  none  happen.  These  changes  include\ndatabase changes, messages and events.\n\u2022 Consistency  \u2013\u2013  A  correct  transformation  of  state.\nActions  taken  as  a  group  do  not  violate  any  of  the\nintegrity constraints associated with the state.\n\u2022 Isolation   \u2013\u2013   Even   though   transactions   execute\nconcurrently,  it  appears  to  each  transaction  T  that\nothers  executed  either  before  T  or  after  T,  but  not\nboth.\n\u2022 Durability    \u2013\u2013    Once    a    transaction    completes\nsuccessfully (commits), its changes to state survive\nfailures.\n6. 6.3  For example, consider a lot that starts processing\nin  a  piece  of  equipment.  The  states  of  the  lot  and  the"),(0,i.yg)("p",null,"6 J. Gray, Transaction Processing Concepts and Techniques, Morgan\nKaufmann Publishers/Harcourt Brace and Co., 6277 Sea Harbor Dr.,\nOrlando, FL, 1993."),(0,i.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 200115\nequipment  should  change  in  order  to  accurately  track\nthe   state   of   the   factory.   Coordinating   the   lot   and\nequipment state changes as a transaction guarantees that\nfactory state can be recovered accurately.\n6. 6.4  Transactions  are  created  by  a  user  of  a  service\n(the client) requesting an operation from a provider of a\nservice  (the  server).  To  maintain  the  ACID  properties\nof  a  transaction,  the  server  should  be  able  to  return  to\nthe  state  prior  to  the  request  for  the  operation  in  the\nevent  of  a  failure.  In  this  sense,  the  server  should  be\nrecoverable.  Failures  are  either  software  or  hardware\nevents  that  prevent  the  completion  of  the  transaction.\nThe  server  is  a  recoverable  server  if  it  is  able  to  main-\ntain the ACID properties when faced with a failure.\n6. 6.5  Transactions  should  be  designed  in  a  manner\nsuch  that  they  do  not  span  a  period  of  interaction  with\nan  external  entity  such  as  a  person  using  a  GUI  or  a\npiece  of  equipment.  Waiting  for  the  response  from  an\nexternal entity can result in locks being held for multi-\nple  seconds,  minutes,  or  longer.  This  can  adversely\naffect  other  transactions  by  causing  time-outs  or  dead-\nlocks.  These  types  of  transactions  can  usually  be  split\ninto  multiple  serially  executed  transactions  with  some\nsmall  amount  of  extra  revalidation  of  current  states  at\nsucceeding transactions.\n6. 6.6  Coordinating  the  completion  of  transactions  may\ninvolve multiple servers and may entail either commit-\nting  the  successfully  completed  transaction  or  rolling\nback the unsuccessful transaction. This activity imposes\nadditional   overhead   on   a   system.   Suppliers   and\nconsumers  should  assess  the  impact  of  transactions  on\nsystem   performance   during   component   design   and\nselection of transactional events.\n6. 6.7  Transactions  may  cause  physical  effects  in  the\nmanufacturing system that cannot simply be rolled back\nin  accordance  with  the  ACID  properties.  Application\nand  system  designers  should  include  ways  to  modify\nthe  logical  view  of  the  system  to  match  the  physical\nreality  of  the  manufacturing  floor  if  such  a  mismatch\noccurs.\n6. 6.8  Transactions  can  create  CIM  Framework  events\nas  state  changes  occur.  As  the  transaction  may  not  be\ncommitted  at  the  point  of  event  creation,  the  event\nshould  not  be  visible  outside  the  transaction  until  the\nfinal  commit  point.  The  details  of  performing  this  task\nare  implementation  dependent.  For  example,  the  event\nannouncing the completion of a lot at a processing step\nshould   not   be   published   until   the   processing   step\ncompletion  transaction  is  committed.  Otherwise,  the\nevent  could  be  published,  but  the  transaction  subse-\nquently rolled back, creating a system inconsistency.\n6. 6.9  Transactions  should  be  able  to  be  nested,  thus\nproviding the ability to define transactions within other\ntransactions.  These  sub-transactions  can  generate  addi-\ntional  sub-transactions,  thus  forming  a  hierarchy  of\ntransactions.  In  the  spirit  of  maintaining  the  ACID\nproperties,  each  sub-transaction  can  issue  a  commit  or\nrollback  for  its  piece  of  work.  The  results  of  the  sub-\ntransaction  are  only  available  to  the  parent  transaction.\nThe  sub-transactions  commit  becomes  permanent  only\nafter it issues a local commit and all ancestors commit.\nIf the parent transaction does a rollback, all descendent\ntransactions  are  rolled  back  regardless  of  any  local\ncommits.\n6. 6.10  There are two types of transactions widely sup-\nported  for  distributed  object  infrastructures.  The  OMA\nsupport  for  transactions  is  described  in  the  OMG\u2019s\nObject  Transaction  Service  (OTS).  Microsoft  provides\nsupport  for  transactions  with  its  Microsoft  Transaction\nServer  (MTS)  product.  The  OTS  closely  aligns  with\nother  standards  such  as  The  Open  Group  Distributed\nTransaction  Processing  (DTP)  model.\n7\nUsing  industry\nstandard  protocols  as  a  base,  the  OTS  supports  inter-\nfacing with products from the major database suppliers.\nUsing  the  provided  OTS  interfaces  and  information\nabout  The  Open  Group  standards,  non-ORB  supplied\ndatabase  interfaces  could  be  developed  to  allow  for\ninteroperability   with   other   cooperating   transaction\nservices.  MTS  also  supports  transactions  with  major\ndatabase suppliers through use of The Open Group XA\ninterface.   Using   the   MTS   Software   Developer   Kit,\ntransaction support can be extended to other resources.\n6. 6.11  Combining heterogeneous components based on\na combination of OTS and MTS is not straightfor-ward.\nAlthough both rely on the XA interface for dis-tributed\ntransaction   coordination,   they   are   not   designed   to\noperate  with  each  other.  Both  OTS  and  MTS  hide  the\ndetails of transactions from users. This makes either so-\nlution very convenient, but makes linking them together\nmore  difficult.  For  example,  suppose  a  CORBA-based\ncomponent  adhering  to  OTS  should  interact  with  an\nMTS-based   component.   The   scenario   calls   for   the\nCORBA  based  component  to  use  the  XA  interface  to\nwork  with  the  MTS  provided  transaction  coordinator\n(see  Gray\n8\nfor  additional  information  on  distributed\ntransactions). However, in hiding XA complexity, OTS\nalso  hides  the  ability  to  readily  specify  the  transaction\ncoordinator  (OTS  does  this  behind  the  scenes).  CIM\nFramework   component   developers   and   consumers\nshould determine the relative need for distributed trans-\nactions  spanning  OTS  and  MTS  against  the  additional\ncomplexity  of  developing  a  XA-based  mechanism  for\ncombined OTS and MTS transactions."),(0,i.yg)("p",null,"7  The Open Group, Distributed TP: The XA+ Specification, Version\n2, The Open Group, 11 Cambridge Center, Cambridge MA, 1994."),(0,i.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 200116\n6. 6.12  The ACID properties provided by either OTS or\nMTS  may  be  used  for  CIM  Framework  transactions.\nMany   implementation   details   are   supplier   specific;\nhowever,  the  major  architectural  principles  have  been\ndescribed above.\n6. 7  Component Management\n6. 7.1  A  component  refers  to  a  collection  of  related\ninterfaces that form a coherent subsystem. Components\nmay have a component manager to assist in the tracking\nand management of the instantiated interfaces (objects).\nThe objects that are managed by a component manager\nare called managed objects.\n6. 7.2  Component Level Interface\n6. 7.2.1  Component  managers  provide  services  such  as\nreporting  on  the  collection  of  instances  they  manage\nand  creating  object  instances.  The  component  manager\nprovides the following:\nObject references to managed objects.\nCollective queries for some aspect (usually a state)\nacross all the objects it manages.\nServices for:\nCreating   a   managed   object   and   returning   a\nreference  to  it,  or  receiving  an  object  reference\nto   a   newly   created   object.   The   component\nmanager then \u201cregisters\u201d the object reference.\nRemoving managed objects.\nFinding managed objects.\n6. 7.3  Component Manager Classification\n6. 7.3.1  Component  Managers  are  classified  by  their\nallowable number of instances.\n6. 7.3.2  Unique Component Managers\n6. 7.3.2.1  A  unique  component  manager  describes  a\ncomponent manager for which there is only one running\ninstance in an MES implementation. Unique component\nmanagers are used when a single point of factory level\ncontrol or focus is required. An example use of this pat-\ntern  might  be  an  interface  within  a  Dispatcher  compo-\nnent   called   DispatchingManager.   This   might   be   a\nunique  component  manager  because  multiple  dispatch-\ning  systems  on  the  factory  floor  could  create  problems\nwith work scheduling.\n6. 7.3.3  Non-Unique Component Managers\n6. 7.3.3.1  A  non-unique  component  manager  describes\na component manager for which multiple instances may\nbe running in an installed MES system. The component\nmanager instances are derived from the same code base,\nbut  have  separate  instance  data  for  each  running  in-\nstance.  Non-unique  component  managers  should  be\nregistered  with  the  factory  with  some  selection  criteria\nin order for a requester to be able to obtain a handle to\nthe  correct  instance.  An  example  use  of  this  pattern  is\nthe  scenario  in  which  several  ProductManagers  are\nemployed within a production system.\n6. 8  Architecture For Service Requests\n6. 8.1  Services are implemented by a factory object that\nis  the  service  provider.  The  productive  entity  in  a\nfactory  invokes  the  service  methods  on  that  factory\nobject.\n6. 8.1.1  For  example,  a  recipe  server  could  offer  the\nfollowing interface:\ninterface RecipeManagementServer {\n// upload a recipe\nvoid acceptRecipe(\nin string recipeName,\nin Recipe recipe);\n// download a recipe\nRecipe provideRecipe(in string\nrecipeName);\n};\n6. 8.1.2  The  problem  with  service  requests  is  that  they\nrequire a flow from the productive entity to the factory\nobject  that  provides  the  service.  This  kind  of  reverse\nflow contradicts the principle of layered architecture by\nwhich  the  productive  entity  is  supposed  to  be  a  more\nprimitive   entity,   unaware   of   factory   objects,   their\nlocations   and   their   structures.   The   trading   service\naddresses this problem.\n6. 8.2  Trading Service\n6. 8.2.1  Using Trading Service\n6. 8.2.1.1  A  trading  helps  clients  to  locate  services.  An\nobject  that  must  locate  a  service  must  know  how  to\naccess the trading service.\n6. 8.2.1.2  A  trading  service  relies  on  the  description  of\nthe service itself, rather than any attribute relating to the\nserver that provides the service (such as the name of the\nserver).  It  must  be  able  to  describe  the  service  it\nrequires. The trading server locates a server that fulfills\nthe required service profile.\nNOTE 3: The  trading  service  described  here  is  based  on  the\nCORBA  COS  Trading  Object  Service,  implementations  of\nwhich    are  available  from  vendors  of  CORBA  environments.\nThe  solution  however  does  not  require  the  full  generality  of\nthe COS Trading Object Service, and can be viewed as a strict\nsubset of the latter.\n6. 8.2.2  The Trading Concept\n6. 8.2.2.1  A  trading  scenario  is  based  on  a  server  that\nexports a service to a trader. The client then imports the\nservice  from  the  trader,  receiving  a  reference  to  the\nserver on which it can invoke the service.\n6. 8.2.2.2  This is depicted in the following diagram:"),(0,i.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 200117\nTrader\nClientServer\nexport(1)import(2)\nservice interaction(3)\nFigure 2\n6. 8.2.2.3  The  diagram  suggests  that  the  server  exports\nits service to the trader. In practice any object aware of\nthe  server  and  its  provided  services  could  assume  this\njob.  For  example,  a  factory  configuration  object  could\nbe responsible for exporting all services to the trader.\n6. 8.2.3  Trading Service Models\n6. 8.2.3.1  The trader has to implement two interfaces:\n\u2022 The   Register   interface   allows   other   objects   to\nregister export service offers to the trader.\nNOTE 4: This   interface   is   used   e.g.   by   the   service\nprovider  to  inform  the  trader  about  the  services  the\nservice provider offers.\n\u2022 The   Lookup   interface   allows   other   objects   to\nlookup the trader for a required service.\nNOTE 5: This  interface  is  used  by  e.g.  the  productive\nentity to find a service provider for a specific service.\n6. 8.2.4  Export Use Cases\n6. 8.2.4.1  The trader offers an interface named Register,\nthat  allows  a  server  to  register  its  services  with  the\ntrader.\n6. 8.2.4.2  The   IDL   definitions   given   below   are   for\nillustrative  purposes.  They  are  extracted  from  the  COS\nTrading   Object   Service   specification   ","[OMG]",".   For\nclarity, not all services are included here.\n6. 8.2.4.3  Exporting a Service\n6. 8.2.4.4  To export a service, the server uses:\nOfferId export (\nin Object reference,\nin ServiceTypeName type,\nin PropertySeq properties\n);\n6. 8.2.4.5  The  server  passes  a  reference  to  itself,  and\ndescribes its offer by passing in a service type name and\na list of properties of the service. The trader answers an\noffer    id,    through    which    the    server    can    further\nmanipulate its offer.\n6. 8.2.4.6  Factory    service    offers    are    described    as\nfollows:\n6. 8.2.4.6.1  Service Type Name\n6. 8.2.4.6.2  The  type  is  a  string  naming  the  service\nitself.  We  are  yet  to  agree  upon  the  services  supported\nby   this   specification.   The   following   are   obvious\ncandidates:\n\u2022 Recipe Service\n\u2022 Wafer Map Service\n\u2022 Fixtures Service\n8\n6. 8.2.4.6.3  Properties\n6. 8.2.4.6.3.1  Properties  are  used  to  characterize  and\nspecialize the service. A property is a name/value pair,\nwhere the name is a string naming the property, and the\nvalue specifies the property value offered by the server.\nThe  constraint  language  defined  by  the  COS  Trading\nObject  Service  ","[OMG]","  limits  the  type  of  values  to  the\nbasic data types (such as numbers, chars, booleans and\nstrings) and sequences of these.\n6. 8.2.4.6.3.2  The  following  properties  are  to  be  used\nfor registering factory services:\n\u2022 \u201cServiced Productive entities\u201d \uf8e7 The value of this\nproperty is a list of the ids of the productive entities\nserviced   by   this   server.   This   allows   multiple\nservers   of   the   same   type   to   be   installed,   and\npartition  the  productive  entity  service  among  the\navailable  servers.  Note  that  it  does  not  require  the\nserver  to  know  the  productive  entities  it  serves,\nsince  the  server  registration  can  be  done  by  a\nfactory configuration service.\n\u2022 \u201cServiced Areas\u201d \uf8e7 The value of this property is a\nstring  collection  naming  the  factory  areas  serviced\nby  the  server.  This  property  is  another  means  of\npartitioning  the  service  among  multiple  servers.\nThe  area  could  be  a  name  of  a  cell  controller  if\ncellular manufacturing is practiced, or the name of\nany    organizational    unit    implemented    by    the\nfactory,  and  known  to  the  factory  configuration\nservice.\n6. 8.2.4.7  Withdrawing a Service\n6. 8.2.4.7.1  To withdraw a registered service, the server\n(or the configuration service) uses:\nvoid withdraw (\nin OfferId Id);"),(0,i.yg)("p",null,"8 In back end fixtures is a generic name for durables and consumable\nmaterials"),(0,i.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 200118\n6. 8.2.4.8  Querying a Registered Service\n6. 8.2.4.8.1  A server may query the trader the details of\na registered service by passing in the offer id.\nStruct OfferInfo {\nObject  reference;\nServiceTYpeName  type;\nPropertySeq  properties;\n};\nOfferInfo describe (\nin OfferId  id);\n6. 8.2.4.9  Modifying a Registered Service\n6. 8.2.4.9.1  The  server  may  modify  the  properties  of    a\nregistered  service.  It  may  add  new  properties,  delete\nexisting  properties,  or  modify  the  value  of  existing\nproperties. This is done using the following method:\nvoid modify (\nin OfferId  id,\nin PropertyNameSeq  del_list,\nin PropertySeq  modify_list\n);\n6. 8.2.4.9.2  The  properties  named  in  the  del_list  are\ndeleted.  Properties  in  the  modify_list  that  do  not  exist\nare   added.   Properties   in   the   modify_list   that   exist,\nreceive a new value.\n6. 8.2.4.9.3  The  modify  method  can  be  used  to  support\nchanges   in   the   factory   configuration,   such   as   new\nproductive  entity  being  added  or  deleted,  a    productive\nentity  being  migrated  from  one  cell  to  another,  a  new\nload balancing policy for the servers installed, etc.\n6. 8.2.5  Import Use Cases\n6. 8.2.5.1  Importing  a  Service \uf8e7  The  trader  offers  an\ninterface named Lookup that clients can use in order to\nlocate a service:\nvoid query (\nin ServiceTypeName  type,\nin Constraint  constr,\nin Preference  pref,\nin PolicySeq  policies,\nin SpecifiedProps  desired_props,\nin unsigned long  how_many,\nout OfferSeq  offers,\nout OfferIterator  offer_itr,\nout PolicyNameSeq  limits_applied\n);\n6. 8.2.5.1.1  The   Query   in   Parameters   \uf8e7   The   \u201cin\u201d\nparameters are used by the client to specify the service\nit needs and the policies for searching it.\n\u2022 The \u201ctype\u201d parameter is key to the central purpose\nof trading. It specifies the name of the service type\nthe client is interested in.\n\u2022 The \u201cconstraint\u201d guides the trader on how to select\na  server  based  on  its  registered  properties.  It  is  a\nstring  that  describes  the  selection  in  some  given\nconstraint  language.  The  typical  constraints  will\nselect a server for a specific productive entity or for\nthe  area  the  productive  entity  belongs  to.  Both\npossibilities  use  the  \u201cin\u201d  operator  for  testing  the\ninclusion  of  an  element  in  a  set.  Some  examples\nfollow:\n\u201cDieAttachXYZ in ServicedProductive-\nEntities\u201d\n\u201cCell22 in ServicedAreas\u201d\n6. 8.2.5.1.2  \u201cPreferences\u201d  specify  how  should  a  server\nbe  selected  in  case  the  query  results  in  more  than  one\nanswer.  It  is  suggested  that  this  parameter  be  ignored,\nwhich means that the default of first is always used.\n6. 8.2.5.1.3  The  \u201cpolicies\u201d  parameter  guides  the  trader\non  how  to  choose  a  policy  for  performing    the  search.\nSearch  policies  are  a  rather  complicated  issue,  which\ncan be ignored in the Simple Trader case.\n6. 8.2.5.1.4  The \u201cdesired_props\u201d parameter instructs the\ntrader which properties are to be returned as part of the\nanswer (it does not affect the selection itself). This does\nnot  make  much  sense  with  the  limited  set  of  properties\nwhich  has  been  defined,  and  can  also  be  ignored  (use\nnone as the parameter value).\n6. 8.2.5.1.5  The \u201chow_many\u201d parameter is another way\nto  restrict  the  number  of  answers.  It  is  proposed  that  1\nalways be used as the value of this parameter.\nNOTE 6: Should  areas  be  used  as  the  selection  criteria,  the\nequipment  must  be  aware  of  its  area  within  the  factory.  This\nshould    be    supported    through    the    productive    entity\n\u201cConfiguration\u201d aspect.\n6. 8.2.5.1.6  The Query out Parameters\n6. 8.2.5.1.6.1  The  query  returns  the  selected  servers  in\none of two forms: a collection of services or a reference\nto an iterator through which the returned servers can be\nobtained.  The  second  method  is  designed  for  queries\nthat  may  return  a  large  number  of  offers.  One  can\nalways  assume  that  results  are  returned  within  the  first\nout parameter (out OfferSeq offers), namely a sequence\nof offers.  Furthermore, having specified 1 as the value\nof  the  \u201chow_many\u201d  parameter,  it  is  ensured  that  the\nanswered sequence contains at most one element.\n6. 8.2.6  Locating the Trading  Service\n6. 8.2.6.1  The  productive  entity  locates  the  services  it\nrequires using a trading service.\n6. 8.2.6.2  A  client  can  obtain  a  reference  to  the  trading\nservice by invoking the following method on the ORB:\nObject resolve_initial_references (\nin ObjectId identifier)^\nraises (InvalidName);\nWhere:\nthe  reserved  name  \u201cTradingService\u201d  is  passed  as  the\nidentifier."),(0,i.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 200119\n6. 8.2.7  A Usage Scenario Example\n6. 8.2.7.1  Here is an example of a usage scenario.\n6. 8.2.7.2  In     common     factory     practice,     cellular\nmanufacturing   has   a   factory   configuration   service\nresponsible   (among   other   things)   for   exporting   the\nfactory  services  to  the  trading  service.  The  following\nare some typical use cases:"),(0,i.yg)("h1",{id:"1"},"1"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"The  factory  configuration  service  registers  a  wafer\nmap  server  to  server  two  cells  named  CellA  and\nCellB.\nThe factory configuration service obtains an initial\nreference to the trading service from the ORB:\ntrader =\norb.resolve_initial_refer\nences(\u201cTradingService\u201d);\nThe trader answers its Register\ninterface:\ntraderRegistry =\ntrader.register_if();\nThe factory configuration service builds properties\nas   a   single-itemed   sequence   of   containing   one\nname/value  pair  whose  name  is  \u201cServicedAreas\u201d\nand  whose  value  is  a  sequence  of  the  cell  names\n{\u201cCellA\u201d,   \u201aCellB\u201d}.   It   then   uses   the   Register\ninterface  of  the  Trading  Service  to  register  the\nservice offer:\ntraderRegistry.export(\nwaferMapServer,\u201dWafer Map\nService\u201d, properties);")),(0,i.yg)("h1",{id:"2"},"2"),(0,i.yg)("ol",{start:2},(0,i.yg)("li",{parentName:"ol"},"The  configuration  manager  informs  a  Die  Attach\nequipment that it belongs to CellA.\nProductiveEntities.setArea(\u201cCellA\u201d);")),(0,i.yg)("h1",{id:"3"},"3"),(0,i.yg)("ol",{start:3},(0,i.yg)("li",{parentName:"ol"},"The Die Attach needs a wafer map.\nIt obtains an initial reference to the trading service\nfrom the ORB:\ntrader =\norb.resolve_initial_refer\nences(\u201cTradingService\u201d);\nThe trader answers its Lookup interface:\ntraderLookup = trader.lookup_if();\nThe  productive  entity  looks  up  the  trading  service\nfor the wafer map service:\ntraderLookup.query(\n\u201cWafer Map Service\u201d,\n\u201cCellA in ServicedAreas\u201d,\npref, policies, desired_props,\n1, preference, offers,\noffers_itr, limits_applied);\nThe   wafer   map   server   is   returned   as   the   first\nelement  of  the  offers  sequence.  The  productive\nentity  may  keep  the  reference  to  the  wafer  map\nserver for future use.")),(0,i.yg)("h1",{id:"4"},"4"),(0,i.yg)("ol",{start:4},(0,i.yg)("li",{parentName:"ol"},"The Die Attach can now invoke the service on the\nwafer map server:\nwaferMapServer.getWaferMap(...);\n7  Technical Architecture Conformance"),(0,i.yg)("li",{parentName:"ol"},"1  Conformance  is  defined  as  \u201cadherence  to  a  stan-\ndard  or  specification  in  the  implementation  of  a  pro-\nduct,  process,  or  service.\u201d  A  conforming  implementa-\ntion  should  have  an  associated  implementation  con-\nformance  statement  that  details  the  capabilities  that\nhave  been  implemented.  While  recognizing  that  the\nCIM Framework is, by definition, not a complete speci-\nfication  of  a  MES,  a  guide  for  technical  architecture\ndefines conformance for each of its major requirements\nas follows."),(0,i.yg)("li",{parentName:"ol"},"2  Distributed Object Communications Conformance"),(0,i.yg)("li",{parentName:"ol"},"2.1  The  CIM  Framework  object  model  is  based  on\nthe  ability  to  issue  service  requests  to  a  component\nobject  and  to  subscribe  to  events  published  by  the\ncomponent object. Component suppliers should explain\nhow  these  two  forms  of  communications  are  accom-\nplished so consumers can assess the ease and feasibility\nof   integrating   a   component   into   the   factory   MES.\nExample  terminology  specific  to  semiconductor  manu-\nfacturing  is  provided  for  clarity.  It  does  not  preclude\napplication specialization for other industries."),(0,i.yg)("li",{parentName:"ol"},"3  Exception Conformance"),(0,i.yg)("li",{parentName:"ol"},"3.1  Alerting  operation  requesters  of  abnormal  out-\ncomes  is  essential  for  robust  implementations.  Compo-\nnent  suppliers  should  explain  how  their  implementa-\ntions  support  raising  specified  system  and  user-defined\nexceptions."),(0,i.yg)("li",{parentName:"ol"},"4  Event Specification Conformance"),(0,i.yg)("li",{parentName:"ol"},"4.1  Notification  of  asynchronous  occurrences  is  a\ncornerstone   of   distributed   event-driven   application\ndomains  such  as  MES.  Suppliers  should  explain  how\ntheir  components  support  event  delivery,  including  the\nregistration of event suppliers, event consumers and the\nprovision for Event Broker features for event filtering."),(0,i.yg)("li",{parentName:"ol"},"5  Distributed Transaction Conformance"),(0,i.yg)("li",{parentName:"ol"},"5.1  Ensuring consistent state changes among compo-\nnents  is  a  key  concern  in  the  integration  of  a  factory\nMES.  Component  suppliers  should  explain  how  their\ncomponents support transactional units of work."),(0,i.yg)("li",{parentName:"ol"},"6  Component Management Conformance"),(0,i.yg)("li",{parentName:"ol"},"6.1  Component  suppliers  should  explain  how  object\ninstances are managed. This includes how the object is\nidentified, constructed, accessed, and destroyed (or flat-\ntened in the case of a persistent object). It also includes")),(0,i.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 200120\nmechanisms  for  query  or  lookup  of  specific  managed\nobject instances.\n7. 7  General Rules for CIM Framework Conformance\n7. 7.1  The  following  rules  define  the  general  expecta-\ntions  for  technical  conformance  to  any  CIM  Frame-\nwork specification. Suppliers should provide document-\nation   explaining   any   deviations   from   these   general\nrules.\n\u2022 All   CIM   Framework-defined   operations   for   an\ninterface should be supported.\n\u2022 All  exceptions  and  events  for  an  interface  should\nbe supported.\n\u2022 A   component   should   use   component   manager\ninterfaces  for  object  instance  creation  and  regis-\ntration where these operations are specified.\n\u2022 A  component  implementation  should  support  all\ninterfaces specified for that component.\n\u2022 An  application  may  not  add  states  and  transitions\nto  the  defined  dynamic  models  that  have  external\ninterfacing ramifications. The application may still\nfurther subdivide the states.\n\u2022 A  component  implementation  should  explain  how\nit  supports  substitutability.  For  example,  it  may\nsupport    different    degrees    of    substitutability\nbetween the following levels:\n\u2022 Strict  \u2014  An  application  that  supplies  a  CIM\nFramework   component   should   be   reconfig-\nurable  so  it  can  use  another  supplier\u2019s  imple-\nmentation of that component. The application\u2019s\ninteractions  with  the  component  are  restricted\nto CIM Framework defined interfaces.\n\u2022 Weak  \u2014  An  application  may  use  extended,\npro-prietary,    or    private    interfaces    of    a\ncomponent.    When    the    another    supplier\u2019s\nimplementation  is  substituted  for  an  installed\ncomponent,     any     components     using     the\nextended, proprietary, or private interfaces need\nto be reassessed and possibly modified. The use\nof the CIM Frame-work-defined interfaces does\nnot change.\nNOTICE: SEMI      makes      no      warranties      or\nrepresentations  as  to  the  suitability  of  the  standard  set\nforth   herein   for   any   particular   application.      The\ndetermination of the suitability of the standard is solely\nthe  responsibility  of  the  user.    Users  are  cautioned  to\nrefer   to   manufacturer\u2019s   instructions,   product   labels,\nproduct   data   sheets,   and   other   relevant   literature\nrespecting   any   materials   mentioned   herein.      These\nstandards are subject to change without notice.\nThe  user\u2019s  attention  is  called  to  the  possibility  that\ncompliance with this standard may require use of copy-\nrighted  material  or  of  an  invention  covered  by  patent\nrights.  By publication of this standard, SEMI takes no\nposition  respecting  the  validity  of  any  patent  rights  or\ncopyrights   asserted   in   connection   with   any   item\nmentioned  in  this  standard.    Users  of  this  standard  are\nexpressly advised that determination of any such patent\nrights  or  copyrights,  and  the  risk  of  infringement  of\nsuch rights, are entirely their own responsibility.\nCopyright   by   SEMI\xae   (Semiconductor   Equipment   and   Materials\nInternational), 3081 Zanker Road, San Jose, CA 95134. Reproduction o\nf\nthe  contents  in  whole  or  in  part  is  forbidden  without  express  written\nconsent of SEMI."),(0,i.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 20001\nSEMI E97-0200A\nPROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBAL\nDECLARATIONS AND ABSTRACT INTERFACES\nThis  provisional  specification  was  technically  approved  by  the  Global  Information  and  Control  Committee\nand  is  the  direct  responsibility  of  the  North  American  Information  and  Control  Committee.  Current  edition\napproved  by  the  North  American  Regional  Standards  Committee  on  October  21  and  December  15,  1999.\nInitially available at ",(0,i.yg)("a",{parentName:"p",href:"http://www.semi.org"},"www.semi.org")," January 2000; to be published February 2000.\nNOTE:  This  document  was  published  twice  during  the\nFebruary 2000 (0200) publishing cycle.\n1  Purpose"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"1  This document defines the glo bal declarations used\nby  all  other  components  of  the  CIM  Framework  and\nalso  specifies  the  common  architecture  patterns  that\nserve    to    functionally    integrate    CIM    Framework\ncomponents.     The     material     architecture     defines\nfunctionality common to product management, durables\nmanagement        and        consumables        management\ncomponents.  The  factory  resource  architecture  defines\nrelationships  and  common  functionality  of  a  variety  of\nfactory   resources.   The   job   architecture   defines   a\nfactory-wide  model  for  controlling  factory  jobs  that\ndrive    a    variety    of    manufacturing    tasks.    These\nspecifications  are  separated  into  a  distinct  group  to\nenable  them  to  be  specified  once  and  then  logically\nincluded  or  inherited  wherever  they  are  subsequently\nneeded.\n2  Scope"),(0,i.yg)("li",{parentName:"ol"},"1  This specification provides the  common interfaces\nrequired by Manufacturing Execution Systems to:\n\u2022 Provide    type    definitions    for    common    data\nstructures    to    ensure    consistent    representation.\nThese   items   include   data   types   for   common\nconcepts      such      as      coordinates,      priorities,\ntimestamps, and sequences of basic data types.\n\u2022 Provide  definitions  for  common  exceptions  used\nconsistently throughout the CIM Framework.\n\u2022 Provide     the     material     architecture     interfaces\ncommon to identifying, grouping, moving, locating\nand tracking material in the factory.\n\u2022 Provide the factory resource architecture interfaces\ncommon to defining, organizing, tracking usage of\nand    maintaining    factory    resources    including\nequipment, sensors, durables, and people.\n\u2022 Provide  the  job  architecture  interfaces  common  to\ncreating,   executing   and   managing   work   in   the\nfactory.   The   job   architecture   is   specialized   for\nmaterial  processing  jobs,  material  transport  jobs,\nresource  maintenance  jobs  and  factory  jobs  that\ndrive product material through their process flows."),(0,i.yg)("li",{parentName:"ol"},"2   This  standard  does  not  purport   to  address  safety\nissues,   if   any,   associated   with   its   use.      It   is   the\nresponsibility  of  the  users  of  this  standard  to  establish\nappropriate  safety  and  health  practices  and  determine\nthe applicability of regulatory limitations prior to use.\n3  Limitations"),(0,i.yg)("li",{parentName:"ol"},"1  Provisional Status"),(0,i.yg)("li",{parentName:"ol"},"1.1   This  specification  is  designate d  as  provisional\ndue  to  known  areas  that  need  to  be  completed.  The\nfollowing   items   summarize   the   deficiencies   of   the\nprovisional   specification   to   be   addressed   before   a\nsubsequent ballot to upgrade it to full standard status."),(0,i.yg)("li",{parentName:"ol"},"1.2   The  specification  uses  the  IDL   typedef  \u201cany\u201d  in\nseveral  places.  While  this  usage  provides  flexibility,  it\ncan  have  the  effect  of  reducing  interoperability  due  to\ndifferences  in  interpretation  of  the  value  provided  by\nseparate    implementations    that    interact    through    a\nstandard   interface.   The   \u201cany\u201d   typedefs   should   be\nreplaced  with  explicit  data  types  prior  to  upgrade  from\nProvisional to full Standard status."),(0,i.yg)("li",{parentName:"ol"},"1.3    The   definition   of   interfaces   for    retrieval   of\nhistory  associated  with  CIM  Framework  objects  may\nneed to be added to abstract interfaces in this document\nafter  the  complete  specification  for  the  history  facility\nwithin     the     CIM     Framework     Factory     Services\nComponent."),(0,i.yg)("li",{parentName:"ol"},"1.4    The   specification   of   CIM   Fram ework   states\nreported   through   published   state   change   events   is\ncurrently based on a type definition for an enumeration\nof  state  values.  There  may  be  alternate  representations\nfor states that are better able to capture the semantics of\nnested and parallel states. The state representation used\nfor  the  CIM  Framework  will  be  reviewed  and  possibly\nchanged before upgrade to full standard status."),(0,i.yg)("li",{parentName:"ol"},"1.5    The   Resource   model   defined   i n   SEMI   E81\nincludes  several  extensions  that  are  not  yet  included  in\nthis      specification.      These      extensions      include\ncomposition    of    resources    from    other    resources,\ncapabilities  associated  with  resources,  and  associations\nwith  tracking  and  maintenance  functions  for  resources.")),(0,i.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 20002\nThese  extensions  will  be  addressed  before  upgrade  to\nfull standard status.\n3. 1.6   The  interfaces  specified  for  M ESFactory,  Area,\nand   ComponentManager   are   included   in   the   E81\nresponsibilities   for   the   Factory   Component   within\nFactory  Operations.  These  interfaces  will  need  to  be\nmoved  to  that  component  when  it  is  considered  in  a\nfuture ballot.\n4  Referenced Standards\n4. 1  SEMI Standards\nSEMI E5 \u2014 SEMI Equipment Communications\nStandard 2 Message Content (SECS-II)\nSEMI    E10    \u2014        Standard    for    Definition    and\nMeasurement  of  Equipment  Reliability,  Availability,\nand Maintainability (RAM)\nSEMI   E81   \u2014   Provisional   Specification   for   CIM\nFramework Domain Architecture\n4. 2  Other Standards\nUML  Notation  Guide,  Version  1.1,  document  number\nad/97-08-05, Object Management Group\n1\nISO/IEC   International   Standard   14750   (also   ITU-T\nRecommendation X.920) \u2013\u2013 Information Technology \u2013\nOpen   Distributed   Processing   \u2013   Interface   Definition\nLanguage\n2\nNOTE 1: As listed or revised, all documents cited shall be the\nlatest publications of adopted standards.\n5  Terminology\n5. 1   abstract  interface \u2014  an  interfa ce  specified  only\nfor  inheritance  rather  than  for  implementation  in  order\nto    standardize    common    features    shared    by    all\nspecializations of the interface.\n6  Requirements\n6. 1  Global Type Definitions\n6. 1.1   This  section  describes  data  type   definitions  and\nexceptions  that  are  global  in  nature.  By  \u201cglobal\u201d  it  is\nmeant   that   they   are   designed   to   be   used   by   any\ncomponent     within     the     CIM     Framework.     This\nspecification    does    not    address    how    they    are\nimplemented   within   a   CIM   Framework   conformant"),(0,i.yg)("p",null,"1 UML Notation Guide v1.1 is available to the general public at\n",(0,i.yg)("a",{parentName:"p",href:"http://www.omg.org/cgi-bin/doclist.pl"},"http://www.omg.org/cgi-bin/doclist.pl"),", +1-508-820 4300, Object\nManagement Group, Inc. , Framingham Corporate Center, 492 Old\nConnecticut Path, Framingham, MA 01701.\n2 ISO Central Secretariat, 1, rue de Varemb\xe9, Case postale 56, CH-\n1211 Gen\xe8ve 20, Switzerland\napplication; that level of detail is within the realm of the\ndevelopment effort.\n6. 1.2   Global  type  definitions  are  spe cified  as  IDL\ndeclarations  which  may  be  referenced  by  any  CIM\nFramework  interface.  The  CIM  Framework  uses  the\nkeyword typedef to define aliases for basic object types,\nbut  with  additional  implied  semantics.  (e.g.,  the  units\ntypedef  defines  a  string,  whose  contents  conform  to\ndefinitions  found  in  SEMI  E5).  The  keyword  struct\nbegins   the   type   declaration   for   record   structures\ncomposed  of  a  collection  of  named  and  typed  values.\nThe third form of type definition is an enumerated type\nbeginning  with  the  reserved  word  enum.  Enumerated\ntypes  are  used  to  declare  a  list  of  tokens  that  can  be\nused  as  values  of  that  type.  Enumerated  types  are\nmainly  used  to  denote  the  states  of  an  object  for\ncommunication   in   CIM   Framework   events.   Finally,\ncollections  of  values  are  declared  with  the  keyword\nsequence.  This  kind  of  type  definition  may  or  may  not\nimply  significance  to  the  ordering  of  the  members  in\nthe    sequence.    Where    no    ordering    constraint    is\nmentioned,   the   elements   of   the   sequence   are   not\nassumed to be in any meaningful order.\nNOTE  2:  In  the  following  definitions,  \u201c//\u201d  or  \u201c/",(0,i.yg)("em",{parentName:"p"},"  ....  "),"/\u201d\ndelimits a comment.\nNOTE  TO  THE  READER:  The  comments  in  the  following\nsections (described in NOTE 2, above) appear to immediately\nprecede,  rather  than  follow,  the  items  they  discuss.  \u2014  SEMI\nStaff\n6. 1.3    All   CIM   Framework   specifica tions   will   be\ndeclared  within  the  context  of  the  CIMFW  module\nwhich   spans   all   of   the   components   of   the   CIM\nFramework.  Within  the  CIMFW  module,  the  global\ntype  definitions  will  be  declared  within  a  second-level\nmodule called Global."),(0,i.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 20003\nModule:Global\ntypedef stringIdentifier;\ntypedef unsigned longFlags;\nstructNamedValue{\nIdentifier name;\nany argument;\nlong len;\nFlags arg_modes;\n};\ntypedef NamedValueNameValue;\ntypedef sequence NamedValueNameValueSequence;\ntypedef stringPropertyName;\nstructProperty{\nPropertyName property_name;\nany property_value;\n};\ntypedef sequence PropertyProperties;\n/",(0,i.yg)("em",{parentName:"p"},"  This  type  definition  represents  units  for  factory  parameters,  measurements.  etc.,  and  conforms  to  the  SEMI  E5\nstandard for representation of units. In that standard, the string contains a code representing a value of the units. For\nexample, \u201cns\u201d would mean nano-seconds; \u201cA\u201d for ampere; and \u201cwfr\u201d for wafer. "),"/\ntypedef stringUnit;\ntypedef stringUnits;\n/",(0,i.yg)("em",{parentName:"p"}," This type definition represents a sequence of string values. "),"/\ntypedef sequence stringStringSequence;\n/",(0,i.yg)("em",{parentName:"p"}," This type definition represents a sequence of any values. "),"/\ntypedef sequence anyAnySequence;\n/",(0,i.yg)("em",{parentName:"p"}," This type definition represents a sequence of long values. "),"/\ntypedef sequence longLongSequence;\n/",(0,i.yg)("em",{parentName:"p"}," This enumerated type identifies event priorities and is used in each event definition. "),"/\nenumPriorityOfEvent{\nLow,\nMedium,\nHigh,\nAlarm };\n/",(0,i.yg)("em",{parentName:"p"}," This enumerated type identifies the lifecycle states that an object may go through. It is used in event notifications\nof state changes. "),"/"),(0,i.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 20004\nenumLifecycleState{\nUndefined,\nCreated,\nDeleted,\nMoved,\nCopied };\n/",(0,i.yg)("em",{parentName:"p"}," This enumerated type identifies the states of objects that can be reserved (Lot, Durable and Machine). It is used in\nevent notifications of state changes. "),"/\nenumReservationState{\nUndefinedReservationState,\nReserved,\nUnReserved };\n/",(0,i.yg)("em",{parentName:"p"},"  This  enumerated  type  represents  the  SEMI  E10  states  for  Machines  and  Support  Resources.  It  is  used  in  event\nnotifications of state changes. "),"/\nenumE10State{\nE10Productive,\nE10Standby,\nE10Engineering,\nE10ScheduledDowntime,\nE10UnscheduledDowntime,\nE10NonscheduledTime };\n/",(0,i.yg)("em",{parentName:"p"}," TimeT is a ulonglong value (64 bits) that represents the number of 100 nanosecond increments that have passed\nsince a base time (October 15, 1582 at 00:00, the Universal Time Representation which refers to time in Greenwich\nMean Time). The specification for TimeT is: "),"/\nstructulonglong{\nunsigned long low;\nunsigned long high;\n};\ntypedef ulonglongTimeT;\n/",(0,i.yg)("em",{parentName:"p"}," TimeStamp is mapped to the data type of TimeT. "),"/\ntypedef TimeTTimeStamp;\ntypedef sequence TimeStampTimeStampSequence;\n/",(0,i.yg)("em",{parentName:"p"},"  The  notion  of  a  specific  interval  of  time  denoting  a  start  time  and  an  end  time  is  represented  as  a  struct  called\nIntervalT. "),"/\nstructIntervalT{\nTimeT lower_bound ;\nTimeT upper_bound ;\n};\n/",(0,i.yg)("em",{parentName:"p"}," TimeWindow is mapped to the data type IntervalT. "),"/\ntypedef IntervalTTimeWindow;\n/",(0,i.yg)("em",{parentName:"p"}," Duration is mapped to the datatype TimeT. "),"/\ntypedef TimeTDuration;\n/",(0,i.yg)("em",{parentName:"p"},"  This  structure  is  for  the  representation  of  a  single  schedule  instance.  It  should  be  noted  that  \u201cEndTime\u201d  should\nnever proceed \u201cStartTime.\u201d "),"/"),(0,i.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 20005\nstructResourceSchedule{\nTimeStamp plannedStartTime;\nTimeStamp plannedEndTime;\nTimeStamp actualStartTime;\nTimeStamp actualEndTime;\n};\n/",(0,i.yg)("em",{parentName:"p"},"  The  definition  of  a  sequence  of  ResourceSchedules.  This  sequence  is  ordered  in  increasing  time  order  and  that\norder must be maintained in any manipulation of the sequence. "),"/\ntypedef sequence ResourceScheduleResourceScheduleSequence;\n6. 2  Global Exception Declaration s\n6. 2.1   This  section  describes  the  stan dard  CIM  Framework  exceptions  that  may  be  thrown  by  operations  in  any\ncomponent.\nModule:Global\n/",(0,i.yg)("em",{parentName:"p"}," This signal is raised when a lookup or find fails. "),"/\nexceptionNotFoundSignal{ string errorMessage; };\n/",(0,i.yg)("em",{parentName:"p"}," This signal is raised when an add fails because an object already exists with the given identifier. Interfaces may\nalso define and raise a ObjectTypeDuplicateSignal. "),"/\nexceptionDuplicateIdentifierSignal{\nstring errorMessage;\nstring duplicateIdentifier; };\n/",(0,i.yg)("em",{parentName:"p"},"This signal is raised when an invalid state transition request is made of an object. "),"/\nexceptionInvalidStateTransitionSignal{\nstring errorMessage; };\n/",(0,i.yg)("em",{parentName:"p"},"This signal is raised when a \u201cset\u201d attribute contains a value out of range. "),"/\nexceptionSetValueOutOfRangeSignal{\nstring errorMessage; };\n/",(0,i.yg)("em",{parentName:"p"}," This signal is raised when an incorrect TimePeriod is used. "),"/\nexceptionTimePeriodInvalidSignal{\nstring errorMessage; };\n/",(0,i.yg)("em",{parentName:"p"}," This signal is raised when a Property name is not valid. "),"/\nexceptionInvalidPropertyNameSignal{};\n/",(0,i.yg)("em",{parentName:"p"}," This signal is raised when a a Property with this name is not defined. "),"/\nexceptionPropertyNotFoundSignal{};\n/",(0,i.yg)("em",{parentName:"p"}," This signal is raised when a Property is not supported. "),"/\nexceptionUnsupportedPropertySignal{};\n/",(0,i.yg)("em",{parentName:"p"}," This signal is raised when a Property is read-only and cannot be set. "),"/\nexceptionReadOnlyPropertySignal{};\n/",(0,i.yg)("em",{parentName:"p"}," This signal is raised when no other defined signal matches the error condition. "),"/"),(0,i.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 20006\nexceptionFrameworkErrorSignal{\nstring errorMessage;\nunsigned long errorCode;\nany errorInformation; };\n/",(0,i.yg)("em",{parentName:"p"}," Definition of fields for FrameworkErrorSignal:\nerrorMessageis a text field representing a description of the circumstances of the exception for use by\ndevelopers in debugging the exception.\nerrorCodeis a numeric field representing the code for the given exception.\nerrorInformationis any further debugging information related to the circumstances of the exception.\nThe errorCode has certain reserved values that are defined and standardized in the CIM Framework.\n\u2022 0000\u20130999 reserved for the CIM Framework.\n\u2022 1000\u20131999 reserved for extensions to the CIM Framework.\n\u2022 2000\u20132999reserved for specializations of CIM Framework interfaces.\n\u2022 3000\u2013maximumreserved for implementers. /"),"\n/",(0,i.yg)("em",{parentName:"p"},"  This  errorCode  should  be  used  for  any  operation  where  the  supplier  has  chosen  to  not  provide  implementation,\nbut needs to communicate to the user that nothing has happened as a result of this operation invocation. "),"/\nconst unsigned longNOT_IMPLEMENTED=0;\n/",(0,i.yg)("em",{parentName:"p"}," This errorCode should be used for any operation where the supplier assumes a specialization will implement this\noperation. If this exception is received, the user will realize that an interface has not been properly specialized. "),"/\nconst unsigned longIMPLEMENTED_BY_SUBCLASS=1;\n/",(0,i.yg)("em",{parentName:"p"},"  This  errorCode  should  be  used  for  any  operation  where  an  unknown  exception  has  been  caught  by  the\nimplementation  and,  rather  than  crashing,  the  implementation  can  map  the  \u201cunknown\u201d  exception  into  this  known\nexception. This probably does not aid in program debugging but does prevent program crashing. "),"/\nconst unsigned longUNKNOWN_EXCEPTION=2;\n/",(0,i.yg)("em",{parentName:"p"},"  This  errorCode  should  be  used  for  any  invocation  where  some  unknown  error  has  occurred  that  left  the  server\nobject in an ambiguous state. "),"/\nconst unsigned longCOMPLETION_UNKNOWN=3;\n6. 3  Abstract Interface Type Defini tions\n6. 3.1  Referenced Declarations\n6. 3.1.1   The  following  declarations  are   not  part  of  this  specification,  but  are  required  for  reference  by  Abstract\nInterface  elements.  These  referenced  declarations  are  defined  in  separate  documents  but  are  noted  here  as\ndependencies that appear in IDL compilations.\nModule:EquipmentTracking\nInterface:Machine\nmodule EquipmentTracking {\ninterfaceMachine {};// Stub\ntypedef sequence MachineMachineSequence;\nexceptionMachineDuplicateSignal{};"),(0,i.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 20007\nexceptionMachineNotAssignedSignal{};\nexceptionMachineRemovalFailedSignal{};\n}; // module EquipmentTracking\nModule:Labor\nInterface:Person\nmodule Labor {\ninterfacePerson {}; // Stub\ntypedef sequence PersonPersonSequence;\nexceptionPersonDuplicateSignal{};\nexceptionPersonNotAssignedSignal{};\nexceptionPersonRemovalFailedSignal{};\n}; // module Labor\n6. 3.2  Abstract Interface Declaration s\nModule:AbstractIF\n/",(0,i.yg)("em",{parentName:"p"},"  The  following  IDL  interfaces  will  be  fully  defined  in  the  sections  below.  They  are  declared  here  as  forward\nreferences to support the sequence typedefs. "),"/\ninterfaceResource;\ninterfaceMaterial;\ninterfaceMaterialGroup;\ninterfaceJobSupervisor;\ninterfaceJob;\ninterfaceJobRequestor;\n/",(0,i.yg)("em",{parentName:"p"}," Type definitions for sequences of interfaces instances. "),"/\ntypedef sequence ResourceResourceSequence;\ntypedef sequence MaterialMaterialSequence;\ntypedef sequence MaterialGroupMaterialGroupSequence;\ntypedef sequence JobJobSequence;\ntypedef sequence JobSupervisorJobSupervisorSequence;\n6. 4  Resource Abstract Interface G roup\n6. 4.1  The Resource Abstract Interfa ce Group provides a set of abstractions that are globally useful. Figure 1 is the\nInformation Model for the Resource Abstract Interface Group."),(0,i.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 20008\nResource\nResource Abstract Interface Group\nNam edEntity\nOw nedEntity\n0 ..1\n0. .",(0,i.yg)("em",{parentName:"p"},"\n0 ..1\n0. ."),"\nowned by\nFigure 1\nResource Abstract Interface Group Information Model\n6. 4.1.1   All  CIM  Framework  interfaces   will  inherit  from  one  of  the  interfaces  shown  in  Figure  1.  NamedEntity\nprovides the most basic naming functions. An OwnedEntity is a NamedEntity with functions supporting the concept\nof ownership. A Resource is an OwnedEntity which also takes an active role in product manufacturing.\n6. 4.2  Named Entity Interface\nModule:AbstractIF\nInterface:NamedEntity\nInherited Interface:Implementation-dependent.\nDescription:The  abstract  interface  NamedEntity  provides  the  concept  of  a  named  item.  This  allows\nfor comparison and conversion of names via a standard object.\nExceptions:None.\nPublished Events:None.\nProvided Services:\ninterfaceNamedEntity{"),(0,i.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 20009\n/",(0,i.yg)("em",{parentName:"p"},"  Set  and  get  the  name.  The  NamedEntity  interface  does  not  specify  scoping  of  names  or  enforce  uniqueness  of\nnames. This could allow distinct instances of a NamedEntity to use the same string as a name. "),"/\nvoidsetName(in string name)\nraises (Global::FrameworkErrorSignal);\nstringgetName()\nraises (Global::FrameworkErrorSignal);\n/",(0,i.yg)("em",{parentName:"p"}," Tests the equality of the name with the name provided as an argument. "),"/\nbooleanisNamed(in string testName)\nraises (Global::FrameworkErrorSignal);\n}; //NamedEntity\nContracted Services:None.\nDynamic Model:None.\n6. 4.3  Owned Entity Interface\n6. 4.3.1  The concept of ownership in th e CIM Framework relates to the hierarchical structure that may be defined\nwhere  one  object  \u201cowns\u201d  another  object.  This  should  not  be  confused  with  the  business  concept  of  ownership\nrelating to an item\u2019s value as an asset.\nModule:AbstractIF\nInterface:OwnedEntity\nInherited Interface:NamedEntity\nDescription:The abstract interface OwnedEntity provides for the concept of an \u201cowned\u201d entity. There\nmay be only one \u201cowner\u201d for each instance of an OwnedEntity. The OwnedEntity is able\nto communicate with the owner to request services, or forward information of interest. To\nbuild a \u201cparts of\u201d hierarchy, a series of ownerships can be established.\nExceptions:None.\nPublished Events:None.\nProvided Services:\ninterfaceOwnedEntity: NamedEntity {\n/",(0,i.yg)("em",{parentName:"p"}," Set and get owner. "),"/\nvoidsetOwner(in NamedEntity owner)\nraises (Global::FrameworkErrorSignal);\nNamedEntitygetOwner()\nraises (Global::FrameworkErrorSignal);\n}; //OwnedEntity\nContracted Services:None.\nDynamic Model:None.\n6. 4.4  Resource Interface\nModule:AbstractIF\nInterface:Resource\nInherited Interface:OwnedEntity"),(0,i.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200010\nDescription:Resource is an abstract inherited interface for any entity in the factory that takes an active\nrole in advancing a product along its manufacturing life cycle (adds value). This includes\nthe factory itself, personnel, production, planning and scheduling resources, and all of the\nmachines  used  for  processing,  transporting,  and  storing  materials.  Resource  provides  a\ncommon set of services for monitoring and control. Resource uses the NamedEntity and\nOwnedEntity characteristics together to allow for the building of resource hierarchies.\nThere must be a clear division between the state of the Resource and the condition of the\nphysical entity which the Resource represents. For instance, a Machine is a resource, but\nthe fact that it is \u201cOut of Service\u201d may not mean the physical equipment is shutdown on\nthe  shop  floor.  In  fact,  the  equipment  may  be  operating  in  manual  mode.  The  Resource\nstate  represents  the  availability  of  the  Resource  object  to  accept  work  for  the  factory\nsystem.\nExceptions:None.\nPublished Events:None.\nProvided Services:\ninterfaceResource: OwnedEntity {\n/",(0,i.yg)("em",{parentName:"p"}," Perform the startup activities for this Resource. Should be implemented by Resource specializations. "),"/\nvoidstartUp()\nraises (Global::FrameworkErrorSignal);\n/",(0,i.yg)("em",{parentName:"p"},"  Perform  normal  shutdown  activities  for  this  Resource.  Normal  is  defined  as  allowing  the  Resource  to  complete\nany current activities and \u201cgracefully\u201d shutdown. "),"/\nvoidshutdownNormal()\nraises (Global::FrameworkErrorSignal);\n/",(0,i.yg)("em",{parentName:"p"},"  Perform  immediate  shutdown  activities  for  this  Resource.  Immediate  is  defined  as  aborting  or  terminating  any\ncurrent activities and stopping activity as soon as possible. This should be implemented by Resource specializations.\n"),"/\nvoidshutdownImmediate()\nraises (Global::FrameworkErrorSignal);\n/",(0,i.yg)("em",{parentName:"p"},"  Respond  with  the  receiver\u2019s  level  in  the  Resource  hierarchy.  Resource  specifies  that  each  different  type  of\nResource provide a \u201cresourceLevel\u201d identifier.\nstringresourceLevel()\nraises (Global::FrameworkErrorSignal);\n/")," The following service provides name scoping for Resources. Resource name scoping makes use of the notion of\n\u201cResource  level\u201d  and  the  ownership  hierarchy.  For  example,  unique  identification  of  MachineResources  within  a\nMachine is possible, but to identify them outside the Machine additional information about their ownership will be\nrequired.\nThus: nameQualifiedTo (\u201cMachine\u201d) sent to the ProcessResource named \u201cChamber\u201d answers\n\u201cTestMachine>Chamber\u201d.\nIf the Machine was owned by a Factory named \u201cTestFactory\u201d, then:\nnameQualifiedTo (\u201cFactory\u201d) sent to the ProcessResource answers\n\u201cTestFactory>TestMachine>Chamber\u201d\nwhere the ProcessResource has now been uniquely identified for the given Factory."),(0,i.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200011\nThere  is  no  limit  to  the  number  of  levels  that  may  be  addressed  this  way.  Based  on  the  implementations  of\nnameQualifiedTo (string); a name need not always be concatenated, if a particular Resource level is not applicable\nto identification. ",(0,i.yg)("em",{parentName:"p"},"/\nstringnameQualifiedTo(in string resourceLevel)\nraises (Global::FrameworkErrorSignal);\n/")," Returns the set of subordinate Resources for a given Resource. ",(0,i.yg)("em",{parentName:"p"},"/\nResourceSequencesubResources()\nraises (Global::FrameworkErrorSignal);\n/")," Answer if the resource is in service. In service means the resource is functional and ready to accept and perform\nits normal tasks. Derivatives of Resource are expected to expand this state (e.g., add sub-interfaces) that explicitly\ndeal with such additional issues as capacity, \u201cnormal\u201d work versus maintenance, etc. ",(0,i.yg)("em",{parentName:"p"},"/\nbooleanisInService();\n/")," Answer if the resource is out of service. Out of service means the resource is unable to accept or begin new tasks.\nPreviously begun tasks may continue in some cases. */\nbooleanisOutOfService();\n}; //Resource\nContracted Services:None.\nDynamic Model:\nImplementations  of  Resource  may  extend  the  state  model  by  providing  additional  sub-states  that  are  wholly\ncontained within a state defined here. Extending the state model by the addition of state transitions is also an option\nfor subtypes of Resource.\nIN SERVICE\nOUT OF SERVICE\n34\n2\n51\nFigure 2\nResource Dynamic Model"),(0,i.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200012\nTable 1  Resource State Definitions and Query Table\nStateDefinitionQuery for State via\nIN SERVICEResource is capable of interacting with other\nresources with its full service interface.\nboolean isInService ( ); sent to the instance of\nResource returns TRUE.\nOUT OF SERVICEResource is not able to provide servicesboolean isOutOfService ( ); sent to the instance of\nResource returns TRUE.\nTable 2  Resource State Transitions\n#Current StateTriggerNew StateActionComment\n1Non ExistentObject creation.OUT OF\nSERVICE\nNone.Default entry.\n2OUT OF\nSERVICE\nstartUp ( ) or object\ninitialization.\nIN SERVICEInitiate Resource and\nsubresources.\nstartUp() service initiates\nthe trigger.\n3IN SERVICEshutdownNormal ( ).OUT OF\nSERVICE\nComplete current\nexecution of resources\nnormally.\nshutdownNormal() service\ninitiates the trigger.\n4IN SERVICEshutdownImmediate ( ).\nTake resource out of\nservice.\nOUT OF\nSERVICE\nStop execution of\nresource immediately.\nshutdownImmediate()\nservice initiates the trigger.\n5OUT OF\nSERVICE\nResource removed.Non ExistentNone.\n6. 5  Material Abstract Interface Gr oup\n6. 5.1   The  CIM  Framework  uses  a  co mmon  architecture  for  identifying,  grouping  and  locating  materials.  Any\nmaterial has an identification, history, location, and associations to any material containers that contain it. Material\ncan also be in multiple material groups that physically (same location or carrier) or logically (same lot, same process\nbatch,  same  product  family,  etc.)  associate  material.  Specializations  of  material  include  products,  durables  and\nconsumables. Specializations of material groups include product groups, lots, and process groups."),(0,i.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200013\nNamedEntity\n(from Resource AIG)\nMaterial Abstract Interface Group\nMaterialTrackingLocation\n(from Machine Abstract Interfaces)\nMaterialGroup\n0. .",(0,i.yg)("em",{parentName:"p"},"\ncontains\n0. ."),"\nPositionalContainer\n(from Durables Management)\nMaterialContainer\n(from Durables Management)\nInventoryRegionSystem\n(from Inventory Region Mgt Comp)\nMaterial\n0. .",(0,i.yg)("em",{parentName:"p"},"\n0. .1\n0. ."),"\n0. .1\nholds\n0. .",(0,i.yg)("em",{parentName:"p"},"\n0. ."),"\n0. .",(0,i.yg)("em",{parentName:"p"},"\n0. ."),"\nis grouped in\n0. .",(0,i.yg)("em",{parentName:"p"},"\n0. .1\n0. ."),"\n0. .1\nholds at position\n0. .1\n0. .",(0,i.yg)("em",{parentName:"p"},"\n0. .1\n0. ."),"\nholds\nin\n0. .",(0,i.yg)("em",{parentName:"p"},"\n0. ."),"\n0. .",(0,i.yg)("em",{parentName:"p"},"\n0. ."),"\nis\nassociated\nwith\nFigure 3\nMaterial Abstract Interface Group Information Model\n6. 5.2  Material Interface\nModule:AbstractIF\nInterface:Material\nInherited Interface:NamedEntity\nDescription:Material  is  an  abstract  interface  for  physical  items  or  substances  that  are  required  as\ninputs  to  the  manufacturing  process.  This  includes  the  product  itself,  consumables  and\ndurables  used  in  the  manufacturing  process.  It  does  not  include  the  resources  used  to\ntransform material into product.\nExceptions:None.\nPublished Events:None.\nProvided Services:\ninterfaceMaterial: NamedEntity {\n/",(0,i.yg)("em",{parentName:"p"},"  Set  and  get  the  identifier  for  this  material.  The  identifier  is  unique  within  the  extent  of  all  material  for  an  MES\nFactory. "),"/\nstringgetIdentifier()\nraises (Global::FrameworkErrorSignal);\nvoidsetIdentifier(in string identifier)\nraises (Global::FrameworkErrorSignal,\nGlobal::DuplicateIdentifierSignal);\n/",(0,i.yg)("em",{parentName:"p"}," Returns the material groups of which the receiver is a member. "),"/\nMaterialGroupSequencematerialGroups()\nraises (Global::FrameworkErrorSignal);"),(0,i.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200014\n/",(0,i.yg)("em",{parentName:"p"}," Answers whether the receiver is a member of the material group indicated by the argument. "),"/\nbooleanisMemberOf(in MaterialGroup aMaterialGroup)\nraises (Global::FrameworkErrorSignal);\n}; //Material\nDynamic Model:None.\n6. 5.3  Material Group Interface\nModule:AbstractIF\nInterface:MaterialGroup\nInherited Interface:NamedEntity\nDescription:MaterialGroup is the abstract interface for any aggregation of Material.\ninterfaceMaterialGroup: NamedEntity {\nExceptions:\n/",(0,i.yg)("em",{parentName:"p"}," Signals an attempt to add Material to the MaterialGroup that is already in the group. "),"/\nexceptionDuplicateMaterialSignal{Material aMaterial;};\n/",(0,i.yg)("em",{parentName:"p"}," Signals an attempt to add a MaterialGroup to a MaterialGroup that is already in the group. "),"/\nexceptionDuplicateMaterialGroupSignal{Material aMaterialGroup;};\n/",(0,i.yg)("em",{parentName:"p"}," Signals an attempt to remove Material that wasn\u2019t found in this MaterialGroup. "),"/\nexceptionMaterialRemovalFailedSignal{Material aMaterial;};\n/",(0,i.yg)("em",{parentName:"p"}," Signals an attempt to remove a MaterialGroup that wasn\u2019t found in this MaterialGroup. "),"/\nexceptionMaterialGroupRemovalFailedSignal{MaterialGroup aMaterialGroup;};\nPublished Events:None.\nProvided Services:\n/",(0,i.yg)("em",{parentName:"p"}," Set and get the unique identifier for this group. "),"/\nstringgetIdentifier()\nraises (Global::FrameworkErrorSignal);\nvoidsetIdentifier(in string identifier)\nraises (Global::FrameworkErrorSignal,\nGlobal::DuplicateIdentifierSignal);\n/",(0,i.yg)("em",{parentName:"p"}," Adds the argument MaterialSequence to the collection of Matrial held by the receiver. "),"/\nvoidaddMaterials(in MaterialSequence aMaterialSequence)\nraises (Global::FrameworkErrorSignal,\nDuplicateMaterialSignal);\n/",(0,i.yg)("em",{parentName:"p"}," Adds the argument Material to the collection of Material held by the receiver. "),"/\nvoidaddMaterial(in Material aMaterial)\nraises (Global::FrameworkErrorSignal,\nDuplicateMaterialSignal);\n/",(0,i.yg)("em",{parentName:"p"}," Removes the Material indicated from the MaterialGroup. Throws the exception if not found. "),"/"),(0,i.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200015\nvoidremoveMaterial(in Material aMaterial)\nraises (Global::FrameworkErrorSignal,\nMaterialRemovalFailedSignal,\nGlobal::NotFoundSignal);\n/",(0,i.yg)("em",{parentName:"p"}," Remove and return all Material from the MaterialGroup. "),"/\nMaterialSequenceremoveAllMaterials()\nraises (Global::FrameworkErrorSignal);\n/",(0,i.yg)("em",{parentName:"p"}," Add the argument MaterialGroup to this MaterialGroup. "),"/\nvoidaddMaterialGroup(in MaterialGroup aMaterialGroup)\nraises (Global::FrameworkErrorSignal,\nDuplicateMaterialGroupSignal);\n/",(0,i.yg)("em",{parentName:"p"}," Removes the argument MaterialGroup from this MaterialGroup. "),"/\nvoidremoveMaterialGroup(in MaterialGroup aMaterialGroup)\nraises (Global::FrameworkErrorSignal,\nMaterialGroupRemovalFailedSignal,\nGlobal::NotFoundSignal);\n/",(0,i.yg)("em",{parentName:"p"}," Remove and return all MaterialGroups from this MaterialGroup. "),"/\nMaterialGroupSequenceremoveAllMaterialGroups()\nraises (Global::FrameworkErrorSignal);\n/",(0,i.yg)("em",{parentName:"p"}," Returns the collection of material in this MaterialGroup. "),"/\nMaterialSequenceallMaterials()\nraises (Global::FrameworkErrorSignal);\n/",(0,i.yg)("em",{parentName:"p"}," Returns all the MaterialGroups in this MaterialGroup. "),"/\nMaterialGroupSequenceallMaterialGroups()\nraises (Global::FrameworkErrorSignal);\n/",(0,i.yg)("em",{parentName:"p"}," Returns the count of the items in the MaterialGroup. "),"/\nlongcount()\nraises (Global::FrameworkErrorSignal);\n}; //MaterialGroup\nDynamic Model:None.\n6. 6  Job Supervision Abstract Inter face Group\n6. 6.1  The Job Supervision Abstract  Interface Group provides the abstractions common to creating, executing and\nmanaging  a  \u201cjob,\u201d  where  a  job  can  be  defined  as  some  system  level  operation  which  may  be  requested  from  the\nJobSupervisor.  The  job  often  spans  a  significant  amount  of  time  and  multiple  resources  within  the  system.  It  is\nintended for specialization to provide specific job supervisors and jobs to provide system solutions."),(0,i.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200016\nResource\n(from Resource AIG)\nOwnedEntity\n(from Resource AIG)\nJob Supervision Abstract Interface Group\nJobSupervisorJob\n0. .*"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},".1"),(0,i.yg)("li",{parentName:"ol"},".*"),(0,i.yg)("li",{parentName:"ol"},".1\nsupervises\nJobRequestor"),(0,i.yg)("li",{parentName:"ol"},".*"),(0,i.yg)("li",{parentName:"ol"},".*"),(0,i.yg)("li",{parentName:"ol"},".*"),(0,i.yg)("li",{parentName:"ol"},".*\ncontracts\nwork\nfrom"),(0,i.yg)("li",{parentName:"ol"},".*\n1"),(0,i.yg)("li",{parentName:"ol"},".*\n1\ntracks\nprogress via\nJobSpecification\ntypedef\nFigure 4\nJob Supervision Abstract Interface Group Information Model"),(0,i.yg)("li",{parentName:"ol"},"6.1.1  The basic Job Supervision Abs tract Interface Group does not interact with other components, except to the\nextent that other components instantiate its interfaces. Figure 4 shows how the interfaces of Job Supervision relate to\none another."),(0,i.yg)("li",{parentName:"ol"},"6.1.2  A Job Specification is a sequen ce of properties containing the parameters required to sufficiently define the\nwork to be done. This sequence is passed by the JobRequestor to the JobSupervisor in the Job request message. See\nthe JobSupervisor interface for more details."),(0,i.yg)("li",{parentName:"ol"},"6.1.3   JobSupervision  levels  are  hiera rchical.  One  level  may  accept  a  Job  and  delegate  portions  of  that  Job  to\nlower levels. Jobs, however, are not purely hierarchical. A Job accepted by one JobSupervisor may be broken down,\nalong with other Jobs of that component and reconstituted as needed to optimize the activities of the factory."),(0,i.yg)("li",{parentName:"ol"},"6.1.4  For example, a ProductReques t may ask for 15 wafers of a particular product. The ProductRequestManager\nmay  delegate  a  LotJob  to  Factory  Operations  with  a  Lot  containing  those  15  wafers  and  10  more  from  a  different\nProductRequest.  In  the  factory,  this  Lot  may  be  split  up  and  processed  in  smaller  groups  at  various  stages  or,  as\nscrap  reduces  the  wafer  count,  combined  with  another  small  lot  to  create  a  more  optimal  process  group.  The  Job\nSupervision implementation is allowed great latitude to optimize performance. Its only requirement is to fulfill the\nspecification of the Job."),(0,i.yg)("li",{parentName:"ol"},"6.2  JobSupervisor Interface\nModule:AbstractIF\nInterface:JobSupervisor\nInherited Interface:Resource")),(0,i.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200017\nDescription:The  JobSupervisor  manages  all  the  Jobs  being  performed  by  the  component  which\nimplements  it.  It  receives  the  requests  for  work,  facilitates  the  creation  of  a  Job  for  the\ntask and returns (a reference to) that Job.\nA JobSupervisor will have a well defined domain which it can call on to perform work.\nThese may be CIM Framework Resources if it delegates the work, or internal resources if\nit performs the work itself. Only activity requests which can be accomplished within the\ndomain of a JobSupervisor should be issued to/accepted by that JobSupervisor.\nJobs,  as  subtypes  of  NamedEntity,  are  named  by  the  JobSupervisor  in  such  a  way  that\ntheir name attribute may be used to query for the Job. Jobs from different JobSupervisors\nmay have the same name.\nThe  definition  of  the  work  to  be  performed  is  the  JobSpecification,  a  sequence  of\nname/value  pairs  (see  \u201cProperties\u201d  definition).  Specializations  of  Job  Supervision  may\nrequire  certain  properties  in  the  JobSpecification.  Some  commonly  useful  properties  are\ndefined   in   the   following   table.   When   possible,   specializations   should   reuse   these\ndefinitions. Specializations should also document the allowable and mandatory properties\nthat are supported. See Job definition for more information.\ninterfaceJobSupervisor: Resource {\nType Definitions:\n/",(0,i.yg)("em",{parentName:"p"}," Type for returning results of Job execution. "),"/\ntypedef Global::NameValueSequence Results;\nJobSpecification Properties:\nNameValue TypeDescription\n\u201cJobType\u201dstringThe kind of Job to run. This is useful when a JobSupervisor can initiate more than one\ntype of Job. String values reserved for this property are:\nProductRequestJobType,\nLotJobType,\nAreaJobType,\nProcessMachineJobType,\nTransportJobType,\nPMJobType,\nControlStrategyJobType,\nAlgorithmJobType.\n\u201cPriority\u201dlongInteger value, ranges from 1 to 99, where 1 is the highest priority and 99 is the lowest.\n\u201cDeadline\u201dTimeStampThe Job is expected to be completed no later than the specified value of the Deadline.\nExceptions:\n/",(0,i.yg)("em",{parentName:"p"}," Requested Job was rejected. "),"/\nexceptionJobRejectedSignal{\nstring errorMessage; };\n/",(0,i.yg)("em",{parentName:"p"}," Requested Job was not found "),"/\nexceptionJobNotFoundSignal{\nstring errorMessage;\nstring missingJobName; };\nPublished Events:\n/",(0,i.yg)("em",{parentName:"p"}," Provide lifecycle event for tracking "),"/"),(0,i.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200018\nconst stringJobLifecycleSubject=\n\u201c/JobSupervision/JobSupervisor/JobLifecycle\u201d;\n/",(0,i.yg)("em",{parentName:"p"}," The use of \u201cname\u201d here (and in all other events) indicates the string value for the name or identifier of the Job to\nwhich  the  event  refers.  Since  filtering  does  not  support  object  reference  comparisons,  the  filtering  must  be  on  the\n\u201cname\u201d of the object. "),"/\nstructJobLifecycleFilters{\nGlobal::Property name;\nGlobal::Property lifecycle;\n};\nJobLifecycleFilters Properties:\nNameValue TypeDescription\n\u201cName\u201dstringThe name of the Job.\n\u201cLifecycle\u201dGlobal::LifecycleStateNew lifecycle state.\nstructJobLifecycleEvent{\nstring eventSubject;\nGlobal::TimeStamp eventTimeStamp;\nJobLifecycleFilters eventFilterData;\nGlobal::Properties eventNews;\nJob aJob; // on Delete, aJob is nil\n};\nProvided Services:\n/",(0,i.yg)("em",{parentName:"p"}," Request that work be done according to the referred specification. A Job which represents the work is returned for\nfuture reference. The post-condition for this operation is the specified Job successfully created. "),"/\nJobrequestJob(\nin Global::Properties aJobSpecification,\nin JobRequestor aJobRequestor)\nraises (Global::FrameworkErrorSignal,\nJobRejectedSignal);\n/",(0,i.yg)("em",{parentName:"p"},"  Request  that  work  be  done  according  to  the  Job  specification.  This  operation  blocks  until  the  Job  completes.\nResults  generated  by  the  Job  are  returned.  The  post-condition  for  this  operation  is  a  successful  execution  of  the\nspecified  Job.  This  interface  offers  a  lightweight  alternative  to  requestJob  that  does  not  require  that  requestors\nsupport  the  JobRequestor  interfaces  (e.g.,  informJobStateChange  operation).  A  Job  may  or  may  not  be  created  by\nrunJob, but if created, the Job may be accessed with the Job query operations of JobSupervisor. "),"/\nResultsrunJob(\nin Global::Properties aJobSpecification)\nraises (Global::FrameworkErrorSignal,\nJobRejectedSignal);\n/",(0,i.yg)("em",{parentName:"p"},"  Ask  whether  the  Job  specified  by  the  JobSpecification  would  be  accepted  for  current  or  future  (queued)\nprocessing if a requestJob or runJob message were issued now. "),"/\nbooleancanPerform(in Properties aJobSpecification)\nraises (Global::FrameworkErrorSignal);\n/",(0,i.yg)("em",{parentName:"p"},"  Command  to  begin  the  pausing  of  all  Jobs  of  this  JobSupervisor  which  can  be  paused  (e.g.  Jobs  that  have  not\nreached the Finished state). "),"/\nvoidpauseAllJobs()\nraises (Global::FrameworkErrorSignal);\n/",(0,i.yg)("em",{parentName:"p"}," Command to \u201cresume\u201d all Jobs of this JobSupervisor which are currently Paused. "),"/"),(0,i.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200019\nvoidresumeAllJobs()\nraises (Global::FrameworkErrorSignal);\n/",(0,i.yg)("em",{parentName:"p"},"  This  command  aborts  all  the  Jobs  under  the  control  of  the  JobSupervisor  immediately,  without  regard  to  the\nimpact  of  abruptly  halting  the  Job.  This  service  should  be  used  with  great  caution.  It  may  result  in  irrevocable\nchange to factory or material state. "),"/\nvoidabortAllJobs()\nraises (Global::FrameworkErrorSignal);\n/",(0,i.yg)("em",{parentName:"p"}," This command stops all Jobs under control of the JobSupervisor, as quickly as possible. Stopping Jobs should not\nresult in damage to the factory or material being processed. "),"/\nvoidstopAllJobs()\nraises (Global::FrameworkErrorSignal);\n/",(0,i.yg)("em",{parentName:"p"}," This service removes a Job which is in the terminated state. If required, persistent information about the Job may\nbe captured in a history entry. Jobs may also be removed based on other archiving rules. "),"/\nvoidremoveFinishedJob(in Job aJob)\nraises (Global::FrameworkErrorSignal);\n/",(0,i.yg)("em",{parentName:"p"}," Find a Job by name. A Job is a NamedEntity "),"/\nJobfindJobNamed(in string jobName)\nraises (Global::FrameworkErrorSignal,\nJobNotFoundSignal);\n/",(0,i.yg)("em",{parentName:"p"}," Find a queued Job by name. "),"/\nJobfindQueuedJobNamed(in string jobName)\nraises (Global::FrameworkErrorSignal,\nJobNotFoundSignal);\n/",(0,i.yg)("em",{parentName:"p"}," Find an active Job by name. "),"/\nJobfindActiveJobNamed(in string jobName)\nraises (Global::FrameworkErrorSignal,\nJobNotFoundSignal);\n/",(0,i.yg)("em",{parentName:"p"}," Find a canceled Job by name. "),"/\nJobfindCanceledJobNamed(in string jobName)\nraises (Global::FrameworkErrorSignal,\nJobNotFoundSignal);\n/",(0,i.yg)("em",{parentName:"p"}," Find a finished Job by name. "),"/\nJobfindFinishedJobNamed(in string jobName)\nraises (Global::FrameworkErrorSignal,\nJobNotFoundSignal);\n/",(0,i.yg)("em",{parentName:"p"}," Return all the specified Jobs. The JobSequence may be empty. "),"/\nJobSequenceallJobs()\nraises (Global::FrameworkErrorSignal);\nJobSequenceallQueuedJobs()\nraises (Global::FrameworkErrorSignal);\nJobSequenceallCanceledJobs()\nraises (Global::FrameworkErrorSignal);"),(0,i.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200020\nJobSequenceallActiveJobs()\nraises (Global::FrameworkErrorSignal);\nJobSequenceallExecutingJobs()\nraises (Global::FrameworkErrorSignal);\nJobSequenceallPausingJobs()\nraises (Global::FrameworkErrorSignal);\nJobSequenceallPausedJobs()\nraises (Global::FrameworkErrorSignal);\nJobSequenceallStoppingJobs()\nraises (Global::FrameworkErrorSignal);\nJobSequenceallAbortingJobs()\nraises (Global::FrameworkErrorSignal);\nJobSequenceallFinishedJobs()\nraises (Global::FrameworkErrorSignal);\nJobSequenceallStoppedJobs()\nraises (Global::FrameworkErrorSignal);\nJobSequenceallAbortedJobs()\nraises (Global::FrameworkErrorSignal);\nJobSequenceallCompletedJobs()\nraises (Global::FrameworkErrorSignal);\n}; //JobSupervisor\nContracted Services:None.\nDynamic Model:Inherited.\n6. 6.3  Job Interface\nModule:AbstractIF\nInterface:Job\nInherited Interface:OwnedEntity\nDescription:The Job interface represents a unit of work requested of an associated JobSupervisor and\nperformed (or facilitated) by a factory entity. A Job generally results in some change of\nthe  overall  factory  state.  How  the  entities  that  supply  the  Job  and  JobSupervisor\ninterfaces  actually  perform  the  work  (or  delegation  of  work)  is  an  implementation\ndecision.  A  Job  is  expected  (but  not  required)  to  take  a  non-zero  time  to  perform  and\nhave a non-zero chance of refusal or failure. A Job may encapsulate a decomposition into\na sequence of jobs/tasks/activities which are delegated to lower level job supervisors. The\nJob exists during the execution timeframe. The more persistent record of the Job should\nbe maintained in a history entry.\ninterfaceJob: OwnedEntity {\nExceptions:\nPublished Events:\n/",(0,i.yg)("em",{parentName:"p"}," Any time the Job\u2019s state changes. "),"/"))}h.isMDXComponent=!0}}]);