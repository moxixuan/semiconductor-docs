"use strict";(globalThis.webpackChunksemiconductor_docs=globalThis.webpackChunksemiconductor_docs||[]).push([[8147],{2073(e,n,t){t.d(n,{A:()=>i});var a=t(6540);const i=function({pdfLink:e,pdfSize:n,title:t,description:i}){if(!e)return null;const r=e.startsWith("http"),o=(e=>{if(!e)return null;try{const n=new URL(e,r?void 0:window.location.origin);return n.pathname.split("/").pop()}catch{return e.split("/").pop()}})(e);return a.createElement("div",{className:"pdf-download-card"},a.createElement("div",{className:"pdf-download-card__header"},a.createElement("div",{className:"pdf-download-card__icon"},"\ud83d\udce5"),a.createElement("div",{className:"pdf-download-card__title"},a.createElement("h3",null,"\u4e0b\u8f7d\u5b8c\u6574PDF"),t&&a.createElement("p",{className:"pdf-download-card__doc-title"},t))),a.createElement("div",{className:"pdf-download-card__info"},a.createElement("div",{className:"pdf-download-card__meta"},a.createElement("span",{className:"pdf-download-card__label"},"\u6587\u4ef6\u5927\u5c0f:"),a.createElement("span",{className:"pdf-download-card__value"},"string"==typeof(l=n)?l:l<1048576?`${(l/1024).toFixed(1)}KB`:`${(l/1024/1024).toFixed(1)}MB`)),i&&a.createElement("div",{className:"pdf-download-card__description"},i),r&&a.createElement("div",{className:"pdf-download-card__notice"},a.createElement("span",{className:"pdf-download-card__notice-icon"},"\u2139\ufe0f"),a.createElement("span",null,"\u6b64\u6587\u4ef6\u6258\u7ba1\u5728GitHub Releases\uff0c\u53ef\u80fd\u9700\u8981GitHub\u8d26\u53f7"))),a.createElement("div",{className:"pdf-download-card__actions"},a.createElement("a",{href:e,className:"pdf-download-card__button pdf-download-card__button--primary",download:r?void 0:o,target:r?"_blank":void 0,rel:r?"noopener noreferrer":void 0},a.createElement("span",{className:"pdf-download-card__button-icon"},"\u2b07\ufe0f"),"\u4e0b\u8f7dPDF"),r&&a.createElement("a",{href:e,className:"pdf-download-card__button pdf-download-card__button--secondary",target:"_blank",rel:"noopener noreferrer"},a.createElement("span",{className:"pdf-download-card__button-icon"},"\ud83d\udd17"),"\u5728\u65b0\u7a97\u53e3\u6253\u5f00")));var l}},5680(e,n,t){t.d(n,{xA:()=>m,yg:()=>y});var a=t(6540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach(function(n){i(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},m=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},g=a.forwardRef(function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),g=p(t),y=i,u=g["".concat(s,".").concat(y)]||g[y]||c[y]||r;return t?a.createElement(u,o(o({ref:n},m),{},{components:t})):a.createElement(u,o({ref:n},m))});function y(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=g;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}g.displayName="MDXCreateElement"},7086(e,n,t){t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=t(8168),i=(t(6540),t(5680));t(2073);const r={title:"E5-1104 - \xa9 SEMI 1982, 2004...",description:"SEMI\u6807\u51c6\u6587\u6863",sidebar_label:"E5-1104 - \xa9 SEMI 1982, 2004...",sidebar_position:250,tags:["SEMI","Standard"],custom_props:{source_type:"pdf",source_file:"semi-chapter-025.pdf",chapter:25,page_count:50}},o=void 0,l={unversionedId:"standards/semi/semi-chapter-025",id:"standards/semi/semi-chapter-025",title:"E5-1104 - \xa9 SEMI 1982, 2004...",description:"SEMI\u6807\u51c6\u6587\u6863",source:"@site/docs/standards/semi/semi-chapter-025.md",sourceDirName:"standards/semi",slug:"/standards/semi/semi-chapter-025",permalink:"/semiconductor-docs/docs/standards/semi/semi-chapter-025",draft:!1,editUrl:"https://github.com/your-org/semiconductor-docs/tree/main/docs/standards/semi/semi-chapter-025.md",tags:[{label:"SEMI",permalink:"/semiconductor-docs/docs/tags/semi"},{label:"Standard",permalink:"/semiconductor-docs/docs/tags/standard"}],version:"current",sidebarPosition:250,frontMatter:{title:"E5-1104 - \xa9 SEMI 1982, 2004...",description:"SEMI\u6807\u51c6\u6587\u6863",sidebar_label:"E5-1104 - \xa9 SEMI 1982, 2004...",sidebar_position:250,tags:["SEMI","Standard"],custom_props:{source_type:"pdf",source_file:"semi-chapter-025.pdf",chapter:25,page_count:50}}},s={},p=[],m={toc:p};function c({components:e,...n}){return(0,i.yg)("wrapper",(0,a.A)({},m,n,{components:e,mdxType:"MDXLayout"}),(0,i.yg)("p",null,'PdfDownloadCard\npdfLink="/pdfs/semi/025.pdf"\npdfSize="0.36MB"\ntitle="E5-1104 - \xa9 SEMI 1982, 2004..."\ndescription="SEMI\u6807\u51c6\u6587\u6863\uff0c\u517150\u9875"\n/'),(0,i.yg)("h1",{id:"\u6587\u6863\u6807\u9898"},"\u6587\u6863\u6807\u9898"),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 143\nStream,Function  Name (Mnemonic) Direction\nS7,F31  Verification Request Send (VRS) M,H->E,reply\nDescription\nThis message requests the interpreting equipment to check the contents of the provided process program and inform the host\nwhether or not the process program is acceptable for processing at the machine.  The values of MDLN and SOFTREV are\nobtained from the PCD used to generate the process program.  If S7,F31 is multi-block, it must be preceded by the S7,F1/S7,F2\nInquire/Grant transaction.\nStructure\nL,4"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"PPID"),(0,i.yg)("li",{parentName:"ol"},"MDLN"),(0,i.yg)("li",{parentName:"ol"},"SOFTREV"),(0,i.yg)("li",{parentName:"ol"},"L,c                          (c = Number of Process Commands)"),(0,i.yg)("li",{parentName:"ol"},"L,2"),(0,i.yg)("li",{parentName:"ol"},"CCODE"),(0,i.yg)("li",{parentName:"ol"},"L,p                (p = Number of Parameters)"),(0,i.yg)("li",{parentName:"ol"},"PPARM\n1")),(0,i.yg)("p",null,".\n.\np. PPARM\np"),(0,i.yg)("ol",{start:2},(0,i.yg)("li",{parentName:"ol"},"L,2\n.\n.\nc. L,2\nException\nNone")),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS7,F32  Verification Request Acknowledge (VRA) S,H<-E\nDescription\nAcknowledges reception of a formatted process program verification request at its destination and whether the process program\nwas accepted by the equi\npment.  A returned status of accepted by the interpreter means only that the message is understood.  The\nvalidity of the contents of the process program is specified through a separate transaction (S7,F27/S7,F28).\nStructure\nACKC7\nException\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS7,F33  Process Program Available Request (PAR) S,H<->E,reply\nDescription\nThis message requests the interpreting host or equipment to check its process program library and tell the requester if the PPID\nwill be supplied if requested.\nStructure\nPPID\nException\nNone"),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 144\nStream,Function  Name (Mnemonic) Direction\nS7,F34  Process Program Availability Data (PAD) S,H<->E\nDescription\nThis message allows originator to tell requester whether it can provide the specified process program and whether it can provide\nit formatted, unformatted, or both.\nStructure\nL,3"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"PPID"),(0,i.yg)("li",{parentName:"ol"},"UNFLEN"),(0,i.yg)("li",{parentName:"ol"},"FRMLEN\nException\nNone")),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS7,F35  Process Program for MID Request (PPMR) S,H<->E,reply\nDescription\nThis message is used to request the transfer of the process program to be used for the material identified.\nStructure\nMID\nException\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS7,F36  Process Program for MID Data (PPMD) M,H<->E\nDescription\nThis message is used to transfer the process program for the material identified.\nStructure\nL,3"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"MID"),(0,i.yg)("li",{parentName:"ol"},"PPID"),(0,i.yg)("li",{parentName:"ol"},"PPBODY\nException\nA zero-length list returned means no such MID or other error.")),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS7,F37  Large Process Program Send (LPPS) S,H <-> E,reply\nDescription\nThis is a request to send a process program via the Data Set Transfer protocol.  The Data Set name, DSNAME, is the text string\nidentifier of the process program, PPID.  The Data Set is subsequently transferred as a Stream with the following internal SECSII\nstructured data:"),(0,i.yg)("p",null,"PPBODY\nStructure\nDSNAME\nException\nNone"),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 145\nStream,Function  Name (Mnemonic) Direction\nS7,F38  Large Process Program Acknowledge(LPPA) S,H <-> E\nDescription\nAcknowledge or error.  A returned status of \u201caccepted\u201d means only that the message is understood.  When the receiving entity is\nthe equipment, there is aseparate verification transaction (For S7,F27/S7,F28) that indicates the completion status of the request.\nWhen the receiving entity is the host, the completion of the request is signaled by an event report.\nStructure\nACKC7\nException\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS7,F39  Large Formatted Process Program Send (LFPPS) S,H <-> E, reply\nDescription\nThis is a request to send a formatted process program via the Data Set Transfer Protocol.  The Data Set name, DSNAME, is the\ntext string identifier of the process program, PPID.  The Data Set is subsequently transferred as a Stream with the following\ninternal SECSII structured data:"),(0,i.yg)("p",null,"L,4"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"PPID"),(0,i.yg)("li",{parentName:"ol"},"MDLN"),(0,i.yg)("li",{parentName:"ol"},"SOFTREV"),(0,i.yg)("li",{parentName:"ol"},"L,c                          (c = Number of Process Commands)"),(0,i.yg)("li",{parentName:"ol"},"L,2"),(0,i.yg)("li",{parentName:"ol"},"CCODE"),(0,i.yg)("li",{parentName:"ol"},"L,p                (p = Number of Parameters)"),(0,i.yg)("li",{parentName:"ol"},"PPARM\n1")),(0,i.yg)("p",null,".\n.\np. PPARM\np"),(0,i.yg)("ol",{start:2},(0,i.yg)("li",{parentName:"ol"},"L,2\n.\n.\nc. L,2\nStructure\nDSNAME\nException\nnone")),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS7,F40  Large Formatted Process Program Acknowledge (LFPPA) S,H <-> E\nDescription\nAcknowledge or error.  A returned status of \u201caccepted\u201d means only that the message is understood.  When the receiving entity is\nthe equipment, there is a separate verification transaction (S7,F27/S7,F28) that indicates the completion status of the request.\nWhen the receiving entity is the host, the completion of the request is signaled by an event report.\nStructure\nACKC7\nException\nNone"),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 146\nStream,Function  Name (Mnemonic) Direction\nS7,F41  Large Process Program Request(LPPR) S,H <-> E, reply\nDescription\nThis message is used to request the transfer of a process program via the Stream 13 Data set Transfer protocol.  The Data Set\nname, DSNAME, is the text string identifier of the process program, PPID.  The Data Set is subsequently transferred as a Stream\nwith the following internal SECSII structured data:"),(0,i.yg)("p",null,"PPBODY\nStructure\nDSNAME\nException\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS7,F42  Large Process Program Acknowledge (LPPA) S,H <-> E\nDescription\nAcknowledge or error.  A returned status of \u201caccepted\u201d means only that the message is understood.  When the receiving entity is\nthe equipment, there is a separate verification transaction (For example: S7,F27/S7,F28) that indicates the completion status of\nthe request.  When the receiving entity is the host, the completion of the request is signaled by an event report.\nStructure\nACKC7\nException\nIt is possible to use the ACKC7 code \u201ccommand will be performed with completion signaled later\u201d for this message."),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS7,F43  Large Formatted Process Program Request (LFPPR) S,H <-> E, reply\nDescription\nThis message is used to request the transfer of a formatted process program via the Data set Transfer protocol.  The Data Set\nname, DSNAME, is the text string identifier of the process program, PPID.  The Data Set is subsequently transferred as a Stream\nwith the following internal SECSII structured data:"),(0,i.yg)("p",null,"L,4"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"PPID"),(0,i.yg)("li",{parentName:"ol"},"MDLN"),(0,i.yg)("li",{parentName:"ol"},"SOFTREV"),(0,i.yg)("li",{parentName:"ol"},"L,c                          (c = Number of Process Commands)"),(0,i.yg)("li",{parentName:"ol"},"L,2"),(0,i.yg)("li",{parentName:"ol"},"CCODE"),(0,i.yg)("li",{parentName:"ol"},"L,p                (p = Number of Parameters)"),(0,i.yg)("li",{parentName:"ol"},"PPARM\n1")),(0,i.yg)("p",null,".\n.\np. PPARM\np"),(0,i.yg)("ol",{start:2},(0,i.yg)("li",{parentName:"ol"},"L,2\n.\n.\nc. L,2\nStructure\nDSNAME\nException\nNone")),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 147\nStream,Function  Name (Mnemonic) Direction\nS7,F44  Large Formatted Process Program Acknowledge (LFPPA) S,H <-> E\nDescription\nAcknowledge or error.  A returned status of \u201caccepted\u201d means only that the message is understood.  When the receiving entity is\nthe equipment, there is a separate verification transaction (S7,F27/S7,F28) that indicates the completion status of the request.\nWhen the receiving entity is the host, the completion of the request is signaled by an event report.\nStructure\nACKC7\nException\nIt is possible to use the ACKC7 code \u201ccommand will be performed with completion signaled later\u201d for this message."),(0,i.yg)("ol",{start:10},(0,i.yg)("li",{parentName:"ol"},"12  Stream 8 Control Program Transfer \u2014 The purpose of this stream is to provide the method for transmitting\nthe programs used in the equipment to perform the control function or to execute the transmitted process program.")),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS8,F0  Abort Transaction (S8F0) S,H<->E\nDescription\nSame form as S1,F0.\nStructure"),(0,i.yg)("p",null,"Exception"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS8,F1  Boot Program Request (BPR) S,H<->E,reply\nDescription\nThis message is used to request the transmission of the boot program.  It is assumed that there is only one boot program\nassociated with any given equipment.\nStructure\nHeader only\nException\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS8,F2  Boot Program Data (BPD) M,H<->E\nDescription\nThe boot program is required by some systems as a precursor to loading an operating system or executive program.\nStructure\nBPD\nException\nA zero-length item means no boot."),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 148\nStream,Function  Name (Mnemonic) Direction\nS8,F3  Executive Program Request (EPR) S,H<->E,reply\nDescription\nThis message is used to request the executive program.  It is assumed that there is only one executive program associated with\nany given equipment.\nStructure\nHeader only\nException\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS8,F4  Executive Program Data (EPD) M,H<->E\nDescription\nThe executive program is the master control program of the equipment.  The executive may contain all the program required or it\nmay contain the information required to request the rest of the program it needs on Stream 13.\nStructure\nEPD\nException\nNone"),(0,i.yg)("ol",{start:10},(0,i.yg)("li",{parentName:"ol"},"13  Stream  9  System  Errors  \u2014  This  stream  provides  a  method  of  informing  the  host  that  a  message  block  has\nbeen  received  which  cannot  be  handled  or  that  a  timeout  on  a  transaction  (receive)  timer  has  occurred.    The\nmessages  indicate  either  a  Message  Fault  or  a  Communications  Fault  has  occurred  but  do  not  indicate  a\nCommunications Failure has occurred."),(0,i.yg)("li",{parentName:"ol"},"13.1  Communications  Failure  \u2014  A  Communications  Failure  occurs  in  a  SECS-I  environment  when,  and  only\nwhen, the RTY limit is exceeded.\nNOTE 10:  In the event of a Communications Failure, no Stream 9 message is sent."),(0,i.yg)("li",{parentName:"ol"},"13.2  Communications  Fault  \u2014  A  Communications  Fault  occurs  when  the  equipment  does  not  receive  an\nexpected message (when a transaction timer or a conversation timer has expired)."),(0,i.yg)("li",{parentName:"ol"},"13.3  Message Fault \u2014 A Message Fault occurs when the equipment receives a message which it cannot process\nbecause of a fault that arises from the content, context, or length of the message.")),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS9,F0  Abort Transaction (S9F0) S,H<->E\nDescription\nSame form as S1,F0.\nStructure"),(0,i.yg)("p",null,"Exception"),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 149\nStream,Function  Name (Mnemonic) Direction\nS9,F1  Unrecognized Device ID (UDN) S,H<-E\nDescription\nThe device ID in the message block header did not correspond to any known device ID in the node detecting the error.\nStructure\nMHEAD\nException\nNone"),(0,i.yg)("p",null,"S9,F2 Not Used"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS9,F3  Unrecognized Stream Type (USN) S,H<-E\nDescription\nThe equipment does not recognize the stream type in the message block header.\nStructure\nMHEAD\nException\nNone"),(0,i.yg)("p",null,"S9,F4 Not Used"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS9,F5  Unrecognized Function Type (UFN) S,H<-E\nDescription\nThis message indicates that the function in the message ID is not recognized by the receiver.\nStructure\nMHEAD\nException\nNone"),(0,i.yg)("p",null,"S9,F6 Not Used"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS9,F7  Illegal Data (IDN) S,H<-E\nDescription\nThis message indicates that the stream and function were recognized, but the associated data format could not be interpreted.\nStructure\nMHEAD\nException\nNone"),(0,i.yg)("p",null,"S9,F8 Not Used"),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 150\nStream,Function  Name (Mnemonic) Direction\nS9,F9  Transaction Timer Timeout (TTN) S,H<-E\nDescription\nThis message indicates that a transaction (receive) timer has timed out and that the corresponding transaction has been aborted.\nIt is up to the host to respond to this error in an appropriate manner to keep  the system operational.\nStructure\nSHEAD\nException\nNone"),(0,i.yg)("p",null,"S9,F10 Not Used"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS9,F11  Data Too Long (DLN) S,H<-E\nDescription\nThis message to the host indicates that the equipment has been sent more data than it can handle.\nStructure\nMHEAD\nException\nNone"),(0,i.yg)("p",null,"S9,F12 Not Used"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS9,F13  Conversation Timeout (CTN) S,H<-E\nDescription\nData were expected but none were received within a reasonable length of time.  Resources have been cleared.\nStructure\nL,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"MEXP"),(0,i.yg)("li",{parentName:"ol"},"EDID\nException\nNone")),(0,i.yg)("p",null,"S9,F14 Not Used"),(0,i.yg)("ol",{start:10},(0,i.yg)("li",{parentName:"ol"},"14  Stream  10  Terminal  Services  \u2014  The  functions  of  this  stream  is  to  pass  textual  messages  between  operator\nterminals  attached  to  processing  and/or  testing  equipment  and  the  host.    The  equipment  makes  no  attempt  to\ninterpret  the  text  of  the  message,  but  merely  passes  it  from  terminal  keyboard  to  the  host  or  from  the  host  to  the\ndisplay  of  the  terminal.    Management  of  human  response  times  to  information  displayed  on  terminals  is  the\nresponsibility of the host.")),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 151\nStream,Function  Name (Mnemonic) Direction\nS10,F0  Abort Transaction (S10F0) S,H<->E\nDescription\nSame form as S1,F0.\nStructure"),(0,i.yg)("p",null,"Exception"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS10,F1  Terminal Request (TRN) S,H<-E,","[reply]","\nDescription\nA terminal text message to the host.\nStructure\nL,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"TID"),(0,i.yg)("li",{parentName:"ol"},"TEXT\nException\nNone")),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS10,F2  Terminal Request Acknowledge (TRA) S,H->E\nDescription\nAcknowledge or error\nStructure\nACKC10\nException\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS10,F3  Terminal Display, Single (VTN) S,H->E, ","[reply]","\nDescription\nData to be displayed.\nStructure\nL,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"TID"),(0,i.yg)("li",{parentName:"ol"},"TEXT\nException\nNone")),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 152\nStream,Function  Name (Mnemonic) Direction\nS10,F4  Terminal Display, Single Acknowledge (VTA) S,H<-E\nDescription\nAcknowledge or error\nStructure\nACKC10\nException\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS10,F5  Terminal Display, Multi-Block (VTN) M,H->E,","[reply]","\nDescription\nData to be displayed on the equipment\u2019s terminal.\nStructure\nL,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"TID"),(0,i.yg)("li",{parentName:"ol"},"L,n"),(0,i.yg)("li",{parentName:"ol"},"TEXT\n1")),(0,i.yg)("p",null,".\n.\nn.TEXT\nn"),(0,i.yg)("p",null,"Exception\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS10,F6  Terminal Display, Multi-block Acknowledge (VMA) S,H<-E\nDescription\nAcknowledge or error\nStructure\nACKC10\nException\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS10,F7 Multi-block Not Allowed (MNN) S,H<-E\nDescription\nAn error message from a terminal that cannot handle a multi-block message from S10,F5.\nStructure\nTID\nException\nNone"),(0,i.yg)("p",null,"S10,F8 Not Used"),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 153\nStream,Function  Name (Mnemonic) Direction\nS10,F9  Broadcast (BCN) S,H->E,","[reply]","\nDescription\nThis function is generally the same as S10,F3 except that specific TID in each equipment need not be specified.  Instead, the text\nis directed to each terminal in the equipment when the function is received.  This function assumes that this feature exists on all\nequipment, otherwise repeated S10,F3 messages should be used.\nStructure\nTEXT\nException\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS10,F10  Broadcast Acknowledge (BCA) S,H<-E\nDescription\nAcknowledge or error\nStructure\nACKC10\nException\nNone"),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 154\n10. 15  Stream  11  has  been  deleted  and  will  not  appear\nagain in this publication.\n10. 15.1  It  is  the  consensus  of  the  Communications\nCommittee  that  Stream  11  is  obsolete.    Its  use  is\ndiscouraged,  and  it  has  been  removed  from  the  1989\nedition  of  the  standard.    The  reasons  for  removal  are\nthree-fold:"),(0,i.yg)("h1",{id:"1"},"1"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"The  purpose  of  this  stream,  as  it  was  originally\nenvisioned,  is  perceived  to  be  of  little  use  and  can\nbest  be  accomplished  by  other  means  beyond  the\nscope of this standard;")),(0,i.yg)("h1",{id:"2"},"2"),(0,i.yg)("ol",{start:2},(0,i.yg)("li",{parentName:"ol"},"The  functions  in  this  stream  have  many  technical\nproblems that severely limit their use;")),(0,i.yg)("h1",{id:"3"},"3"),(0,i.yg)("ol",{start:3},(0,i.yg)("li",{parentName:"ol"},"There  is  a  noticeable  lack  of  implementations  of\nthis standard that utilize Stream 11 in its originally\nintended form.\nNOTE 11:  Applications  that  need  to  transfer  unformatted\ndata between the host and equipment should use the facilities\nof Stream 13."),(0,i.yg)("li",{parentName:"ol"},"16  Stream  12  Wafer  Mapping  \u2014  Messages  which\ndeal with coordinate positions and data associated with\nthose  positions.    This  includes  functions  such  as  wafer\nmapping  with  coordinates  of  die  on  a  wafer  and  the\nassociated binning information."),(0,i.yg)("li",{parentName:"ol"},"16.1  Structure  \u2014  Functions  1  through  20  address\nthe  variations  required  by  semiconductor  equipment\nmanufacturers  in  transmitting  wafer  maps  to  and  from\nthe process equipment (wafer probe through die attach).\nThe  functions  include  three  basic  formats.    The  three\nformats developed are:"),(0,i.yg)("li",{parentName:"ol"},"Row/column   format   where   a   coordinate   row\nstarting position is given with die count in the row\nand   starting   direction.      The   respective   binning\ninformation follows for each die."),(0,i.yg)("li",{parentName:"ol"},"Array format is structured such that a matrix array\ncaptures  all  or  part  of  a  wafer  with  the  associated\nbinning information."),(0,i.yg)("li",{parentName:"ol"},"Coordinate  format  provides  an  X/Y  location  and\nbin code for die on the wafer."),(0,i.yg)("li",{parentName:"ol"},"16.2  Definitions and Descriptions \u2014 The following\ninformation  is  required  to  perform  map  association  to\nthe  physical  wafer  as  it  relates  to  the  archival  use  and\ntransmission of wafer maps."),(0,i.yg)("li",{parentName:"ol"},"Flat/Notch Location"),(0,i.yg)("li",{parentName:"ol"},"Frame Rotation"),(0,i.yg)("li",{parentName:"ol"},"Row Count")),(0,i.yg)("h1",{id:"4"},"4"),(0,i.yg)("ol",{start:4},(0,i.yg)("li",{parentName:"ol"},"Column Count")),(0,i.yg)("h1",{id:"5"},"5"),(0,i.yg)("ol",{start:5},(0,i.yg)("li",{parentName:"ol"},"Die Units of Measure")),(0,i.yg)("h1",{id:"6"},"6"),(0,i.yg)("ol",{start:6},(0,i.yg)("li",{parentName:"ol"},"Die Size")),(0,i.yg)("h1",{id:"7"},"7"),(0,i.yg)("ol",{start:7},(0,i.yg)("li",{parentName:"ol"},"Process Die Count")),(0,i.yg)("h1",{id:"8"},"8"),(0,i.yg)("ol",{start:8},(0,i.yg)("li",{parentName:"ol"},"Reference Points")),(0,i.yg)("h1",{id:"9"},"9"),(0,i.yg)("ol",{start:9},(0,i.yg)("li",{parentName:"ol"},"Bin Code Equivalents")),(0,i.yg)("h1",{id:"10"},"10"),(0,i.yg)("ol",{start:10},(0,i.yg)("li",{parentName:"ol"},"Process Axis")),(0,i.yg)("h1",{id:"11"},"11"),(0,i.yg)("ol",{start:11},(0,i.yg)("li",{parentName:"ol"},"Null Bin Code Value")),(0,i.yg)("h1",{id:"12"},"12"),(0,i.yg)("ol",{start:12},(0,i.yg)("li",{parentName:"ol"},"ID Type"),(0,i.yg)("li",{parentName:"ol"},"16.2.1  Flat/Notch   Location   \u2014   The   position   in\ndegrees   that   the   flat   or   notch   are   oriented   during\nprocessing   relative   to   a   \u201cnormal\u201d   position   of   zero\ndegrees.  See Figure 6."),(0,i.yg)("li",{parentName:"ol"},"16.2.2  Frame Rotation \u2014 The orientation of a film\nframe  relative  to  a  \u201cnormal\u201d  position  of  zero  degrees.\nSee Figure 7."),(0,i.yg)("li",{parentName:"ol"},"16.2.3  Row/Column  Count  \u2014  The  row  and  column\ncounts  are  the  total  number  of  rows  and  columns,\nrespectively,  on  a  wafer  which  must  be  correlated\ndirectly  with  the  wafer  map.    These  numbers  will\nalways be greater than zero."),(0,i.yg)("li",{parentName:"ol"},"16.2.4  Die Sizes \u2014 The die size is given in standard\nunits  as  specified  by  the  die  unit  of  measure  item\nDUTMS, and will also be greater than zero.  The value\nof the die size is determined by measuring the distance\nfrom  a  point  on  one  die  to  the  same  point  on  the  next\ndie,  often  referred  to  as  an  index.    This  is  depicted  in\nthe lower portion of Figure 7, Section B in the General\nRules Section."),(0,i.yg)("li",{parentName:"ol"},"16.2.5  Process Die Count \u2014 The process die count\nitem  is  used  by  equipment  that  is  being  map  driven  to\nmake   determinations   about   how   much   material   to\nprepare.    For  example,  a  die  attach  will  epoxy  lead\nframes  in  advance  of  the  attach  process.    By  knowing\nthe  total  number  of  die  to  be  processed  within  a  wafer\nmap,  the  equipment  can  stop  epoxying  lead  frames\nequivalent  to  the  last  die  to  be  attached.    This  item  is\nalso  used  by  the  equipment  to  tell  the  host  how  many\ntotal  die  it  processed  for  that  map.    For  example,  a  die\nattach would use PRDCT to report the total die actually\nattached from a particular wafer."),(0,i.yg)("li",{parentName:"ol"},"16.2.6  Reference    Points    \u2014    Reference    points\nprovide a means of relating a map to the physical wafer.\nThe  total  number  of  these  points,  and  the  method  for\nassigning  and  detecting  them,  is  the  responsibility  of\nthe equipment.  This standard only provides a means for\ntransmitting them."),(0,i.yg)("li",{parentName:"ol"},"16.2.7  Origin   \u2014   The   origin   is   in   one   of   five\nlocations  which  is  specified  by  the  equipment  when\ngenerating  a  wafer  map.    The  origin  is  on  an  array\nstructure   having   dimensional   values   equal   to   those")),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 155\nspecified by the row and column count.  The origin then\nlies  on  one  of  the  four  corners  of  that  array  or  in  a\ncenter location determined by the following formula:\nrow~or~column+ 1\n2\n\u239b\n\u239d\n\u239c\n\u239e\n\u23a0\n\u239f truncated"),(0,i.yg)("ol",{start:10},(0,i.yg)("li",{parentName:"ol"},"16.2.7.1  It   is   implicit   in   determining   the   center\nlocation  that  the  upper-left-hand  corner  of  the  area,  in\nthe  normal  position,  be  counted  as  the  first  row  and\ncolumn  position.    An  equipment  requesting  a  map\nprovides the origin location that it wants the map to be\nbased  on  before  transmission.    If  the  equipment  does\nnot  provide  an  origin,  the  host  must  provide  a  default\nvalue.    An  equipment  transmitting  a  map  must  provide\nthe origin with the map setup data."),(0,i.yg)("li",{parentName:"ol"},"16.2.8  Bin     Code     Equivalents     \u2014     Bin     code\nequivalents  is  a  list  of  bin  codes  that  the  receiving\nequipment will process.  (i.e., if a map contains codes 1\nthrough 10 and the good die are bins 1 and 2, then bin\ncode  equivalent  list  could  indicate  1  and  2  if  only  the\ngood  die  categories  were  needed.    These  are  the  only\nbin  codes  to  which  an  equivalent  will  drive  for  its\nrespective   process   function.)   In   the   case   of   X/Y\ncoordinate format, the locations transmitted will be only\nthose   with   the   bin   codes   stated   in   the   Bin   Code\nEquivalent  list,  unless  the  length  byte  is  set  to  zero,  in\nwhich   all   of   the   bin   codes   in   the   map   will   be\ntransmitted."),(0,i.yg)("li",{parentName:"ol"},"16.2.9  Process Axis \u2014 The process axis is the axis,\neither  rows  or  columns,  increasing  or  decreasing,  and\nthe   side   of   the   map,   (top,   bottom,   left,   or   right,\nrespectively)  that  the  map  data  will  originate  from.\nThis  is  based  on  the  coordinate  system  as  described\nunder the General Rules section of this document."),(0,i.yg)("li",{parentName:"ol"},"16.2.10  ID    Type    \u2014    ID    type    indicates    the\nappropriate  material  ID  type  (i.e.,  wafer,  cassette,  or\nfilm frame)."),(0,i.yg)("li",{parentName:"ol"},"16.3  General Rules"),(0,i.yg)("li",{parentName:"ol"},"16.3.1  Map Data Size \u2014 Stream 12 provides for the\ntransmission  of  a  complete  map  regardless  of  size.\nEquipment  requiring  segmented  maps  for  transmission\nor  reception  will  not  be  able  to  use  the  Stream  12\nfunctions to handle the complete conversation."),(0,i.yg)("li",{parentName:"ol"},"16.3.2  Orientation  Conventions  \u2014  The  orientation\nof  a  wafer  presented  for  processing  will  differ  from\nequipment    to    equipment.        Stream    12    specifies\nconventions  for  expressing  wafer  orientation  so  that  a\nmap     can     be     translated     from     one     geometric\nrepresentation to another."),(0,i.yg)("li",{parentName:"ol"},"16.3.2.1  The bottom of the wafer is the notch or the\nline  of  the  major  flat.    The  orientation  of  a  wafer  is\nmeasured in positive degrees clockwise (CW) from the\n\u201cnormal\u201d position.  The \u201cnormal\u201d position is where the\nbottom of the wafer is closest to you when the wafer is\nlying  horizontally  in  front  of  you  with  the  die  side\nfacing up.  The \u201cnormal\u201d position has an orientation of\nzero degrees.  See Figure 6 for graphic representation of\nwafer orientations."),(0,i.yg)("li",{parentName:"ol"},"16.3.2.2  The  bottom  of  a  film  frame  is  also  the\nnotch   or   the   line   of   notches.      Its   orientation   and\n\u201cnormal\u201d  position  are  measured  in  the  same  manner  as\nfor  wafers.    See  Figure  7  for  examples  of  bottoms  of\nfilm frames."),(0,i.yg)("li",{parentName:"ol"},"16.3.2.3  The  orientation  of  an  unmounted  wafer\npresented  for  processing  is  given  by  the  parameter\nFNLOC, Flat/Notch LOCation."),(0,i.yg)("li",{parentName:"ol"},"16.3.2.4  The    ultimate    orientation    of    a    wafer\npresented for processing after it has been mounted on a\nfilm frame is the cumulative rotation of the wafer from\nthe \u201cnormal\u201d position on the film frame and the rotation\nof film frame as it is presented  to  the  equipment.    This\nis determined by the sum of the parameters FNLOC and\nFFROT,  Film  Frame  ROTation.    It  is  possible  for  an\napplication  to  represent  the  ultimate  orientation  of  a\nwafer in one of these parameters only and pass the other\nparameter as zero length."),(0,i.yg)("li",{parentName:"ol"},"16.3.2.5  Figure  6  shows  wafers  oriented  at  270\ndegrees  with  respect  to  the  bottoms  of  a  metal  and\nround  film  frame.    If  one  of  these  film  frames  were\npresented to an equipment rotated 90 degrees clockwise\n(CW),  (bottom  facing  the  left  edge  of  the  page),  the\nultimate orientation of the wafer would be zero degrees."),(0,i.yg)("li",{parentName:"ol"},"16.3.2.6  In the case where either FNLOC or FFROT\nare  unknown  or  irrelevant  information,  a  zero-length\ndata item is transmitted, and the item will be ignored by\nthe application.  One of the items must exist."),(0,i.yg)("li",{parentName:"ol"},"16.3.3  Coordinate  Axis  System  \u2014  The  coordinate\naxis  orientation  is  shown  in  Figure  8,  Section  A.    The\nassumption  is  that  the  \u201cX\u201d  or  \u201ccolumn\u201d  coordinates\nincrease  to  the  right  of  the  \u201cY-axis\u201d  and  the  \u201cY\u201d  or\n\u201crow\u201d   coordinates   increase   above   the   \u201cX-axis.\u201d   In\ndescribing  the  physical  wafer  it  is  also  given  that  the\ncoordinate  axis  orientation  never  rotates.    The  wafer\nmoves  or  rotates  within  the  coordinate  axis  system.\nThe  origin  within  the  array  describing  the  wafer\u2019s\ncoordinate  system  must  be  in  one  of  five  locations  on\nthat array (the center, upper-left, lower-left, upper-right,\nor lower-right corner of the array).")),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 156\n10. 16.3.3.1  Figures  9  and  10  summarize  the  conversation  protocol  in  the  form  of  a  flow  chart.    Since  a  single\ntransmit  inquire/grant  can  be  used  for  one  of  three  message  function  pairs,  the  application  is  required  to  examine\nMAPFT, is received as part of the map setup data to determine the appropriate function to follow.  If the appropriate\nfunction is not transmitted, the conversation is aborted and the error is reported using the appropriate error reporting\nstream and function."),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS12,F0  Abort Transaction (S12F0) S,H<->E\nDescription\nSame form as S1F0.\nStructure"),(0,i.yg)("p",null,"Exception"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS12,F1  Map Set-up Data Send (MSDS) S,H<-E,reply\nDescription\nUsed to send all of the map set-up data common to all formats and required to link the data map with the physical wafer.\nStructure\nL,15"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"MID"),(0,i.yg)("li",{parentName:"ol"},"IDTYP"),(0,i.yg)("li",{parentName:"ol"},"FNLOC"),(0,i.yg)("li",{parentName:"ol"},"FFROT"),(0,i.yg)("li",{parentName:"ol"},"ORLOC"),(0,i.yg)("li",{parentName:"ol"},"RPSEL"),(0,i.yg)("li",{parentName:"ol"},"L,n"),(0,i.yg)("li",{parentName:"ol"},"REFP\nx\nREFP\ny")),(0,i.yg)("p",null,".\n.\nn. REFP\nx\nREFP\ny"),(0,i.yg)("ol",{start:8},(0,i.yg)("li",{parentName:"ol"},"DUTMS"),(0,i.yg)("li",{parentName:"ol"},"XDIES"),(0,i.yg)("li",{parentName:"ol"},"YDIES"),(0,i.yg)("li",{parentName:"ol"},"ROWCT"),(0,i.yg)("li",{parentName:"ol"},"COLCT"),(0,i.yg)("li",{parentName:"ol"},"NULBC"),(0,i.yg)("li",{parentName:"ol"},"PRDCT"),(0,i.yg)("li",{parentName:"ol"},"PRAXI\nException\nNone")),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 157\nStream,Function  Name (Mnemonic) Direction\nS12,F2  Map Set-up Data Acknowledge (MSDA) S,H->E\nDescription\nAcknowledgment of receipt of complete set of map set-up parameters.\nStructure\nSDACK\nException\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS12,F3  Map Set-up Data Request (MSDR) S,H<-E,reply\nDescription\nUsed to request set-up data from the host for the product ready to be processed at the equipment (common to all formats).\nStructure\nL,9"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"MID"),(0,i.yg)("li",{parentName:"ol"},"IDTYP"),(0,i.yg)("li",{parentName:"ol"},"MAPFT"),(0,i.yg)("li",{parentName:"ol"},"FNLOC"),(0,i.yg)("li",{parentName:"ol"},"FFROT"),(0,i.yg)("li",{parentName:"ol"},"ORLOC"),(0,i.yg)("li",{parentName:"ol"},"PRAXI"),(0,i.yg)("li",{parentName:"ol"},"BCEQU..."),(0,i.yg)("li",{parentName:"ol"},"NULBC\nException\nNone")),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 158\nStream,Function  Name (Mnemonic) Direction\nS12,F4  Map Set-up Data (MSD) S,H->E\nDescription\nUsed to send all of the map set-up data required to link the data map with the physical wafer.\nStructure\nL,15"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"MID"),(0,i.yg)("li",{parentName:"ol"},"IDTYP"),(0,i.yg)("li",{parentName:"ol"},"FNLOC"),(0,i.yg)("li",{parentName:"ol"},"ORLOC"),(0,i.yg)("li",{parentName:"ol"},"RPSEL"),(0,i.yg)("li",{parentName:"ol"},"L,n"),(0,i.yg)("li",{parentName:"ol"},"REFP\nx\nREFP\ny")),(0,i.yg)("p",null,".\n.\nn. REFP\nx\nREFP\ny"),(0,i.yg)("ol",{start:7},(0,i.yg)("li",{parentName:"ol"},"DUTMS"),(0,i.yg)("li",{parentName:"ol"},"XDIES"),(0,i.yg)("li",{parentName:"ol"},"YDIES"),(0,i.yg)("li",{parentName:"ol"},"ROWCT"),(0,i.yg)("li",{parentName:"ol"},"COLCT"),(0,i.yg)("li",{parentName:"ol"},"PRDCT"),(0,i.yg)("li",{parentName:"ol"},"BCEQU"),(0,i.yg)("li",{parentName:"ol"},"NULBC"),(0,i.yg)("li",{parentName:"ol"},"MLCL\nException\nA zero-length list returned means no such MID.")),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS12,F5  Map Transmit Inquire (MAPTI) S,H<-E,reply\nDescription\nUsed to prepare the host for map transmission.  S12,F5 must precede all S12,F7-8,F9-10, & F11-12 transactions.\nStructure\nL,4"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"MID"),(0,i.yg)("li",{parentName:"ol"},"IDTYP"),(0,i.yg)("li",{parentName:"ol"},"MAPFT"),(0,i.yg)("li",{parentName:"ol"},"MLCL\nException\nNone")),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS12,F6  Map Transmit Grant (MAPTG) S,H->E\nDescription\nProvides permission to transfer.\nStructure\nGRNT1\nException\nNone"),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 159\nStream,Function  Name (Mnemonic) Direction\nS12,F7  Map Data Send Type 1 (MDS1) M,H<-E,reply\nDescription\nUsed to send map data from the equipment to the host in row or column compressed format.  If S12,F7 is multi-block, it must be\npreceded by the S12,F5/S12,F6 Inquire/Grant transaction.\nStructure\nL,3"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"MID")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"IDTYP")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,n")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"RSINF\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"BINLT\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2\n.\n.\nn. L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"RSINF\nn")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"BINLT\nn"))),(0,i.yg)("p",null,"Exception\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS12,F8  Map Data Acknowledge Type 1 (MDA1) S,H->E\nDescription\nAcknowledge or error\nStructure\nMDACK\nException\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS12,F9  Map Data Send Type 2 (MDS2) M,H<-E,reply\nDescription\nUsed to send map data from the equipment in array format.  If S12,F9 is multi-block, it must be preceded by the S12,F5/S12,F6\nInquire/Grant transaction.\nStructure\nL,4"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"MID")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"IDTYP")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"STRP\nx\nSTRP\ny")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"BINLT...\nException\nNone"))),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 160\nStream,Function  Name (Mnemonic) Direction\nS12,F10  Map Data Acknowledge Type 2 (MDA2) S,H->E\nDescription\nAcknowledge or error\nStructure\nMDACK\nException\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS12,F11  Map Data Send Type 3 (MDS3) M,H<-E,reply\nDescription\nUsed to send map data from the equipment in cartesian coordinate format.  Bin values may or may not be included in the\nmessage.  If S12,F11 is multi-block, it must be preceded by the S12,F5/S12,F6 Inquire/Grant transaction.\nStructure\nL,3"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"MID")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"IDTYP")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,n")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"XYPOS1\nx\nXYPOS1\ny")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"BINLT1...")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2\n.\n.\nn. L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"XYPOS\nn")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"BINLT\nn"))),(0,i.yg)("p",null,"Exception\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS12,F12  Map Data Acknowledge Type 3 (MDA3) S,H->E\nDescription\nAcknowledge or error\nStructure\nMDACK\nException\nNone"),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 161\nStream,Function  Name (Mnemonic) Direction\nS12,F13  Map Data Request Type 1 (MDR1) S,H<-E,reply\nDescription\nUsed to request map data for product at equipment process station in row or column format.\nStructure\nL,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"MID"),(0,i.yg)("li",{parentName:"ol"},"IDTYP\nException\nNone")),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS12,F14  Map Data Type 1 (MD1) M,H->E\nDescription\nUsed to send map data from the host to the equipment in row or column format.\nStructure\nL,3"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"MID")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"IDTYP")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,n")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"RSINF\nx1\nRSINF\ny1\nRSIN\nd")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"BINLT...")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2\n.\n.\nn. L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"RSINF\nn")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"BINLT\nn"))),(0,i.yg)("p",null,"Exception\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS12,F15  Map Data Request Type 2 (MDR2) S,H<-E,reply\nDescription\nUsed to request map data for product at an equipment process station, in array format.\nStructure\nL,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"MID"),(0,i.yg)("li",{parentName:"ol"},"IDTYP\nException\nNone")),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 162\nStream,Function  Name (Mnemonic) Direction\nS12,F16  Map Data Type 2 (MD2) M,H->E\nDescription\nUsed to send map data from the host to the equipment in array format.\nStructure\nL,4"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"MID")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"IDTYP")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"STRP\nx\nSTRP\ny")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"BINLT...\nException\nA zero-length list returned means no such MID."))),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS12,F17  Map Data Request Type 3 (MDR3) S,H<-E,reply\nDescription\nUsed to request map data for product at an equipment process station in cartesian coordinate format.\nStructure\nL,3"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"MID"),(0,i.yg)("li",{parentName:"ol"},"IDTYP"),(0,i.yg)("li",{parentName:"ol"},"SDBIN\nException\nNone")),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS12,F18  Map Data Type 3 (MD3) M,H->E\nDescription\nUsed to send map data from the host to the equipment in cartesian coordinate format.  Bin values may or may not be included.\nStructure\nL,3"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"MID")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"IDTYP")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,n")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"XYPOS\nx1\nXYPOS\ny1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"BINLT\n1\n...")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2\n.\n.\nn. L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"XYPOS\nn")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"BINLT\nn"))),(0,i.yg)("p",null,"Exception\nA zero-length list returned means no such MID."),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 163\nStream,Function  Name (Mnemonic) Direction\nS12,F19  Map Error Report Send (MERS) S,H<->E\nDescription\nUsed to transmit map related errors.\nStructure\nL,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"MAPER"),(0,i.yg)("li",{parentName:"ol"},"DATLC\nException\nNone")),(0,i.yg)("p",null,"S12,F20 Not Used"),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 164"),(0,i.yg)("p",null,"Figure 6\nWafer Rotation Position in Degrees"),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 165"),(0,i.yg)("p",null,"Figure 7\nWafer Rotation on Film Frame"),(0,i.yg)("p",null,"Figure 8\nOrientation Reference and Index Determination"),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 166"),(0,i.yg)("p",null,"Figure 9\nWafer Map Transmitted by Equipment"),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 167"),(0,i.yg)("p",null,"Figure 10\nWafer Map Received by Equipment"),(0,i.yg)("ol",{start:10},(0,i.yg)("li",{parentName:"ol"},"17  Stream  13  Data  Set  Transfers  \u2014  This  stream\nprovides  protocols  to  transfer  data  sets  between  sys-\ntems.  It is not intended to provide a general file access\nmechanism."),(0,i.yg)("li",{parentName:"ol"},"17.1  Data  Set Characteristics  \u2014  The  data  set  may\nreside on the host or the equipment."),(0,i.yg)("li",{parentName:"ol"},"17.1.1  The  term  data  set  is  used  in  a  very  general\nsense.  A data set may represent a file, a data structure\nin  memory,  a  collection  of  sensor  values,  or  high\ndensity  wafer  profile  data.    The  protocols  define  only\nthe way data is sent from one system to another and do\nnot  define  how  the  data  set  is  stored  by  either  the  host\nor equipment."),(0,i.yg)("li",{parentName:"ol"},"17.1.2  The sending  system  is  defined  to  be  the\nsystem  that  has  the  data  set.    The  receiving  system  is\ndefined  to  be  the  system  to  which  the  data  set  is  being\ntransferred.    The  host  or  the  equipment  may  assume\neither role."),(0,i.yg)("li",{parentName:"ol"},"17.2  Unformatted  Data  Set  Protocol  \u2014  The  proto-\ncol  for  transferring  unformatted  data  sets  has  the  fol-\nlowing characteristics:"),(0,i.yg)("li",{parentName:"ol"},"Information  about  the  record  structure  of  the  data\nset may be available."),(0,i.yg)("li",{parentName:"ol"},"ASCII  records  are  transferred  without  the  record\nterminating   \u201cnoise\u201d   characters   used   by   some\noperating systems."),(0,i.yg)("li",{parentName:"ol"},"Data  sets  do  not  need  to  be  transferred  in  a  single\nmessage."),(0,i.yg)("li",{parentName:"ol"},"No  arbitrary  limits  are  imposed  on  the  length  of\none  message.    The  maximum  amount  of  data  sent\nin each message is determined by both the sending\nand  receiving  systems,  so  there  can  be  no  data\noverruns."),(0,i.yg)("li",{parentName:"ol"},"There  is  a  method  of  restarting  a  transfer  in  the\nevent of an interruption.")),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 168\n10. 17.2.1  Data  Set  Name  \u2014  An  ASCII  string  (format\n20)  which  performs  a  function  similar  to  the  Message\nID (Stream and Function) of the SECS-I protocol.  This\nis a logical name which has meaning to both the equip-\nment and the host.  Neither the equipment nor the host\nis  required  to  use  the  Data  Set  Name  for  the  same\ninformation in any other context.  For example, mainte-\nnance  data  may  be  stored  in  the  equipment  in  the  file\n\u201cWIDGET.DAT\u201d  and  in  the  host  as  records  in  a  data-\nbase, but the Data Set Name may be \u201cS11,F2\u201d.\n10. 17.2.2  Records \u2014 The Record Type determines the\nway the data set is divided into messages for transfer to\nthe  receiving  system.    There  are  two  types  of  records:\nDiscrete and Stream."),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"A  data  set  with  Discrete records  has  a  traditional\nrecord      structure,      such      as      ASCII      text.\nRecordLength is  the  length  of  the  longest  record.\nZero-length records are allowed.  Each record from\nthe data set is sent as a single item in a message."),(0,i.yg)("li",{parentName:"ol"},"If Record  Type  is Stream, then  the  data  set  has  no\ninternal structure which can be communicated with\nthis protocol.\nThese kind of data set might be, for example, a dump of\nmain  memory,  SECS-II  structured  data,  or  data  which\nhas  implicit  record  boundaries.    RecordLength  has  no\nmeaning for this kind of data set.  Items containing data\nfrom the data set have no relationship to the structure of\nthe data set."),(0,i.yg)("li",{parentName:"ol"},"17.2.3  Transactions  \u2014  The  basic  data  transfer  is\nperformed  by  the  OPEN,  READ,  and  CLOSE  transac-\ntions.  There is no explicit write transaction.  A write is\nperformed  indirectly  using  the  SEND  transaction.    A\nRESET  transaction  is  provided  to  allow  a  graceful\nrecovery  after  a  crash.    This  protocol  describes  the\ntransactions over the communications channel only.  No\nassumption  is  made  about  the  implementation  of  the\ntransactions.    For  example,  the  OPEN  transaction  on  a\ndata   set   which   is   stored   on   a   disk   file   does   not\nnecessarily cause the sending system to open the file."),(0,i.yg)("li",{parentName:"ol"},"17.2.3.1  The  OPEN,  READ,  and  CLOSE  transac-\ntions are initiated by the receiving system.  The SEND\ntransaction  is  initiated  by  the  sending  system.    The\nRESET  transaction  is  initiated  by  either  system.    The\nusual  transaction  timer  operates  between  the  primary\nand secondary messages of each transaction.  The time\nbetween  transactions,  especially  between  READ  trans-\nactions, is application-specific so no additional timer is\ndefined."),(0,i.yg)("li",{parentName:"ol"},"17.2.3.2  Internally,  the  protocol  uses  a  Handle  to\nkeep track of multiple open data sets, and a Checkpoint\nwhich   aids   in   error   recovery.      A   value   called\nReadLength is used to negotiate the amount of data sent\nat one time."),(0,i.yg)("li",{parentName:"ol"},"17.2.4  Handle    \u2014    Between    the    sending    and\nreceiving systems, more than one data set may be open\nat  a  time,  or  one  data  set  may  be  opened  many  times.\nThe  Handle  is  a  short  name  used  to  keep  track  of  the\nstate  of  a  particular  data  set  and  instance  of  OPEN\nbetween the sending and receiving systems (see Figure\n11).    This  Handle may  be  thought  of  as  a  name  for  a\nsingle application level connection from the sending to\nthe  receiving  system.    Its  value  is  assigned  in  the\nprimary message of the OPEN transaction."),(0,i.yg)("li",{parentName:"ol"},"17.2.4.1  The value used for the Handle must not be\nused  in  another  OPEN  by  the  receiving  system  to  the\nsame sending system until it is used in a CLOSE to that\nsending  system,  or  the  RESET  transaction  is  sent  by\neither  system.    For  example,  assume  a  host  system\nopens a data set on equipment 255 using Handle 1.  The\nhost  may  not  issue  another  OPEN  to  equipment  255\nusing Handle  1  until  it  closes  1  on  255.    However,  the\nhost  may  use  Handle  1  to  open  a  data  set  on  another\npiece  of  equipment,  and  equipment  255  may  use  Han-\ndle 1 to open a data set on the host."),(0,i.yg)("li",{parentName:"ol"},"17.2.4.2  The  number  of  data  sets  which  may  be\nopen  at  one  time  and  the  number  of  times  one  data  set\nmay be opened is not specified by this standard.  Error\ncodes  are  defined  for  situations  where  the  limits  are\nexceeded.    It  must  be  possible  to  have  one  outstanding\ntransaction (i.e., a primary message for which there has\nnot been a reply) for each open Handle.  If the sending\nsystem receives a primary message for a Handle which\nalready  has  an  outstanding  transaction,  then  the  error\ncode for Pending Transaction is returned in the second-\nary message (see Figure 11)."),(0,i.yg)("li",{parentName:"ol"},"17.2.5  Checkpoint  \u2014  The  response  to  each  READ\ntransaction  contains  the  data  and  a  new  Checkpoint\nvalue.    The  Checkpoint is  defined  by  and  has  meaning\nonly  for  the  sending  system.    Its  purpose  is  to  allow  a\ndata  transfer  to  be  restarted  from  the  point  of  the  last\ncomplete  message  after  some  communication  interrup-\ntion.    The  exact  nature  of  the  Checkpoint is  not  speci-\nfied.  It could be the byte index in the data set, a record\ncounter  (for  Discrete  records),  or  some  other  system-\ndependent value.\nNOTE 12:  Checkpoint  and  the  SECS-II  transaction  timer\ndefine  a  performance  requirement  for  the  sending  system.\nThe  sending  system  must  be  able  to  get  data  from  any\ncheckpoint  location  within  a  data  set  between  the  receipt  of\nthe OPEN primary message and the time for reply to the first\nREAD."),(0,i.yg)("li",{parentName:"ol"},"17.2.5.1  The  value  of  Checkpoint must  conform  to\nseveral rules:"),(0,i.yg)("li",{parentName:"ol"},"The Checkpoint value is exactly four bytes long.")),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 169\n2. The beginning of the data set has Checkpoint value\nwith all bits reset.\n3. A Checkpoint with all bits set is illegal.\n4. A   Checkpoint   supplied   by   the   sending   system\nwhich  does  not  have  all  bits  set  is  usable  in  an\nOPEN transaction to restart a data transfer without\nany lost data or duplicated data.\n10. 17.2.5.2  The  receiving  system  defines  the  initial\nCheckpoint in the primary message of the OPEN trans-\naction.  The sending system returns the next Checkpoint\nin the response to each READ.\n10. 17.2.6  Read  Length  \u2014  The  Read  Length  must  be\nsupplied  by  the  receiving  system  with  each  READ\ntransaction.    It  specifies  the  maximum  number  of  data\nbytes  which  that  system  is  prepared  to  process  at  one\ntime.  The sending system may supply less if it has lim-\nited resources.  The sending system may supply more if\nReadLength is zero, or is smaller than RecordLength.\n10. 17.2.7  Reading   a   Data   Set   \u2014   The   basic   data\ntransfer  is  initiated  with  the  OPEN  transaction  and\ncompleted with the CLOSE transaction.  Information is\nsent  from  the  sending  to  the  receiving  systems  by  a\nseries of READ transactions.\n10. 17.2.8  OPEN  Transaction  \u2014  The  receiving  system\nsends a primary message containing the DataSet Name\nof  the  desired  data  set,  the  Handle to  be  used,  and  the\nCheckpoint of   the   initial   READ   transaction.      The\nresponse  from  the  sending  system  is  a  secondary  mes-\nsage   with   a   return   code   and   the   RecordType and\nRecordLength of the data set.  If the return code is one\nof the error codes, then no data set was opened and the\nvalues of RecordType and RecordLength are undefined.\nIf   the   RecordType is Stream, then   the   value   of\nRecordLength is  undefined.    Notice  that  the  undefined\nitems will still appear in the secondary message.\n10. 17.2.8.1  The  return  code  in  the  secondary  message\nis one of the following:\nOK.\nERROR: Unknown Data Set ID.\nERROR: Try later (i.e., the data set is in use).\nERROR: Too many open data sets.\nERROR: Data set open too many times.\nERROR: Handle in use.\nERROR: Pending Transaction.\n10. 17.2.9  The  READ  Transaction  \u2014  The  receiving\nsystem  sends  a  primary  message  which  contains  the\nHandle,  and  the  ReadLength.    The  sending  system\nresponds  with  a  secondary  message  which  has  a  return\ncode, the next Checkpoint, and zero or more items with\ndata.    At  least  one  data  item  must  be  supplied  unless\nthere is an error.  The return codes are:\nOK.\nERROR: End of Data.\nERROR: No open Data Set (i.e., incorrect Handle).\nERROR: Cannot continue (i.e., a disk read error on the\nsending system).\nERROR: Pending Transaction.\n10. 17.2.9.1  Any  READ  transaction  which  follows  a\nREAD   which   returned   an   error,   except   \u201cPending\nTransaction,\u201d  will  generate  the  same  error.    The  value\nof Checkpoint must be illegal (i.e., all bits must be set)\nwhen  the  \u201cEnd  of  Data,\u201d  \u201cNo  open  Data  Set,\u201d  or\n\u201cPending  Transaction\u201d  error  is  returned.    The  value  of\nCheckpoint error  must  be  a  value  from  which  recovery\nmay  be  attempted  without  duplicating  data  when  the\n\u201cCannot continue\u201d error is returned.  Recovery may be\nattempted  by  issuing  a  CLOSE,  followed  by  an  OPEN\nwith  the  last  value  of  Checkpoint,  and  then  another\nREAD.\n10. 17.2.9.2  Each  secondary  message  for  the  READ\ntransaction  must  contain  a  whole  number  of  Discrete\nrecords.  A record may be sent as an ASCII or a binary\nitem.    Stream data  sets  are  broken  into  pieces  by  the\nREAD  transaction  without  regard  to  internal  structure.\nEach piece would be sent as a single binary item.  The\nnumber  of  items  which  contain  data  depends  on  the\nRecordType,  Record  Length,  and Read  Length.    The\nalgorithm  is  designed  so  that  the  maximum  length  of\nthe  secondary  message  is  deterministic.    It  gives  the\nreceiving  system  the  ability  to  control  the  amount  of\nresources  (such  as  SECS-I  buffers)  which  it  must  allo-\ncate.    The  sending  system  may  send  less  data  than  the\nmaximum if it has limited resources.  The performance\n(i.e.,  the  packing  of  records  into  a  message  of  some\nmaximum size) should be very good for the case where\nrecords  are  all  nearly  the  maximum  length.    This  is\nassumed to be the usual case.  The efficiency in patho-\nlogical  cases  (e.g.,  many  short  records)  will  not  be\ngood,  but  the  algorithm  is  robust  enough  to  accommo-\ndate this without exceeding the maximum message size.\nNOTE 13:  If the RecordType is Stream, then there is exactly\none  item  with  a  binary  format  whose  length  is  not  more  than\nReadLength.      If   the   RecordType is Discrete, then   the\nmaximum  number  of  items,  MaxItems,  is  calculated  by  the\nformula:\n\u239f\n\u239f\n\u23a0\n\u239e\n\u239c\n\u239c\n\u239d\n\u239b\n\u239f\n\u239f\n\u23a0\n\u239e\n\u239c\n\u239c\n\u239d"),(0,i.yg)("h1",{id:""},"\u239b"),(0,i.yg)("p",null,"thRecordLeng\nReadLength\nint,1maxMaxItems"),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 170\n10. 17.2.9.3  The size of the secondary message may be\nless because of limited resources in the sending system.\n10. 17.2.9.4  For data sets with Discrete records, the for-\nmat  of  each  item  is  either  ASCII  (format  20)  or  binary\n(format 10).  There is no requirement that all records be\nin  the  same  format,  but  mixed  record  formats  are  not\nencouraged.  Items with ASCII format should have only\ndata  characters.    Characters  which  the  sending  system\nuses  for  control  information  (e.g.,  newline  for  a  record\nterminator) should not appear.  If an application finds it\nnecessary to include these characters, then format 10, or\nStream should be used.\n10. 17.2.10  CLOSE Transaction \u2014 This transaction ter-\nminates  a  data  transfer  and  frees  the  Handle  for  future\nuse.  The primary message is sent by the receiving sys-\ntem and contains only the Handle.  The sending system\nresponds  with  a  secondary  message  which  has  a  return\ncode.\n10. 17.2.10.1  The return code is one of the following:\nOK.\nERROR: No open Data Set (i.e., incorrect Handle).\nERROR: Pending Transaction.\n10. 17.2.11  Sending a Data Set \u2014 Writing a data set is\nperformed by requesting that the receiving system read\nit.    The  sending  system  initiates  the  SEND  transaction\nto request that a data set be read.  The receiving system\nis expected to perform the OPEN, READ, and CLOSE\ntransactions  to  transfer  the  data  set  if  it  accepts  the\nrequest.    The  time  between  the  secondary  message  of\nthe  SEND  and  the  primary  message  of  the  OPEN\ndepends on the application.\n10. 17.2.12  The   SEND   Transaction   \u2014   The   primary\nmessage  sent  from  the  sending  system  to  the  receiving\nsystem contains the Data Set Name.\n10. 17.2.12.1  The secondary message contains the Data\nSet Name and a return code which is one of the follow-\ning:\nOK.\nERROR: Unknown Data Set Name.\nERROR: Try later (i.e., the system is busy).\n10. 17.2.13  Error  Recovery  \u2014  The  receiving  system\nmay crash while a data set is open but no READ trans-\naction is pending.  The sending system will not be able\nto  tell  that  this  has  happened  because  there  is  no  time-\nout  value  defined  between  READ  transactions.    When\nthe  receiving  system  is  restarted  it  may  have  forgotten\nwhich  data  sets  were  open.    States  in  the  two  systems\nare now inconsistent.\n10. 17.2.14  RESET Transaction \u2014 The RESET transac-\ntion  offers  a  way  to  resynchronize  the  two  systems.\nWhen  one  system  issues  the  primary  message  of  the\nRESET transaction, it is informing the other system that\nany  data  sets  which  may  have  been  open  are  to  be\nclosed.  This applies to all data sets open between both\nsystems.    It  is  not  necessary  to  issue  CLOSE  transac-\ntions  for  each  individual  data  set  because  the  RESET\ntransaction is a global close.\n10. 17.2.15  Any equipment which uses Stream 13 must\nissue the RESET transaction as part of its initialization\nor  bootstrap  procedure.    A  host  system  must  issue  a\nRESET to equipment which uses Stream 13 during the\ninitialization for that equipment.\n10. 17.2.16  SECS-II  Protocol  Definition  \u2014\nFigure  11\nshows the state diagram for the sending system while a\ndata set is being transferred.  Each circle shows a possi-\nble  state  of  the  sending  system.    The  names  of  these\nstates  are  for  reference  only.    They  are  not  meant  to\nsuggest  an  implementation.    The  arrows  show  transi-\ntions  due  to  SECS-II  messages  received  or  sent  by  the\nsending system.\n10. 17.2.16.1  In  the  initial  state  (Idle)  handle  X  is  not\nopen.    The  states  marked  with  an  asterisk  are  those  in\nwhich  a  transaction  is  outstanding.    If  the  sending  sys-\ntem  receives  any  primary  message  from  the  receiving\nsystem  with  handle  X  during  the  time  it  is  in  these\nstates,  then  the  secondary  message  for  that  transaction\nwill  contain  the  \u201cPending  Transaction\u201d  error  code,  but\nthe   original   transaction   for   handle   X   will   not   be\naffected.    Some  states,  especially  the  error  states,  may\ntake zero time in some implementations.  In these cases,\nthe  \u201cPending  Transaction\u201d  error  code  would  not  be\nreturned from those states.\n10. 17.3  Formatted  Data  Sets  \u2014  Formatted  data  sets\nare  data  sets  transferred  in  a  standard  format.    Stream\n13  provides  a  method  for  transferring  data  sets  in  a\ntable  format.    A  table  has  both  attributes  and  content.\nThe attributes of the table provide information about the\ndata set as a whole, such as the date and time that it was\nlast  modified,  its  size,  etc.    The  content  of  the  table\nconsists  of  column  headers  and  rows.    A  row  is  an\nordered  list  of  table  elements.    A  column  refers  to  all\ntable  elements  at  a  specific  position  within  all  rows,\nwhere each column is identified by a corresponding text\nstring as a column header.  The table elements in the 1st\ncolumn position are used as an identifier for the row."),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 171\nStream,Function  Name (Mnemonic) Direction\nS13,F0  Abort Transaction (S13F0) S,H<->E\nDescription\nSame form as S1,F0.\nStructure"),(0,i.yg)("p",null,"Exception"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS13,F1  Send Data Set Send (DSSS) S,H<->E,reply\nDescription\nSent by the sending system to request that the other system read a dataset.\nStructure\nL,1"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"DSNAME\nException\nNone")),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS13,F2  Send Data Set Acknowledge (DSSA) S,H<->E\nDescription\nSent by the receiving system in response to Send Data Set Send."),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"DSNAME"),(0,i.yg)("li",{parentName:"ol"},"ACKC13\nStructure")),(0,i.yg)("p",null,"Exception\nThe possible ACKC13 codes for this message are:"),(0,i.yg)("p",null,"0 = O.K.\n1 = ERROR:Try later.\n2 = ERROR:Unknown Data Set Name."),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS13,F3  Open Data Set Request (DSOR) S,H<->E,reply\nDescription\nSent by the receiving system to open a data set for reading.\nStructure\nL,3"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"HANDLE"),(0,i.yg)("li",{parentName:"ol"},"DSNAME"),(0,i.yg)("li",{parentName:"ol"},"CKPNT\nException\nNone")),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 172\nStream,Function  Name (Mnemonic) Direction\nS13,F4  Open Data Set Data (DSOD) S,H<->E\nDescription\nSent by the sending system in response to Open Data Set Request.\nStructure\nL,5"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"HANDLE"),(0,i.yg)("li",{parentName:"ol"},"DSNAME"),(0,i.yg)("li",{parentName:"ol"},"ACKC13"),(0,i.yg)("li",{parentName:"ol"},"RTYPE"),(0,i.yg)("li",{parentName:"ol"},"RECLEN\nException\nThe possible ACKC13 codes for this message are:")),(0,i.yg)("p",null,"0 = O.K.\n1 = ERROR:Try later.\n2 = ERROR:Unknown Data Set Name.\n3 = ERROR:Illegal Checkpoint value.\n4 = ERROR:Too many open Data Sets.\n5 = ERROR:Data set open too many times.\n9 = ERROR:Handle in Use.\n10 = ERROR:Pending Transaction."),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS13,F5  Read Data Set Request (DSRR) S,H<->E,reply\nDescription\nSent by the receiving system to read data from an open data set.\nStructure\nL,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"HANDLE"),(0,i.yg)("li",{parentName:"ol"},"READLN\nException\nNone")),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 173\nStream,Function  Name (Mnemonic) Direction\nS13,F6  Read Data Set Data (DSRD) M,H<->E\nDescription\nSent by the sending system in response to Read Data Set Request.\nStructure\nL,4"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"HANDLE"),(0,i.yg)("li",{parentName:"ol"},"ACKC13"),(0,i.yg)("li",{parentName:"ol"},"CKPNT"),(0,i.yg)("li",{parentName:"ol"},"L,n"),(0,i.yg)("li",{parentName:"ol"},"FILDAT\n.\n.\nn. FILDAT\nException\nThe possible item formats, number of items (n), and length of each FILDAT item (|th) are given by the following table.\nMaxItems is defined in Section 10.17.10.2.")),(0,i.yg)("p",null,"RTYPE              0 (Stream)          1 (Discrete)\nItem Format        10 (binary)         10 (binary)\nor 20 (ASCII)\nMaximum n          1                   MaxItems\nMaximum n          1 (ACKC13 = 0)      1 (ACKC13 = 0)\n0(any error)        0(any error)\nMaximum |th        READLN              RECLEN\nMaximum |th        0                   0"),(0,i.yg)("p",null,"The possible ACKC13 codes for this message are:\n0 = O.K.\n6 = ERROR: No open Data Set\n7 = ERROR: Cannot Continue\n8 = ERROR: End of Data\n10 = ERROR: Pending Transaction"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS13,F7  Close Data Set Send (DSCS) S,H<->E,reply\nDescription\nSent by the receiving system to close an open data set.\nStructure\nL,1"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"HANDLE\nException\nNone")),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 174\nStream,Function  Name (Mnemonic) Direction\nS13,F8  Close Data Set Acknowledge (DSCA) S,H<->E\nDescription\nSent by the sending system in response to Close Data Set Send (DSCS).\nStructure\nL,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"HANDLE"),(0,i.yg)("li",{parentName:"ol"},"ACKC13")),(0,i.yg)("p",null,"The possible ACKC13 codes for this message are:\n0 = O.K.\n6 = ERROR:No open Data Set.\n10 = ERROR:Pending Transaction.\nException\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS13,F9  Reset Data Set Send (DSRS) S,H<->E,reply\nDescription\nSent by either system to close all open data sets.\nStructure\nHeader only\nException\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS13,F10  Reset Data Set Acknowledge (DSRA) S,H<->E\nDescription\nSent in response to Reset Data Set Send.\nStructure\nHeader only\nException\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS13,F11  Data Set Object Multi-Block Inquire (DSOMGI) S,H<->E,reply\nDescription\nThis message requests permission to send a multi-block data set.  If the receiving system does not grant permission in the reply,\nthe multi-block data set may not be sent.  OBJSPEC is used to identify the data set object type and identifier and may include a\ndestination.  DATALENGTH represents the total message length, not the length of the data set.\nStructure\nL,3"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"DATAID"),(0,i.yg)("li",{parentName:"ol"},"OBJSPEC"),(0,i.yg)("li",{parentName:"ol"},"DATALENGTH\nException\nNone")),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 175\nStream,Function  Name (Mnemonic) Direction\nS13,F12  Data Set Object Multi-Block Grant (DSOMBG) S,H<->E\nDescription\nThis message grants or denies permission to send a multi-block data set.\nStructure\nGRANT\nException\nNone"),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS13,F13  Table Data Send (TDS) M,H<->E,reply\nDescription\nThis message allows the host and the equipment to exchange predefined datasets in a tabular format.  The first element of every\nrow is used to reference that row for all other elements.  If S13,F13 is Multi-block, it must be preceded by the S13,F11/S13,F12\nInquire/Grant transaction.\nStructure\nL,8"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"DATAID")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJSPEC")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"TBLTYP")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"TBLID")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"TBLCMD")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,n                          # of table attributes")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\n1"))),(0,i.yg)("p",null,".\n.\nn. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\nn")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\nn")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,c                          # of column definitions")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"COLHDR\n1\n1st column element description\n.\n.\nc. COLHDR\nc\ncth column element description")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,r                          # of row definitions")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,c\n1"))),(0,i.yg)("h1",{id:"of-entries-per-definition"},"of entries per definition"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"TBLELT\n11\n1st table element, 1st row\n.\nm. TBLELT\n1c1\nmth table element, 1st row\n.\n.\nr. L,c\nr\nrth       row       definition"),(0,i.yg)("li",{parentName:"ol"},"TBLELT\nr1\n1st table element, rth row\n.\nm. TBLELT\nrcr\nmth table element, rth row\nException\nIf OBJSPEC is a zero-length item, then the owner of the table is the receiver of the message.  If r is zero, any existing table\ndefinition of the given type and id is to be deleted.  Otherwise, c\n1\nmay not be zero, and the value of c\n1\nshall be less than or equal\nto the value of c.")),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 176\nStream,Function  Name (Mnemonic) Direction\nS13,F14  Table Data Acknowledge (TDA) S,H<->E\nDescription\nThis message is used to acknowledge the receipt of a table and to indicate any errors.\nStructure\nL,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"TBLACK")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,p")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\n1"))),(0,i.yg)("p",null,".\n.\np. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\np")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\np"))),(0,i.yg)("p",null,"Exception\np = 0 if and only if TBLACK indicates no errors."),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS13,F15  Table Data Request (TDR) M,H<->E,reply\nDescription\nThis message allows the host or the equipment to request part or all of a specific table.  Either specific columns or specific rows\nmay be requested, but not both at the same time.  If S13,F15 is Multi-block, it must be preceded by the S13,F11/S13,F12\nInquire/Grant transaction.\nStructure\nL,7"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"DATAID"),(0,i.yg)("li",{parentName:"ol"},"OBJSPEC"),(0,i.yg)("li",{parentName:"ol"},"TBLTYP"),(0,i.yg)("li",{parentName:"ol"},"TBLID"),(0,i.yg)("li",{parentName:"ol"},"TBLCMD"),(0,i.yg)("li",{parentName:"ol"},"L,p                          # of column definitions"),(0,i.yg)("li",{parentName:"ol"},"COLHDR\n1\n1st column element description\n.\n.\np. COLHDR\np\npth column element description"),(0,i.yg)("li",{parentName:"ol"},"L,q"),(0,i.yg)("li",{parentName:"ol"},"TBLELT\n1\n1st       row       identifier\n.\n.\nq. TBLELT\nq")),(0,i.yg)("p",null,"Exception\nIf OBJSPEC is a zero-length item, then the owner of the table is the receiver of the message.  Either p or q, or both, must be zero.\nIf p = 0 and q = 0, all rows are requested; otherwise, only the specified columns, or the rows referenced by TBLELT, are\nrequested."),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 177\nStream,Function  Name (Mnemonic) Direction\nS13,F16  Table Data (TD) M,H<->E\nDescription\nThis message is used to return data from the requested table.\nStructure\nL,6"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"TBLTYP")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"TBLID")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,n                          # of table attributes")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\n1"))),(0,i.yg)("p",null,".\n.\nn. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\nn")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\nn")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,c                          # of column definitions")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"COLHDR\n1\n1st column element description\n.\n.\nc. COLHDR\nc\ncth column element description")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,r                          # of row definitions")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,c\n1"))),(0,i.yg)("h1",{id:"of-entries-per-definition-1"},"of entries per definition"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"TBLELT\n11\n1st table element, 1st row\n.\n.\nm. TBLELT\n1c1\nlast table element, 1st row\n.\n.\nr. L,c\nr\nrth       row       definition")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"TBLELT\nr1\n1st table element, rth row\n.\n.\nm. TBLELT\nrcr\nmth table element, rth row")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"TBLACK")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,p")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\n11")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\n12"))),(0,i.yg)("p",null,".\np. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\np1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\np2"))),(0,i.yg)("p",null,"Exception\np = 0 if, and only if, TBLACK indicates no errors.  The length c\n11\nof a table row may not exceed the value of c."),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 178"),(0,i.yg)("p",null,"Figure 11\nThe Sending System\u2019s State Diagram During a Data Set Transfer\nAn Asterisk (*) marks the states where a primary message which uses handle X would result in a secondary\nmessage with the error code for \u201cPending Transaction.\u201d"),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 179\n10. 18  Stream 14 Object Services \u23af The functions in this stream are used for generic functions concerning objects,\nincluding obtaining information about objects and setting values for an object."),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS14,F0  Abort Transaction (S14F0) S,H<->E\nDescription\nSame form as S1,F0.\nStructure"),(0,i.yg)("p",null,"Exception"),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 180\nStream,Function  Name (Mnemonic) Direction\nS14,F1  GetAttr Request (GAR) S,H<->E,reply\nDescription\nThis message is used to request a set of specified attributes for one or more objects.  It consists of an \u201cobject specifier\u201d for the\nowner of the target objects (the objects of interest), the target object type, a list of identifiers of the target objects, a filter (a list of\nqualifying relationships) that limits the target objects of interest to those that meet all of the qualifications in and the specific\nattributes whose values are requested.\nThe object specifier provides a specification of the owner of the target object(s).  It contains a sequence of hierarchical object\nrelationships.  Each element of the object specifier identifies a specific object instance that is the superior of the following object\ninstance in the sequence.  The last object instance in the sequence is in a hierarchical relationship to the target objects.  The target\nobject type designates the type of the target object, and the list of object identifiers indicates the specific instance of that type that\nare of interest.  The target type may be omitted only if object identifiers are unique across all object types and the list of\nidentifiers is not empty.\nThe object filter is an optional list of qualifications, each of which provides a condition to be applied to the object instances of\ninterest.  Each qualification objects of interest are those that meet all of the specified qualifications.\nThe attribute relationship quantifier is a logical binary relationship ATTRRELN\ni\nthat the specified qualifying value\nATTRDATA\ni\nhas to the corresponding attribute of each instance of the desired object type(s).  The objects that are to be\nqualified with this filter have an attribute value V\ni\nsuch that the statement \u201cATTRDATA\ni\nATTRRELN\ni\nV\ni\n\u201d is TRUE.  If\nATTRRELN\ni\nis omitted, the relationship of equality is intended.\nFor ASCII attribute values ATTRDATA\ni\n, the characters for question mark \u201c?\u201d and asterisk \u201c",(0,i.yg)("em",{parentName:"p"},"\u201d are used as \u201cwild characters\u201d to\nprovide filtering for certain object types.  The character \u201c?\u201d may be used in any attribute or key attribute value with an ASCII\nformat to represent \u201cany single character\u201d and may be repeated.  The asterisk character \u201c"),"\u201d may be similarly used to represent a\nvariable-length string, including a null string.  The string \u201c",(0,i.yg)("em",{parentName:"p"},"x\u201d represents a string of any length that ends in \u201cx\u201d, the string \u201cx"),"\u201d\nrepresents any string that begins with \u201cx\u201d, and the string \u201c*\u201d represents any string of any non-zero\nlength.  The comparison for\ntext characters is case insensitive.\nEquipment is not required to support wild characters in particular, or attribute filters in general.\nStructure\nL,5"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"OBJSPEC"),(0,i.yg)("li",{parentName:"ol"},"OBJTYPE"),(0,i.yg)("li",{parentName:"ol"},"L,i                          i = identifiers of the object instances requested"),(0,i.yg)("li",{parentName:"ol"},"OBJID\n1")),(0,i.yg)("p",null,".\n.\ni. OBJID\ni"),(0,i.yg)("ol",{start:4},(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,q                          q = # object qualifiers to match")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,3")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRRELN\n1"))),(0,i.yg)("p",null,".\n.\nq. L,3"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\nq")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\nq")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRRELN\nq")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,a                          a = # attributes requested")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1"))),(0,i.yg)("p",null,".\n.\na. ATTRID\na"),(0,i.yg)("p",null,"Exception\nIf OBJSPEC is a zero-length item, no object specifier is provided.  If i = 0,only the filter is to be applied.  If q = 0, no filter is\nspecified.  If both i and q = 0, information for all instances of the objects are requested.  If a = 0, all attributes are requested."),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 181\nStream,Function  Name (Mnemonic) Direction\nS14,F2  GetAttr Data (GAD) M,H<->E\nDescription\nThis message is used to transfer the set of requested attributes for the specified object(s).  The order of attributes is retained from\nthe primary message.\nStructure\nL,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,n                          n = number of objects")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJID\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,a                a = number of attributes")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\n1"))),(0,i.yg)("p",null,".\n.\na. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\na")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\na"))),(0,i.yg)("p",null,".\n.\nn. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJID\nn")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,b                b = number of attributes")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\n1"))),(0,i.yg)("p",null,".\n.\nb. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\nb")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\nb")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJACK")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,p                      p = number of errors reported")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\n1"))),(0,i.yg)("p",null,".\n.\np. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\np")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\np"))),(0,i.yg)("p",null,"Exception\nIf OBJSPEC is a zero-length item, no object specifier is provided.  If n = 0, no objects matched the specified filter.  If p = 0, no\nerrors were detected."),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 182\nStream,Function  Name (Mnemonic) Direction\nS14,F3  SetAttr Request (SAR) S,H<->E, reply\nDescription\nThis message is used to request that a given set of attributes be assigned specified values for all objects of the specified type and\nexactly matching the specified attribute requirements.  Certain attributes may not be changed through the interface.  For a\ndescription of filters, see S14,F1.\nStructure\nL,4"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"OBJSPEC"),(0,i.yg)("li",{parentName:"ol"},"OBJTYPE"),(0,i.yg)("li",{parentName:"ol"},"L,i                          i = number of object instances requested"),(0,i.yg)("li",{parentName:"ol"},"OBJID\n1")),(0,i.yg)("p",null,".\n.\ni. OBJID\ni"),(0,i.yg)("ol",{start:4},(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,n                          n = # attribute settings")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\n1"))),(0,i.yg)("p",null,".\n.\nn. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\nn")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\nn"))),(0,i.yg)("p",null,"Exception\nIf OBJSPEC is a zero-length item, no object specifier is provided."),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 183\nStream,Function  Name (Mnemonic) Direction\nS14,F4  SetAttr Data (SAD) M,H<->E\nDescription\nThis message is used to acknowledge that the attributes for the specified objects have been set as requested or to indicate an error\nfor each attribute value that was not set as requested.  The order of attributes is retained from the primary message.\nStructure\nL,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,i                          i = number of objects requested")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJID\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,n                n = number of attributes set.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\n1"))),(0,i.yg)("p",null,".\n.\nn. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\nn")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\nn"))),(0,i.yg)("p",null,".\n.\ni. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJID\ni")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,n")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\n1"))),(0,i.yg)("p",null,".\n.\nn. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\nn")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\nn")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJACK")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,p                      p = number of errors reported")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\n1"))),(0,i.yg)("p",null,".\n.\np. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\np")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\np"))),(0,i.yg)("p",null,"Exception\nIf n = 0 for any object, the object was not found.  If p = 0, no errors were detected."),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 184\nStream,Function  Name (Mnemonic) Direction\nS14,F5  GetType Request (GTR) S,H<->E,reply\nDescription\nThis message is used to request the types of objects owned by an object.  This is an operation performed on an object type rather\nthan on object instances.  Wild characters \u201c?\u201d and \u201c*\u201d may be used as a filter for object types.  Equipment is not required to\nsupport wild characters.\nStructure\nOBJSPEC\nException\nIf OBJSPEC is a zero-length item, no object specifier is provided."),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS14,F6  GetType Data (GTD)\nDescription"),(0,i.yg)("p",null,"Structure\nL,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"L,n                          n = number of object types"),(0,i.yg)("li",{parentName:"ol"},"OBJTYP\n1")),(0,i.yg)("p",null,".\n.\nn. OBJTYP\nn"),(0,i.yg)("ol",{start:2},(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJACK")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,p                      p = number of errors reported")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\n1"))),(0,i.yg)("p",null,".\n.\np. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\np")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\np"))),(0,i.yg)("p",null,"Exception\nIf n = 0, there are no owned object types.  If p = 0, no errors were detected."),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS14,F7  GetAttrName Request (GANR) S,H<->E,reply\nDescription\nThis message is used to request the names of the attributes of specified types of owned objects.  This is an operation performed\non an object type rather than on object instances.  Wild characters \u201c?\u201d and \u201c*\u201d may be used as a filter for object types.\nEquipment is not required to support wild characters.\nStructure\nL,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"OBJSPEC"),(0,i.yg)("li",{parentName:"ol"},"L,n                          n = # of object types"),(0,i.yg)("li",{parentName:"ol"},"OBJTYP\n1")),(0,i.yg)("p",null,".\n.\nn. OBJTYP\nn"),(0,i.yg)("p",null,"Exception\nIf OBJSPEC is a zero-length item, no object specifier is provided."),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 185\nStream,Function  Name (Mnemonic) Direction\nS14,F8  GetAttrName Data (GAND) M,H<->E\nDescription\nThis message contains the names of the attributes of the requested objects.\nStructure\nL,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,n                          n = number of object types")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJTYP\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,a                a = number of attributes")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1"))),(0,i.yg)("p",null,".\n.\na. ATTRID\na"),(0,i.yg)("p",null,".\n.\nn. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJTYP\nn")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,b                b = number of attributes")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1"))),(0,i.yg)("p",null,".\n.\nb. ATTRID\nb"),(0,i.yg)("ol",{start:2},(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJACK")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,p                      p = number of errors reported")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\n1"))),(0,i.yg)("p",null,".\n.\np. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\np")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\np"))),(0,i.yg)("p",null,"Exception\nIf OBJSPEC is a zero-length item, no objects matched the specified filter.  If p = 0, no errors were detected."),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 186\nStream,Function  Name (Mnemonic) Direction\nS14,F9  Create Object Request (COR) M,H<->E,reply\nDescription\nThis message is used to request an object owner to create an object instance.  OBJSPEC specifies the object owner.\nStructure\nL,3"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJSPEC")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJTYPE")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,a                          a = # attributes requested")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\n1"))),(0,i.yg)("p",null,".\n.\na. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\na")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\na"))),(0,i.yg)("p",null,"Exception\nIf OBJSPEC is a null-length item, no object specifier is provided.  If a = 0, no specific attribute settings are requested for the new\nobject."),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS14,F10  Create Object Acknowledge (CAO) M,H<->E\nDescription\nThis message is used to acknowledge the success or failure of creating the new object specified.  If successful, OBJSPEC is the\nobject specifier of the new object.  The list of attributes returned is dependent upon the type of object specified.\nStructure\nL,3"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJSPEC")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,b                          b = number of attributes returned")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\n1"))),(0,i.yg)("p",null,".\n.\nb. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\nb")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\nb")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJACK")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,p                      p = number of errors reported")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\n1"))),(0,i.yg)("p",null,".\n.\np. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\np")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\np"))),(0,i.yg)("p",null,"Exception\nIf OBJSPEC is a null-length item, no object was created.  If b = 0, no attributes of the new object are returned.  If p = 0, no errors\nwere detected."),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 187\nStream,Function  Name (Mnemonic) Direction\nS14,F11  Delete Object Request S,H<->E,reply\nDescription\nThis message is used to request that the object specified in OBJSPEC be deleted.  The list of attribute settings depends upon the\ntype of object to be deleted.\nStructure\nL,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJSPEC")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,a                          n = # attribute settings")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\n1"))),(0,i.yg)("p",null,".\n.\na. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\na")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\na"))),(0,i.yg)("p",null,"Exception\nIf n = 0, no attribute settings are provided."),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS14,F12  Delete Object Acknowledge (DOA) M,H<->E\nDescription\nThis message is used to acknowledge the success or failure of deleting the object specified.  The list of attributes returned is\ndependent upon the type of object to be deleted.\nStructure\nL,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,b                          n = number of attributes returned")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\n1"))),(0,i.yg)("p",null,".\n.\nb. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\nb")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\nb")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJACK")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,p                      p = number of errors reported")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\n1"))),(0,i.yg)("p",null,".\n.\np. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\np")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\np"))),(0,i.yg)("p",null,"Exception\nIf n = 0, no attribute values are returned.  If p = 0, no errors were detected."),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 188\nStream,Function  Name (Mnemonic) Direction\nS14,F13  Object Attach Request (OAR) M,H<->E,reply\nDescription\nThis message is sent by a supervisor to request the object specified in OBJSPEC to attach or reattach itself to the requestor.\nStructure\nL,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJSPEC")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,a                          a = # attribute settings")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\n1"))),(0,i.yg)("p",null,".\n.\na. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\na")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\na"))),(0,i.yg)("p",null,"Exception\nIf a = 0, no attribute settings are provided."),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS14,F14  Object Attach Acknowledge (OAA) M,H<->E\nDescription\nThis message is used to acknowledge the success or failure of the requested attachment.  If successful, a non-zero token shall be\nreturned for the supervisor\u2019s use in subsequent communications with the attached object.\nStructure\nL,3"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJTOKEN")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,b                          b = number of attributes")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\n1"))),(0,i.yg)("p",null,".\n.\nb. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\nb")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\nb")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJACK")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,p                      p = number of errors reported")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\n1"))),(0,i.yg)("p",null,".\n.\np. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\np")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\np"))),(0,i.yg)("p",null,"Exception\nOBJTOKEN is zero if and only if p is non-zero.  If b = 0, no attribute values are returned.  If p = 0, no errors were detected."),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 189\nStream,Function  Name (Mnemonic) Direction\nS14,F15  Attached Object Action Request (AOAR) M,H<->E,reply\nDescription\nThis message is used by a supervisor (only) to request an attached object to perform an action.\nStructure\nL,4"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJSPEC")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJCMD")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJTOKEN")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,a                          a = # attribute settings")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\n1"))),(0,i.yg)("p",null,".\n.\na. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\na")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\na"))),(0,i.yg)("p",null,"Exception\nIf a = 0, no attribute settings are provided."),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS14,F16  Attached Object Action Acknowledge (AOAA) M,H<->E\nDescription\nThis message is used to acknowledge the success or failure of an  action requested by a supervisor.\nStructure\nL,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,b                          b = number of attributes")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\n1"))),(0,i.yg)("p",null,".\n.\nb. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\nb")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\nb")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJACK")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,p                      p = number of errors reported")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\n1"))),(0,i.yg)("p",null,".\n.\np. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\np")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\np"))),(0,i.yg)("p",null,"Exception\nIf p = 0, no errors were detected."),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 190\nStream,Function  Name (Mnemonic) Direction\nS14,F17  Supervised Object Action Request (SOAR) S,H<->E,reply\nDescription\nThis message is used to request a supervisor to have a supervised attached object perform an action.  OBJSPEC specifies the\nsupervisor, and TARGETSPEC specifies the attached object.\nStructure\nL,4"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJSPEC")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJCMD")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"TARGETSPEC")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,a                          a = number of attribute settings")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\n1"))),(0,i.yg)("p",null,".\n.\na. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\na")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\na"))),(0,i.yg)("p",null,"Exception\nIf a = 0, no attribute settings are provided."),(0,i.yg)("p",null,"Stream,Function  Name (Mnemonic) Direction\nS14,F18  Supervised Object Action Acknowledge (SOAA) M,H<->E\nDescription\nThis message is used to acknowledge the success or failure of an action requested of a supervisor.\nStructure\nL,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,b                          b = number of attributes")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\n1"))),(0,i.yg)("p",null,".\n.\nb. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\nb")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\nb")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"OBJACK")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,p                      p = number of errors reported")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\n1"))),(0,i.yg)("p",null,".\n.\np. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRCODE\np")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ERRTEXT\np"))),(0,i.yg)("p",null,"Exception\nIf b = 0, no attributes are returned.  If p = 0, no errors were detected."),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 191\nStream,Function  Name (Mnemonic) Direction\nS14,F19  Generic Service Request (GSR) M,H->E,reply\nDescription\nThe host requests an object to perform the specified service with its associated parameters.  If multi-block, it shall be preceded\nby the S14F23/F24 Multi-Block Inquire/Grant transaction.  DATAID is given uniquely to each message.  OPID is uniquely\nspecified to identify delayed completion information for time consuming service.  OPID could be zero if and only if the service\ncannot take a long time.\nStructure\nL,5"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"DATAID"),(0,i.yg)("li",{parentName:"ol"},"OPID"),(0,i.yg)("li",{parentName:"ol"},"OBJSPEC"),(0,i.yg)("li",{parentName:"ol"},"SVCNAME"),(0,i.yg)("li",{parentName:"ol"},"L,m                          # of parameter groups"),(0,i.yg)("li",{parentName:"ol"},"L,2"),(0,i.yg)("li",{parentName:"ol"},"SPNAME\n1\nservice parameter 1 name"),(0,i.yg)("li",{parentName:"ol"},"SPVAL\n1\nservice parameter 1 value"),(0,i.yg)("li",{parentName:"ol"},"L,2"),(0,i.yg)("li",{parentName:"ol"},"SPNAME\n2\nservice parameter 2 name"),(0,i.yg)("li",{parentName:"ol"},"SPVAL\n2\nservice parameter 2 value\n.\n.\nm. L,2"),(0,i.yg)("li",{parentName:"ol"},"SPNAME\nm\nservice parameter m name"),(0,i.yg)("li",{parentName:"ol"},"SPVAL\nm\nservice parameter m value")),(0,i.yg)("p",null,"If a specific value of SPNAME is defined to have a SPVAL defined as a LIST, it shall\nalways be a LIST.  If the SPVAL that is associated to that specific value of SPNAME is\ndefined to be anything other than LIST, it will result in a format error.\nException\nA zero length list, m = 0, indicates that no parameter groups are sent with the service request.  OBJSPEC can be a null length\nitem if no object provide the services is defined in the standards which are referred to and it is assumed that \u201cEquipment\u201d is\ndelegated and handled as if it is an object.\nNotes:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"If some service parameters are attributes of the specified object, service parameter name-value pair, that is SPNAME and\nSPVAL, is actually attribute id-data pair, that is ATTRID and ATTRDATA.  An example of parameter part in the message\nformat could be interpreted as below.")),(0,i.yg)("p",null,"L,m"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"SPNAME\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"SPVAL\n1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2\n.\n.\nk. L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRID\nk")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"ATTRDATA\nk"))),(0,i.yg)("p",null,".\n.\nm. ..."),(0,i.yg)("ol",{start:2},(0,i.yg)("li",{parentName:"ol"},"If SPVAL is a LIST, the items that make up that list shall take on one of the following forms: (1) a list of items with an\nidentical format, (2) a LIST of SPNAME, SPVAL pairs, as illustrated below.  When SPVAL is actually ATTRDATA, even if it\nis a LIST, it or its parts are not required to expand into lower level items if their names have not been formally named in the\ncorresponding SEMI standard.")),(0,i.yg)("p",null,"A)  L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"SPNAME\na")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,m"))),(0,i.yg)("p",null,"SEMI E5-1104 \xa9 SEMI 1982, 2004 192"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"SPVAL\na1")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"SPVAL\na2"))),(0,i.yg)("p",null,".\n.\nm. SPVAL\nam"),(0,i.yg)("p",null,"B)  L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"SPNAME\nb")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L, n")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"L,2")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"SPNAME\nbl")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"SPVAL\nbl"))),(0,i.yg)("p",null,".\n.\nn. L,2"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"SPNANE\nbn")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"SPVAL\nbn"))))}c.isMDXComponent=!0}}]);