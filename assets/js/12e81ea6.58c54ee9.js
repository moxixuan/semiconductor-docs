"use strict";(globalThis.webpackChunksemiconductor_docs=globalThis.webpackChunksemiconductor_docs||[]).push([[7346],{6346(e,t,i){i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>s,metadata:()=>l,toc:()=>h});var a=i(8168),n=(i(6540),i(5680)),o=i(2073),r=i(9109);const s={title:"E95-1101 - \xa9 SEMI 2000, 20016...",description:"SEMI\u6807\u51c6\u6587\u6863",sidebar_label:"E95-1101 - \xa9 SEMI 2000, 20016...",sidebar_position:54,tags:["SEMI","Standard"],custom_props:{source_type:"pdf",source_file:"semi-chapter-054.pdf",chapter:54,page_count:50}},c=void 0,l={unversionedId:"standards/semi/semi-chapter-054",id:"standards/semi/semi-chapter-054",title:"E95-1101 - \xa9 SEMI 2000, 20016...",description:"SEMI\u6807\u51c6\u6587\u6863",source:"@site/docs/standards/semi/semi-chapter-054.md",sourceDirName:"standards/semi",slug:"/standards/semi/semi-chapter-054",permalink:"/semiconductor-docs/docs/standards/semi/semi-chapter-054",draft:!1,editUrl:"https://github.com/your-org/semiconductor-docs/tree/main/docs/standards/semi/semi-chapter-054.md",tags:[{label:"SEMI",permalink:"/semiconductor-docs/docs/tags/semi"},{label:"Standard",permalink:"/semiconductor-docs/docs/tags/standard"}],version:"current",sidebarPosition:54,frontMatter:{title:"E95-1101 - \xa9 SEMI 2000, 20016...",description:"SEMI\u6807\u51c6\u6587\u6863",sidebar_label:"E95-1101 - \xa9 SEMI 2000, 20016...",sidebar_position:54,tags:["SEMI","Standard"],custom_props:{source_type:"pdf",source_file:"semi-chapter-054.pdf",chapter:54,page_count:50}},sidebar:"standardsSidebar",previous:{title:"E92-0302 - E \xa9 SEMI 1999,...",permalink:"/semiconductor-docs/docs/standards/semi/semi-chapter-015"},next:{title:"E97-0200A - \xa9 SEMI 200021 const...",permalink:"/semiconductor-docs/docs/standards/semi/semi-chapter-055"}},d={},h=[{value:"\ud83d\udcd6 \u5e76\u6392\u67e5\u770b\uff1aMarkdown\u6587\u672c + PDF\u539f\u6587\u6863",id:"-\u5e76\u6392\u67e5\u770bmarkdown\u6587\u672c--pdf\u539f\u6587\u6863",level:2},{value:"page_count: 50",id:"page_count-50",level:2}],u={toc:h};function p({components:e,...t}){return(0,n.yg)("wrapper",(0,a.A)({},u,t,{components:e,mdxType:"MDXLayout"}),(0,n.yg)(o.A,{pdfLink:"/pdfs/semi/054.pdf",pdfSize:"N/A",title:"E95-1101 - \xa9 SEMI 2000, 20016...",description:"SEMI\u6807\u51c6\u6587\u6863",mdxType:"PdfDownloadCard"}),(0,n.yg)("hr",null),(0,n.yg)("h2",{id:"-\u5e76\u6392\u67e5\u770bmarkdown\u6587\u672c--pdf\u539f\u6587\u6863"},"\ud83d\udcd6 \u5e76\u6392\u67e5\u770b\uff1aMarkdown\u6587\u672c + PDF\u539f\u6587\u6863"),(0,n.yg)(r.A,{pdfPath:"/pdfs/semi/054.pdf",mdxType:"PdfSplitView"},(0,n.yg)("hr",null),(0,n.yg)("p",null,'title: "E95-1101 - \xa9 SEMI 2000, 20016..."\ndescription: "SEMI\u6807\u51c6\u6587\u6863"\nsidebar_label: "E95-1101 - \xa9 SEMI 2000, 20016..."\nsidebar_position: 54\ntags: ',"['SEMI', 'Standard']","\ncustom_props:\nsource_type: 'pdf'\nsource_file: 'semi-chapter-054.pdf'\nchapter: 54"),(0,n.yg)("h2",{id:"page_count-50"},"page_count: 50"),(0,n.yg)("p",null,"<","!-- Page 1 --",">"),(0,n.yg)("p",null,"SEMI E95-1101 \xa9 SEMI 2000, 2001 6 Jobs System Recipes Setup (Future) Alarms Help View 6View 5View 4View 3View 2View 1 View 6View 5View 4View 3View 2View 1 View 6View 5View 4View 3View 2View 1 View 6View 5View 4View 3View 2View 1View 6View 5View 4View 3View 2View 1 View 6View 5View 4View 3View 2View 1 View 6View 5View 4View 3View 2View 1 InformationPanel FunctionalAreas Figure 6Network Navigation Model  Tab Sub-navigation Jobs System Recipes Setup (Future) Alarms Help View 1 View 2 View 3 View 4 View 5 View 6 View 1 View 2 View 3 View 4 View 5 View 6 View 1 View 2 View 3 View 4 View 5 View 6 InformationPanel FunctionalAreas View 1 View 2 View 3 View 4 View 5 View 6View 6View 5View 4View 3View 2View 1View 6View 5View 4View 3View 2View 1 View 6View 5View 4View 3View 2View 1 Sub-navigation Buttons Figure 7Network Navigation Model  Button Sub-navigation 5.3.5 Display Layout Description5.3.5.1 The display layout is designed for ease of use with touchscreen input devices and does not require akeyboard or other pointing device. By dividing the screen into rectangular panels, provision is made toaccommodate the display and input of information organized by the tasks users must accomplish in managing andmonitoring processing, maintaining and repairing the equipment, and other relevant work.5.3.6 Basic Layout Mandatory5.3.6.1 The basic layout shall contain four panels as shown and oriented in Figure 8. At a minimum, the interfaceshall support the orientation of the command panel on the right-hand side, unless the enhanced layout (Section 5.3.7)is implemented."),(0,n.yg)("p",null,"<","!-- Page 2 --",">"),(0,n.yg)("p",null,"SEMI E95-1101 \xa9 SEMI 2000, 20017 Title Panel Inform ation Panel Command Panel N avigation Panel Figure 8Basic Layout 5.3.6.2 All the panels are tiled edge to edge to create the display, and only the relative position of the panels isspecified in this standard. Panels may or may not display a visible border. For an interface that is the primary display(typically, but not always at the front of equipment), an outer window frame allowing window resizing, closing, orpositioning shall not be shown or enabled. This is to prevent the user from mistakenly losing the window, whichmay result in a dangerous condition. If desired, a logged-in user with sufficient privileges may be allowed to resize,but not minimize or close, the primary display window. Secondary instances of the interface (e.g., displayed at amaintenance node or displayed at a remote node) may show and enable the outer window frame.5.3.7 Enhanced Layout Recommended5.3.7.1 It is strongly recommended that left-handed users be allowed to change the location of the command panelto the left-hand side (see Figure 9(b)) to avoid obscuring the screen when reaching with their left hand to makeselections on the command panel when it is located on the right-hand side of the screen. Title Panel Information Panel Command Panel Navigation Panel Title Panel Information Panel Command Panel Navigation Panel (a) (b)Figure 9Enhanced Layout  Right and Left Command Panel Orientation"),(0,n.yg)("p",null,"<","!-- Page 3 --",">"),(0,n.yg)("p",null,"SEMI E95-1101 \xa9 SEMI 2000, 2001 8 5.3.8 Title Panel Description5.3.8.1 The title panel is a horizontal area above the information and command panels, at the top of the interfacewindow. It is always displayed and contains the host communications status display (if host communications issupported), date/time display, Login/Logout button (if security is supported), message display area, and the name ofthe current view. It may optionally contain a corporate identifier or logo, a display of critical parameters, an audiblealarm silencing button, orientation graphics, a light tower representation, and other items that should always bedisplayed to ensure effective operation.5.3.9 Title Panel Basic Information Mandatory5.3.9.1 Shown below is the title panel with the mandatory display objects. The relative positions shown, with thetop portion of the title panel containing the date/time display at the left, the current view name to its right, and withthe message area below the top portion, are mandatory. Date/TimeDisplay Message Area Current View Name Figure 10Title Panel 5.3.10 Title Panel with Conditional Information Conditional5.3.10.1 Shown below is the title panel with the mandatory display objects, plus the conditional hostcommunications status display and the conditional Login/Logout button. The relative positions shown, with the hostcommunications status display left-most, and the Login/Logout button at the upper right, are mandatory. HostCommunicationStatus Login HereDate/TimeDisplay Message Area Current View Name Figure 11Title Panel 5.3.10.2 Title Panel Host Communications Status Conditional5.3.10.2.1 If the equipment supports host communication then status information shall be included in the title panel.Information such as communications status (i.e., whether communications is active), communications state (i.e.,connected, disconnected, etc.), and whether the equipment is in a local or remote mode may be displayed here. Thedisplay of specific information is dependent on the host communication protocol which may impose additionalspecific requirements on what is displayed.5.3.10.3 Title Panel Login/Logout Button Conditional5.3.10.3.1 The Login/Logout button label reads Login Here until a user is logged in, then displays a useridentifier until the user logs out. User selection of the Login/Logout button invokes a dialog box where the user mayenter a user identifier and password, or, if already logged in, may select a button to log out. If required by theimplementation, when this dialog box is displayed, all other functions in the interface window may be disabled,including the navigation panel."),(0,n.yg)("p",null,"<","!-- Page 4 --",">"),(0,n.yg)("p",null,"SEMI E95-1101 \xa9 SEMI 2000, 20019 5.3.11 Title Panel with Additional Information Recommended5.3.11.1 Shown below is an example of a layout for the title panel incorporating some recommended display objectsand their relative positions. HostCommunicationStatus Login HereDate/TimeDisplay Message Area Current View NameCorporateIdentifier Light TowerDisplay CriticalParameters,AlarmSilencing,etc. Figure 12Title Panel with Some Additional Display Objects 5.3.11.2 Title Panel Alarms Button Recommended5.3.11.2.1 Although not recommended for new designs, the title panel may also contain an Alarms button thatallows the user to respond to cautions and severe alarms. In this case, the Alarms navigation button in the navigationpanel shall be omitted, and any alarms accessed through a title panel Alarms button shall be displayed in a dialogbox, not as an information panel and its command panel.5.4 Navigation Panel Mandatory5.4.1 Navigation buttons shall have a text label. In addition, they may also include an icon to graphically representtheir function. When no icon is present, the button label shall be centered on the button. If an icon is present, thelabel shall be centered below the icon. Navigation buttons are arranged horizontally along the bottom of the display,in the navigation panel, which shall always be present.5.4.2 Required Navigation Functions Mandatory5.4.2.1 At a minimum, the user shall always be able to immediately access and respond to alarm and cautionnotifications, even when a dialog box is displayed on the current view. Dialog boxes shall not obscure the navigationpanel. Additionally, the user shall always be able to immediately access other parts of the interface if such access isrequired to ensure the safe operation of the equipment. Only when prohibited by the operating system or otherimplementation limitations such that a displayed dialog box cannot be maintained during, or redisplayed afternavigation, it is allowed that such access may be accomplished by displaying another dialog box that completelycovers the originally displayed dialog box. When the overlaying dialog box is dismissed, the underlying dialog boxis redisplayed, in the same state it was in prior to the invocation of the overlying dialog box (i.e., given the statedprohibition or limitations, it is not mandatory that access be provided through navigation using the navigationpanel). Immediate access shall mean that the user shall not have to dismiss or otherwise interact with any displayeddialog box in order to perform the required access. When the user navigates back or otherwise returns from therequired access, the last selected view shall be displayed, along with any dialog box that was displayed, in the samestate it was in. If no dialog box was displayed, the last selected view shall be displayed.5.4.2.2 An allowed exception is a login and/or logout dialog box or screen if an implementation requires modaloperation while logging in or out.5.4.3 Conditional Navigation Functions Conditional5.4.3.1 Except when absolutely prevented by the operating system or implementation limitations, the navigationpanel shall always be available for user selection, even when a dialog box is displayed on the current view. Thismakes it possible for the user to directly and immediately access any functional area from anywhere within the userinterface. Immediate access shall mean that the user shall not have to dismiss or otherwise interact with anydisplayed dialog box in order to perform the required access. When the user navigates back to a functional area, thelast selected view is displayed, along with any dialog box that was displayed, in the same state it was in.5.4.3.2 An allowed exception is a login and/or logout dialog box or screen if an implementation requires modaloperation while logging in or out."),(0,n.yg)("p",null,"<","!-- Page 5 --",">"),(0,n.yg)("p",null,"SEMI E95-1101 \xa9 SEMI 2000, 2001 10 5.4.4 Navigation Panel Layout Mandatory5.4.4.1 The figure below shows the navigation panel, with three buttons labeled (Future) indicating the positionswhere buttons may be placed if required by the specific implementation of the interface, or as a result ofmodifications or enhancements in future releases of the software. It is recommended that the navigation panelcontain no more than ten buttons.5.4.4.2 The navigation buttons shall be sequenced from left to right in descending order of expected frequency ofuse. The most frequently selected navigation button shall be left-most within the navigation panel; and the leastfrequently selected button shall be right-most. Jobs System Recipes Setup (Future) (Future) (Future) Alarms Help Figure 13Navigation Panel 5.4.5 Navigation Panel Alarm and Help Buttons Conditional5.4.5.1 The two exceptions to the above ordering are the Alarms and Help navigation buttons, which, when they aresupported in an implementation, shall be the next to right-most and right-most buttons, respectively. This placementensures that the position of these buttons shall remain unchanged, even if subsequent interface modifications orenhancements require additional buttons. The Alarm button shall be placed so that the spacing between it andadjacent buttons is larger than the spacing between other buttons, to allow its selection quickly, and without error.5.4.6 Navigation Button Labels Conditional5.4.6.1 For each functional area, there is a corresponding navigation button identified by a text label (mandatory)and icon (recommended) identifying the functionality and information provided. The table below shows text labels(conditional) for the navigation buttons, a description of each functional area, and some recommended alternativelabels. Table 1 Functional Areas Navigation Button Label Description Alternate LabelsJobs Operations related to product processing, includingany pre- and post-production equipment setupLot Operations, Operation,Operations, Processing, Main, RunSystem Equipment status, manual move, maintenance, service,calibration, & other engineering-level functionsOverview, Service, Status, SystemStatus, MaintenanceRecipes Recipe management, including creation, editing,storing, etc.None Datalog Data histories, event logs, SPC functions(If supported)History, Analysis, Logs, Data Setup User account administration, host communicationscontrol, user preferences, parameters, hardwareconfiguration/options, light tower programming, etc. Configuration, Options Alarms Alarm and caution summary to acknowledge and clearposted alarms, current event logNone (see Section 5.4.5) Help Help files on operations, procedures, and the interface None (see Section 5.4.5) 5.4.6.2 The top to bottom ordering of the table reflects the left to right ordering of navigation buttons. Also allowed,but not recommended for new designs, is a left to right ordering of: System, Jobs, Equipment Setup, Recipes,History, Maintenance, and Configuration. The alternative labels specified in the table may be applied to this"),(0,n.yg)("p",null,"<","!-- Page 6 --",">"),(0,n.yg)("p",null,"SEMI E95-1101 \xa9 SEMI 2000, 200111 ordering also. Additional buttons, if required for a particular implementation, shall be added between the Setup andAlarm button positions.5.4.7 Navigation Panel Saliences Conditional5.4.7.1 Only one navigation button at a time shall display a pressed appearance. Additionally, navigation buttonsshall display colored salience coding for a number of purposes: 1, to indicate the user is viewing a functional area(medium blue salience); 2, to indicate an unfinished task (typically an open dialog box) in a functional area notcurrently displayed (medium blue salience); and 3, to inform the user that there are new or unacknowledged cautionsor alarms (saturated yellow or saturated red salience, respectively). The caution and alarm saliences are displayed onthe Alarms navigation button only. As an example, if the user has opened a dialog box in the Jobs functional area,and then selects the Recipes navigation button, the Recipes button shall display a pressed (down) appearance and amedium blue salience, and the Jobs button shall display an unpressed (up) appearance and a medium blue salience(Figure 14). This reminds the user that there is an open dialog box in the Jobs functional area. More than onenavigation button may display the unfinished task salience.5.4.7.2 The Jobs button may also display a medium green salience (not shown) to notify the user that the equipmentis Ready to Load, Ready to Unload, Ready to Run, or is in a similar state such that the users attention isrequested in the Jobs functional area. This is useful when the user has navigated to another functional area of theinterface. If there is an unfinished task, its medium blue salience shall remain displayed, even if the users attentionis requested. Jobs System Setup (Future) (Future) (Future) Alarms Help Medium Blue Salience Recipes Figure 14Navigation Button Saliences 5.4.7.3 The Alarm navigation button, in addition to the medium blue salience, displays a saturated (bright) yellowsalience when there are new or unacknowledged cautions, or displays a saturated red salience when there are new orunacknowledged alarms. Only the severest level is displayed. That is, when there are both cautions and alarms, thered alarm salience shall be displayed. When there are no alarms and only cautions, the caution salience shall bedisplayed. The figures below show the same situation as Figure 14, with Figure 15 showing a caution salience, andFigure 16 showing an alarm salience. If there are no cautions or alarms, the Alarm button displays a medium bluesalience if the user is viewing the Alarms functional area, or if there is an unfinished task and another functional areais being viewed. If a caution or alarm occurs, the medium blue salience is replaced with the appropriate salience, andis only re-displayed when all cautions and alarms have been acknowledged or cleared. Jobs System Recipes Setup (Future) (Future) (Future) Alarms Help Bright Yellow SalienceMedium Blue Salience Figure 15Warning Salience"),(0,n.yg)("p",null,"<","!-- Page 7 --",">"),(0,n.yg)("p",null,"SEMI E95-1101 \xa9 SEMI 2000, 2001 12 Jobs System Recipes Setup (Future) (Future) (Future) Alarms Help Medium Blue Salience Bright Red Salience Figure 16Alarm Salience 5.4.8 Sub-navigation Conditional5.4.8.1 When sub-navigation is supported it shall be by a single row of tabs or buttons in a sub-navigation panel asshown below.5.4.8.2 Sub-navigation Layout A  Tabs5.4.8.2.1 Shown below are two orientations of the layout (right-hand and left-hand command panels), with sub-navigation using tabs. This is the preferred method for new designs where more than one view per functional area isneeded. User selection of a tab brings the tab to the front, displays its information and command panel, and allowsthe user access to its display objects. Use of tabs in each functional area must be consistent throughout the interface,even if there is only one view in a functional area, and thus, one tab. Title Panel Information Panel Command Panel Navigation Panel View 1 View 2 View 3 View 4 View 5 View 6Title Panel Navigation Panel Command Panel Information Panel View 1 View 2 View 3 View 4 View 5 View 6 (a) (b)Figure 17View Sub-navigation Using Tabs 5.4.8.3 Sub-navigation Layout B  Sub-navigation Panel With Buttons5.4.8.3.1 Shown below are two orientations of the layout, with sub-navigation using view selection buttons in a sub-navigation panel. The figure shows one possible relative location for a sub-navigation panel, but is not intended torestrict implementation. Other arrangements are allowed. However, if a sub-navigation panel is used, its size andlocation in each functional area must be consistent throughout the interface, even if there is only one view in afunctional area, and thus, no buttons in the panel."),(0,n.yg)("p",null,"<","!-- Page 8 --",">"),(0,n.yg)("p",null,"SEMI E95-1101 \xa9 SEMI 2000, 200113 Title Panel Information Panel Command Panel Navigation Panel Subnav. Panel Title Panel Information Panel Command Panel Navigation Panel Subnav. Panel (a) (b)Figure 18View Sub-navigation Using Buttons in Separate Panel 5.4.8.3.2 It is important in the layout to separate sub-navigation methods from the global commands in thecommand panel. This limits the number of buttonsneeded in the command panel; and reduces or elim-inates the need for multiple columns of buttons, whichwould alter the information panel display aspect ratio.If an information panel has a different aspect ratio thanthe others, its contents may appear to jump sidewayswhen navigating, distracting the user. The separation ofsub-navigation from commands accomplishes twoimportant objectives; a) users do not become confusedtrying to differentiate sub-navigation from commands,and b) the aspect ratio of the information panel displayis consistent for all views across all functional areas.5.5 Information Panel Mandatory5.5.1 The information panel displays a view or viewsof the information and graphics for each functionalarea. Graphics and other display objects are placed inthis panel to achieve the control and monitoringcapabilities required. If necessary, multiple views ofinformation may be displayed within a functional area,one at a time, in the information panel.5.5.2 When any functional areas have more than oneview, the user must be able to switch between thoseviews while remaining within the context of the currentfunctional area. The ways the user may select amongmultiple views presented in this standard are called sub-navigation methods to distinguish them from usernavigation between functional areas using thenavigation panel.5.6 Command Panel Mandatory5.6.1 The command panel is a vertical column ofcommand buttons located to the right of the infor-mation panel (to the left if switched to accommodate left-handed users). Only buttons for common or globalcommands related to the current view displayed in theinformation panel shall be located in the commandpanel. If there are no common commands for an infor-mation panel, the command panel shall have no but-tons. Each view in a functional area shall have its owncommand panel. To limit the number of command but-tons needed in each command panel, user selection of adifferent view shall display that view and its associatedcommand panel, with commands that apply only to theselected view. A command panel may be used for morethan one view if it is suitable for that purpose.Command buttons or other display objects that have amore limited scope shall be located in the informationpanel. Restricting locally-acting commands andfunctions to the information panel makes clear to theuser that only general, global commands are located inthe command panel. Buttons for navigation (i.e., thatinvoke the display of another view in the informationpanel) shall not be located in the command panel. It isrecommended that multiple columns of buttons in thecommand panel be avoided. 6 Compliance Statement6.1 In order to be compliant with this specification, thedocumentation accompanying an equipment shall in-clude a Human Computer Interface (HCI) ComplianceStatement that accurately indicates compliance with theindividual requirements defined in this document.Requirements and recommended capabilities aredefined in Table 2.6.2 In order to be compliant with HCI, equipment mustmeet all requirements in each of three categories, asfollows:"),(0,n.yg)("p",null,"<","!-- Page 9 --",">"),(0,n.yg)("p",null,"SEMI E95-1101 \xa9 SEMI 2000, 2001 14 6.2.1 Mandatory: In order to be compliant with thisstandard, all of the mandatory requirements shall beboth implemented and compliant as defined in thisspecification.6.2.2 Conditional: In order to be compliant with thisstandard, each conditional requirement shall either beimplemented as defined in this specification or shallboth not be implemented in the user interface and notbe supported in some other way by the equipment. (i.e.,no conditional capability which is present on theequipment shall be implemented in a manner other thanas defined in this specification).6.2.3 Recommended: Implementation of these feat-ures is at the discretion of the implementers. The only requirement for compliance with this specification forthese capabilities is that they be accurately documentedin the compliance statement for the equipment.6.3 Each requirement/capability shall be marked Yesunder Implemented if the equipment includes afeature which provides equivalent functionality as thatdefined in this specification even if that feature appearsin a different form. Otherwise it shall be marked No.6.4 Each requirement/capability shall be marked Yesunder HCI Compliant if the equipment includes afeature which conforms to all aspects of therequirement or recommended capability as defined inthis specification. Otherwise it shall be marked No. Table 2 HCI Compliance Statement HCI Compliance StatementMandatory Requirements Reference Implemented HCI CompliantButton Size 5.2.2.1 \x1f Yes \x1f No \x1f Yes \x1f NoButton Behavior 5.2.2.3 \x1f Yes \x1f No \x1f Yes \x1f NoButton Text 5.2.2.4 \x1f Yes \x1f No \x1f Yes \x1f NoDialog Boxes 5.2.5 \x1f Yes \x1f No \x1f Yes \x1f NoBasic Network Navigation Model 5.3 \x1f Yes \x1f No \x1f Yes \x1f NoBasic Layout 5.3.6 \x1f Yes \x1f No \x1f Yes \x1f NoTitle Panel Basic Information 5.3.9 \x1f Yes \x1f No \x1f Yes \x1f NoNavigation Panel 5.4 \x1f Yes \x1f No \x1f Yes \x1f NoRequired Navigation Panel Functions 5.4.2 \x1f Yes \x1f No \x1f Yes \x1f NoNavigation Panel Layout 5.4.4 \x1f Yes \x1f No \x1f Yes \x1f NoInformation Panel 5.5 \x1f Yes \x1f No \x1f Yes \x1f NoCommand Panel 5.6 \x1f Yes \x1f No \x1f Yes \x1f NoConditional Requirements Reference Implemented HCI CompliantSaliences 5.2.3 \x1f Yes \x1f No \x1f Yes \x1f NoInformation Dialog Boxes 5.2.6 \x1f Yes \x1f No \x1f Yes \x1f NoInput/Selection Dialog Box 5.2.7 \x1f Yes \x1f No \x1f Yes \x1f NoMessage Dialog Box 5.2.8 \x1f Yes \x1f No \x1f Yes \x1f NoNetwork Navigation Model with Sub-navigation 5.3.4 \x1f Yes \x1f No \x1f Yes \x1f NoTitle Panel with Conditional Information 5.3.10 \x1f Yes \x1f No \x1f Yes \x1f NoTitle Panel Host Communications Status 5.3.10.2 \x1f Yes \x1f No \x1f Yes \x1f NoTitle Panel Login/Logout Button 5.3.10.3 \x1f Yes \x1f No \x1f Yes \x1f NoConditional Navigation Panel Functions 5.4.3 \x1f Yes \x1f No \x1f Yes \x1f NoNavigation Panel Alarm & Help Buttons 5.4.5 \x1f Yes \x1f No \x1f Yes \x1f NoNavigation Button Labels 5.4.6 \x1f Yes \x1f No \x1f Yes \x1f NoNavigation Panel Saliences 5.4.7 \x1f Yes \x1f No \x1f Yes \x1f NoSub-navigation 5.4.8 \x1f Yes \x1f No \x1f Yes \x1f NoRecommended Capabilities Reference Implemented HCI CompliantButton Dimensions 5.2.2.2 \x1f Yes \x1f No \x1f Yes \x1f NoEnhanced Layout 5.3.7 \x1f Yes \x1f No \x1f Yes \x1f NoTitle Panel with Additional Information 5.3.11 \x1f Yes \x1f No \x1f Yes \x1f NoTitle Panel Alarms Button 5.3.11.2 \x1f Yes \x1f No \x1f Yes \x1f No"),(0,n.yg)("p",null,"<","!-- Page 10 --",">"),(0,n.yg)("p",null,"SEMI E95-1101 \xa9 SEMI 2000, 200115 7 Related Documents7.1 SEMATECH Documents1 Computer Integrated Manufacturing (CIM) ApplicationFramework SpecificationSCC User-Interface Style GuideNOTICE: SEMI makes no warranties orrepresentations as to the suitability of the standard setforth herein for any particular application. Thedetermination of the suitability of the standard is solelythe responsibility of the user. Users are cautioned torefer to manufacturers instructions, product labels,product data sheets, and other relevant literaturerespecting any materials mentioned herein. Thesestandards are subject to change without notice.The users attention is called to the possibility thatcompliance with this standard may require use ofcopyrighted material or of an invention covered bypatent rights. By publication of this standard, SEMItakes no position respecting the validity of any patentrights or copyrights asserted in connection with anyitem mentioned in this standard. Users of this standardare expressly advised that determination of any suchpatent rights or copyrights, and the risk of infringementof such rights, are entirely their own responsibility. 1 SEMATECH, 2706 Montopolis Drive, Austin, TX, 78741-6499.Website: ",(0,n.yg)("a",{parentName:"p",href:"http://www.sematech.org"},"www.sematech.org")," Copyright by SEMI\xae (Semiconductor Equipment and MaterialsInternational), 3081 Zanker Road, San Jose, CA 95134. Reproduction ofthe contents in whole or in part is forbidden without express writtenconsent of SEMI."),(0,n.yg)("p",null,"<","!-- Page 11 --",">"),(0,n.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 20011 SEMI E96-1101GUIDE FOR CIM FRAMEWORK TECHNICAL ARCHITECTURE This guide was technically approved by the Global Information and Control Committee and is the directresponsibility of the North American Information and Control Committee. Current edition approved by theEuropean Regional Standards Committee on June 11, 2001, and by the North American Regional StandardsCommittee on July 19, 2001. Initially available at ",(0,n.yg)("a",{parentName:"p",href:"http://www.semi.org"},"www.semi.org")," August 2001; to be published November2001. Originally published February 2000. This document replaces PR5-0699 in its entirety. 1 Purpose1.1 This guide describes technical architecture choicesthat enable application components to cooperate in aComputer Integrated Manufacturing (CIM) environ-ment and reduce the effort required to integrate thosecomponents into a working solution. The CIM Frame-work technical architecture guide builds on publiclyavailable specifications for distributed object comput-ing. It defines manufacturing production systemsrequirements for the technical infrastructure needed forimproved component interoperability, substitutability,and extensibility. It provides guidance for specifyingcomponents and addresses options for using an under-lying distributed object communication infrastructure.1.2 This guide provides guidance for the technicalfoundation of the SEMI Computer Integrated Manufact-uring (CIM) Framework standards. It discusses a com-ponent-based architecture using object-oriented andframework technology that helps implementers achievecomponent interoperability and substitutability, applica-tion extensibility, and reuse. It establishes the role ofdistributed object communications infrastructure in pro-viding necessary support for the framework technology.Specification methods for mapping a CIM Frameworkspecification to alternative infrastructure technologiesare also addressed by this technical architecture. How-ever, these mappings are not intended to be prescrip-tive. Further work may be required to define additionalmappings to emerging technologies. Many implement-ation issues that should be resolved for a particularsoftware implementation are outside the scope of thisguide.1.3 Adhering to this guide for technical architecturealone does not provide interoperability between appli-cations. While the technical architecture provides afoundation for interoperability, it is limited by thefollowing factors: Multiple infrastructure implementation choices arepossible, and interoperability across these environ-ments is not guaranteed. The technical architecture intentionally limits itsscope to only the most fundamental infrastructurerequirements, leaving additional technical issues for future guide upgrades or for implementersdiscretion. Conformance to a specification for CIM Frame-work Domain Architecture is also required forinteroperability of domain components. More complete semantics (including behavioralconstraints and collaboration patterns) for compo-nents are needed to ensure consistent interactionsamong components developed by separatesuppliers.1.4 A guide for technical architecture is a necessary,but not a sufficient, basis to achieve the goals of theCIM Framework specifications. It does not mandatespecific solutions to address the identified technicalrequirements because there are multiple implementationchoices that meet these requirements. Rather, the tech-nical architecture identifies those crucial technicalrequirements that should be considered by both CIMsoftware suppliers and consumers. The proposed stan-dard identifies the technical capabilities implement-ations should provide, but leaves the implementationoptions open. It is the responsibility of suppliers toprovide and explain an implementation of eachcapability, and the responsibility of consumers to assessparticular implementations for use in their factories.1.5 This guide provides guidance on the technicaltradeoffs for services provided by the distributedcomputing infrastructure for the purpose of supportingand enabling the domain specifications of CIM Frame-work components. These areas are: Distributed Object Communication  Provides thebasic services to enable implementationssupporting the CIM Framework interfaces to trans-parently locate other, possibly distributed imple-mentations and exchange messages requestingstandard CIM Framework operations. InterfaceDefinition Language provides a formal specifica-tion of the CIM Framework interfaces that can beautomatically transformed into conformant imple-mentations ready for integration and interoperation. Exception Declarations  Identify the form andstructure of return messages that inform requestorsthat a requested operation resulted in ananticipated, but abnormal outcome."),(0,n.yg)("p",null,"<","!-- Page 12 --",">"),(0,n.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 2001 2  Event Specification  Establishes the deliverymechanism, identification conventions, and datastructures for reporting the occurrence of antici-pated state changes to CIM Framework objects. Distributed Transactions  Define mechanismsneeded to coordinate the start, completion orrollback of units-of-work that cross CIMFramework component boundaries. Component Manager Support  Identifies thecomponent-level operations needed to create,locate, or remove instances of objects (and managecollections of those objects) that support the CIMFramework specified interfaces. 2 Scope2.1 Intended Audience2.1.1 This document is intended for developers ofcomponents and applications, and integrators of MESsystems that adhere to the CIM Framework speci-fications. It is also intended for system architects whocontribute to the evolution of the CIM Frameworkarchitecture and guides based on implementation exper-ience. A guide for technical architecture is focused onthe software technologies that support the architecturalgoals for the CIM Framework rather than on the manu-facturing domain concepts that the CIM Frameworkencompasses. The technical architecture perspectivecomplements SEMI E81.2.2 Architectural Issues Not Covered2.2.1 A number of architectural issues are not coveredwithin this document because they are beyond the scopeof the CIM Framework standards and are not expectedto come within the scope of the standards as they arerevised. They are itemized here because a productarchitecture layered on the CIM Framework TechnicalArchitecture should address these additionalarchitecture issues. In these cases, other more generalspecifications emerging in the infrastructure technologyareas are expected to provide these needed standards.The CIM Framework domain specifications do notrequire specific conformance in these areas to supportcomponent specifications.2.2.2 Persistence2.2.2.1 Persistence refers to the ability of an object tomaintain a nonvolatile copy of its current state such thatthe object could recreate the state during a futureinitialization. There are various operations for objectpersistence, and problems can occur if objects withcross-references do not coordinate their persistencestrategies and mechanisms. The CIM Frameworkexcludes persistence as an implementation mechanism. 2.2.3 System Performance2.2.3.1 System performance is highly dependent on theselection of hardware and software platforms forsystem execution. Tests should be performed to verifyadequate system performance and scalability for theanticipated operating environment. Performance tuningmechanisms or measurement tools are excluded fromthe CIM Framework specifications as an implement-ation dependent mechanism.2.2.4 Data Replication2.2.4.1 Data replication is a technique used to provideadditional fault tolerance or improve system perform-ance in certain situations. The CIM Frameworkexcludes specification of replication strategies as animplementation dependent mechanism.2.2.5 Change Management2.2.5.1 Change management is the ability to introduceand control changes to the system configuration. TheCIM Framework encompasses change management inthe domain context of document control, but the CIMFramework excludes the broader treatment of changemanagement for the MES software configuration itself.2.2.6 Externalization2.2.6.1 Externalization can be used to provide a formof persistence or to transfer object state between dis-joint implementations. The ability of an object to exter-nalize its data and state supports recovery of data andstate for objects that terminated from memory. TheCIM Framework excludes externalization as animplementation dependent mechanism.2.3 This standard does not purport to address safetyissues, if any, associated with its use. It is the responsi-bility of the users of this standard to establish appro-priate safety and health practices and determine theapplicability of regulatory limitations prior to use. 3 Limitations3.1 The CIM Framework should continue to evolve tomeet the needs of a competitive and vital industry. Thecontent of this framework represents a significantamount of real development experience from a numberof commercial software suppliers and their customers.These specifications reflect the product architectures ofthose companies, as well as the requirements of theircustomers. This evolution process should continue asmore products based on the CIM Framework aredeveloped.3.1.1 This guide acknowledges the followingdeficiencies that should be addressed in futurerevisions. These deficiencies are identified in thefollowing sections."),(0,n.yg)("p",null,"<","!-- Page 13 --",">"),(0,n.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 20013 3.2 Mapping to Alternate Distributed ComputingInfrastructures3.2.1 The CIM Framework provides a specification forMES software components, specified in terms of gener-alized manufacturing production systems requirements,that may be implemented using a variety of technicalinfrastructure foundations. While the intent of thisguide is to provide both rigor in specification and flexi-bility to make infrastructure implementation choices,these goals often conflict. The use of mapping tech-niques complicates the task of integrating applicationsacross technology boundaries.3.2.2 While it is anticipated that a conformant imple-mentation using either CORBA\xae1 or the Microsoft \xae2Distributed Component Object Model (DCOM) is feasi-ble by mapping the specifications to the implementa-tion, it is recognized that cross-infrastructureintegration is significantly more difficult (for example,merging transaction models). The mapping describedhere offers more diverse implementation choices, but itdoes not guarantee that all of those chosen technologieseasily work together in a single heterogeneousimplementation.3.2.3 Although the DCOM mapping provides astraightforward transform from the OMG InterfaceDefinition Language (IDL)\u2122 3 specifications for staticinvocation, the Microsoft OLE Automation interfacesmay be required for dynamic invocation. There appearsto be greater risk in being able to successfully map theCIM Framework to the OLE Automation interfaces.The requirement for dynamic invocation should beevaluated with this in mind.3.2.4 Another issue with DCOM mapping concernsexceptions. DCOM returns exceptions using its returnvalue HRESULT. Many CIM Framework operationsalready use return values and would not be able toreturn a HRESULT without restructuring the returnmechanism for the operation results.3.2.5 Finally, there has not yet been a detailed analysisof the CIM Framework interfaces to verify that they canbe successfully mapped using the CORBAInterworking Architecture.4 This is especially true ofthe OLE Automation mapping resolution. 1 CORBA is a registered trademark of Object Management Group,Inc. in the United States and other countries.2 Microsoft is a registered trademark of Microsoft Corporation, Inc.in the United States and other countries.3 OMG Interface Definition Language (IDL) is a trademark of ObjectManagement Group, Inc. in the United States and other countries.4 Object Management Group. The Common Object Request Broker:Architecture and Specification, Revision 2.2, Object ManagementGroup, 492 Old Connecticut Path, Framingham, MA: ObjectManagement Group, 1998. 3.3 Business Rules3.3.1 The management of factory objects requires theuse of a set of business rules; that is, procedures repre-senting common business practices that should beapplied under a given set of circumstances in responseto some factory event. For instance, Do not assign aprocess job to a machine which is scheduled for main-tenance within 24 hours. Factory systems implement-ations typically specify business rules as event-drivenECA (event-condition-action) or ECAA (event-condition-action-alternative action) rules. For example: event  request to edit a process specification; condition  invalid user access privilege; action  deny access; (alternative action  deny access and reportbreach of security).3.3.2 Business rules can also be embodied in thesequencing logic of sequential process definitions. Inthis case the business rules define the criteria formaking sequencing decisions that effect the flow ofwork through the factory.3.3.3 Business rules are intended to be addressed infuture revisions of this guide.3.4 Security and Access Control3.4.1 The management of sensitive informationregarding business processes and product specificationsrequires that MES implementations (especiallydistributed systems) provide some level of security andaccess control services. Typically, such services: identify and authenticate any factory object seekingsensitive information, permit access to information or operations basedupon identity and privilege, provide security-related audit trails, provide secure communications (not susceptible tobeing intercepted nor malicious or inadvertentmodification), and administer an enterprises security policy.3.4.2 Security and access control is intended to beaddressed in future revisions of this guide.3.5 Internationalization3.5.1 Specifications that deal with issues related tointernationalization are emerging from several sources,including the OMG. This guide should encompass theneed and ability to incorporate internationalizationfeatures into the CIM Framework specifications."),(0,n.yg)("p",null,"<","!-- Page 14 --",">"),(0,n.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 2001 4 3.5.2 Internationalization are intended to be addressedin future revisions of this guide.3.6 Object Properties3.6.1 Object properties refers to a technique that allowsadditional attributes (data) to be dynamically associatedwith an object without changing the interfaces of theobjects to which the properties are attached. This can beused as a convenient dynamic extensibility mechanismthat may be considered in future CIM Frameworkspecifications.3.6.2 Object properties are intended to be addressed infuture revisions of this guide.3.7 Object Collections and Queries3.7.1 Object collections and queries allow flexibleaccess to aggregate data for a group of objects. Thiscapability may be a candidate to replace the limitedoperations for collections found in the componentmanager interface.3.7.2 Object collections and queries are intended to beaddressed in future revisions of this guide. 4 Referenced Standard4.1 SEMI StandardSEMI E81  Provisional Specification for CIMFramework Domain ArchitectureNOTE 1: As listed or revised, all documents cited shall be thelatest publications of adopted standards. 5 Terminology5.1 Abbreviations and Acronyms5.1.1 ACID  Atomicity Consistency IsolationDurability5.1.2 CIM  Computer Integrated Manufacturing5.1.3 ECA  Event-Condition-Action (rule)5.1.4 ECAA  Event-Condition-Action-AlternativeAction (rule)5.1.5 ENS  Event Notification System5.1.6 ERP  Enterprise Resource Planning5.1.7 GUI  Graphical User Interface5.1.8 MES  Manufacturing Execution System5.1.9 ODL  Object Definition Language5.1.10 OMA  Object Management Architecture5.1.11 OTS  Object Transaction Service 5.2 Definitions5.2.1 application  1. one or more programsconsisting of a collection of interoperating objectswhich provide domain specific functionality to an enduser or other applications. 2. functionality provided byone or more programs consisting of a collection ofinteroperating objects.5.2.2 application interface  the interface provided byan application or application program.5.2.3 application object  an object implementing anapplication interface.5.2.4 architecture  the structure of the componentsof a program/system, their interrelationships, andprinciples and guidelines governing their design andevolution over time.5.2.5 attribute  an identifiable association betweenan object and a value. An attribute may have functionsto set and retrieve its value.5.2.6 behavior  the effects of performing a requestedservice, including its results (e.g., changes in the stateof an object).5.2.7 binding  a specific choice of platformtechnologies and other implementation-specific criteria.5.2.8 class  the shared common structure andcommon behavior of a set of object implementations.5.2.9 client  an object that uses the services ofanother object by sending messages to it or referencingits state.5.2.10 collection  an object containing references to(collections of) other objects with services formanaging them and providing access to them as arelated group of objects.5.2.11 component  a reusable package ofencapsulated objects and/or other components withwell-specified, published interfaces. The component isthe element of standardization and substitutability forthe CIM Framework.5.2.12 Computer Integrated Manufacturing  anapproach that leverages the information handlingcapability of computers to manage manufacturinginformation and support or automate the execution ofmanufacturing operations.5.2.13 conformance  adherence to a standard orspecification in the implementation of a product,process, or service.5.2.14 conformance requirement  identification inthe specification of behavior and/or capabilitiesrequired by an implementation for it to conform to thatspecification."),(0,n.yg)("p",null,"<","!-- Page 15 --",">"),(0,n.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 20015 5.2.15 conforming implementation  animplementation that satisfies all relevant specifiedconformance requirements.5.2.16 event  an asynchronous message denoting theoccurrence of some incident of importance. Forexample, state change or new object created.5.2.17 event channel  the intermediate object thatforwards published events to interested subscribers.5.2.18 exception  an infrastructure mechanism usedto notify a calling client of an operation that an unusualcondition occurred in carrying out the operation.5.2.19 extensibility  the ability to extend orspecialize existing components and add new objectclasses or components while preserving architecturalintegrity and component conformance to standards.5.2.20 framework  a collection of classes orcomponents that provide a set of interoperable servicesand functionality for a particular domain.5.2.21 implementation  the internal view of a class,object or module, including any non-public behavior.The specific code and functionality that implements aninterface.5.2.22 implementation conformance statement  astatement made by the supplier of an implementation orsystem claiming to conform to one or morespecifications and stating which capabilities have beenimplemented. It specifically includes the relevantoptional capabilities and limits.5.2.23 infrastructure  the services, facilities, andcommunications mechanisms that support the collabor-ation between and lifecycle of distributed objects.5.2.24 inheritance  the ability to derive new classes,types or interfaces from existing classes, types orinterfaces. For example, a derived class (subclass)inherits the instance variables and methods of the baseclass (superclass) and may add new instancevariables and methods. In the CIM Framework,inheritance applies to interfaces and their specificationof operations rather than implementations of classes.5.2.25 instance  a software entity that has state,behavior and identity. The terms instance and object areinterchangeable. An object is an instance of an interfaceif it provides the operations, signatures, and semanticsspecified by that interface. An object is an instance ofan implementation if its behavior is provided by thatimplementation.5.2.26 interface  the external view of a class, object,or module that emphasizes its abstraction while hidingits structure and internal behavior. An interface definition ideally includes the semantics of attributesand operations.5.2.27 interoperability  the ability for twoapplications or the parts of an application to cooperate.In the CIM Framework, interoperability requires thatapplication components be able to support specifiedrelationships, share data, invoke each others behavior(operations), return exceptions, and exchange events.5.2.28 lifecycle  the life of an object, includingcreation, deletion, copy, and equivalence.5.2.29 message  in object oriented systems amessage is the means by which a client object invokesthe behavior specified by an operation of a serverobject.5.2.30 message bus  a software infrastructure thatprovides distributed communication between objects incomponent implementations. It can refer to an ObjectRequest Broker, Microsoft DCOM, Java RemoteMethod Invocation or other infrastructure for conveyingmessages between objects.5.2.31 name-value pair  a data structure thatassociates a name with an arbitrary value, typicallyused as an extensibility mechanism for conveyinginformation by name-based retrieval.5.2.32 namespace  a namespace is a boundedcollection of names with a constraint to ensure that eachname is unique within the collection.5.2.33 object  a software entity that has state,behavior, and identity. The terms instance and objectare interchangeable. An object is an instance of aninterface if it provides the operations, signatures, andsemantics specified by that interface. An object is aninstance of an implementation if its behavior isprovided by that implementation.5.2.34 object services  interfaces for general servicesthat are likely to be used in any program based ondistributed objects.5.2.35 operation  an operation is a specification en-tity, identified by an operation identifier, that denotes aservice that can be requested. An operation has a sig-nature that describes the legitimate values of requestparameters and returned results, including anyexceptions.5.2.36 persistent object  an object that can survivethe process or thread that created it.5.2.37 productive entity  productive entity is anabstraction of a physical unit, which is involved in anyway in a production process (e.g. production orsupporting equipment). A productive entity has its own"),(0,n.yg)("p",null,"<","!-- Page 16 --",">"),(0,n.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 2001 6 internal logic and provides a software interface toaccess this logic5.2.38 query  a message sent to a server (e.g. theproductive entity) by a client interested in someinformation from the server (state of the productiveentity). A query may or may not have arguments and italways has an answer. The semantics of a query is thatsome information from the server is returned, but thequery cannot effect any change to the state of theserver.5.2.39 service  a function provided by a serviceprovider that is performed through an operationspecified by the provider.5.2.40 service provider, server  an object providingservices to other objects as specified by its publishedoperations.5.2.41 signature  a signature is the name,parameters, return values, and exceptions for a specificoperation.5.2.42 substitutability  the ability to replace a givencomponent from one supplier with a functionallyequivalent component from another supplier withoutimpacting the other components or its clients in thesystem.5.2.43 trader service  a collection of names withassociated properties of features for each name andmethods for manipulating and inspection thatcollection.5.2.44 type  a declaration that describes the commonproperties and behavior for a collection of objects.Types classify objects according to a common inter-face; classes classify objects according to a commonimplementation. 6 Technical Architecture Guidance6.1 The computing infrastructure provides the distrib-uted computing environment for CIM Frameworkapplications. This infrastructure includes the operatingsystem, networking and communications, data storageand access, user interface and presentation services,event distribution, systems management, and manyother elements. Of these many infrastructure elements,a guide for technical architecture specifies a smallsubset of key services that need to be standardized inorder to facilitate and streamline system integrationbetween conformant CIM Framework implementations.6.2 The CIM Framework relies on publicly availablespecifications to define the use of infrastructureservices wherever such published specifications exist.The largest single source for openly defined specifica-tions for distributed object services is the Object Man- agement Architecture. 5 Reference to this guide does notimply that CIM Framework conformant implement-ations should implement the referenced services. Theimplementations that realize these infrastructuretechnologies are outside the scope of this guide. Thetechnology choices made by implementers should bekept transparent to the CIM Framework to the greatestextent possible.6.3 Distributed Object Communication6.3.1 The CIM Framework documents assume the useof software infrastructure to provide distributed com-munication between objects in an implementation. Theacronym ORB was originated by the OMG to describeits distributed object communication infrastructure, butis sometimes used in a more general sense. In this doc-ument ORB is used only to refer to the OMG specifiedtechnology and the more general term message bus isused for the diverse class of distributed communicationmechanisms for communication between objects. Themessage bus is used to allow objects to make requestsand receive responses from other objects. An object cancommunicate through the message bus with objects thatare local or remote. Location transparency allows theobject to remain ignorant of the actual location of theobject with which it communicates.6.3.2 A primary criterion for a message bus imple-mentation is its ability to deliver all messages specifiedby the interfaces of the CIM Framework components.To accomplish this, the message bus should provide theability to support or map a specified interface, includingits inherited features, data types, operations, objectreferences, and exceptions to and from runtimemarshaled transport formats.6.3.3 Alternate message bus implementation technolo-gies are supported by the CIM Framework by mappingthe OMG IDL for the CIM Framework interfaces into aspecific message bus implementation. The CommonObject Request Broker: Architecture and Specification4contains sections that define this mapping fromCORBA to COM and from CORBA to OLE Automa-tion. These sections, called the Interworking Architec-ture, cover detailed rules for mapping OMG IDL,types, and exceptions to compatible interfaces in COMand OLE Automation.6.3.4 From a high level perspective, the DCOM andCORBA message buses are comparable. The DCOMcapabilities are roughly equivalent to those of an ORB.However, with a lower level analysis, differences showup in data types, inheritance, object identity, and thehandling of exceptions. The CORBA Interworking 5 Object Management Group. The Object Management ArchitectureGuide, Revision 3.0, John Wiley and Sons, New York NY, 1995."),(0,n.yg)("p",null,"<","!-- Page 17 --",">"),(0,n.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 20017 Architecture4 (Chapter 15, Interworking Architecture,Chapter 16, Mapping COM to CORBA, and Chapter17, Mapping OLE Automation to CORBA) definesmapping approaches covering:Interface Mapping,Interface Composition Mapping, andIdentity Mapping. 6.3.5 These areas should be addressed in order to pro-vide a mapping between the OMG IDL used to specifyCIM Framework interfaces and the message bus usedfor implementation. If the mapping is not specific (i.e.,can occur in multiple ways) then two implementationsmay not necessarily be able to communicate even ifthey use the same message bus type. Although theCORBA Interworking Architecture is specific toMicrosoft technologies, it could provide the foundationfor future interworking mappings.6.3.6 The current CIM Framework interfaces arespecified in OMG IDL. The interfaces can be directlycompiled and used with any of the available ORBimplementations on the market.6.3.7 The only way to provide such a direct solutionusing Microsoft DCOM would be to create additionalCIM Framework interface specifications in DCOMMIDL and/or OLE Automation ODL. This would allowdirect support for message bus functionality usingDCOM. For example, the CIM Framework memorymanagement requirement of in for parameter passing(see Section 6.3.15) would be directly supported byMIDL and DCOM but since the CORBA exceptionmodel is significantly richer than the DCOM exceptionmodel, mapping CORBA exceptions to COM wouldrequire an additional protocol to be defined for DCOM.6.3.8 The CORBA Interworking Architecture supportsmapping the current CIM Framework interfaces definedin OMG IDL to DCOM MIDL or OLE AutomationODL. This mapping is detailed enough that the map-ping should always provide the same MIDL/ODL solu-tion. Even though the current scope does not includeinteroperability between implementations on DCOMand CORBA (see Section 3.2), the issue of mapping theinterface is still the same. This would also provide astep towards true interoperability using CORBA/DCOM bridge products that are beginning to becomeavailable.6.3.9 Microsoft also provides an extension called OLEAutomation. These interfaces are described in ObjectDefinition Language (ODL). The OLE interfaces can beinvoked dynamically by a client with no compile-timeinterface knowledge. The OLE data types are a subsetof the types supported in DCOM, and there is no sup-port for user-defined constructed types. The mapping solution differs for the DCOM and the OLE Automa-tion. OLE Automation does not provide as clean a map-ping from OMG IDL as DCOM does. This limitationmay not allow some of the interfaces to translate com-pletely to an OLE Automation implementation. Thus,component suppliers using an OLE Automation imple-mentation should explain impact on interfaces that werenot fully supported due to the Automation restrictions.6.3.10 The CORBA Interworking Architecture coversmapping issues for the major areas of concern for theCIM Framework. The areas of primary importance arethe Interface mapping, Interface composition mapping,Identity mapping, and Exception mapping. TheCORBA Interworking Architecture gives detailed map-pings for each of these areas and deals with the DCOMand OLE Automation mappings separately. The follow-ing five subsections summarize these mapping issues.6.3.11 Interface Mapping6.3.11.1 The OMG IDL primitives, constructed datatypes, and object references map closely to DCOM. Theinherited CORBA interfaces may be represented asmultiple DCOM interfaces. The CORBA attributes maybe mapped to get and set operations in DCOMinterfaces.6.3.11.2 The OMG IDL primitives map to OLEprimitives except for special cases. The OLE interfacesdo not support constructed data types and should bemapped to specially constructed interfaces. CORBAobject references map to OLE Automation interfacepointers. There are difficulties in mapping CORBAmultiple inheritance to OLE Automation interfacesdocumented in the CORBA specification.4 CORBAattributes may be mapped to get and set operations inOLE Automation interfaces.6.3.12 Aspects  The total behavior of a piece of aproductive entity in a factory can be viewed as theunion of distinct behaviors. Each such isolated behavior(or functional area) is called an aspect of the productiveentity.6.3.12.1 There is great variety in productive entitybehavior. There are generic aspects that are shared byall or most productive entities (such as recipemanagement or process state model or materialtracking) and there are aspects that are specific to oneproductive entity type or to a particular productiveentity model. The behavior of each productive entity isthe union of the particular aspects of that productiveentity.6.3.12.2 Saying that two pieces of productive entitieshave a certain aspect does not necessarily mean thatthey behave absolutely the same way. There are two"),(0,n.yg)("p",null,"<","!-- Page 18 --",">"),(0,n.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 2001 8 ways by which behavioral variation within an aspectcan be modeled: Parameters and Variants.6.3.13 Parameterized Aspects  An aspect can haveparameters. Differences in productive entities behaviorare modeled by assigning different values to theparameters. For example if a physical structure aspectof the productive entity specifies that the productiveentity has a material buffer, the number of materialunits (buffer size) that can be placed on the buffer is apossible parameter. The number of buffers theproductive entity has can be another parameter.6.3.14 Variants  While parameterization is a verypowerful tool, there are variations in behavior thatcannot be simply modeled as different parametervalues. In this case one can use variants. An aspect issaid to have variants if there are some differentbehaviors related to the same aspect. For example theprocess control aspect can have a discrete variant and acontinuous variant. In the discrete variant theproductive entity processes discrete units of material(like the material within a magazine or a single wafercarrier), while in the continuous variant the productiveentity processes continuously as long as there ismaterial to be processed.6.3.14.1 Differences between productive entities arebest modeled as parameters when possible in order toavoid an explosion of the number of variants, while atthe same time trying to maintain the clarity of themodel.6.3.14.2 A complete specification of the behavior of apiece of productive entity should specify variants forthese aspects that have them.6.3.15 Where do aspects and variants come from? They leverage on previous work done by the industry.GEM (Generic Equipment Model, SEMI E30) is aprimary source for identifying generic aspects. VariousSEMs (Specific Equipment Models) are a source forspecific aspects and very likely for variants. OtherSEMI standards like SEMI E-40 (Standard ForProcessing Management) cover other aspects neglectedby GEM.6.3.16 Specifying Productive Entity Interfaces in aFactory  In order to specify the interface of aproductive entity it is necessary first to identify theaspects (or variants of these aspects) supported by theproductive entity, then to specify the interfacesassociated with each aspect. The productive entityinterface specification is then the sum of the interfacespecifications for all participating aspects.6.3.16.1 The interface of an aspect (or variants of theseaspects) is the sum of its Queries, Commands, EventNotifications and Service Requests and thus the problem of defining productive entity interface isreduced to the problem of defining the interfaces ofindividual aspects (or variants of these aspects).6.3.17 Architecture  The productive entity in afactory is viewed as a composition of its aspects. Thetotal productive entity behavior is therefore representedby the sum of all its aspects representing thesebehaviors. Each aspect specifies a specific behavior ofproductive entity and provides an interface forincoming messages (queries and commands).6.3.17.1 An aspect has a name. The productive entitycan answer a reference to one of its aspects given theaspect name:AspectInterface aspectNamed(in stringaspectName);6.3.17.2 An AspectInterface is a virtual interface thatrepresents a generic aspect. All aspect interfaces inheritfrom the generic AspectInterface. When an aspect hasvariants, the aspect interface itself is virtual, and all itsvariant interfaces inherit from it.6.3.17.3 Additionally the productive entity answers alist of the names of all its aspects:StringList allAspectNames();6.3.17.4 The usual scenario for a client is to acquire areference to the productive entity. It then acquiresreferences to the productive entity aspects of interest byquerying the productive entity. The client then invokesmethods on the aspect interfaces as required.6.3.17.5 The client only needs to acquire aspectinterfaces once when it first establishes communicationwith the productive entity. From then on it caches theproductive entity interface as well as the references tothe productive entity aspects for further use. Theprocedure of acquiring references needs to be repeatedonly in case the references become invalid (due toproductive entity restart for example).6.3.18 How To Add A New Aspect  The definition ofan aspect follows the following aspect definitionpattern. It includes the following items:6.3.18.1 Aspect Name  Each aspect has a name thatidentifies it.6.3.18.2 Aspect Description  The aspect descriptionexplains the productive entity behavior covered by theaspect. If the aspect has been derived from an existingstandard, the description includes a reference to thisstandard. It explains the concepts and the usedterminology, adds state models and state transitiondiagrams if required, and explains the interactionsbetween the productive entity and the factory elementsrelated to the aspect. If the interactions require certainsequences of messages, they are also described (as usecases or interaction diagrams)."),(0,n.yg)("p",null,"<","!-- Page 19 --",">"),(0,n.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 20019 6.3.18.3 The description also includes all the sideeffects and exceptions that can occur as a result of theinteractions related to the aspect.6.3.18.4 If the aspect has any relation or effects relatedto other aspects, they are also described here.6.3.19 Variants  If the aspect has variants, eachvariant is named and described.6.3.19.1 IDL  Usually the IDL will include a specialmodule for the aspect. The module includes data typedefinitions specific to the aspect and usually a singleinterface that provides the various queries andcommands of the aspect. An aspect that has variants hasan interface per variant. The interfaces for the variantscan be inherited from a common (abstract) aspectinterface.6.3.19.1.1 An aspect that deals with service requestsshould also include an IDL definition for the server thatprovides the services. Which is to be done in a separatemodule.6.3.19.2 Aspect Definition Example  Here theControl State Aspect has been chosen as an example foraspect definition.6.3.19.2.1 Aspect Name  Control State6.3.19.2.2 Aspect Description  The definition of theControl State Aspect is based on Generic EquipmentModel (GEM) SEMI standard E30.NOTE 2: The state diagram presented here is simpler than theone in SEMI E30, since the internal sub-states are irrelevantto the productive entity interface, and the concept of HOSTOFFLNE is obsolete in a distributed factory environment6.3.19.2.2.1 The control state model defines the levelof cooperation between the productive entity and thefactory. It also specifies how the operator interacts inthe different levels of factory control.6.3.19.2.2.2 The control state model provides thefactory with three levels of control over the productiveentity:6.3.19.2.3 OFFLINE  In the OFFLINE state,operation of the productive entity is done by theoperator. In the OFFLINE state the productive entityaccepts a query to find out the current control state andthe command to change its control state, but rejects allother queries or commands (raising the rejectedexception). While in the OFFLINE state the productiveentity produces no events and no service requests.6.3.19.2.4 LOCAL  In the LOCAL state theproductive entity is operated by the operator.6.3.19.2.4.1 In the LOCAL state the productive entityanswers all queries from the factory and allows the factory to execute a limited set of commands. Thecommands that are prohibited are those that causemovement or directly affect the process. The productiveentity sends events and asks for services from thefactory.6.3.19.2.5 REMOTE  In the REMOTE state theproductive entity is controlled by the factory. Thefactory has full access to all the necessary commands tooperate the productive entity through the full processcycle in an automated manner. The degree ofautomation can vary from productive entity toproductive entity and from factory to factory. Generallyoperators are required to intervene in setup operations,operator assist situations, etc. Therefore when inREMOTE state, even though theoretically fully undercontrol of the factory, the productive entity should notrestrict the operator from executing essential operationssuch as selecting a recipe, pausing or resuming theprocess, operator assists, material movement to/fromthe productive entity, initiating recipe download andother productive entity specific commands on acommand by command basis as needed. At the veryleast the operator should be able to change the controlstate, actuate an emergency stop and interruptprocessing (stop, abort or pause).6.3.19.2.6 The following diagram depicts theproductive entity Control State model. OFFLINE LOCAL REMOTE 1 2 3 4 56 Figure 16.3.19.2.7 As can be seen from the diagram, transitionfrom any state is allowed to the two others. The aspectprovides the factory methods for querying the currentstate, for initiating a transition to any of the states, andfor events when state transitions occur."),(0,n.yg)("p",null,"<","!-- Page 20 --",">"),(0,n.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 2001 10 Variants : NoneIDLmodule ControlStateModule ","{","// Type Definitionsenum ControlState ","{","OFFLINE, LOCAL,REMOTE);interface ControlState ","{","// QueriesControlState getControlState()raises (EqBasicTypesModule::CommunicationFailure);// Commandsvoid changeControlStateToOffline()raises (EqBasicTypesModule::CommunicationFailure);void changeControlStateToLocal()raises (EqBasicTypesModule::CommunicationFailure);void changeControlStateToRemote()raises (EqBasicTypesModule::CommunicationFailure);","}",";","}",";6.3.19.2.8 The control state aspect can post thefollowing events:ControlStateChangedToLocalControlStateChangedToRemotecontrolStateChangedToOffline6.3.20 Interface Composition Mapping6.3.20.1 The DCOM interfaces do not support multi-ple inheritance. When multiple inheritance is used toextend functionality, the mapping is not very difficult.When multiple inheritance is used to mix in orthogo-nal behavior the mapping is more difficult. The CIMFramework interfaces that only use single inheritanceprovide the most reliable mapping. Interfaces that usemultiple inheritance should follow the detailed mappingrules and ordering provided in the CORBAInterworking Architecture.6.3.20.2 OLE Automation also has problems directlysupporting the multiple inheritance of CORBA. TheCORBA Interworking Architecture4 provides detailedmapping rules for making the conversion wheremultiple inheritance is used.6.3.21 Identity Mapping6.3.21.1 CORBA and DCOM/OLE Automation havedifferent notions of what object identity means.CORBA defines an object as a combination of the stateand a set of operations that explicitly define theinstance. An object reference is defined as a name thatreliably and consistently denotes an instantiated object.A CORBA object exists until it is destroyed; itslifecycle is controlled by the server.6.3.21.2 DCOM does not provide the same mechanismfor identifying a particular object. DCOM objects are usually created when used and their state does notpersist as an object instance. DCOM objects exist whilethey are referenced; their lifecycle is controlled by theclient. This is true of OLE Automation objects as well.6.3.21.3 The CORBA Interworking Architectureprovides mapping solutions for managing the objectlifecycle. The lifecycle issues should be minimized withthe CIM Framework use of component managers tocontrol object lifecycles. The implementation ofDCOM lifecycle mapping should be encapsulated in thecomponent manager.6.3.22 Naming6.3.22.1 As a mechanism to support initializationbetween collaborating components, the name of eachcomponent manager should be registered in a publiclyavailable namespace along with the object reference forthe component manager. The same name may be reusedunambiguously as long as all occurrences belong todistinct namespaces. Other objects should be able toobtain a handle (object reference) to each componentmanager by utilizing the namespace through theoperations of a naming service. A trader service mayalso be used to perform lookup of component managersand other objects based on well documented searchcriteria. Additional objects may also be registered in thenamespace or trader as appropriate. The componentmanager serves as the namespace for the objects itmanages, providing object references for namedobjects. Implementations should provide documentationon how to obtain available object references in eitherthe namespace or the trader.6.3.23 Memory Management6.3.23.1 ORB implementations memory allocationand deallocation services should handle all three typesof OMG IDL parameter passing: in  Memory is caller-allocated and read-only.The caller is responsible for memory deallocation. out  Memory deallocation depends on thespecific usage of the argument. inout  Memory allocation and deallocationdepend on the specific usage of the argument.6.3.23.2 The CIM Framework uses only the in para-meter passing mechanism. Within operations that havehad objects passed by reference, any modification ofthe object occurs by using the in parameter as a refer-ence. Supplier provided extensions to the CIM Frame-work that use either the out or inout parameter passingmechanism should document the caller and calleeresponsibilities with respect to memory allocation anddeallocation."),(0,n.yg)("p",null,"<","!-- Page 21 --",">"),(0,n.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 200111 6.3.24 Use of OMG IDL Module Packaging Con-structs6.3.24.1 All IDL statements included as part of thespecification of SEMI E81 should be contained withinone or more CIM Framework defined modules.6.3.24.2 CIMFW Module Conventions6.3.24.2.1 Each CIM Framework sub-document thatspecifies IDL declarations should provide a full listingof the IDL statements in a compilable IDL file. This filemay be presented as an appendix to the specificationprior to final adoption and preparation for distributionwith the standard. The IDL file should include modulestatements to enclose all IDL declarations for thatspecification.6.3.24.2.2 IDL files (or appendices) should begin witha comment identifying the correct name of the file thatcontains the enclosed IDL specification. The followinghypothetical example illustrates the form of thiscomment.//File: CIMFactoryLabor.idl//Part of the CIM Framework for theFactory Labor Component6.3.24.2.3 Every IDL appendix should contain thefollowing statement identifying the top-level modulethat contains all CIM Framework declarations.module CIMFW","{"," ... ","}",";6.3.24.3 Lower Level Modules within the CIMFramework Module6.3.24.3.1 The CIM Framework module should enclosesecond level modules that further package eachpartition of the CIM Framework specification asdefined in SEMI E81. All IDL declarations should thusbe scoped, first, to the CIM Framework, and second, tothe specific component of the framework. The fol-lowing example illustrates the positioning of elementsof the Factory Labor component within a componentmodule.module CIMFW","{"," module FactoryLabor","{"," typedef ..., etc. ","}","; ","}",";6.3.24.3.2 Subsequent decomposition of CIM Frame-work specifications into a third level of module contain-ment may be necessary in some places, but should be avoided where possible to keep fully qualified namesfrom getting to an unworkable length.6.3.24.4 Conventions for CIM Framework Dependen-cies6.3.24.4.1 Each CIM Framework IDL file shouldinclude explicit statements identifying any other files inthe CIM Framework specification set that contain mod-ules that are referenced. These statements should be inthe form of #include statements. In order to avoidcircular references among related modules, a specifi-cation may need to partition a module into more thanone file and include parts of the module at differentpoints in the referencing file. This structure of IDL filesis dependent on the specific implementation and whichparts of the CIM Framework it implements and may beadjusted as needed to achieve successful compiles. TheIDL files distributed with the standard should suggest afile structure to achieve a successful compile, butshould not indicate that the file structure is specified asa part of the standard. The following example illustratesan include statement.#include module CIMFW","{"," ...6.3.24.4.2 All references to elements of separate mod-ules will then need to be fully qualified with the modulescoping. For example, to reference a type defined inthe CIMGlobal module, the reference should take aform similar to the following hypothetical example:#include module CIMFW","{"," module FactoryLabor","{"," ... Global::MachineSequenceassignedMachines ( ) raises(Global::FrameworkErrorSignal); ","}","; ","}",";6.3.24.4.3 Fully qualified names may also beautomatically generated if the target programminglanguage compiler supports the namespace concepts.For example, the C++ standard uses namespace andJava uses package to support namespaces.6.3.24.5 Guard Statements6.3.24.5.1 To avoid the possibility of the same CIMFramework file being included more than once and thuscausing multiple definition errors, each module shouldbe preceded by the following type of guard statement."),(0,n.yg)("p",null,"<","!-- Page 22 --",">"),(0,n.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 2001 12 #ifndef ","_","CIM","_","FACTORY","_","LABOR","_","IDL","_"," #define ","_","CIM","_","FACTORY","_","LABOR","_","IDL","_"," module ... ","}","; #endif // ","_","CIM","_","FACTORY","_","LABOR","_","IDL","_","6.3.24.5.2 The guard name should be designated by thestring that begins and ends with an underscore andincludes an all caps version of the filename withembedded underscores to separate the parts of thename. The guard statement should be documented foreach module.6.3.24.6 Naming Modules and IDL Files6.3.24.6.1 All Module names for CIM Frameworkspecifications are scoped within the CIMFW moduleand need not use redundant prefixing of the name withCIMFW. The names should be derived as closely aspossible from the name of the CIM Frameworkspecification they represent.6.3.24.6.2 All Names should be composed of one ormore words, abbreviations or acronyms concatenatedtogether with capital letters used as delimiters betweenparts.6.3.24.6.3 Names should be kept as short as possiblewhile still providing understandable semanticassociations for the subject module.6.3.24.6.4 IDL File names should be based on thesecond level module contained within the CIMFWmodule.6.4 Exception Declarations6.4.1 Exceptions provide an alternative returnmechanism for operations. When performing a normalreturn, control is returned to the point of invocation andthe provided return values and output parameters arevalid. Abnormal operation results raise an exception,which causes control to return to the defined exceptionhandler and breaks the flow of control. Any datadefined as part of the exception and provided by thecalled operation is valid and available to the exceptionhandler. When an exception is raised, normal outputparameters defined in the operation signature are notvalid and are not available in the exception handler.6.4.2 Exceptions are not communicated as an oper-ation return code. An exception signifies that the post-conditions for successful operation completion have notbeen satisfied. If, on the other hand, the operationmerely needs to communicate which one of multiplepost-conditions were met, then the operation should provide this information in a return code or returnstructure as part of the normal operation completion.6.4.3 Exception declarations in OMG IDL follow a Cstruct-like data structure with the keyword exceptiontaking the place of struct. It contains attributes that canbe used to pass information about an exceptioncondition to a service requester. An exception isdeclared with an identifier (ExceptionNameSignal, theexception name), which is accessible as a value whenthe exception is raised, allowing the client to determinewhich exception has been received. Data valuesassociated with the exception, if declared, areaccessible to the client. The keyword raises is used inthe operation definition to specify that a user-definedexception may be raised (or thrown in implementationterminology). The CIM Framework specificationsassume that an operation may raise a CORBA-definedstandard system exception, thus these exceptions arenot specified.6.4.4 The following conventions are used whendefining exceptions:Exceptions are not reserved for system orprogramming errors or failures, but should be includedfor any abnormal application behavior in the calledservice. This is consistent with CORBA usage ofexceptions for application errors.Exception descriptions are shown as OMG IDLcomments similar to descriptions for services.Return values should, if necessary, be implementedas fields in the exception definition.All state transition services (e.g., makeXXX ser-vices) should include the InvalidStateTransition-Signalexception in their list of raised exceptions.Services that perform a find or lookup functionraise an appropriate NotFound-Signalexception: a null return value is not an appropriateresponse. However, services that return a collection ofobjects do not raise an exception but simply return anempty collection.Services that perform add functions raise aDuplicateSignal exception for the casewhere the object to be added is already in the targetcollection or logical set. The exception includes a fieldcontaining a reference to the currently existing object.Services that perform remove functions raise aNotAssignedSignal exception for thecase when the given object is not in the collection itwas to be removed from or RemovalFailedSignal exception if the object could notbe removed."),(0,n.yg)("p",null,"<","!-- Page 23 --",">"),(0,n.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 200113 Boolean query services should rarely raise anexception unless conditions are such that neither a trueor false return value can be determined. 6.4.5 User-defined exceptions can be defined for anyoperation specified in IDL. Only user-definedexceptions that are defined and listed in the raisesclause of an operation should be thrown. Interface-defined or other standard system exceptions may bethrown without using a raises clause on an operation.The data contained in the user exception should helpthe caller interpret and deal with the exception. Specificdata can be defined for each user exception. Anyadditional information that assists in debuggingsituations should be sent to a tracing or logging facility.6.4.6 Operations should throw standard systemexceptions when an error condition clearly matches thedefined exception. This ability should be usedjudiciously as the receiver of the exception may not beable to distinguish between a system-thrown or user-thrown exception. If a system exception does notclearly fit the situation at hand, then a user exceptionshould be defined. Use of user-defined exceptions ispart of the binding that should be considered forinteroperability and substitutability.6.4.7 The mapping defined for exceptions shouldsupport both the system exceptions and user exceptions.The CORBA model uses the concept of exceptionsbeing raised to report error information. There shouldbe exception specific data associated with theexception. The DCOM model provides errorinformation by returning an HRESULT type. There isno facility for returning user-defined exception data.6.4.8 The CORBA Interworking Architecture providesa mapping for the CORBA System Exceptions to theDCOM HRESULT values. The additional exceptioninformation for User Exceptions can be returned in anexception structure and added as another parameter tomethods that include the raises keyword. The OLEAutomation mapping provides for the use of a Pseudo-Automation Interface called a pseudo-exception. This isincluded in the interface as an additional out parameter.6.4.9 The mapping of exceptions from CORBA toDCOM is very complex and requires an addedparameter on many of the interfaces. The completemapping rules are defined in the CORBA InterworkingArchitecture.6.5 Event Specification6.5.1 This guide uses a publish/subscribe model ofevents. Published events are sent to subscribers of theevent in an asynchronous manner. The identity andquantity of subscribers are not known by the publisherof an event. The publisher is also known as the supplier and the subscriber known as the consumerof the event. Although the receipt of an event can alterthe flow of control in the consumer, they shouldtypically be used primarily as an information broadcastmechanism. Direct operation requests to another objectshould be used when affecting changes to critical flowof control to ensure message receipt by the intendedrecipient.6.5.2 This guide suggests the use of an event deliverymechanism called event channels. Event channels canprovide a coarse grain filtering capability for events.Consumers can subscribe to a specific event channel inorder to receive a particular event type. The eventbroker specification of this guide extends this eventchannel capability by adding features for locating eventchannel, registering for event delivery, and filtering theevents of interest to minimize performance penaltieswhen large numbers of events are present.6.5.3 This guide supports creating, posting, andsubscribing to events. It also provides the mechanismsto support subject-based addressing. When a consumersubscribes to events for a particular subject, it should benotified whenever an event for the subject is posted byany supplier.6.5.4 The event delivery requirements are summarizedas follows:Suppliers do not know who the consumers of newsevents are; therefore, suppliers do not need to get ahandle for them.No response or answer is sent back from theconsumer(s) to the supplier once the post is completed.Message delivery is based entirely on messagecontext (subject). 6.5.5 Event Content6.5.5.1 The specification of event content should havetwo parts: a header and a body. The header shouldconsist of information of a general nature regarding theevent, such as the name of its subject (a subject stringused for identification); an aging factor (fordetermining event effectiveness and may be sitespecific); priority; and any filtering informationrelevant to event delivery at a general level. The eventbody should contain: the actual event message; theoriginal time of the event; and data relevant to filteringby the consumer of the event. The body should alsocontain any information required by the consumer notused in the filtering process (called News). The bodyshould be extended with object references as required tofacilitate communication with any objects associatedwith the event."),(0,n.yg)("p",null,"<","!-- Page 24 --",">"),(0,n.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 2001 14 6.5.5.2 The event header is constructed by the supplierof the event and is used by an Event NotificationSystem (ENS) to route the event to any consumerregistering interest in the event. Note that the structureof the header may be specific to a particular ENS. Thebody of the event is constructed by the event supplierand is intended for use by the event consumer.Consumers of events express interest in an event typeby passing the subject name and associated filter dataalong to the ENS. The ENS returns an originalconnection, called an event channel, to the consumer.6.5.5.3 Name-value pairs are one mechanism thatshould be used to define data either in the header orbody. Specific information within the body variesaccording to event type; issues such as allocation areimplementation dependent.6.5.6 Subject String6.5.6.1 The event subject string should be defined as amulti-level hierarchy to assist in event classificationand filtering. The levels designate the CIM Frameworkissuing the event component, the issuing interfacewithin that component, and the event type. Each levelshould be delimited by a special character (e.g., aforward slash: /). An example of this syntax is/RecipeManagement/MachineRecipe/ParameterChanged.6.5.7 Filter Data and News6.5.7.1 Filter data are attribute names, values, andoperators that are specified by the consumer and areused by the filter subsystem to further qualify an event.News consists of additional attributes and values thatare received by the consumer but not used in thefiltering process and thus are not specified by theconsumer. The consumer specifies the attributes,values, and operators upon which the event data isfiltered. The actual filtering is performed after thesupplier sends an event but prior to the consumerreceiving the event. The filterable data should be wellknown and standardized. News may be used by theconsumer to further filter the event, but the attributesand values are not standardized. Additionally, newsmay be used to convey the identity of the objectgenerating the event to any consumer of the event.6.5.7.2 An Event Broker is required to supportsubscription to an event channel that has the specifiedsubject and supports filtering. The actual filteringmechanism is an implementation dependency. Filterdata is passed to the Event Broker by the consumer toqualify the particular events that the consumer isinterested in receiving. The filter data specifiesfilterable items in which the consumer is interested plusoperators and operands to perform the filtering. Thefiltering sub-system should use the filter data to ensurethat a specific event is passed to the consumer. The interface is simple and does not try to constructadvanced logic to build the filter. The results of thefiltering are anded together, such that the passed eventshould meet all of the filter criteria. The need tospecify logical operators (e.g., or) on the filter criteriaor the use of query languages should be evaluated.Extensions to the filter structures would be required tosupport these additional capabilities.NOTE 2: The location of the filtering subsystem is animplementation detail.6.6 Distributed Transactions6.6.1 Many operations defined in the CIM Frameworkare related to one another in complex ways that requiremultiple operations to be treated as a single unit ofwork. For example, grouping operations are combinedwith the ability to make an explicit decision to committhe aggregation of changes, or to abort all of the opera-tions and return to the prior state. These grouping ofoperations are consistent with the familiar concept of atransaction (most commonly encountered in the contextof database management systems). CIM Frameworkobjects should be capable of participating in trans-actions as described below. However, the choice of howan object participates is implementation specific. Forexample, the implementer chooses the implementationtechnology and whether a change in object state isrecoverable (that is, whether a change in state can berolled back).6.6.2 A transaction is a contract between two or moreobjects to perform some action based upon one or morerequests in some context and having the ACIDproperties as follows: 6  Atomicity  State changes are atomic; either allhappen or none happen. These changes includedatabase changes, messages and events. Consistency  A correct transformation of state.Actions taken as a group do not violate any of theintegrity constraints associated with the state. Isolation  Even though transactions executeconcurrently, it appears to each transaction T thatothers executed either before T or after T, but notboth. Durability  Once a transaction completessuccessfully (commits), its changes to state survivefailures.6.6.3 For example, consider a lot that starts processingin a piece of equipment. The states of the lot and the 6 J. Gray, Transaction Processing Concepts and Techniques, MorganKaufmann Publishers/Harcourt Brace and Co., 6277 Sea Harbor Dr.,Orlando, FL, 1993."),(0,n.yg)("p",null,"<","!-- Page 25 --",">"),(0,n.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 200115 equipment should change in order to accurately trackthe state of the factory. Coordinating the lot andequipment state changes as a transaction guarantees thatfactory state can be recovered accurately.6.6.4 Transactions are created by a user of a service(the client) requesting an operation from a provider of aservice (the server). To maintain the ACID propertiesof a transaction, the server should be able to return tothe state prior to the request for the operation in theevent of a failure. In this sense, the server should berecoverable. Failures are either software or hardwareevents that prevent the completion of the transaction.The server is a recoverable server if it is able to main-tain the ACID properties when faced with a failure.6.6.5 Transactions should be designed in a mannersuch that they do not span a period of interaction withan external entity such as a person using a GUI or apiece of equipment. Waiting for the response from anexternal entity can result in locks being held for multi-ple seconds, minutes, or longer. This can adverselyaffect other transactions by causing time-outs or dead-locks. These types of transactions can usually be splitinto multiple serially executed transactions with somesmall amount of extra revalidation of current states atsucceeding transactions.6.6.6 Coordinating the completion of transactions mayinvolve multiple servers and may entail either commit-ting the successfully completed transaction or rollingback the unsuccessful transaction. This activity imposesadditional overhead on a system. Suppliers andconsumers should assess the impact of transactions onsystem performance during component design andselection of transactional events.6.6.7 Transactions may cause physical effects in themanufacturing system that cannot simply be rolled backin accordance with the ACID properties. Applicationand system designers should include ways to modifythe logical view of the system to match the physicalreality of the manufacturing floor if such a mismatchoccurs.6.6.8 Transactions can create CIM Framework eventsas state changes occur. As the transaction may not becommitted at the point of event creation, the eventshould not be visible outside the transaction until thefinal commit point. The details of performing this taskare implementation dependent. For example, the eventannouncing the completion of a lot at a processing stepshould not be published until the processing stepcompletion transaction is committed. Otherwise, theevent could be published, but the transaction subse-quently rolled back, creating a system inconsistency.6.6.9 Transactions should be able to be nested, thusproviding the ability to define transactions within other transactions. These sub-transactions can generate addi-tional sub-transactions, thus forming a hierarchy oftransactions. In the spirit of maintaining the ACIDproperties, each sub-transaction can issue a commit orrollback for its piece of work. The results of the sub-transaction are only available to the parent transaction.The sub-transactions commit becomes permanent onlyafter it issues a local commit and all ancestors commit.If the parent transaction does a rollback, all descendenttransactions are rolled back regardless of any localcommits.6.6.10 There are two types of transactions widely sup-ported for distributed object infrastructures. The OMAsupport for transactions is described in the OMGsObject Transaction Service (OTS). Microsoft providessupport for transactions with its Microsoft TransactionServer (MTS) product. The OTS closely aligns withother standards such as The Open Group DistributedTransaction Processing (DTP) model. 7 Using industrystandard protocols as a base, the OTS supports inter-facing with products from the major database suppliers.Using the provided OTS interfaces and informationabout The Open Group standards, non-ORB supplieddatabase interfaces could be developed to allow forinteroperability with other cooperating transactionservices. MTS also supports transactions with majordatabase suppliers through use of The Open Group XAinterface. Using the MTS Software Developer Kit,transaction support can be extended to other resources.6.6.11 Combining heterogeneous components based ona combination of OTS and MTS is not straightfor-ward.Although both rely on the XA interface for dis-tributedtransaction coordination, they are not designed tooperate with each other. Both OTS and MTS hide thedetails of transactions from users. This makes either so-lution very convenient, but makes linking them togethermore difficult. For example, suppose a CORBA-basedcomponent adhering to OTS should interact with anMTS-based component. The scenario calls for theCORBA based component to use the XA interface towork with the MTS provided transaction coordinator(see Gray8 for additional information on distributedtransactions). However, in hiding XA complexity, OTSalso hides the ability to readily specify the transactioncoordinator (OTS does this behind the scenes). CIMFramework component developers and consumersshould determine the relative need for distributed trans-actions spanning OTS and MTS against the additionalcomplexity of developing a XA-based mechanism forcombined OTS and MTS transactions. 7 The Open Group, Distributed TP: The XA+ Specification, Version2, The Open Group, 11 Cambridge Center, Cambridge MA, 1994."),(0,n.yg)("p",null,"<","!-- Page 26 --",">"),(0,n.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 2001 16 6.6.12 The ACID properties provided by either OTS orMTS may be used for CIM Framework transactions.Many implementation details are supplier specific;however, the major architectural principles have beendescribed above.6.7 Component Management6.7.1 A component refers to a collection of relatedinterfaces that form a coherent subsystem. Componentsmay have a component manager to assist in the trackingand management of the instantiated interfaces (objects).The objects that are managed by a component managerare called managed objects.6.7.2 Component Level Interface6.7.2.1 Component managers provide services such asreporting on the collection of instances they manageand creating object instances. The component managerprovides the following:Object references to managed objects.Collective queries for some aspect (usually a state)across all the objects it manages.Services for:Creating a managed object and returning areference to it, or receiving an object referenceto a newly created object. The componentmanager then registers the object reference.Removing managed objects.Finding managed objects. 6.7.3 Component Manager Classification6.7.3.1 Component Managers are classified by theirallowable number of instances.6.7.3.2 Unique Component Managers6.7.3.2.1 A unique component manager describes acomponent manager for which there is only one runninginstance in an MES implementation. Unique componentmanagers are used when a single point of factory levelcontrol or focus is required. An example use of this pat-tern might be an interface within a Dispatcher compo-nent called DispatchingManager. This might be aunique component manager because multiple dispatch-ing systems on the factory floor could create problemswith work scheduling.6.7.3.3 Non-Unique Component Managers6.7.3.3.1 A non-unique component manager describesa component manager for which multiple instances maybe running in an installed MES system. The componentmanager instances are derived from the same code base,but have separate instance data for each running in-stance. Non-unique component managers should be registered with the factory with some selection criteriain order for a requester to be able to obtain a handle tothe correct instance. An example use of this pattern isthe scenario in which several ProductManagers areemployed within a production system.6.8 Architecture For Service Requests6.8.1 Services are implemented by a factory object thatis the service provider. The productive entity in afactory invokes the service methods on that factoryobject.6.8.1.1 For example, a recipe server could offer thefollowing interface:interface RecipeManagementServer ","{","// upload a recipevoid acceptRecipe(in string recipeName,in Recipe recipe);// download a recipeRecipe provideRecipe(in stringrecipeName);","}",";6.8.1.2 The problem with service requests is that theyrequire a flow from the productive entity to the factoryobject that provides the service. This kind of reverseflow contradicts the principle of layered architecture bywhich the productive entity is supposed to be a moreprimitive entity, unaware of factory objects, theirlocations and their structures. The trading serviceaddresses this problem.6.8.2 Trading Service6.8.2.1 Using Trading Service6.8.2.1.1 A trading helps clients to locate services. Anobject that must locate a service must know how toaccess the trading service.6.8.2.1.2 A trading service relies on the description ofthe service itself, rather than any attribute relating to theserver that provides the service (such as the name of theserver). It must be able to describe the service itrequires. The trading server locates a server that fulfillsthe required service profile.NOTE 3: The trading service described here is based on theCORBA COS Trading Object Service, implementations ofwhich are available from vendors of CORBA environments.The solution however does not require the full generality ofthe COS Trading Object Service, and can be viewed as a strictsubset of the latter.6.8.2.2 The Trading Concept6.8.2.2.1 A trading scenario is based on a server thatexports a service to a trader. The client then imports theservice from the trader, receiving a reference to theserver on which it can invoke the service.6.8.2.2.2 This is depicted in the following diagram:"),(0,n.yg)("p",null,"<","!-- Page 27 --",">"),(0,n.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 200117 Trader Client Server export(1)import(2) service interaction(3) Figure 26.8.2.2.3 The diagram suggests that the server exportsits service to the trader. In practice any object aware ofthe server and its provided services could assume thisjob. For example, a factory configuration object couldbe responsible for exporting all services to the trader.6.8.2.3 Trading Service Models6.8.2.3.1 The trader has to implement two interfaces: The Register interface allows other objects toregister export service offers to the trader.NOTE 4: This interface is used e.g. by the serviceprovider to inform the trader about the services theservice provider offers. The Lookup interface allows other objects tolookup the trader for a required service.NOTE 5: This interface is used by e.g. the productiveentity to find a service provider for a specific service.6.8.2.4 Export Use Cases6.8.2.4.1 The trader offers an interface named Register,that allows a server to register its services with thetrader.6.8.2.4.2 The IDL definitions given below are forillustrative purposes. They are extracted from the COSTrading Object Service specification ","[","OMG","]",". Forclarity, not all services are included here.6.8.2.4.3 Exporting a Service6.8.2.4.4 To export a service, the server uses:OfferId export (in Object reference,in ServiceTypeName type,in PropertySeq properties);6.8.2.4.5 The server passes a reference to itself, anddescribes its offer by passing in a service type name anda list of properties of the service. The trader answers an offer id, through which the server can furthermanipulate its offer.6.8.2.4.6 Factory service offers are described asfollows:6.8.2.4.6.1 Service Type Name6.8.2.4.6.2 The type is a string naming the serviceitself. We are yet to agree upon the services supportedby this specification. The following are obviouscandidates: Recipe Service Wafer Map Service Fixtures Service 8 6.8.2.4.6.3 Properties6.8.2.4.6.3.1 Properties are used to characterize andspecialize the service. A property is a name/value pair,where the name is a string naming the property, and thevalue specifies the property value offered by the server.The constraint language defined by the COS TradingObject Service ","[","OMG","]"," limits the type of values to thebasic data types (such as numbers, chars, booleans andstrings) and sequences of these.6.8.2.4.6.3.2 The following properties are to be usedfor registering factory services: Serviced Productive entities  The value of thisproperty is a list of the ids of the productive entitiesserviced by this server. This allows multipleservers of the same type to be installed, andpartition the productive entity service among theavailable servers. Note that it does not require theserver to know the productive entities it serves,since the server registration can be done by afactory configuration service. Serviced Areas  The value of this property is astring collection naming the factory areas servicedby the server. This property is another means ofpartitioning the service among multiple servers.The area could be a name of a cell controller ifcellular manufacturing is practiced, or the name ofany organizational unit implemented by thefactory, and known to the factory configurationservice.6.8.2.4.7 Withdrawing a Service6.8.2.4.7.1 To withdraw a registered service, the server(or the configuration service) uses:void withdraw (in OfferId Id); 8 In back end fixtures is a generic name for durables and consumablematerials"),(0,n.yg)("p",null,"<","!-- Page 28 --",">"),(0,n.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 2001 18 6.8.2.4.8 Querying a Registered Service6.8.2.4.8.1 A server may query the trader the details ofa registered service by passing in the offer id.Struct OfferInfo ","{","Object reference;ServiceTYpeName type;PropertySeq properties;","}",";OfferInfo describe (in OfferId id);6.8.2.4.9 Modifying a Registered Service6.8.2.4.9.1 The server may modify the properties of aregistered service. It may add new properties, deleteexisting properties, or modify the value of existingproperties. This is done using the following method:void modify (in OfferId id,in PropertyNameSeq del","_","list,in PropertySeq modify","_","list);6.8.2.4.9.2 The properties named in the del","_","list aredeleted. Properties in the modify","_","list that do not existare added. Properties in the modify","_","list that exist,receive a new value.6.8.2.4.9.3 The modify method can be used to supportchanges in the factory configuration, such as newproductive entity being added or deleted, a productiveentity being migrated from one cell to another, a newload balancing policy for the servers installed, etc.6.8.2.5 Import Use Cases6.8.2.5.1 Importing a Service  The trader offers aninterface named Lookup that clients can use in order tolocate a service:void query (in ServiceTypeName type,in Constraint constr,in Preference pref,in PolicySeq policies,in SpecifiedProps desired","_","props,in unsigned long how","_","many,out OfferSeq offers,out OfferIterator offer","_","itr,out PolicyNameSeq limits","_","applied);6.8.2.5.1.1 The Query in Parameters  The inparameters are used by the client to specify the serviceit needs and the policies for searching it. The type parameter is key to the central purposeof trading. It specifies the name of the service typethe client is interested in. The constraint guides the trader on how to selecta server based on its registered properties. It is astring that describes the selection in some givenconstraint language. The typical constraints willselect a server for a specific productive entity or for the area the productive entity belongs to. Bothpossibilities use the in operator for testing theinclusion of an element in a set. Some examplesfollow:DieAttachXYZ in ServicedProductive-EntitiesCell22 in ServicedAreas6.8.2.5.1.2 Preferences specify how should a serverbe selected in case the query results in more than oneanswer. It is suggested that this parameter be ignored,which means that the default of first is always used.6.8.2.5.1.3 The policies parameter guides the traderon how to choose a policy for performing the search.Search policies are a rather complicated issue, whichcan be ignored in the Simple Trader case.6.8.2.5.1.4 The desired","_","props parameter instructs thetrader which properties are to be returned as part of theanswer (it does not affect the selection itself). This doesnot make much sense with the limited set of propertieswhich has been defined, and can also be ignored (usenone as the parameter value).6.8.2.5.1.5 The how","_","many parameter is another wayto restrict the number of answers. It is proposed that 1always be used as the value of this parameter.NOTE 6: Should areas be used as the selection criteria, theequipment must be aware of its area within the factory. Thisshould be supported through the productive entityConfiguration aspect.6.8.2.5.1.6 The Query out Parameters6.8.2.5.1.6.1 The query returns the selected servers inone of two forms: a collection of services or a referenceto an iterator through which the returned servers can beobtained. The second method is designed for queriesthat may return a large number of offers. One canalways assume that results are returned within the firstout parameter (out OfferSeq offers), namely a sequenceof offers. Furthermore, having specified 1 as the valueof the how","_","many parameter, it is ensured that theanswered sequence contains at most one element.6.8.2.6 Locating the Trading Service6.8.2.6.1 The productive entity locates the services itrequires using a trading service.6.8.2.6.2 A client can obtain a reference to the tradingservice by invoking the following method on the ORB:Object resolve","_","initial","_","references (in ObjectId identifier)^raises (InvalidName);Where:the reserved name TradingService is passed as theidentifier."),(0,n.yg)("p",null,"<","!-- Page 29 --",">"),(0,n.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 200119 6.8.2.7 A Usage Scenario Example6.8.2.7.1 Here is an example of a usage scenario.6.8.2.7.2 In common factory practice, cellularmanufacturing has a factory configuration serviceresponsible (among other things) for exporting thefactory services to the trading service. The followingare some typical use cases:1. The factory configuration service registers a wafermap server to server two cells named CellA andCellB.The factory configuration service obtains an initialreference to the trading service from the ORB:trader =orb.resolve","_","initial","_","references(TradingService);The trader answers its Registerinterface:traderRegistry =trader.register","_","if();The factory configuration service builds propertiesas a single-itemed sequence of containing onename/value pair whose name is ServicedAreasand whose value is a sequence of the cell names","{","CellA, CellB","}",". It then uses the Registerinterface of the Trading Service to register theservice offer:traderRegistry.export(waferMapServer,Wafer MapService, properties);2. The configuration manager informs a Die Attachequipment that it belongs to CellA.ProductiveEntities.setArea(CellA);3. The Die Attach needs a wafer map.It obtains an initial reference to the trading servicefrom the ORB:trader =orb.resolve","_","initial","_","references(TradingService);The trader answers its Lookup interface:traderLookup = trader.lookup","_","if();The productive entity looks up the trading servicefor the wafer map service:traderLookup.query(Wafer Map Service,CellA in ServicedAreas,pref, policies, desired","_","props,1, preference, offers,offers","_","itr, limits","_","applied);The wafer map server is returned as the firstelement of the offers sequence. The productiveentity may keep the reference to the wafer mapserver for future use. 4. The Die Attach can now invoke the service on thewafer map server:waferMapServer.getWaferMap();7 Technical Architecture Conformance7.1 Conformance is defined as adherence to a stan-dard or specification in the implementation of a pro-duct, process, or service. A conforming implementa-tion should have an associated implementation con-formance statement that details the capabilities thathave been implemented. While recognizing that theCIM Framework is, by definition, not a complete speci-fication of a MES, a guide for technical architecturedefines conformance for each of its major requirementsas follows.7.2 Distributed Object Communications Conformance7.2.1 The CIM Framework object model is based onthe ability to issue service requests to a componentobject and to subscribe to events published by thecomponent object. Component suppliers should explainhow these two forms of communications are accom-plished so consumers can assess the ease and feasibilityof integrating a component into the factory MES.Example terminology specific to semiconductor manu-facturing is provided for clarity. It does not precludeapplication specialization for other industries.7.3 Exception Conformance7.3.1 Alerting operation requesters of abnormal out-comes is essential for robust implementations. Compo-nent suppliers should explain how their implementa-tions support raising specified system and user-definedexceptions.7.4 Event Specification Conformance7.4.1 Notification of asynchronous occurrences is acornerstone of distributed event-driven applicationdomains such as MES. Suppliers should explain howtheir components support event delivery, including theregistration of event suppliers, event consumers and theprovision for Event Broker features for event filtering.7.5 Distributed Transaction Conformance7.5.1 Ensuring consistent state changes among compo-nents is a key concern in the integration of a factoryMES. Component suppliers should explain how theircomponents support transactional units of work.7.6 Component Management Conformance7.6.1 Component suppliers should explain how objectinstances are managed. This includes how the object isidentified, constructed, accessed, and destroyed (or flat-tened in the case of a persistent object). It also includes"),(0,n.yg)("p",null,"<","!-- Page 30 --",">"),(0,n.yg)("p",null,"SEMI E96-1101 \xa9 SEMI 1999, 2001 20 mechanisms for query or lookup of specific managedobject instances.7.7 General Rules for CIM Framework Conformance7.7.1 The following rules define the general expecta-tions for technical conformance to any CIM Frame-work specification. Suppliers should provide document-ation explaining any deviations from these generalrules. All CIM Framework-defined operations for aninterface should be supported. All exceptions and events for an interface shouldbe supported. A component should use component managerinterfaces for object instance creation and regis-tration where these operations are specified. A component implementation should support allinterfaces specified for that component. An application may not add states and transitionsto the defined dynamic models that have externalinterfacing ramifications. The application may stillfurther subdivide the states. A component implementation should explain howit supports substitutability. For example, it maysupport different degrees of substitutabilitybetween the following levels: Strict  An application that supplies a CIMFramework component should be reconfig-urable so it can use another suppliers imple-mentation of that component. The applicationsinteractions with the component are restrictedto CIM Framework defined interfaces. Weak  An application may use extended,pro-prietary, or private interfaces of acomponent. When the another suppliersimplementation is substituted for an installedcomponent, any components using theextended, proprietary, or private interfaces needto be reassessed and possibly modified. The useof the CIM Frame-work-defined interfaces doesnot change. NOTICE: SEMI makes no warranties orrepresentations as to the suitability of the standard setforth herein for any particular application. Thedetermination of the suitability of the standard is solelythe responsibility of the user. Users are cautioned torefer to manufacturers instructions, product labels,product data sheets, and other relevant literature respecting any materials mentioned herein. Thesestandards are subject to change without notice.The users attention is called to the possibility thatcompliance with this standard may require use of copy-righted material or of an invention covered by patentrights. By publication of this standard, SEMI takes noposition respecting the validity of any patent rights orcopyrights asserted in connection with any itemmentioned in this standard. Users of this standard areexpressly advised that determination of any such patentrights or copyrights, and the risk of infringement ofsuch rights, are entirely their own responsibility. Copyright by SEMI\xae (Semiconductor Equipment and MaterialsInternational), 3081 Zanker Road, San Jose, CA 95134. Reproduction ofthe contents in whole or in part is forbidden without express writtenconsent of SEMI."),(0,n.yg)("p",null,"<","!-- Page 31 --",">"),(0,n.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 20001 SEMI E97-0200APROVISIONAL SPECIFICATION FOR CIM FRAMEWORK GLOBALDECLARATIONS AND ABSTRACT INTERFACES This provisional specification was technically approved by the Global Information and Control Committeeand is the direct responsibility of the North American Information and Control Committee. Current editionapproved by the North American Regional Standards Committee on October 21 and December 15, 1999.Initially available at ",(0,n.yg)("a",{parentName:"p",href:"http://www.semi.org"},"www.semi.org")," January 2000; to be published February 2000.NOTE: This document was published twice during theFebruary 2000 (0200) publishing cycle. 1 Purpose1.1 This document defines the glo bal declarations usedby all other components of the CIM Framework andalso specifies the common architecture patterns thatserve to functionally integrate CIM Frameworkcomponents. The material architecture definesfunctionality common to product management, durablesmanagement and consumables managementcomponents. The factory resource architecture definesrelationships and common functionality of a variety offactory resources. The job architecture defines afactory-wide model for controlling factory jobs thatdrive a variety of manufacturing tasks. Thesespecifications are separated into a distinct group toenable them to be specified once and then logicallyincluded or inherited wherever they are subsequentlyneeded. 2 Scope2.1 This specification provides the common interfacesrequired by Manufacturing Execution Systems to: Provide type definitions for common datastructures to ensure consistent representation.These items include data types for commonconcepts such as coordinates, priorities,timestamps, and sequences of basic data types. Provide definitions for common exceptions usedconsistently throughout the CIM Framework. Provide the material architecture interfacescommon to identifying, grouping, moving, locatingand tracking material in the factory. Provide the factory resource architecture interfacescommon to defining, organizing, tracking usage ofand maintaining factory resources includingequipment, sensors, durables, and people. Provide the job architecture interfaces common tocreating, executing and managing work in thefactory. The job architecture is specialized formaterial processing jobs, material transport jobs, resource maintenance jobs and factory jobs thatdrive product material through their process flows.2.2 This standard does not purport to address safetyissues, if any, associated with its use. It is theresponsibility of the users of this standard to establishappropriate safety and health practices and determinethe applicability of regulatory limitations prior to use. 3 Limitations3.1 Provisional Status3.1.1 This specification is designate d as provisionaldue to known areas that need to be completed. Thefollowing items summarize the deficiencies of theprovisional specification to be addressed before asubsequent ballot to upgrade it to full standard status.3.1.2 The specification uses the IDL typedef any inseveral places. While this usage provides flexibility, itcan have the effect of reducing interoperability due todifferences in interpretation of the value provided byseparate implementations that interact through astandard interface. The any typedefs should bereplaced with explicit data types prior to upgrade fromProvisional to full Standard status.3.1.3 The definition of interfaces for retrieval ofhistory associated with CIM Framework objects mayneed to be added to abstract interfaces in this documentafter the complete specification for the history facilitywithin the CIM Framework Factory ServicesComponent.3.1.4 The specification of CIM Framework statesreported through published state change events iscurrently based on a type definition for an enumerationof state values. There may be alternate representationsfor states that are better able to capture the semantics ofnested and parallel states. The state representation usedfor the CIM Framework will be reviewed and possiblychanged before upgrade to full standard status.3.1.5 The Resource model defined i n SEMI E81includes several extensions that are not yet included inthis specification. These extensions includecomposition of resources from other resources,capabilities associated with resources, and associationswith tracking and maintenance functions for resources."),(0,n.yg)("p",null,"<","!-- Page 32 --",">"),(0,n.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 2000 2 These extensions will be addressed before upgrade tofull standard status.3.1.6 The interfaces specified for M ESFactory, Area,and ComponentManager are included in the E81responsibilities for the Factory Component withinFactory Operations. These interfaces will need to bemoved to that component when it is considered in afuture ballot. 4 Referenced Standards4.1 SEMI StandardsSEMI E5  SEMI Equipment CommunicationsStandard 2 Message Content (SECS-II)SEMI E10  Standard for Definition andMeasurement of Equipment Reliability, Availability,and Maintainability (RAM)SEMI E81  Provisional Specification for CIMFramework Domain Architecture 4.2 Other StandardsUML Notation Guide, Version 1.1, document numberad/97-08-05, Object Management Group 1 ISO/IEC International Standard 14750 (also ITU-TRecommendation X.920)  Information Technology Open Distributed Processing  Interface DefinitionLanguage 2 NOTE 1: As listed or revised, all documents cited shall be thelatest publications of adopted standards. 5 Terminology5.1 abstract interface  an interfa ce specified onlyfor inheritance rather than for implementation in orderto standardize common features shared by allspecializations of the interface. 6 Requirements6.1 Global Type Definitions6.1.1 This section describes data type definitions andexceptions that are global in nature. By global it ismeant that they are designed to be used by anycomponent within the CIM Framework. Thisspecification does not address how they areimplemented within a CIM Framework conformant 1 UML Notation Guide v1.1 is available to the general public at",(0,n.yg)("a",{parentName:"p",href:"http://www.omg.org/cgi-bin/doclist.pl"},"http://www.omg.org/cgi-bin/doclist.pl"),", +1-508-820 4300, ObjectManagement Group, Inc. , Framingham Corporate Center, 492 OldConnecticut Path, Framingham, MA 01701.2 ISO Central Secretariat, 1, rue de Varemb, Case postale 56, CH-1211 Genve 20, Switzerland application; that level of detail is within the realm of thedevelopment effort.6.1.2 Global type definitions are spe cified as IDLdeclarations which may be referenced by any CIMFramework interface. The CIM Framework uses thekeyword typedef to define aliases for basic object types,but with additional implied semantics. (e.g., the unitstypedef defines a string, whose contents conform todefinitions found in SEMI E5). The keyword structbegins the type declaration for record structurescomposed of a collection of named and typed values.The third form of type definition is an enumerated typebeginning with the reserved word enum. Enumeratedtypes are used to declare a list of tokens that can beused as values of that type. Enumerated types aremainly used to denote the states of an object forcommunication in CIM Framework events. Finally,collections of values are declared with the keywordsequence. This kind of type definition may or may notimply significance to the ordering of the members inthe sequence. Where no ordering constraint ismentioned, the elements of the sequence are notassumed to be in any meaningful order.NOTE 2: In the following definitions, // or /","*"," .... ","*","/delimits a comment.NOTE TO THE READER: The comments in the followingsections (described in NOTE 2, above) appear to immediatelyprecede, rather than follow, the items they discuss.  SEMIStaff 6.1.3 All CIM Framework specifica tions will bedeclared within the context of the CIMFW modulewhich spans all of the components of the CIMFramework. Within the CIMFW module, the globaltype definitions will be declared within a second-levelmodule called Global."),(0,n.yg)("p",null,"<","!-- Page 33 --",">"),(0,n.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 20003 Module: Global typedef string Identifier; typedef unsigned long Flags; struct NamedValue ","{","Identifier name;any argument;long len;Flags arg","_","modes;","}","; typedef NamedValue NameValue; typedef sequence NameValueSequence; typedef string PropertyName; struct Property ","{","PropertyName property","_","name;any property","_","value;","}","; typedef sequence Properties;/","*"," This type definition represents units for factory parameters, measurements. etc., and conforms to the SEMI E5standard for representation of units. In that standard, the string contains a code representing a value of the units. Forexample, ns would mean nano-seconds; A for ampere; and wfr for wafer. ","*","/ typedef string Unit; typedef string Units;/","*"," This type definition represents a sequence of string values. ","*","/ typedef sequence StringSequence;/","*"," This type definition represents a sequence of any values. ","*","/ typedef sequence AnySequence;/","*"," This type definition represents a sequence of long values. ","*","/ typedef sequence LongSequence;/","*"," This enumerated type identifies event priorities and is used in each event definition. ","*","/ enum PriorityOfEvent ","{","Low,Medium,High,Alarm ","}",";/","*"," This enumerated type identifies the lifecycle states that an object may go through. It is used in event notificationsof state changes. ","*","/"),(0,n.yg)("p",null,"<","!-- Page 34 --",">"),(0,n.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 2000 4 enum LifecycleState ","{","Undefined,Created,Deleted,Moved,Copied ","}",";/","*"," This enumerated type identifies the states of objects that can be reserved (Lot, Durable and Machine). It is used inevent notifications of state changes. ","*","/ enum ReservationState ","{","UndefinedReservationState,Reserved,UnReserved ","}",";/","*"," This enumerated type represents the SEMI E10 states for Machines and Support Resources. It is used in eventnotifications of state changes. ","*","/ enum E10State ","{","E10Productive,E10Standby,E10Engineering,E10ScheduledDowntime,E10UnscheduledDowntime,E10NonscheduledTime ","}",";/","*"," TimeT is a ulonglong value (64 bits) that represents the number of 100 nanosecond increments that have passedsince a base time (October 15, 1582 at 00:00, the Universal Time Representation which refers to time in GreenwichMean Time). The specification for TimeT is: ","*","/ struct ulonglong ","{","unsigned long low;unsigned long high;","}","; typedef ulonglong TimeT;/","*"," TimeStamp is mapped to the data type of TimeT. ","*","/ typedef TimeT TimeStamp; typedef sequence TimeStampSequence;/","*"," The notion of a specific interval of time denoting a start time and an end time is represented as a struct calledIntervalT. ","*","/ struct IntervalT ","{","TimeT lower","_","bound ;TimeT upper","_","bound ;","}",";/","*"," TimeWindow is mapped to the data type IntervalT. ","*","/ typedef IntervalT TimeWindow;/","*"," Duration is mapped to the datatype TimeT. ","*","/ typedef TimeT Duration;/","*"," This structure is for the representation of a single schedule instance. It should be noted that EndTime shouldnever proceed StartTime. ","*","/"),(0,n.yg)("p",null,"<","!-- Page 35 --",">"),(0,n.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 20005 struct ResourceSchedule ","{","TimeStamp plannedStartTime;TimeStamp plannedEndTime;TimeStamp actualStartTime;TimeStamp actualEndTime;","}",";/","*"," The definition of a sequence of ResourceSchedules. This sequence is ordered in increasing time order and thatorder must be maintained in any manipulation of the sequence. ","*","/ typedef sequence ResourceScheduleSequence; 6.2 Global Exception Declaration s6.2.1 This section describes the stan dard CIM Framework exceptions that may be thrown by operations in anycomponent.Module: Global/","*"," This signal is raised when a lookup or find fails. ","*","/ exception NotFoundSignal ","{"," string errorMessage; ","}",";/","*"," This signal is raised when an add fails because an object already exists with the given identifier. Interfaces mayalso define and raise a DuplicateSignal. ","*","/ exception DuplicateIdentifierSignal ","{","string errorMessage;string duplicateIdentifier; ","}",";/","*","This signal is raised when an invalid state transition request is made of an object. ","*","/ exception InvalidStateTransitionSignal ","{","string errorMessage; ","}",";/","*","This signal is raised when a set attribute contains a value out of range. ","*","/ exception SetValueOutOfRangeSignal ","{","string errorMessage; ","}",";/","*"," This signal is raised when an incorrect TimePeriod is used. ","*","/ exception TimePeriodInvalidSignal ","{","string errorMessage; ","}",";/","*"," This signal is raised when a Property name is not valid. ","*","/ exception InvalidPropertyNameSignal ","{","}",";/","*"," This signal is raised when a a Property with this name is not defined. ","*","/ exception PropertyNotFoundSignal ","{","}",";/","*"," This signal is raised when a Property is not supported. ","*","/ exception UnsupportedPropertySignal ","{","}",";/","*"," This signal is raised when a Property is read-only and cannot be set. ","*","/ exception ReadOnlyPropertySignal ","{","}",";/","*"," This signal is raised when no other defined signal matches the error condition. ","*","/"),(0,n.yg)("p",null,"<","!-- Page 36 --",">"),(0,n.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 2000 6 exception FrameworkErrorSignal ","{","string errorMessage;unsigned long errorCode;any errorInformation; ","}",";/","*"," Definition of fields for FrameworkErrorSignal:errorMessage is a text field representing a description of the circumstances of the exception for use bydevelopers in debugging the exception.errorCode is a numeric field representing the code for the given exception.errorInformation is any further debugging information related to the circumstances of the exception.The errorCode has certain reserved values that are defined and standardized in the CIM Framework. 00000999 reserved for the CIM Framework. 10001999 reserved for extensions to the CIM Framework. 20002999 reserved for specializations of CIM Framework interfaces. 3000maximum reserved for implementers. /","*","/","*"," This errorCode should be used for any operation where the supplier has chosen to not provide implementation,but needs to communicate to the user that nothing has happened as a result of this operation invocation. ","*","/ const unsigned long NOT","_","IMPLEMENTED = 0;/","*"," This errorCode should be used for any operation where the supplier assumes a specialization will implement thisoperation. If this exception is received, the user will realize that an interface has not been properly specialized. ","*","/ const unsigned long IMPLEMENTED","_","BY","_","SUBCLASS = 1;/","*"," This errorCode should be used for any operation where an unknown exception has been caught by theimplementation and, rather than crashing, the implementation can map the unknown exception into this knownexception. This probably does not aid in program debugging but does prevent program crashing. ","*","/ const unsigned long UNKNOWN","_","EXCEPTION = 2;/","*"," This errorCode should be used for any invocation where some unknown error has occurred that left the serverobject in an ambiguous state. ","*","/ const unsigned long COMPLETION","_","UNKNOWN = 3; 6.3 Abstract Interface Type Defini tions6.3.1 Referenced Declarations6.3.1.1 The following declarations are not part of this specification, but are required for reference by AbstractInterface elements. These referenced declarations are defined in separate documents but are noted here asdependencies that appear in IDL compilations.Module: EquipmentTrackingInterface: Machine module EquipmentTracking ","{"," interface Machine ","{","}","; // Stub typedef sequence MachineSequence; exception MachineDuplicateSignal ","{"," ","}",";"),(0,n.yg)("p",null,"<","!-- Page 37 --",">"),(0,n.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 20007 exception MachineNotAssignedSignal ","{"," ","}","; exception MachineRemovalFailedSignal ","{"," ","}","; ","}","; // module EquipmentTracking Module: LaborInterface: Person module Labor ","{"," interface Person ","{","}","; // Stub typedef sequence PersonSequence; exception PersonDuplicateSignal ","{"," ","}","; exception PersonNotAssignedSignal ","{"," ","}","; exception PersonRemovalFailedSignal ","{"," ","}","; ","}","; // module Labor 6.3.2 Abstract Interface Declaration sModule: AbstractIF/","*"," The following IDL interfaces will be fully defined in the sections below. They are declared here as forwardreferences to support the sequence typedefs. ","*","/ interface Resource; interface Material; interface MaterialGroup; interface JobSupervisor; interface Job; interface JobRequestor;/","*"," Type definitions for sequences of interfaces instances. ","*","/ typedef sequence ResourceSequence; typedef sequence MaterialSequence; typedef sequence MaterialGroupSequence; typedef sequence JobSequence; typedef sequence JobSupervisorSequence; 6.4 Resource Abstract Interface G roup6.4.1 The Resource Abstract Interfa ce Group provides a set of abstractions that are globally useful. Figure 1 is theInformation Model for the Resource Abstract Interface Group."),(0,n.yg)("p",null,"<","!-- Page 38 --",">"),(0,n.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 2000 8 Resource Resource Abstract Interface Group Nam edEntity Ow nedEntity 0 ..1 0 ..","*"," 0 ..1 0 ..","*"," o w n e d b y Figure 1Resource Abstract Interface Group Information Model 6.4.1.1 All CIM Framework interfaces will inherit from one of the interfaces shown in Figure 1. NamedEntityprovides the most basic naming functions. An OwnedEntity is a NamedEntity with functions supporting the conceptof ownership. A Resource is an OwnedEntity which also takes an active role in product manufacturing.6.4.2 Named Entity InterfaceModule: AbstractIFInterface: NamedEntityInherited Interface: Implementation-dependent.Description: The abstract interface NamedEntity provides the concept of a named item. This allowsfor comparison and conversion of names via a standard object.Exceptions: None.Published Events: None.Provided Services: interface NamedEntity ","{"),(0,n.yg)("p",null,"<","!-- Page 39 --",">"),(0,n.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 20009 /","*"," Set and get the name. The NamedEntity interface does not specify scoping of names or enforce uniqueness ofnames. This could allow distinct instances of a NamedEntity to use the same string as a name. ","*","/ void setName (in string name)raises (Global::FrameworkErrorSignal); string getName ( )raises (Global::FrameworkErrorSignal);/","*"," Tests the equality of the name with the name provided as an argument. ","*","/ boolean isNamed (in string testName)raises (Global::FrameworkErrorSignal); ","}","; // NamedEntityContracted Services: None.Dynamic Model: None. 6.4.3 Owned Entity Interface6.4.3.1 The concept of ownership in th e CIM Framework relates to the hierarchical structure that may be definedwhere one object owns another object. This should not be confused with the business concept of ownershiprelating to an items value as an asset.Module: AbstractIFInterface: OwnedEntityInherited Interface: NamedEntityDescription: The abstract interface OwnedEntity provides for the concept of an owned entity. Theremay be only one owner for each instance of an OwnedEntity. The OwnedEntity is ableto communicate with the owner to request services, or forward information of interest. Tobuild a parts of hierarchy, a series of ownerships can be established.Exceptions: None.Published Events: None.Provided Services: interface OwnedEntity : NamedEntity ","{","/","*"," Set and get owner. ","*","/ void setOwner (in NamedEntity owner)raises (Global::FrameworkErrorSignal); NamedEntity getOwner ( )raises (Global::FrameworkErrorSignal); ","}","; // OwnedEntityContracted Services: None.Dynamic Model: None. 6.4.4 Resource InterfaceModule: AbstractIFInterface: ResourceInherited Interface: OwnedEntity"),(0,n.yg)("p",null,"<","!-- Page 40 --",">"),(0,n.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 2000 10 Description: Resource is an abstract inherited interface for any entity in the factory that takes an activerole in advancing a product along its manufacturing life cycle (adds value). This includesthe factory itself, personnel, production, planning and scheduling resources, and all of themachines used for processing, transporting, and storing materials. Resource provides acommon set of services for monitoring and control. Resource uses the NamedEntity andOwnedEntity characteristics together to allow for the building of resource hierarchies.There must be a clear division between the state of the Resource and the condition of thephysical entity which the Resource represents. For instance, a Machine is a resource, butthe fact that it is Out of Service may not mean the physical equipment is shutdown onthe shop floor. In fact, the equipment may be operating in manual mode. The Resourcestate represents the availability of the Resource object to accept work for the factorysystem.Exceptions: None.Published Events: None.Provided Services: interface Resource : OwnedEntity ","{","/","*"," Perform the startup activities for this Resource. Should be implemented by Resource specializations. ","*","/ void startUp ( )raises (Global::FrameworkErrorSignal);/","*"," Perform normal shutdown activities for this Resource. Normal is defined as allowing the Resource to completeany current activities and gracefully shutdown. ","*","/ void shutdownNormal ( )raises (Global::FrameworkErrorSignal);/","*"," Perform immediate shutdown activities for this Resource. Immediate is defined as aborting or terminating anycurrent activities and stopping activity as soon as possible. This should be implemented by Resource specializations.","*","/ void shutdownImmediate ( )raises (Global::FrameworkErrorSignal);/","*"," Respond with the receivers level in the Resource hierarchy. Resource specifies that each different type ofResource provide a resourceLevel identifier. string resourceLevel ( )raises (Global::FrameworkErrorSignal);/","*"," The following service provides name scoping for Resources. Resource name scoping makes use of the notion ofResource level and the ownership hierarchy. For example, unique identification of MachineResources within aMachine is possible, but to identify them outside the Machine additional information about their ownership will berequired.Thus: nameQualifiedTo (Machine) sent to the ProcessResource named Chamber answersTestMachine",">","Chamber.If the Machine was owned by a Factory named TestFactory, then:nameQualifiedTo (Factory) sent to the ProcessResource answersTestFactory",">","TestMachine",">","Chamberwhere the ProcessResource has now been uniquely identified for the given Factory."),(0,n.yg)("p",null,"<","!-- Page 41 --",">"),(0,n.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200011 There is no limit to the number of levels that may be addressed this way. Based on the implementations ofnameQualifiedTo (string); a name need not always be concatenated, if a particular Resource level is not applicableto identification. ","*","/ string nameQualifiedTo (in string resourceLevel)raises (Global::FrameworkErrorSignal);/","*"," Returns the set of subordinate Resources for a given Resource. ","*","/ ResourceSequence subResources ( )raises (Global::FrameworkErrorSignal);/","*"," Answer if the resource is in service. In service means the resource is functional and ready to accept and performits normal tasks. Derivatives of Resource are expected to expand this state (e.g., add sub-interfaces) that explicitlydeal with such additional issues as capacity, normal work versus maintenance, etc. ","*","/ boolean isInService ( );/","*"," Answer if the resource is out of service. Out of service means the resource is unable to accept or begin new tasks.Previously begun tasks may continue in some cases. ","*","/ boolean isOutOfService ( ); ","}","; // ResourceContracted Services: None.Dynamic Model:Implementations of Resource may extend the state model by providing additional sub-states that are whollycontained within a state defined here. Extending the state model by the addition of state transitions is also an optionfor subtypes of Resource. IN SERVICE OUT OF SERVICE 3 42 51 Figure 2Resource Dynamic Model"),(0,n.yg)("p",null,"<","!-- Page 42 --",">"),(0,n.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 2000 12 Table 1 Resource State Definitions and Query Table State Definition Query for State viaIN SERVICE Resource is capable of interacting with otherresources with its full service interface.boolean isInService ( ); sent to the instance ofResource returns TRUE.OUT OF SERVICE Resource is not able to provide services boolean isOutOfService ( ); sent to the instance ofResource returns TRUE. Table 2 Resource State Transitions # Current State Trigger New State Action Comment1 Non Existent Object creation. OUT OFSERVICENone. Default entry. 2 OUT OFSERVICEstartUp ( ) or objectinitialization.IN SERVICE Initiate Resource andsubresources.startUp() service initiatesthe trigger.3 IN SERVICE shutdownNormal ( ). OUT OFSERVICEComplete currentexecution of resourcesnormally. shutdownNormal() serviceinitiates the trigger. 4 IN SERVICE shutdownImmediate ( ).Take resource out ofservice. OUT OFSERVICEStop execution ofresource immediately.shutdownImmediate()service initiates the trigger. 5 OUT OFSERVICEResource removed. Non Existent None. 6.5 Material Abstract Interface Gr oup6.5.1 The CIM Framework uses a co mmon architecture for identifying, grouping and locating materials. Anymaterial has an identification, history, location, and associations to any material containers that contain it. Materialcan also be in multiple material groups that physically (same location or carrier) or logically (same lot, same processbatch, same product family, etc.) associate material. Specializations of material include products, durables andconsumables. Specializations of material groups include product groups, lots, and process groups."),(0,n.yg)("p",null,"<","!-- Page 43 --",">"),(0,n.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200013 NamedEntity(from Resource AIG) Material Abstract Interface Group MaterialTrackingLocation(from Machine Abstract Interfaces)MaterialGroup 0..","*"," contains 0..","*"," PositionalContainer(from Durables Management) MaterialContainer(from Durables Management) InventoryRegionSystem(from Inventory Region Mgt Comp) Material0..","*","0..1 0..","*","0..1holds0..","*","0..","*"," 0..","*","0..","*"," is grouped in0..","*"," 0..1 0..","*"," 0..1holds at position 0..1 0..","*"," 0..1 0..","*"," holdsin 0..","*"," 0..","*"," 0..","*"," 0..","*"," isassociatedwith Figure 3Material Abstract Interface Group Information Model 6.5.2 Material InterfaceModule: AbstractIFInterface: MaterialInherited Interface: NamedEntityDescription: Material is an abstract interface for physical items or substances that are required asinputs to the manufacturing process. This includes the product itself, consumables anddurables used in the manufacturing process. It does not include the resources used totransform material into product.Exceptions: None.Published Events: None.Provided Services: interface Material : NamedEntity ","{","/","*"," Set and get the identifier for this material. The identifier is unique within the extent of all material for an MESFactory. ","*","/ string getIdentifier ( )raises (Global::FrameworkErrorSignal); void setIdentifier (in string identifier)raises (Global::FrameworkErrorSignal,Global::DuplicateIdentifierSignal);/","*"," Returns the material groups of which the receiver is a member. ","*","/ MaterialGroupSequence materialGroups ( )raises (Global::FrameworkErrorSignal);"),(0,n.yg)("p",null,"<","!-- Page 44 --",">"),(0,n.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 2000 14 /","*"," Answers whether the receiver is a member of the material group indicated by the argument. ","*","/ boolean isMemberOf (in MaterialGroup aMaterialGroup)raises (Global::FrameworkErrorSignal); ","}","; // MaterialDynamic Model: None. 6.5.3 Material Group InterfaceModule: AbstractIFInterface: MaterialGroupInherited Interface: NamedEntityDescription: MaterialGroup is the abstract interface for any aggregation of Material. interface MaterialGroup : NamedEntity ","{","Exceptions:/","*"," Signals an attempt to add Material to the MaterialGroup that is already in the group. ","*","/ exception DuplicateMaterialSignal ","{","Material aMaterial;","}",";/","*"," Signals an attempt to add a MaterialGroup to a MaterialGroup that is already in the group. ","*","/ exception DuplicateMaterialGroupSignal ","{","Material aMaterialGroup;","}",";/","*"," Signals an attempt to remove Material that wasnt found in this MaterialGroup. ","*","/ exception MaterialRemovalFailedSignal ","{","Material aMaterial;","}",";/","*"," Signals an attempt to remove a MaterialGroup that wasnt found in this MaterialGroup. ","*","/ exception MaterialGroupRemovalFailedSignal ","{","MaterialGroup aMaterialGroup;","}",";Published Events: None.Provided Services:/","*"," Set and get the unique identifier for this group. ","*","/ string getIdentifier ( )raises (Global::FrameworkErrorSignal); void setIdentifier (in string identifier)raises (Global::FrameworkErrorSignal,Global::DuplicateIdentifierSignal);/","*"," Adds the argument MaterialSequence to the collection of Matrial held by the receiver. ","*","/ void addMaterials (in MaterialSequence aMaterialSequence)raises (Global::FrameworkErrorSignal,DuplicateMaterialSignal);/","*"," Adds the argument Material to the collection of Material held by the receiver. ","*","/ void addMaterial (in Material aMaterial)raises (Global::FrameworkErrorSignal,DuplicateMaterialSignal);/","*"," Removes the Material indicated from the MaterialGroup. Throws the exception if not found. ","*","/"),(0,n.yg)("p",null,"<","!-- Page 45 --",">"),(0,n.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200015 void removeMaterial (in Material aMaterial)raises (Global::FrameworkErrorSignal,MaterialRemovalFailedSignal,Global::NotFoundSignal);/","*"," Remove and return all Material from the MaterialGroup. ","*","/ MaterialSequence removeAllMaterials ( )raises (Global::FrameworkErrorSignal);/","*"," Add the argument MaterialGroup to this MaterialGroup. ","*","/ void addMaterialGroup (in MaterialGroup aMaterialGroup)raises (Global::FrameworkErrorSignal,DuplicateMaterialGroupSignal);/","*"," Removes the argument MaterialGroup from this MaterialGroup. ","*","/ void removeMaterialGroup (in MaterialGroup aMaterialGroup)raises (Global::FrameworkErrorSignal,MaterialGroupRemovalFailedSignal,Global::NotFoundSignal);/","*"," Remove and return all MaterialGroups from this MaterialGroup. ","*","/ MaterialGroupSequence removeAllMaterialGroups ( )raises (Global::FrameworkErrorSignal);/","*"," Returns the collection of material in this MaterialGroup. ","*","/ MaterialSequence allMaterials ( )raises (Global::FrameworkErrorSignal);/","*"," Returns all the MaterialGroups in this MaterialGroup. ","*","/ MaterialGroupSequence allMaterialGroups ( )raises (Global::FrameworkErrorSignal);/","*"," Returns the count of the items in the MaterialGroup. ","*","/ long count ( )raises (Global::FrameworkErrorSignal); ","}","; // MaterialGroupDynamic Model: None. 6.6 Job Supervision Abstract Inter face Group6.6.1 The Job Supervision Abstract Interface Group provides the abstractions common to creating, executing andmanaging a job, where a job can be defined as some system level operation which may be requested from theJobSupervisor. The job often spans a significant amount of time and multiple resources within the system. It isintended for specialization to provide specific job supervisors and jobs to provide system solutions."),(0,n.yg)("p",null,"<","!-- Page 46 --",">"),(0,n.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 2000 16 Resource(from Resource AIG)OwnedEntity(from Resource AIG) Job Supervision Abstract Interface Group JobSupervisor Job0..","*","1..1 0..","*","1..1 supervises JobRequestor 1..","*"," 0..","*"," 1..","*"," 0..","*"," contractsworkfrom 1..","*"," 1 1..","*"," 1 tracksprogress viaJobSpecification","<","\\",">"," Figure 4Job Supervision Abstract Interface Group Information Model 6.6.1.1 The basic Job Supervision Abs tract Interface Group does not interact with other components, except to theextent that other components instantiate its interfaces. Figure 4 shows how the interfaces of Job Supervision relate toone another.6.6.1.2 A Job Specification is a sequen ce of properties containing the parameters required to sufficiently define thework to be done. This sequence is passed by the JobRequestor to the JobSupervisor in the Job request message. Seethe JobSupervisor interface for more details.6.6.1.3 JobSupervision levels are hiera rchical. One level may accept a Job and delegate portions of that Job tolower levels. Jobs, however, are not purely hierarchical. A Job accepted by one JobSupervisor may be broken down,along with other Jobs of that component and reconstituted as needed to optimize the activities of the factory.6.6.1.4 For example, a ProductReques t may ask for 15 wafers of a particular product. The ProductRequestManagermay delegate a LotJob to Factory Operations with a Lot containing those 15 wafers and 10 more from a differentProductRequest. In the factory, this Lot may be split up and processed in smaller groups at various stages or, asscrap reduces the wafer count, combined with another small lot to create a more optimal process group. The JobSupervision implementation is allowed great latitude to optimize performance. Its only requirement is to fulfill thespecification of the Job.6.6.2 JobSupervisor InterfaceModule: AbstractIFInterface: JobSupervisorInherited Interface: Resource"),(0,n.yg)("p",null,"<","!-- Page 47 --",">"),(0,n.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200017 Description: The JobSupervisor manages all the Jobs being performed by the component whichimplements it. It receives the requests for work, facilitates the creation of a Job for thetask and returns (a reference to) that Job.A JobSupervisor will have a well defined domain which it can call on to perform work.These may be CIM Framework Resources if it delegates the work, or internal resources ifit performs the work itself. Only activity requests which can be accomplished within thedomain of a JobSupervisor should be issued to/accepted by that JobSupervisor.Jobs, as subtypes of NamedEntity, are named by the JobSupervisor in such a way thattheir name attribute may be used to query for the Job. Jobs from different JobSupervisorsmay have the same name.The definition of the work to be performed is the JobSpecification, a sequence ofname/value pairs (see Properties definition). Specializations of Job Supervision mayrequire certain properties in the JobSpecification. Some commonly useful properties aredefined in the following table. When possible, specializations should reuse thesedefinitions. Specializations should also document the allowable and mandatory propertiesthat are supported. See Job definition for more information. interface JobSupervisor : Resource ","{","Type Definitions:/","*"," Type for returning results of Job execution. ","*","/ typedef Global::NameValueSequence Results;JobSpecification Properties: Name Value Type DescriptionJobType string The kind of Job to run. This is useful when a JobSupervisor can initiate more than onetype of Job. String values reserved for this property are:ProductRequestJobType,LotJobType,AreaJobType,ProcessMachineJobType,TransportJobType,PMJobType,ControlStrategyJobType,AlgorithmJobType.Priority long Integer value, ranges from 1 to 99, where 1 is the highest priority and 99 is the lowest.Deadline TimeStamp The Job is expected to be completed no later than the specified value of the Deadline. Exceptions:/","*"," Requested Job was rejected. ","*","/ exception JobRejectedSignal ","{","string errorMessage; ","}",";/","*"," Requested Job was not found ","*","/ exception JobNotFoundSignal ","{","string errorMessage;string missingJobName; ","}",";Published Events:/","*"," Provide lifecycle event for tracking ","*","/"),(0,n.yg)("p",null,"<","!-- Page 48 --",">"),(0,n.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 2000 18 const string JobLifecycleSubject =/JobSupervision/JobSupervisor/JobLifecycle;/","*"," The use of name here (and in all other events) indicates the string value for the name or identifier of the Job towhich the event refers. Since filtering does not support object reference comparisons, the filtering must be on thename of the object. ","*","/ struct JobLifecycleFilters ","{","Global::Property name;Global::Property lifecycle;","}",";JobLifecycleFilters Properties: Name Value Type DescriptionName string The name of the Job.Lifecycle Global::LifecycleState New lifecycle state. struct JobLifecycleEvent ","{","string eventSubject;Global::TimeStamp eventTimeStamp;JobLifecycleFilters eventFilterData;Global::Properties eventNews;Job aJob; // on Delete, aJob is nil","}",";Provided Services:/","*"," Request that work be done according to the referred specification. A Job which represents the work is returned forfuture reference. The post-condition for this operation is the specified Job successfully created. ","*","/ Job requestJob (in Global::Properties aJobSpecification,in JobRequestor aJobRequestor)raises (Global::FrameworkErrorSignal,JobRejectedSignal);/","*"," Request that work be done according to the Job specification. This operation blocks until the Job completes.Results generated by the Job are returned. The post-condition for this operation is a successful execution of thespecified Job. This interface offers a lightweight alternative to requestJob that does not require that requestorssupport the JobRequestor interfaces (e.g., informJobStateChange operation). A Job may or may not be created byrunJob, but if created, the Job may be accessed with the Job query operations of JobSupervisor. ","*","/ Results runJob (in Global::Properties aJobSpecification)raises (Global::FrameworkErrorSignal,JobRejectedSignal);/","*"," Ask whether the Job specified by the JobSpecification would be accepted for current or future (queued)processing if a requestJob or runJob message were issued now. ","*","/ boolean canPerform (in Properties aJobSpecification)raises (Global::FrameworkErrorSignal);/","*"," Command to begin the pausing of all Jobs of this JobSupervisor which can be paused (e.g. Jobs that have notreached the Finished state). ","*","/ void pauseAllJobs ()raises (Global::FrameworkErrorSignal);/","*"," Command to resume all Jobs of this JobSupervisor which are currently Paused. ","*","/"),(0,n.yg)("p",null,"<","!-- Page 49 --",">"),(0,n.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200019 void resumeAllJobs ()raises (Global::FrameworkErrorSignal);/","*"," This command aborts all the Jobs under the control of the JobSupervisor immediately, without regard to theimpact of abruptly halting the Job. This service should be used with great caution. It may result in irrevocablechange to factory or material state. ","*","/ void abortAllJobs ()raises (Global::FrameworkErrorSignal);/","*"," This command stops all Jobs under control of the JobSupervisor, as quickly as possible. Stopping Jobs should notresult in damage to the factory or material being processed. ","*","/ void stopAllJobs ()raises (Global::FrameworkErrorSignal);/","*"," This service removes a Job which is in the terminated state. If required, persistent information about the Job maybe captured in a history entry. Jobs may also be removed based on other archiving rules. ","*","/ void removeFinishedJob (in Job aJob)raises (Global::FrameworkErrorSignal);/","*"," Find a Job by name. A Job is a NamedEntity ","*","/ Job findJobNamed (in string jobName)raises (Global::FrameworkErrorSignal,JobNotFoundSignal);/","*"," Find a queued Job by name. ","*","/ Job findQueuedJobNamed (in string jobName)raises (Global::FrameworkErrorSignal,JobNotFoundSignal);/","*"," Find an active Job by name. ","*","/ Job findActiveJobNamed (in string jobName)raises (Global::FrameworkErrorSignal,JobNotFoundSignal);/","*"," Find a canceled Job by name. ","*","/ Job findCanceledJobNamed (in string jobName)raises (Global::FrameworkErrorSignal,JobNotFoundSignal);/","*"," Find a finished Job by name. ","*","/ Job findFinishedJobNamed (in string jobName)raises (Global::FrameworkErrorSignal,JobNotFoundSignal);/","*"," Return all the specified Jobs. The JobSequence may be empty. ","*","/ JobSequence allJobs ( )raises (Global::FrameworkErrorSignal); JobSequence allQueuedJobs ( )raises (Global::FrameworkErrorSignal); JobSequence allCanceledJobs ( )raises (Global::FrameworkErrorSignal);"),(0,n.yg)("p",null,"<","!-- Page 50 --",">"),(0,n.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 2000 20 JobSequence allActiveJobs ( )raises (Global::FrameworkErrorSignal); JobSequence allExecutingJobs ( )raises (Global::FrameworkErrorSignal); JobSequence allPausingJobs ( )raises (Global::FrameworkErrorSignal); JobSequence allPausedJobs ( )raises (Global::FrameworkErrorSignal); JobSequence allStoppingJobs ( )raises (Global::FrameworkErrorSignal); JobSequence allAbortingJobs ( )raises (Global::FrameworkErrorSignal); JobSequence allFinishedJobs ( )raises (Global::FrameworkErrorSignal); JobSequence allStoppedJobs ( )raises (Global::FrameworkErrorSignal); JobSequence allAbortedJobs ( )raises (Global::FrameworkErrorSignal); JobSequence allCompletedJobs ( )raises (Global::FrameworkErrorSignal); ","}","; // JobSupervisorContracted Services: None.Dynamic Model: Inherited. 6.6.3 Job InterfaceModule: AbstractIFInterface: JobInherited Interface: OwnedEntityDescription: The Job interface represents a unit of work requested of an associated JobSupervisor andperformed (or facilitated) by a factory entity. A Job generally results in some change ofthe overall factory state. How the entities that supply the Job and JobSupervisorinterfaces actually perform the work (or delegation of work) is an implementationdecision. A Job is expected (but not required) to take a non-zero time to perform andhave a non-zero chance of refusal or failure. A Job may encapsulate a decomposition intoa sequence of jobs/tasks/activities which are delegated to lower level job supervisors. TheJob exists during the execution timeframe. The more persistent record of the Job shouldbe maintained in a history entry. interface Job : OwnedEntity ","{","Exceptions:Published Events:/","*"," Any time the Jobs state changes. ","*","/")))}p.isMDXComponent=!0}}]);