"use strict";(globalThis.webpackChunksemiconductor_docs=globalThis.webpackChunksemiconductor_docs||[]).push([[4480],{2073(e,n,t){t.d(n,{A:()=>i});var a=t(6540);const i=function({pdfLink:e,pdfSize:n,title:t,description:i}){if(!e)return null;const r=e.startsWith("http"),o=(e=>{if(!e)return null;try{const n=new URL(e,r?void 0:window.location.origin);return n.pathname.split("/").pop()}catch{return e.split("/").pop()}})(e);return a.createElement("div",{className:"pdf-download-card"},a.createElement("div",{className:"pdf-download-card__header"},a.createElement("div",{className:"pdf-download-card__icon"},"\ud83d\udce5"),a.createElement("div",{className:"pdf-download-card__title"},a.createElement("h3",null,"\u4e0b\u8f7d\u5b8c\u6574PDF"),t&&a.createElement("p",{className:"pdf-download-card__doc-title"},t))),a.createElement("div",{className:"pdf-download-card__info"},a.createElement("div",{className:"pdf-download-card__meta"},a.createElement("span",{className:"pdf-download-card__label"},"\u6587\u4ef6\u5927\u5c0f:"),a.createElement("span",{className:"pdf-download-card__value"},"string"==typeof(s=n)?s:s<1048576?`${(s/1024).toFixed(1)}KB`:`${(s/1024/1024).toFixed(1)}MB`)),i&&a.createElement("div",{className:"pdf-download-card__description"},i),r&&a.createElement("div",{className:"pdf-download-card__notice"},a.createElement("span",{className:"pdf-download-card__notice-icon"},"\u2139\ufe0f"),a.createElement("span",null,"\u6b64\u6587\u4ef6\u6258\u7ba1\u5728GitHub Releases\uff0c\u53ef\u80fd\u9700\u8981GitHub\u8d26\u53f7"))),a.createElement("div",{className:"pdf-download-card__actions"},a.createElement("a",{href:e,className:"pdf-download-card__button pdf-download-card__button--primary",download:r?void 0:o,target:r?"_blank":void 0,rel:r?"noopener noreferrer":void 0},a.createElement("span",{className:"pdf-download-card__button-icon"},"\u2b07\ufe0f"),"\u4e0b\u8f7dPDF"),r&&a.createElement("a",{href:e,className:"pdf-download-card__button pdf-download-card__button--secondary",target:"_blank",rel:"noopener noreferrer"},a.createElement("span",{className:"pdf-download-card__button-icon"},"\ud83d\udd17"),"\u5728\u65b0\u7a97\u53e3\u6253\u5f00")));var s}},3742(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var a=t(8168),i=(t(6540),t(5680));t(2073);const r={title:"P39-0304 - E2 \xa9 SEMI 2004...",description:"SEMI\u6807\u51c6\u6587\u6863",sidebar_label:"P39-0304 - E2 \xa9 SEMI 2004...",sidebar_position:1190,tags:["SEMI","Standard"],custom_props:{source_type:"pdf",source_file:"semi-chapter-119.pdf",chapter:119,page_count:50}},o=void 0,s={unversionedId:"standards/semi/semi-chapter-119",id:"standards/semi/semi-chapter-119",title:"P39-0304 - E2 \xa9 SEMI 2004...",description:"SEMI\u6807\u51c6\u6587\u6863",source:"@site/docs/standards/semi/semi-chapter-119.md",sourceDirName:"standards/semi",slug:"/standards/semi/semi-chapter-119",permalink:"/semiconductor-docs/docs/standards/semi/semi-chapter-119",draft:!1,editUrl:"https://github.com/your-org/semiconductor-docs/tree/main/docs/standards/semi/semi-chapter-119.md",tags:[{label:"SEMI",permalink:"/semiconductor-docs/docs/tags/semi"},{label:"Standard",permalink:"/semiconductor-docs/docs/tags/standard"}],version:"current",sidebarPosition:1190,frontMatter:{title:"P39-0304 - E2 \xa9 SEMI 2004...",description:"SEMI\u6807\u51c6\u6587\u6863",sidebar_label:"P39-0304 - E2 \xa9 SEMI 2004...",sidebar_position:1190,tags:["SEMI","Standard"],custom_props:{source_type:"pdf",source_file:"semi-chapter-119.pdf",chapter:119,page_count:50}}},l={},d=[],p={toc:d};function c({components:e,...n}){return(0,i.yg)("wrapper",(0,a.A)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,i.yg)("p",null,'PdfDownloadCard\npdfLink="/pdfs/semi/119.pdf"\npdfSize="0.63MB"\ntitle="P39-0304 - E2 \xa9 SEMI 2004..."\ndescription="SEMI\u6807\u51c6\u6587\u6863\uff0c\u517150\u9875"\n/'),(0,i.yg)("h1",{id:"\u6587\u6863\u6807\u9898"},"\u6587\u6863\u6807\u9898"),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 4\nTable 1  Unsigned-Integer Examples\nUnsigned-Integer Value Binary Representation\n0                                       00000000\n127                                     01111111\n128                                     10000000                                     00000001\n16,383                                   11111111                                   01111111\n16,384 10000000 10000000 00000001"),(0,i.yg)("ol",{start:7},(0,i.yg)("li",{parentName:"ol"},"2.2  A signed-integer follows the same byte-continuation scheme as an unsigned-integer, and is stored in signed-\nmagnitude form, with the significand left-shifted one bit and the sign bit stored in the least significant bit of the low-\norder (first) byte. A sign bit of 0 indicates a positive number, and a sign bit of 1 indicates a negative number. Both\nrepresentations of zero (+0 and -0) should be treated as numerically equivalent for the purposes of comparison.")),(0,i.yg)("p",null,"Figure 2\nSigned-Integer Representation"),(0,i.yg)("p",null,"Table 2  Signed Integer Examples\nSigned Integer Value Binary Representation\n0                                       00000000\n+1                                      00000010\n\u22121                                      00000011\n+63                                     01111110\n\u221264                                     10000001                                     00000001\n+8,191                                   11111110                                   01111111\n\u22128,192 10000001 10000000 00000001"),(0,i.yg)("ol",{start:7},(0,i.yg)("li",{parentName:"ol"},"2.3  EXCEPTION HANDLING  \u2014    OASIS  processors  which  only  support  integer  data  in  a  restricted  space  (e.g.,\n32-bit space) should treat any magnitude outside of this space as a fatal error."),(0,i.yg)("li",{parentName:"ol"},"3  Reals"),(0,i.yg)("li",{parentName:"ol"},"3.1  A real  number  may  be  stored  in  one  of  several  rational  forms,  or  as  a  single-precision  4-byte  (ieee-4)    or\ndouble-precision 8-byte (ieee-8) floating point value. The rational forms are usually more compact than the floating-\npoint  forms,  and  have  the  advantage  of  being  able  to  precisely  represent  many  values  which  can  only  be\napproximated by the binary floating point representation. The type of representation is stored in an unsigned-integer\nwhich precedes the significant portion of the real:")),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 5\nTable 3  Real Number Types\nFormat                                                                Meaning\n\u20180\u2019 unsigned-integer Positive whole number\n\u20181\u2019 unsigned-integer                                          Negative                                          whole                                          number\n\u20182\u2019 unsigned-integer                                              Positive                                              reciprocal\n\u20183\u2019 unsigned-integer                                             Negative                                             reciprocal\n\u20184\u2019 unsigned-integer unsigned-integer                                    Positive                                    ratio\n\u20185\u2019 unsigned-integer unsigned-integer                                   Negative                                   ratio\n\u20186\u2019 IEEE-4-byte-float Single-precision floating point\n\u20187\u2019 IEEE-8-byte-float Double-precision floating point"),(0,i.yg)("ol",{start:7},(0,i.yg)("li",{parentName:"ol"},"3.2  In  types  0  and  1,  the  real  is  a  whole  number\u2014its  fractional  portion  is  zero.  In  types  2  and  3,  the  unsigned-\ninteger represents the denominator of a reciprocal, with an implicit numerator of 1. Types 4 and 5 are ratios, with the\nnumerator listed first, followed by the denominator. Types 6 and 7 are binary floating point numbers in IEEE 754-\n1985 format, with the least significant byte of the fraction (byte 0) stored first\n.")),(0,i.yg)("p",null,"Figure 3\nIEEE Floating Point Formats"),(0,i.yg)("p",null,"Table 4  Real Number Examples\nValue Rational Form IEEE-4 Form\n0. 0 00000000 00000000 00000110 00000000 00000000 00000000 00000000"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"0 00000000 00000001 00000110 00000000 00000000 10000000 00111111\n\u22120.5 00000011 00000010 00000110 00000000 00000000 00000000 10111111")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"3125 00000100 00000101 00010000 00000110 00000000 00000000 10100000 00111110\n1/3 00000010 00000011 00000110 10101011 10101010 10101010 00111110\n\u22122/13 00000101 00000010 00001101 00000110 11011001 10001001 00011101 10111110")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"3.3  EXCEPTION HANDLING  \u2014    For  types  2\u20135,  a  denominator  of  0  should  be  treated  as  a  fatal  error.  A  type\noutside the range of 0\u20137 should be treated as a fatal error.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"4  Strings")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"4.1  A string is a sequence of zero or more bytes (\u201ccharacters\u201d) preceded by an unsigned-integer representing the\nnumber of characters in the string:"))),(0,i.yg)("p",null,"string  ->  length byte*"),(0,i.yg)("p",null,"Strings in OASIS are further sub-typed by semantic. A b-string (\u201cbinary string\u201d) is a string which may contain any\ncombination  of  8-bit  character  codes  in  any  sequence.  An  a-string  (\u201cASCII  string\u201d)  may  contain  only  printable\nASCII  character  codes  (hexadecimal  21-7E)  plus  the  SP  (space)  character  (hexadecimal  20),  in  any  sequence.  An\nn-string (\u201cname string\u201d) may contain only printable ASCII character codes (hexadecimal 21-7E), and must have a\nlength greater than zero."),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 6\n7. 4.2  The  set  of  printable  ASCII  characters  consists  of  hexadecimal  character  codes  21-7E.  In ascending order of\ncharacter code, we have:"),(0,i.yg)("p",null,'!"#$%&\u2019()*+,-./0123456789:;<=>?@       ',"[21-40]","\nABCDEFGHIJKLMNOPQRSTUVWXYZ[","]","^_\u2018       ","[41-60]","\nabcdefghijklmnopqrstuvwxyz{|}~         ","[61-7E]"),(0,i.yg)("p",null,"This excludes space (SP), tabs (HT, VT), and all other control characters.\n7. 4.3  EXCEPTION HANDLING\n\u2014    OASIS  processors  should  treat  illegal  characters  in  a-strings  or  n-strings  as\nfatal errors. Zero-length n-strings should also be treated as fatal errors.\n7. 5  Deltas\n7. 5.1  A delta represents geometric data (coordinates, vectors, planar offsets, etc.).\n7. 5.2  A 1-delta is  stored  as  a  signed-integer  and  represents  a  horizontal  or  vertical  displacement.  Bit  0  encodes\ndirection:  0  for  east  or  north,  1  for  west  or  south.  The  remaining  bits  are  the  magnitude.  Horizontal  or  vertical\nalignment is implied by context.\n7. 5.3  A 2-delta is  stored  as  an  unsigned-integer  and  represents  a  horizontal  or  vertical  displacement.  Bits  0-1\nencode direction: 0 for east, 1 for north, 2 for west, and 3 for south. The remaining bits are the magnitude.\n7. 5.4  A 3-delta is  stored  as  an  unsigned-integer  and  represents  a  horizontal,  vertical,  or  45-degree  diagonal\ndisplacement.  Bits  0-2  encode  direction:  0  for  east,  1  for  north,  2  for  west,  3  for  south,  4  for  northeast,  5  for\nnorthwest,  6  for  southwest,  and  7  for  southeast.  The  remaining  bits  are  the  magnitude  (for  horizontal  and  vertical\ndeltas) or the magnitude of the projection onto the x- or y-axis (for 45-degree deltas).\n7. 5.5  A g-delta has two alternative forms and is stored either as a single unsigned-integer or as a pair of unsigned-\nintegers. The first form is indicated when bit 0 is zero, and represents a horizontal, vertical, or 45-degree diagonal\ndisplacement, with bits 1-3 encoding direction, and the remaining bits storing the magnitude, in the same fashion as\na 3-delta.  The  second  form  represents  a  general (x,y) displacement and is a pair of unsigned-integers.  Bit  0  of  the\nfirst  integer  is  1.  Bit  1  of  the  first  integer  is  the  x-direction  (0  for  east,  1  for  west).  The  remaining  bits  of  the  first\ninteger  represent  the  magnitude  in  the  x-direction.  Bit  0  of  the  second  integer  is  the  y-direction  (0  for  north,  1  for\nsouth). The remaining bits of the second integer represent the magnitude in the y-direction. Both forms may appear\nin a list of g-deltas."),(0,i.yg)("p",null,"Figure 4\nDelta Types"),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 7\nTable 5  Delta Examples\nBit Pattern Type Meaning\n11111001 00100011 1-delta\n\u2206 = -2300\n11111000 00100011 1-delta\n\u2206 = +2300\n10011000 00101010 2-delta\n\u2206x = +1350\n10011011 00101010 2-delta\n\u2206y = -1350\n11001101 00000001 3-delta\n\u2206x = -25, \u2206y = +25\n11010111 00000111 3-delta\n\u2206x = +122, \u2206y = -122\n11101001 00000011 01111010 g-delta\n2"),(0,i.yg)("p",null,"\u2206x = +122, \u2206y = +61\n11101100 00000101 g-delta\n1"),(0,i.yg)("p",null,"\u2206x = -46, \u2206y = -46\n10111011 00000001 10110111 00001111 g-delta\n2"),(0,i.yg)("p",null,"\u2206x = -46, \u2206y = -987"),(0,i.yg)("ol",{start:7},(0,i.yg)("li",{parentName:"ol"},"6  Repetitions"),(0,i.yg)("li",{parentName:"ol"},"6.1  A repetition  represents  an  \u201carray\u201d  of  cell  placements,  geometries,  or  text  elements.  The  repetition  is  part  of\nthe PLACEMENT, geometry,  or  TEXT  record  itself.  A  repetition  consists  of  an  unsigned-integer  which\nencodes the type, followed by any related repetition parameters:\nTable 6  Repetition Types\nTYPE\nFormat\n0\nre-use the previous repetition definition\n1 x-dimension y-dimension x-space y-space\n2            x-dimension            x-space\n3            y-dimension            y-space\n4\nx-dimension x-space\n1\n... x-space\nN-1")),(0,i.yg)("p",null,"5\nx-dimension grid x-space\n1\n... x-space\nN-1"),(0,i.yg)("p",null,"6\ny-dimension y-space\n1\n... y-space\nM-1"),(0,i.yg)("p",null,"7\ny-dimension grid y-space\n1\n... y-space\nM-1"),(0,i.yg)("p",null,"8 n-dimension m-dimension n-displacement m-displacement\n9            dimension            displacement\n10\ndimension displacement\n1\n... displacement\nP-1"),(0,i.yg)("p",null,"11\ndimension grid displacement\n1\n... displacement\nP-1"),(0,i.yg)("ol",{start:7},(0,i.yg)("li",{parentName:"ol"},"6.1.1  x-dimension,  y-dimension,  x-space,  y-space,  dimension,  n-dimension,  m-dimension,  and  grid  are  all\nunsigned-integers. displacement, n-displacement, and m-displacement are g-deltas."),(0,i.yg)("li",{parentName:"ol"},"6.2  TYPE 0 indicates that the previous repetition description, stored in modal variable repetition, is to be re-used.\n(See Section 10 on page 11.) No additional values are stored with this type."),(0,i.yg)("li",{parentName:"ol"},"6.3  TYPE  1  is an N-column (N > 1) by M-row (M > 1) matrix  with  uniform  horizontal  and  vertical  spacing\nbetween the elements. x-dimension is N - 2 and y-dimension is M - 2. The (x-offset, y-offset) (cumulative spacing\nin  the  (horizontal,vertical)  direction)  of  element  (i,j)  of  the  repetition  (i  =  0,  ...,  N-1  and  j  =  0,  ...,  M-1)  is\n(i ",(0,i.yg)("em",{parentName:"li"}," x-space, j ")," y-space)."),(0,i.yg)("li",{parentName:"ol"},"6.4  TYPE 2 is  an  N-column  (N  >  1)  by  1-row vector with uniform horizontal spacing between the elements. x-\ndimension is N - 2. The (x-offset, y-offset) (cumulative spacing in the (horizontal,vertical) direction) of element i of\nthe repetition (i = 0, ..., N-1) is (i * x-space, 0)."),(0,i.yg)("li",{parentName:"ol"},"6.5  TYPE  3  is  a  1-column  by  M-row  (M  >  1)  vector  with  uniform  vertical  spacing  between  the  elements.  y-\ndimension is M - 2. The (x-offset, y-offset) (cumulative spacing in the (horizontal,vertical) direction) of element j of\nthe repetition (j = 0, ..., M-1) is (0, j * y-space).")),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 8\n7. 6.6  TYPE 4 is an N-column (N > 1) by 1-row vector with (potentially) non-uniform horizontal spacing between\nthe elements. x-dimension is N - 2. The (x-offset, y-offset) (cumulative spacing in the (horizontal,vertical) direction)\nof element i of the repetition (i = 0, ..., N-1) is (x-space\n0"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"... + x-space\ni\n, 0), with x-space\n0\n= 0.")),(0,i.yg)("ol",{start:7},(0,i.yg)("li",{parentName:"ol"},"6.7  TYPE 5 is identical to TYPE 4, except that all offset values must be multiplied by grid during expansion of\nthe repetition."),(0,i.yg)("li",{parentName:"ol"},"6.8  TYPE 6 is a 1-column by M-row (M > 1) vector with (potentially) non-uniform vertical spacing between the\nelements. y-dimension is M - 2. The (x-offset, y-offset) (cumulative spacing in the (horizontal,vertical) direction) of\nelement j of the repetition (j = 0, ..., M-1) is (0, y-space\n0")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"... + y-space\nj\n), with y-space\n0\n= 0.")),(0,i.yg)("ol",{start:7},(0,i.yg)("li",{parentName:"ol"},"6.9  TYPE 7 is identical to TYPE 6, except that all offset values must be multiplied by grid during expansion of\nthe repetition."),(0,i.yg)("li",{parentName:"ol"},"6.10  TYPE  8  is  an  N  (N  >  1)  by  M  (M  >  1)  repetition  with  uniform  and  (potentially)  diagonal  displacements\nbetween  the  elements.  n-dimension  is  N  -  2  and  m-dimension  is  M  -  2.  Defining  n-displacement  in  terms  of  its\ncomponents nx-space and ny-space (and similarly for m-displacement), the (x-offset, y-offset) (cumulative spacing\nin  the  (horizontal,vertical)  direction)  of  element  (i,j)  of  the  repetition  (i  =  0,  ...,  N-1  and  j  =  0,  ...,  M-1)  is\n(i ",(0,i.yg)("em",{parentName:"li"}," nx-space + j ")," mx-space, i ",(0,i.yg)("em",{parentName:"li"}," ny-space + j ")," my-space)."),(0,i.yg)("li",{parentName:"ol"},"6.11  TYPE 9 is a P-element (P > 1) repetition with uniform and (potentially) diagonal displacements between the\nelements. dimension is P - 2. Defining displacement in terms of its components x-space and y-space, the (x-offset,\ny-offset) (cumulative spacing in the (horizontal,vertical) direction) of element k of the repetition (k = 0, ..., P-1) is\n(k ",(0,i.yg)("em",{parentName:"li"}," x-space, k ")," y-space)."),(0,i.yg)("li",{parentName:"ol"},"6.12  TYPE  10  is  a  P-element  (P  >  1)  repetition  with  (potentially)  non-uniform  and  arbitrary  two-dimensional\ndisplacements  between  the  elements.  dimension  is  P  -  2.  Defining  displacement\nk\nin  terms  of  its  components  x-\nspace\nk\nand y-space\nk\n, the (x-offset, y-offset) (cumulative spacing in the (horizontal,vertical) direction) of element k\nof the repetition (k = 0, ..., P-1) is (x-space\n0")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"... + x-space\nk\n, y-space\n0"),(0,i.yg)("li",{parentName:"ul"},"... + y-space\nk\n) with x-space\n0\n= y-space",(0,i.yg)("h1",{parentName:"li",id:"0"},"0"),"0).")),(0,i.yg)("ol",{start:7},(0,i.yg)("li",{parentName:"ol"},"6.13  TYPE 11 is identical to TYPE 10, except that all offset values must be multiplied by grid during expansion\nof the repetition.")),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 9"),(0,i.yg)("p",null,"Figure 5\nRepetition Types"),(0,i.yg)("ol",{start:7},(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"6.14  EXCEPTION HANDLING\n\u2014 A repetition type outside the range of 0 to 11 should be treated as a fatal error.\nA repetition type of 0 may not be the first repetition type used within a cell.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"7  Point Lists")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"7.1  A point-list  represents  a  list  of  geometric  coordinates  for  polygons  or  paths,  and  consists  of  an  unsigned-\ninteger denoting its type, followed by a list of deltas, in one of several formats. The initial vertex at (x,y) is supplied\nby  the  POLYGON  or  PATH  record  and  is  not  part  of  the  point-list; vertex-count  (an  unsigned-integer)  is  the\nnumber of points or deltas, excluding the initial vertex and any implicit vertices\n.\nTable 7  Point List Types\nType                                           Format                                           Description\n0\nvertex-count [ 1-delta ","[ ... 1-delta ]"," ] Implicit manhattan delta point-list (horizontal-first)\n1\nvertex-count [ 1-delta ","[ ... 1-delta ]"," ] Implicit manhattan delta point-list (vertical-first)\n2\nvertex-count [ 2-delta ","[ ... 2-delta ]"," ] Explicit manhattan delta point-list\n3\nvertex-count [ 3-delta ","[ ... 3-delta ]"," ] Explicit octangular delta point-list\n4\nvertex-count [ g-delta ","[ ... g-delta ]"," ] Explicit all-angle delta point-list\n5\nvertex-count [ g-delta ","[ ... g-delta ]"," ] Explicit all-angle double-delta point-list")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"7.2  A point-list  of  type  0  consists  of  a  list  of  1-deltas,  representing  alternating  horizontal  and  vertical  relative\ndisplacements, with the first displacement implicitly horizontal\n. When describing a polygon point-list in this form,\nthe final  two  displacements  are  omitted,  since  they  can  be  unambiguously  implied  from  the  current  point,  the  last"))),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 10\nedge, and the starting point. When describing a polygon, vertex-count must be an even number greater than or equal\nto 2.\n7. 7.3  A point-list  of  type  1  consists  of  a  list  of  1-deltas,  representing  alternating  vertical  and  horizontal  relative\ndisplacements, with the first displacement implicitly vertical\n. When describing a polygon point-list in this form, the\nfinal two displacements are omitted, since they can be unambiguously implied from the current point, the last edge,\nand the starting point. When describing a polygon, vertex-count must be an even number greater than or equal to 2.\n7. 7.4  A point-list of type 2 consists of a list of 2-deltas, representing a series of manhattan relative displacements.\nWhen describing a polygon point-list in this form, the final displacement is omitted, since the polygon is assumed to\nbe  implicitly  closed,  but  this  final  implicit  displacement  must  be  a  manhattan  displacement,  with  either  \u2206x  =  0  or\n\u2206y = 0.\n7. 7.5  A point-list of type 3 consists of a list of 3-deltas, representing a series of octangular relative displacements.\nWhen describing a polygon point-list in this form, the final displacement is omitted, since the polygon is assumed to\nbe implicitly closed, but this final implicit displacement must be an octangular displacement at an angle that is an\nintegral multiple of 45\xb0.\n7. 7.6  A point-list  of  type  4  consists  of  a  list  of  g-deltas,  representing  a  series  of  any-angle  relative  displacements.\nWhen describing a polygon point-list in this form, the final displacement is omitted, since the polygon is assumed to\nbe implicitly closed.\n7. 7.7  A point-list  of  type  5  consists  of  a  list  of  g-deltas,  representing  a  series  of  adjustments  to  a  relative\ndisplacement vector, with the initial vector set to (\n\u2206x = 0, \u2206y = 0). To calculate the coordinates of each successive\npoint, the x and y components of each successive g-delta are added to the relative displacement vector, which in turn\ndescribes the relative displacement from the current point to the next point. When describing a polygon point-list in\nthis form, the final displacement is omitted, since the polygon is assumed to be implicitly closed. This form of point-\nlist is intended to allow more compact representation of polygons and paths which are approximations of large-field\ncurvilinear figures on a fine grid, where the curvature is not extreme."),(0,i.yg)("p",null,"Figure 6\nPoint List Describing Polygons"),(0,i.yg)("p",null,"Table 8  Polygon Point List for Figure 6\nType                                                                               Bit                                                                               Pattern\n0 00000000 00000100 00001100 00001000 00010001 00000101\n1 00000001 00000100 00010001 00000100 00000100 00000100\n2 00000010 00000101 00100000 00011001 00010010 00001011 00010010\n3 00000011 00000100 00010101 00100001 00110000 00010011\n4 00000100 00000010 01000100 00001001 00001101\n5 00000101 00001001 00000001 00000011 00101001 00000000 00000001 00000100\n00000001 00000011 00000001 00000011 00101011 00000100 00101011 00000000\n00000001 00000011 00000001 00000011"),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 11\n7. 7.8  EXCEPTION HANDLING  \u2014  A  point-list  type  outside  the  range  of  0  to  5  should  be  treated  as  a  fatal  error.\nFor point-list  types  0-1,  successive  coincident  points  and/or  adjacent  colinear  edges  are  not  permitted.  A  non-\nmanhattan implicit closing vector for a polygon using point-list type 2, or a non-octangular implicit closing vector\nfor  a  polygon  using  point-list  type  3  should  be  treated  as  a  fatal  error.  For  polygons  using  point-list  types  0-1,  a\nvertex count which is odd or less than 2 should be treated as a fatal error.\n7. 8  Property Values\n7. 8.1  A property-value stores one element of a property value list. It consists of an unsigned-integer which encodes\nits type, followed by either the value itself or a reference number. Types 0-7 are reals which conform to the scheme\ndescribed in Table 3 on page 5.\nTable 9  Property Value Types\nType                                               Format\n0-7 real (see Table 3)\n8\nunsigned-integer\n9\nsigned-integer\n10\na-string\n11\nb-string\n12\nn-string\n13 propstring-reference-number (implied a-string)\n14 propstring-reference-number (implied b-string)\n15 propstring-reference-number (implied n-string)"),(0,i.yg)("ol",{start:7},(0,i.yg)("li",{parentName:"ol"},"8.2  EXCEPTION HANDLING \u2014 A property-value type outside the range of 0 to 15 should be treated as a fatal\nerror.  Use  of  a  propstring-reference-number  for  which  there  is  no  corresponding  PROPSTRING record  within\nthe same OASIS file should be treated as a fatal error.\n8  CELL Referencing"),(0,i.yg)("li",{parentName:"ol"},"1  As  in  GDSII  Stream,  cells  in  OASIS  are  identified  by  name\n.  The  CELL  record  not  only  introduces  a  cell\ndefinition  but  also  defines  its  name.  PLACEMENT  records  refer  by  name  to  the  cell  being  placed.  As  in  GDSII\nStream, there are no \u201canonymous\u201d cells in OASIS.\n9  Layers, Datatypes, and Texttypes"),(0,i.yg)("li",{parentName:"ol"},"1  As in GDSII Stream, every geometry has associated with it a layer number and a datatype number and every\ntext element has associated with it a textlayer number and a texttype number.\n10  Modal Variables"),(0,i.yg)("li",{parentName:"ol"},"1  For compaction purposes, selected data elements in many OASIS records may be implicitly specified through\nthe use of modal variables or stored state. At the beginning of the file, and whenever a CELL or name record is\nencountered,  all  modal  variables  with  the  exception  of  placement-x, placement-y, geometry-x, geometry-y, text-x,\nand text-y, are set to a state of undefined; the exceptions just mentioned are set to 0. As various elements appear in\nthe cell\u2019s description, modal variables related to those elements are set from the elements\u2019 definitions. These modal\nvariables  can  then  be  used  implicitly  by  successive  elements.  A  modal  variable  may  hold  a  single  value  such  as\ngeometry-w, or a multi-variable structure such as a repetition.")),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 12\nTable 10  Modal Variables\nModal Variables Related Records\nrepetition\nPLACEMENT, TEXT, POLYGON, PATH,\nRECTANGLE, TRAPEZOID, CTRAPEZOID,\nCIRCLE, XGEOMETRY\nplacement-x, placement-y, placement-cell\nPLACEMENT\nlayer, datatype POLYGON, PATH, RECTANGLE, TRAPEZOID,\nCTRAPEZOID, CIRCLE, XGEOMETRY\ntextlayer, texttype, text-x, text-y, text-string\nTEXT\ngeometry-x, geometry-y\nPOLYGON, PATH, RECTANGLE, TRAPEZOID\nCTRAPEZOID, CIRCLE, XGEOMETRY\nxy-mode\nPLACEMENT, TEXT, POLYGON, PATH,\nRECTANGLE, TRAPEZOID, CTRAPEZOID,\nCIRCLE, XGEOMETRY, XYABSOLUTE,\nXYRELATIVE\ngeometry-w, geometry-h\nRECTANGLE, TRAPEZOID, CTRAPEZOID\npolygon-point-list\nPOLYGON\npath-halfwidth, path-point-list, path-start-extension,\npath-end-extension\nPATH\nctrapezoid-type\nCTRAPEZOID\ncircle-radius\nCIRCLE\nlast-property-name, last-value-list\nPROPERTY"),(0,i.yg)("ol",{start:10},(0,i.yg)("li",{parentName:"ol"},"2  Modal variable xy-mode governs the interpretation of the x and y fields for those related record types indicated\nin  Table  10.  Two  interpretation  modes  are  provided:  absolute  and  relative.  See  Section  21  on  page  17  for  a\ndiscussion of how these two modes work."),(0,i.yg)("li",{parentName:"ol"},"3  EXCEPTION HANDLING\n\u2014 An OASIS record which implicitly references a modal variable which is in the\nundefined state should be treated as a fatal error.\n11  Records"),(0,i.yg)("li",{parentName:"ol"},"1  The  basic  unit  of  information  in  an  OASIS  file  is  a  record.  A  record  consists  of  a  single  unsigned-integer\nwhich  encodes  the  record-ID,  followed  by  the  remainder  of  the  record\u2019s  descriptive  data.  In  this  specification,\nrecord-ID values are displayed as decimal numbers enclosed in apostrophes."),(0,i.yg)("li",{parentName:"ol"},"2  The CBLOCK  record  is  a  special  case  since  it  encapsulates  a  series  of  ordinary  records  in  byte-compressed\nform. When a CBLOCK record is encountered while reading an OASIS file, it is first necessary to decompress its\ndata,  which  will  produce  one  or  more  ordinary  records,  which  can  in  turn  be  decoded.  For  more  information  on\nCBLOCK records refer to Section 35 on page 26."),(0,i.yg)("li",{parentName:"ol"},"3  Most records have an implicit length\u2014the record must be parsed and decoded in order to determine its length.\nThe XNAME, XELEMENT, and XGEOMETRY records are exceptions to this. They encapsulate all of their user-\ndefined  data  in  a  single  variable-length  b-string,  so  they  can  be  used  for  prototyping  new  record  types,  hiding\nembedded  proprietary  data,  supporting  local  non-interoperable  extensions,  etc.  without  rendering  an  OASIS  file\nillegible to older readers, which can simply note the string length and skip over the record."),(0,i.yg)("li",{parentName:"ol"},"4  EXCEPTION HANDLING\n\u2014 OASIS processors should treat the nesting of a CBLOCK record within another\nCBLOCK record as a fatal error.\n12  PAD Record"),(0,i.yg)("li",{parentName:"ol"},"1  A PAD record provides a simple way to reserve space within an OASIS file. It has the following format:")),(0,i.yg)("p",null,"\u20180\u2019"),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 13"),(0,i.yg)("ol",{start:12},(0,i.yg)("li",{parentName:"ol"},"2  PAD records may be inserted between any other two records."),(0,i.yg)("li",{parentName:"ol"},"3  EXCEPTION HANDLING\n\u2014  The  presence  of  a  PAD  record  before  the  START  record  or  after  the  END\nrecord should be treated as a fatal error.\n13  START Record"),(0,i.yg)("li",{parentName:"ol"},"1  A START  record  identifies  the  beginning  of  an  OASIS  file,  and  immediately  follows  the  magic-bytes\nsequence described in Section 6.4 on page 3. It has the following format:")),(0,i.yg)("p",null,"\u20181\u2019 version-string unit offset-flag ","[ table-offsets ]"),(0,i.yg)("ol",{start:13},(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"2  The version-string  is  an  a-string  whose  value  is  \u201c1.0\u201d  for  this  version  of  the  OASIS  specification.  Version\n\u201c1.0\u201d corresponds to the OASIS format as described in this document.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"3  The unit  declaration  is  a  positive\nreal  number  which  specifies  the  global  precision  of  the  OASIS  file\u2019s\ncoordinate system in grid steps per micron. The OASIS unit value is essentially the reciprocal of the first value in\nthe GDSII Stream UNITS record.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"4  offset-flag (an unsigned-integer) is 0 when the table-offsets structure is stored in the START record; offset-\nflag is 1 when the table-offsets structure is instead stored in the END record. The option of storing table-offsets in\nthe END record is provided to make it possible to write an OASIS file sequentially, with no seek-and-update access\nrequired, while still providing cell-level random-access capability for subsequent readers of that OASIS file.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"5  The table-offsets  structure  consists  of  6  pairs  of  unsigned-integers.  Each  pair  consists  of  a  flag  field,  and  a\ncorresponding byte-offset field, in the following order:\nTable 11  Table Offset Order\nFlag                                      Byte-Offset\ncellname-flag                            cellname-offset\ntextstring-flag                           textstring-offset\npropname-flag                          propname-offset\npropstring-flag                          propstring-offset\nlayername-flag                         layername-offset\nxname-flag                               xname-offset")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"6  Each  of  the  flag  fields  is  either  1,  indicating  strict  mode,  or  0,  indicating  non-strict  mode,  for  its  respective\ntable.  The  corresponding  byte-offset  field  indicates  the  position  of  the  first  record  of  its  respective  table  relative  to\nthe first byte (byte 0) of the OASIS file. A byte-offset of 0 indicates the absence of that particular table.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"7  In non-strict  mode,  records  of  the  corresponding  type  may  occur  anywhere  in  the  file,  even  if  some  of  them\nhave been gathered into a table pointed to by the corresponding byte-offset.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"8  In strict  mode,  all\nrecords  of  the  corresponding  type  (plus  any  associated  PROPERTY  records)  have  been\ngathered into a single contiguous table pointed to by the corresponding byte-offset. PAD records are also permitted\nin strict  mode  tables.  In  addition,  strict  mode  guarantees\nthat  all  references  to  the  corresponding  class  of  objects\n(names, strings, or cells) are made exclusively by reference-number.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"9  When  a  given  strict  mode  table  has  been  encapsulated  within  one  or  more  CBLOCK  records,  the\ncorresponding byte-offset  should  point  to  the  first  byte  of  the  first  CBLOCK  record  containing  that  table,  and  the\nfirst  record  of  the  table  must  be  the  first  record  which  appears  after  decompression  of  the  CBLOCK  record.\nAdherence to this requirement means that it is not permissible to encapsulate more than one strict mode table within\na single CBLOCK record, nor is it permissible to begin a strict mode table in the middle of a CBLOCK record.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"10  EXCEPTION HANDLING\n\u2014 The absence of a START record as the first record in an OASIS file should be\ntreated  as  a  fatal  error.  A  value  of  unit  which  is  NaN, Inf,  or  non-positive,  should  also  be  treated  as  a  fatal  error.\nWhen a given table offset is nonzero and the table is flagged as strict, the presence of a \u201cstray\u201d record of that type"))),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 14\nlocated  discontiguously  from  its  tabular  group  should  be  treated  as  a  fatal  error,  and  any  records  which  fail  to  use\nreference-number access for that class of objects should be treated as a fatal error. An OASIS reader which does not\nrely  on  any  of  the  record  grouping,  reference-number,  and  byte-offset  guarantees  provided  by  strict  mode  is  not\nrequired to detect and report any exceptions related to strict mode.\n14  END Record\n14. 1  An END  record  identifies  the  end  of  the  OASIS  file.  The  END  record  must  be  the  last  record  in  the  file;  no\ntrailing bytes are permitted. It has the following format:"),(0,i.yg)("p",null,"\u20182\u2019 ","[ table-offsets ]"," padding-string validation-scheme ","[ validation-signature ]"),(0,i.yg)("ol",{start:14},(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"2  The presence of the table-offsets structure is governed by offset-flag in the START record (see Section 13 on\npage  13).  The  padding-string  (a  b-string)  must  be  sized  and  inserted  by  the  OASIS  writer  so  that  the  total  byte\nlength of the END record, including the record-ID, is exactly 256 bytes. This makes it possible for an OASIS reader\nto find the END record (and any table-offsets and validation-signature) using a relative seek from the logical end-\nof-file, avoiding the need to store a forward pointer in the START record. The contents of padding-string should\nbe initialized to NUL characters.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"3  validation-scheme is an unsigned-integer which selects the validation scheme used, and validation-signature\nis  an  optional  scheme-dependent  group  of  bytes  used  for  validating  the  integrity  of  the  OASIS  file.  The  following\nvalidation schemes are defined:\nTable 12  END Record Validation Schemes\nScheme               Description               Validation Signature Length\n0            No            Validation            0\n1            CRC32            4\n2            CHECKSUM32            4")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"4  CRC32 Validation")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"4.1  The CRC32 polynomial is specified in ISO 3309:"))),(0,i.yg)("p",null,"x\n32"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"x\n26"),(0,i.yg)("li",{parentName:"ul"},"x\n23"),(0,i.yg)("li",{parentName:"ul"},"x\n22"),(0,i.yg)("li",{parentName:"ul"},"x\n16"),(0,i.yg)("li",{parentName:"ul"},"x\n12"),(0,i.yg)("li",{parentName:"ul"},"x\n11"),(0,i.yg)("li",{parentName:"ul"},"x\n10"),(0,i.yg)("li",{parentName:"ul"},"x\n8"),(0,i.yg)("li",{parentName:"ul"},"x\n7"),(0,i.yg)("li",{parentName:"ul"},"x\n5"),(0,i.yg)("li",{parentName:"ul"},"x\n4"),(0,i.yg)("li",{parentName:"ul"},"x\n2"),(0,i.yg)("li",{parentName:"ul"},"x\n1"),(0,i.yg)("li",{parentName:"ul"},"x\n0")),(0,i.yg)("p",null,"With the left-most bit representing the most significant bit, this corresponds to a value of:"),(0,i.yg)("p",null,"binary  1 0000 0100 1100 0001 0001 1101 1011 0111\nhexadecimal              104c11db7"),(0,i.yg)("ol",{start:14},(0,i.yg)("li",{parentName:"ol"},"4.2  The  CRC32  value  is  computed  using  all  of  the  bytes  in  the  OASIS  file  from  the  first  byte  of  the  START\nrecord  to  the  END  record\u2019s  validation-scheme  integer.  It  is  byte-order  dependent.  The  resulting  32-bit  word  is\nstored  in  the  last  4  bytes  of  the  file,  with  the  least  significant  byte  first.  This  calculation  is  usually  implemented\nusing a table-lookup shift/XOR method. See Appendix 1 for sample C-language source code."),(0,i.yg)("li",{parentName:"ol"},"5  CHECKSUM32 Validation"),(0,i.yg)("li",{parentName:"ol"},"5.1  The  CHECKSUM32  validation  signature  is  computed  as  a  simple  unsigned  arithmetic  summation  of  all  of\nthe  bytes  in  the  OASIS  file  from  the  first  byte  of  the  START  record  to  the  END  record\u2019s  validation-scheme\ninteger. This value is then truncated to its least significant 32 bits and stored in the last 4 bytes of the file, with the\nleast  significant  byte  first.  It  is  not  byte-order  dependent,  and  this  characteristic  makes  it  somewhat  easier  to\ncalculate if the file is not written sequentially. It is, however, far less effective than CRC32 for detecting errors. See\nAppendix 1 for sample C-language source code."),(0,i.yg)("li",{parentName:"ol"},"6  EXCEPTION HANDLING\n\u2014 OASIS processors should treat the absence of an END record in an OASIS file\nas a fatal error.")),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 15\n15  CELLNAME Record\n15. 1  A CELLNAME record associates the name of a cell with a unique reference number. This allows CELL and\nPLACEMENT records, if desired, to avoid redundantly storing the actual text of the cell name and instead refer to\nthe cell by its assigned reference number. It has the following format:"),(0,i.yg)("p",null,"\u20183\u2019              cellname-string\n\u20184\u2019 cellname-string reference-number"),(0,i.yg)("ol",{start:15},(0,i.yg)("li",{parentName:"ol"},"2  cellname-string  is  an  n-string  which  holds  the  cell  name.  The  reference-number  is  an  unsigned-integer\nwhich  is  either  implicitly  or  explicitly  assigned  to  the  cell.  Implicit  assignment  occurs  in  record  type  \u20183\u2019,  by\nassigning  sequential  reference  numbers  beginning  with  0  as  each  successive  CELLNAME  record  is  encountered.\nExplicit assignment occurs in record type \u20184\u2019."),(0,i.yg)("li",{parentName:"ol"},"3  Two standard properties, S_BOUNDING_BOX and S_CELL_OFFSET (described in Section A2-2 on page\n36), may be associated with each CELLNAME record. When all CELLNAME records have been grouped into a\nsingle contiguous table in strict mode (as described in Section 13 on page 13), with an S_CELL_OFFSET property\nfor every CELLNAME record, the table forms a complete index of all cells in the OASIS file, suitable for random\naccess."),(0,i.yg)("li",{parentName:"ol"},"4  Record types \u20183\u2019 and \u20184\u2019 may not both be used in the same OASIS file."),(0,i.yg)("li",{parentName:"ol"},"5  EXCEPTION  HANDLING\n\u2014  The  appearance  of  two  CELLNAME  records  in  the  same  file  with  the  same\nnumber  but  different  names,  or  two  CELLNAME records  in  the  same  file  with  the  same  name  but  different\nnumbers, should be treated as a fatal error. The appearance of both record types \u20183\u2019 and \u20184\u2019 in the same OASIS file\nshould  be  treated  as  a  fatal  error.  The  presence  of  more  than  one  S_CELL_OFFSET  or  S_BOUNDING_BOX\nproperty after a given CELLNAME record should be treated as a fatal error.\n16  TEXTSTRING Record"),(0,i.yg)("li",{parentName:"ol"},"1  A TEXTSTRING record associates a text string with a unique reference number. This allows TEXT records,\nif  desired,  to  avoid  redundantly  storing  the  actual  text  of  the  string  and  instead  refer  to  the  string  by  its  assigned\nreference number. It has the following format:")),(0,i.yg)("p",null,"\u20185\u2019              text-string\n\u20186\u2019 text-string reference-number"),(0,i.yg)("ol",{start:16},(0,i.yg)("li",{parentName:"ol"},"2  text-string is an a-string which holds the text string. The reference-number is an unsigned-integer which is\neither implicitly or explicitly assigned to the text string. Implicit assignment occurs in record type \u20185\u2019, by assigning\nsequential  reference  numbers  beginning  with  0  as  each  successive  TEXTSTRING  record  is  encountered.  Explicit\nassignment occurs in record type \u20186\u2019."),(0,i.yg)("li",{parentName:"ol"},"3  Record types \u20185\u2019 and \u20186\u2019 may not both be used in the same OASIS file."),(0,i.yg)("li",{parentName:"ol"},"4  EXCEPTION HANDLING\n\u2014 The appearance of two TEXTSTRING records in the same file with the same\nnumber  but  different  names,  or  two  TEXTSTRING records  in  the  same  file  with  the  same  name  but  different\nnumbers, should be treated as a fatal error. The appearance of both record types \u20185\u2019 and \u20186\u2019 in the same OASIS file\nshould be treated as a fatal error.\n17  PROPNAME Record"),(0,i.yg)("li",{parentName:"ol"},"1  A PROPNAME  record  associates  the  name  of  a  property  with  a  unique  reference  number.  This  allows\nPROPERTY records, if desired, to avoid redundantly storing the actual text of the property name and instead refer\nto the property name by its assigned reference number. It has the following format:")),(0,i.yg)("p",null,"\u20187\u2019              propname-string\n\u20188\u2019 propname-string reference-number"),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 16\n17. 2  propname-string  is  an  n-string  which  holds  the  property  name.  The  reference-number  is  an  unsigned-\ninteger which is either implicitly or explicitly assigned to the property name. Implicit assignment occurs in record\ntype  \u20187\u2019,  by  assigning  sequential  reference  numbers  beginning  with  0  as  each  successive  PROPNAME record  is\nencountered. Explicit assignment occurs in record type \u20188\u2019.\n17. 3  Record types \u20187\u2019 and \u20188\u2019 may not both be used in the same OASIS file.\n17. 4  EXCEPTION  HANDLING\n\u2014  The  appearance  of  two  PROPNAME records  in  the  same  file  with  the  same\nnumber  but  different  names,  or  two  PROPNAME records  in  the  same  file  with  the  same  name  but  different\nnumbers, should be treated as a fatal error. The appearance of both record types \u20187\u2019 and \u20188\u2019 in the same OASIS file\nshould be treated as a fatal error.\n18  PROPSTRING Record\n18. 1  A PROPSTRING   record   associates   a   property   string   with   a   unique   reference   number.   This   allows\nPROPERTY records, if desired, to avoid redundantly storing the actual text of the property string and instead refer\nto the property string by its assigned reference number. It has the following format:"),(0,i.yg)("p",null,"\u20189\u2019              prop-string\n\u201810\u2019 prop-string reference-number"),(0,i.yg)("ol",{start:18},(0,i.yg)("li",{parentName:"ol"},"2  prop-string is an a-string, b-string , or n-string which holds the property string, depending on the referencing\nPROPERTY record. The reference-number is an unsigned-integer which is either implicitly or explicitly assigned\nto  the  property  string.  Implicit  assignment  occurs  in  record  type  \u20189\u2019,  by  assigning  sequential  reference  numbers\nbeginning  with  0  as  each  successive  PROPSTRING record  is  encountered.  Explicit  assignment  occurs  in  record\ntype \u201810\u2019."),(0,i.yg)("li",{parentName:"ol"},"3  Record types \u20189\u2019 and \u201810\u2019 may not both be used in the same OASIS file."),(0,i.yg)("li",{parentName:"ol"},"4  EXCEPTION HANDLING\n\u2014 The appearance of two PROPSTRING records in the same file with the same\nnumber but different names should be treated as a fatal error. The appearance of both record types \u20189\u2019 and \u201810\u2019 in the\nsame OASIS file should be treated as a fatal error.\n19  LAYERNAME Record"),(0,i.yg)("li",{parentName:"ol"},"1  A LAYERNAME  record  provides  a  means  of  mapping  numeric  (layer,datatype)  and  (layer,texttype)\ncombinations to layer names. It has the following format:")),(0,i.yg)("p",null,"\u201811\u2019 layername-string layer-interval datatype-interval\n\u201812\u2019              layername-string              textlayer-interval texttype-interval"),(0,i.yg)("ol",{start:19},(0,i.yg)("li",{parentName:"ol"},"2  Record type \u201811\u2019 maps a range of (layer,datatype) numbers to a layer name, and record type \u201812\u2019 maps a range\nof (textlayer,texttype) numbers to a layer name."),(0,i.yg)("li",{parentName:"ol"},"3  layername-string is an n-string containing the layer name."),(0,i.yg)("li",{parentName:"ol"},"4  Each  of  the  interval  fields  consists  of  an  unsigned-integer  denoting  the  interval  type,  followed  by  0,  1,  or  2\nunsigned-integers representing the bounds of that interval as follows:\nTable 13  LAYERNAME Interval Types\nType                 Bounds                 Implied                 Range\n0\n0 to \u221e\n1\nbound-a\n0 to bound-a\n2\nbound-a\nbound-a to \u221e\n3\nbound-a                     bound-a\n4\nbound-a bound-b\nbound-a to bound-b")),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 17\n19. 5  LAYERNAME records may be repeated for the same layer name. The complete mapping for a layer name is\nformed by the union of all layer, datatype, textlayer, and texttype ranges associated with that name.\n20  CELL Record\n20. 1  A CELL record introduces a cell definition. It has the following format:"),(0,i.yg)("p",null,"\u201813\u2019              reference-number\n\u201814\u2019              cellname-string"),(0,i.yg)("ol",{start:20},(0,i.yg)("li",{parentName:"ol"},"2  In  record  type  \u201813\u2019,  reference-number  is  an  unsigned-integer referring  to  a  CELLNAME  record  where  the\ncell  name  is  stored.  In  record  type  \u201814\u2019,  cellname-string  stores  the  cell  name  locally.  In  either  representation,  the\ncell name must be an n-string."),(0,i.yg)("li",{parentName:"ol"},"3  All subsequent records in the file up to the next CELL, END, or name record are considered to be part of\nthat cell."),(0,i.yg)("li",{parentName:"ol"},"4  EXCEPTION HANDLING\n\u2014 Use of a reference-number for which there is no corresponding CELLNAME\nrecord  within  the  same  OASIS  file  should  be  treated  as  a  fatal  error.  Multiple  CELL  records  within  a  single  file\nwhich refer to the same cell name (in effect, a duplicate cell definition) should also be treated as a fatal error.\n21  XYABSOLUTE & XYRELATIVE Records"),(0,i.yg)("li",{parentName:"ol"},"1  The XYABSOLUTE and XYRELATIVE records control the value of modal variable xy-mode, which in turn\ngoverns  the  interpretation  of  the  x  and  y  values  found  in  PLACEMENT, geometry,  and  TEXT  records.  They\nconsist simply of a record-ID with no additional fields:")),(0,i.yg)("p",null,"\u201815\u2019              =              XYABSOLUTE\n\u201816\u2019              =              XYRELATIVE"),(0,i.yg)("ol",{start:21},(0,i.yg)("li",{parentName:"ol"},"2  When each CELL record is encountered, modal variable xy-mode is set to absolute, and related modal position\nvariables placement-x, placement-y, geometry-x, geometry-y, text-x,  and  text-y  are  set  to  0.  The  presence  of  an\nXYRELATIVE record forces modal variable xy-mode  to  relative, and the presence of an XYABSOLUTE record\nforces modal variable xy-mode to absolute. This mode may be changed any number of times within a cell definition."),(0,i.yg)("li",{parentName:"ol"},"3  In absolute mode, explicit x and y values, when present, are used directly as the actual (x,y) coordinates."),(0,i.yg)("li",{parentName:"ol"},"4  In relative  mode,  explicit  x  and  y  values,  when  present,  are  interpreted  as  relative  displacements  from  the\nstored  position  information  in  modal  variables  placement-x, placement-y, geometry-x,\ngeometry-y, text-x,  or  text-y,\ndepending on the record type in which they occur. In this mode, the actual x-coordinate is computed as the sum of\nthe x value and its corresponding modal position variable, and the actual y-coordinate is computed as the sum of the\ny value and its corresponding modal position variable."),(0,i.yg)("li",{parentName:"ol"},"5  In both absolute and relative modes, when an x or y value is not explicitly present in the record, the value of\nthe  corresponding  modal  position  variable  is  used  for  the  actual  x  or  y  coordinate.  In  both  absolute  and  relative\nmodes, the corresponding modal position variables are always updated with the actual (x,y) coordinate position."),(0,i.yg)("li",{parentName:"ol"},"6  The interpretation of point-lists and repetitions does not depend on absolute or relative mode. Also, even when\na  given  element  includes  a  repetition,  the  corresponding  modal  position  variables  (placement-x, placement-y,\ngeometry-x, geometry-y, text-x, or text-y) are always updated with the actual (x,y) coordinate of the initial element.\n22  PLACEMENT Record"),(0,i.yg)("li",{parentName:"ol"},"1  A PLACEMENT record describes one or more placements of the referenced cell within the current cell. It has\nthe following format:")),(0,i.yg)("p",null,"\u201817\u2019 placement-info-byte ","[ reference-number | cellname-string ][ x ]"," ","[ y ][ repetition ]","\n\u201818\u2019 placement-info-byte ","[ reference-number | cellname-string ][ magnification ]"," ","[ angle ][ x ]"," ","[ y ][ repetition ]"),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 18"),(0,i.yg)("ol",{start:22},(0,i.yg)("li",{parentName:"ol"},"2  In record type \u201817\u2019, placement-info-byte contains the bit pattern \u2018CNXYRAAF\u2019."),(0,i.yg)("li",{parentName:"ol"},"3  In record type \u201818\u2019, placement-info-byte contains the bit pattern \u2018CNXYRMAF\u2019."),(0,i.yg)("li",{parentName:"ol"},"4  When C = 1, the cell reference is explicit, in which case N = 1 means that reference-number (an unsigned-\ninteger) is present, and refers to a CELLNAME record where the cell name is stored; N = 0 means that cellname-\nstring (an n-string) is present and stores the cell name locally. When C = 0, N is ignored, and the value of modal\nvariable placement-cell is used, referring to the same cell as the previous PLACEMENT record."),(0,i.yg)("li",{parentName:"ol"},"5  x  and  y  are  signed-integer  coordinates  representing  either  the  absolute  or  the  relative  (x,y)  location  of  the\nplacement. X  is  1  if  x  is  present,  and  Y  is  1  if  y  is  present.  When  either  x  or  y  is  unspecified,  the  value  of  modal\nvariable placement-x or placement-y, respectively, is used instead. Refer to Section 21 on page 17 for a discussion of\nhow absolute and relative modes affect the interpretation of x and y."),(0,i.yg)("li",{parentName:"ol"},"6  R is 1 if repetition is present. F = 1 indicates reflection (or flip) about the x-axis; F = 0 indicates no flip."),(0,i.yg)("li",{parentName:"ol"},"7  In record type \u201817\u2019, magnification is 1.0 and rotation is a counterclockwise integral multiple of 90\xb0: AA = 0 for\n0\xb0,\nAA = 1 for 90\xb0, AA = 2 for 180\xb0, and AA = 3 for 270\xb0."),(0,i.yg)("li",{parentName:"ol"},"8  In record type \u201818\u2019, magnification and rotation are reals; angle is dimensioned in degrees, with positive values\ndenoting a counterclockwise rotation; magnification is, of course, unitless. A is 1 if angle is present, otherwise the\nrotation defaults to 0\xb0. M is 1 if magnification is present, otherwise the magnification defaults to 1.0."),(0,i.yg)("li",{parentName:"ol"},"9  Each successive PLACEMENT record updates all placement-related modal variables."),(0,i.yg)("li",{parentName:"ol"},"10  EXCEPTION HANDLING\n\u2014 Use of a reference-number for which there is no corresponding CELLNAME\nrecord  should  be  treated  as  a  fatal  error.  Any  recursive  cell  reference  (a  cell  placing  a  copy  of  itself  within  itself)\nshould be treated as a fatal error. Magnification values which are negative or zero should be treated as fatal errors.\nFloating  point  values  of  NaN   or   Inf   for   either   magnification   or   angle   should   be   treated   as   fatal   errors.\nPLACEMENT records may refer to CELL records regardless of their relative location within the file, and may also\nrefer to external cells which are not defined in the same file.\n23  Placement Transform Representation"),(0,i.yg)("li",{parentName:"ol"},"1  EDA applications generally define a placement transform as a 3\xd73 matrix:\nT =\nX00 X01 0\nX10 X11 0\nX20 X21 1")),(0,i.yg)("p",null,"which  transforms  any  point  (p,q)  via  left-multiplication  by  the  1\xd73  row  matrix  ","[  p  q  1  ]",".  Conversion  of  OASIS\nplacement data to this form is defined as follows:"),(0,i.yg)("p",null,"X00 = cos( angle ) ",(0,i.yg)("em",{parentName:"p"}," magnification\nX01 = sin( angle ) ")," magnification\nX10 = -f ",(0,i.yg)("em",{parentName:"p"}," sin( angle ) ")," magnification\nX11 = +f ",(0,i.yg)("em",{parentName:"p"}," cos( angle ) ")," magnification\nX20 = x\nX21 = y"),(0,i.yg)("p",null,"where f = 1 if F = 0, f = -1 if F = 1, \u201cangle\u201d is the rotation angle given by either AA or angle in the PLACEMENT\nrecord, and \u201cmagnification\u201d is magnification if specified, else 1.0. Note that if the rotation is a multiple of 90\xb0 and\nthe  magnification  is  1.0,  then  the  upper  2\xd72  sub-matrix  takes  one  of  the  following  eight  forms  and  OASIS\nprocessors may optimize accordingly:"),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 19\nTable 14  Standard Placement Values\nF            angle           X00           X01           X10           X11\n0              0\xb0              +1              0               0              +1\n1              0\xb0              +1              0               0              \u22121\n0             90\xb0             0              +1             \u22121              0\n1             90\xb0             0              +1             +1              0\n0            180\xb0            \u22121              0               0              \u22121\n1            180\xb0            \u22121              0               0              +1\n0            270\xb0            0            \u22121             +1              0\n1            270\xb0            0            \u22121 \u22121              0"),(0,i.yg)("ol",{start:23},(0,i.yg)("li",{parentName:"ol"},"2  When repetition  is  present,  the  above  transform  is  that  of  the  first  element  of  the  repetition.  In  general,  the\ntransform of any element E of the repetition is computed by right-multiplying the transform of the first element by\nthe matrix:\n1\n0\nx-offset\n0\n1\ny-offset\n0\n0\n1\nS =")),(0,i.yg)("p",null,"to yield:\nX00\nX10\n(X20 +\nx-offset\n)\nX01\nX11\n(X21 +\ny-offset\n)\n0\n0\n1"),(0,i.yg)("p",null,"(Refer to Section 7.6.3 and subsequent paragraphs beginning on page 7 for a discussion of how x-offset and y-offset\nare determined for the various repetition types.)\n24  TEXT Record\n24. 1  A TEXT record represents a text element, consisting of an (x,y) coordinate point and an annotation string. It\nhas the following format:"),(0,i.yg)("p",null,"\u201819\u2019 text-info-byte ","[ reference-number | text-string][ textlayer-number ]"," ","[ texttype-number ][ x ]"," ","[ y ][ repetition ]"),(0,i.yg)("ol",{start:24},(0,i.yg)("li",{parentName:"ol"},"2  The text-info-byte contains the bit pattern \u20180CNXYRTL\u2019."),(0,i.yg)("li",{parentName:"ol"},"3  When C = 1, the text reference is explicit, in which case N = 1 means that reference-number (an unsigned-\ninteger)  is  present,  and  refers  to  a  TEXTSTRING record  where  the  text  string  is  stored;  N =  0  means  that  text-\nstring (an a-string) is present and stores the text string locally. When C = 0, N is ignored, and the value of modal\nvariable text-string is used instead."),(0,i.yg)("li",{parentName:"ol"},"4  x and y are signed-integer coordinates representing either the absolute or the relative (x,y) location of the text\nelement. X  is  1  if  x  is  present,  and  Y  is  1  if  y  is  present.  When  either  x  or  y  is  unspecified,  the  value  of  modal\nvariable text-x  or  text-y,  respectively,  is  used  instead.  Refer  to  Section  21  on  page  17  for  a  discussion  of  how\nabsolute and relative modes affect the interpretation of x and y."),(0,i.yg)("li",{parentName:"ol"},"5  R  is  1  if  repetition\nis  present.  L  is  1  if  textlayer-number  is  present.  T  is  1  if  texttype-number  is  present.\nBoth textlayer-number  and  texttype-number  are  unsigned-integers.  When  textlayer-number  and/or  texttype-\nnumber are unspecified, they assume the value of modal variables textlayer and texttype, respectively."),(0,i.yg)("li",{parentName:"ol"},"6  Each successive TEXT record updates all text-related modal variables.")),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 20\n24. 7  EXCEPTION   HANDLING   \u2014   Use   of   a   reference-number   for   which   there   is   no   corresponding\nTEXTSTRING record within the same OASIS file should be treated as a fatal error. Implicit use of modal variables\ntextlayer or texttype when they are in the undefined state should be treated as a fatal error.\n25  RECTANGLE Record\n25. 1  A RECTANGLE record represents a rectangular figure whose edges are parallel to the x- and y-axes. It has\nthe following format:"),(0,i.yg)("p",null,"\u201820\u2019 rectangle-info-byte ","[ layer-number ][ datatype-number ]"," ","[ width ][ height ]"," ","[ x ][ y ]"," ","[ repetition ]"),(0,i.yg)("ol",{start:25},(0,i.yg)("li",{parentName:"ol"},"2  The rectangle-info-byte contains the bit pattern \u2018SWHXYRDL\u2019."),(0,i.yg)("li",{parentName:"ol"},"3  R is 1 if repetition is present. L is 1 if layer-number is present. D is 1 if datatype-number is present. Both\nlayer-number  and  datatype-number are unsigned-integers.  When  layer-number  and/or  datatype-number  are\nunspecified, they assume the value of modal variables layer and datatype, respectively. W is 1 if width is present.\nH  is  1  if  height  is  present.  Both  width  and  height  are  unsigned-integers.    When  width  and/or  height  are\nunspecified, they assume the value of modal variables geometry-w and geometry-h, respectively."),(0,i.yg)("li",{parentName:"ol"},"4  S is 1 if the rectangle is a square. In this case, H must be 0, and width, if present, is used for both dimensions\nof the rectangle. When width is unspecified, the value of modal variable geometry-w is used instead."),(0,i.yg)("li",{parentName:"ol"},"5  x  and  y\nare  signed-integer  coordinates  representing  either  the  absolute  or  the  relative  (x,y)  location  of  the\nlower-left corner of the rectangle. X is 1 if x is present, and Y is 1 if y is present. When either x or y is unspecified,\nthe value of modal variable geometry-x or geometry-y, respectively, is used instead. Refer to Section 21 on page 17\nfor a discussion of how absolute and relative modes affect the interpretation of x and y."),(0,i.yg)("li",{parentName:"ol"},"6  Each  successive  RECTANGLE  record  updates  all  rectangle-related  modal  variables.  (When  S =  1,  both\ngeometry-w and geometry-h are set to the rectangle\u2019s width.)"),(0,i.yg)("li",{parentName:"ol"},"7  EXCEPTION  HANDLING\n\u2014  Implicit  use  of  modal  variables  geometry-w,  geometry-h,  layer,  or  datatype\nwhen they are in the undefined state should be treated as a fatal error. When S = 1, H = 1 should be treated as a fatal\nerror. The interpretation of zero-area RECTANGLEs is application-dependent.\n26  POLYGON Record"),(0,i.yg)("li",{parentName:"ol"},"1  A POLYGON record represents an arbitrary polygon figure. It has the following format:")),(0,i.yg)("p",null,"\u201821\u2019 polygon-info-byte ","[ layer-number ][ datatype-number ]"," ","[ point-list ][ x ]"," ","[ y ][ repetition ]"),(0,i.yg)("ol",{start:26},(0,i.yg)("li",{parentName:"ol"},"2  The polygon-info-byte contains the bit pattern \u201800PXYRDL\u2019."),(0,i.yg)("li",{parentName:"ol"},"3  x  and  y  are  signed-integer  coordinates  representing  either  the  absolute  or  the  relative  (x,y)  location  of  the\ninitial vertex of the polygon. X is 1 if x is present, and Y is 1 if y is present. When either x or y is unspecified, the\nvalue of modal variable geometry-x or geometry-y, respectively, is used instead. Refer to Section 21 on page 17 for a\ndiscussion of how absolute and relative modes affect the interpretation of x and y."),(0,i.yg)("li",{parentName:"ol"},"4  R is 1 if repetition is present. L is 1 if layer-number is present. D is 1 if datatype-number is present. Both\nlayer-number  and  datatype-number are unsigned-integers.  When  layer-number  and/or  datatype-number  are\nunspecified, they assume the value of modal variables layer and datatype, respectively."),(0,i.yg)("li",{parentName:"ol"},"5  P\nis 1 if point-list is present. Otherwise, the value of modal variable polygon-point-list is used. The format of\npoint-lists is defined in Section 7.7 on page 9."),(0,i.yg)("li",{parentName:"ol"},"6  Each successive POLYGON record updates all polygon-related modal variables."),(0,i.yg)("li",{parentName:"ol"},"7  EXCEPTION HANDLING\n\u2014 Polygons with fewer than three vertices should be treated as fatal errors. Implicit\nuse of modal variables polygon-point-list, layer, or datatype when they are in the undefined state should be treated\nas  a  fatal  error.  The  interpretation  of  self-intersecting  polygons,  reentrant  polygons,  and  polygons  with  zero-area\nregions is application-dependent.")),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 21\n27  PATH Record\n27. 1  A PATH record represents an arbitrary path figure, which may be thought of as a polyline with finite width. It\nhas the following format:"),(0,i.yg)("p",null,"\u201822\u2019 path-info-byte ","[ layer-number ][ datatype-number ]"," ","[ half-width ]"," extension-scheme ","[ start-extension][ end-extension ]"," ] ","[ point-list ][ x ]"," ","[ y ][ repetition ]"),(0,i.yg)("ol",{start:27},(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"2  The path-info-byte contains the bit pattern \u2018EWPXYRDL\u2019.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"3  x  and  y  are  signed-integer  coordinates  representing  either  the  absolute  or  the  relative  (x,y)  location  of  the\ninitial vertex of the path centerline. X is 1 if x is present, and Y is 1 if y is present. When either x or y is unspecified,\nthe value of modal variable geometry-x or geometry-y, respectively, is used instead. Refer to Section 21 on page 17\nfor a discussion of how absolute and relative modes affect the interpretation of x and y.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"4  R is 1 if repetition is present. L is 1 if layer-number is present. D is 1 if datatype-number is present. Both\nlayer-number  and  datatype-number are unsigned-integers.  When  layer-number  and/or  datatype-number  are\nunspecified, they assume the value of modal variables layer and datatype, respectively.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"5  P  is  1  if  point-list  is  present.  Otherwise,  the  value  of  modal  variable  path-point-list  is  used.  The  format  of\npoint-lists is defined in Section 7.7 on page 9.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"6  W\nis  1  if  half-width  (an  unsigned-integer)  is  present;  if  absent,  the  half-width  value  assumes  the  value  of\nmodal  variable  path-halfwidth.  The  path  is  formed  by  expanding  the  centerline  (represented  by  line  segments\nconnecting the points) by the half-width value to each side.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"7  E is 1 if extension-scheme is present. Otherwise, extension-scheme, start-extension, and end-extension are\nabsent, and the values of modal variables path-start-extension, and path-end-extension are used instead.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"8  When present, extension-scheme (an unsigned-integer) contains bit pattern \u20180000SSEE\u2019. The SS bits govern\nthe  path  starting  extension,  and  the  EE  bits  govern  the  path  ending  extension.  Both  start-extension  (present  only\nwhen SS = \u201811\u2019) and end-extension  (present  only  when  EE =  \u201811\u2019)  are  signed-integers,  as  in  GDSII  Stream, with\npositive values causing the path to extend beyond its starting and/or ending vertices, and negative values causing the\npath to retract from its starting and/or ending vertices.\nTable 15  Path Extension Schemes\nSS Bits Description\n00                     Use                     path-start-extension modal variable\n01 Use flush (zero-length) extension at starting vertex\n10 Use path-halfwidth extension at starting vertex\n11                     Use                     explicit                     start-extension at starting vertex\nEE Bits\n00                     Use                     path-end-extension modal variable\n01 Use flush (zero-length) extension at ending vertex\n10 Use path-halfwidth extension at ending vertex\n11                     Use                     explicit                     end-extension at ending vertex")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"9  Each successive PATH record updates all path-related modal variables.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"10  Various  types  of  degenerate  paths,  where  the  half-width  =  0,  the  path  traces  back  on  itself,  an  extension  is\nnegative  with  magnitude  greater  than  its  segment  length,  etc.  are  not  prohibited;  their  interpretation  is  application-\ndependent. The path expansion scheme used at the path\u2019s interior vertices or \u201cjoints\u201d is also application-dependent.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"11  EXCEPTION  HANDLING\n\u2014  Implicit  use  of  modal  variables  path-halfwidth,  path-point-list,  path-start-\nextension,  path-end-extension,  layer,  or  datatype  when  they  are  in  the  undefined  state  should  be  treated  as  a  fatal\nerror."))),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 22\n28  TRAPEZOID Record\n28. 1  A TRAPEZOID  record  represents  a  trapezoid  figure  (a  polygon  with  four  vertices  having  at  least  two\nopposite sides parallel and parallel to either the x- or the y-axis). It has the following format:"),(0,i.yg)("p",null,"\u201823\u2019 trap-info-byte ","[ layer-number ][ datatype-number ]","\n","[ width ][ height ]"," delta-a delta-b ","[ x ][ y ]"," ","[ repetition ]"),(0,i.yg)("p",null,"\u201824\u2019 trap-info-byte ","[ layer-number ][ datatype-number ]","\n","[ width ][ height ]"," delta-a ","[ x ][ y ]"," ","[ repetition ]"),(0,i.yg)("p",null,"\u201825\u2019 trap-info-byte ","[ layer-number ][ datatype-number ]","\n","[ width ][ height ]"," delta-b ","[ x ][ y ]"," ","[ repetition ]"),(0,i.yg)("ol",{start:28},(0,i.yg)("li",{parentName:"ol"},"2  The trap-info-byte contains bit pattern \u2018OWHXYRDL\u2019."),(0,i.yg)("li",{parentName:"ol"},"3  R is 1 if repetition is present. L is 1 if layer-number is present. D is 1 if datatype-number is present. Both\nlayer-number  and  datatype-number are unsigned-integers.  When  layer-number  and/or  datatype-number  are\nunspecified, they assume the value of modal variables layer and datatype, respectively.  W is 1 if width is present.\nH  is  1  if  height  is  present.  Width  and  height  are  unsigned-integers  which  describe  the  overall  dimensions  of  the\nbounding box of the trapezoid as shown in Figure 7 on page 22.  When width and/or height are unspecified, they\nassume the value of modal variables geometry-w and geometry-h, respectively."),(0,i.yg)("li",{parentName:"ol"},"4  x  and  y  are  signed-integer  coordinates  representing  either  the  absolute  or  the  relative  (x,y)  location  of  the\nlower-left corner of the trapezoid\u2019s bounding box. X is 1 if x is present, and Y\nis 1 if y is present. When either x or y\nis unspecified, the value of modal variable geometry-x or geometry-y, respectively, is used instead. Refer to Section\n21 on page 17 for a discussion of how absolute and relative modes affect the interpretation of x and y."),(0,i.yg)("li",{parentName:"ol"},"5  delta-a  and  delta-b  are  1-deltas,  and  are  both  present  in  record  type  \u201823\u2019.  In  record  type  \u201824\u2019  delta-b  is\nassumed to be 0 and is omitted, and in record type \u201825\u2019 delta-a is assumed to be 0 and is omitted."),(0,i.yg)("li",{parentName:"ol"},"6  O is 0 if the trapezoid is horizontally-oriented, with top (PQ) and bottom (RS) sides parallel to the x-axis. In\nthis case, delta-a represents (x\nP")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"x\nR\n) and delta-b represents (x\nQ"),(0,i.yg)("li",{parentName:"ul"},"x\nS\n).")),(0,i.yg)("ol",{start:28},(0,i.yg)("li",{parentName:"ol"},"7  O is 1 if the trapezoid is vertically-oriented, with left (PQ) and right (RS) sides parallel to the y-axis. In this\ncase, delta-a represents (y\nP")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"y\nR\n) and delta-b represents (y\nQ"),(0,i.yg)("li",{parentName:"ul"},"y\nS\n).")),(0,i.yg)("ol",{start:28},(0,i.yg)("li",{parentName:"ol"},"8  Each successive TRAPEZOID record updates all trapezoid-related modal variables.")),(0,i.yg)("p",null,"Figure 7\nHorizontal and Vertical Trapezoids"),(0,i.yg)("ol",{start:28},(0,i.yg)("li",{parentName:"ol"},"9  EXCEPTION HANDLING\n\u2014 For any trapezoid, deltas of sufficient magnitude to cause segments PR and QS\nto cross, as well as any delta which causes either segment PR or QS not to fit diagonally within the bounding box,\nshould  be  treated  as  fatal  errors.  Implicit  use  of  modal  variables  geometry-w,  geometry-h,  layer,  or  datatype  when")),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 23\nthey  are  in  the  undefined  state  should  be  treated  as  a  fatal  error.  The  interpretation  of  zero-area  trapezoids  is\napplication-dependent.\n29  CTRAPEZOID Record\n29. 1  A CTRAPEZOID  record  represents  a  trapezoid  figure  in  a  compact  form  by  assuming  that  two  sides  are\nparallel to either the x- or the y-axis, and the remaining two sides form either a 45- or 90-degree angle with them. It\nhas the following format:"),(0,i.yg)("p",null,"\u201826\u2019 ctrapezoid-info-byte ","[ layer-number ][ datatype-number ]","\n","[ ctrapezoid-type ][ width ]"," ","[ height ][ x ]"," ","[ y ][ repetition ]"),(0,i.yg)("ol",{start:29},(0,i.yg)("li",{parentName:"ol"},"2  The ctrapezoid-info-byte contains the bit pattern \u2018TWHXYRDL\u2019."),(0,i.yg)("li",{parentName:"ol"},"3  R is 1 if repetition is present. L is 1 if layer-number is present. D is 1 if datatype-number is present. Both\nlayer-number  and  datatype-number are unsigned-integers.  When  layer-number  and/or  datatype-number  are\nunspecified, they assume the value of modal variables layer and datatype, respectively. W is 1 if width is present.\nH is 1 if height is present.  Both width and height are unsigned-integers, and represent the width (w) and height (h)\nof the trapezoid\u2019s bounding box, respectively. When width and/or height are unspecified, they assume the value of\nmodal variables geometry-w and geometry-h, respectively."),(0,i.yg)("li",{parentName:"ol"},"4  x  and  y  are  signed-integer  coordinates  representing  either  the  absolute  or  the  relative  (x,y)  location  of  the\nlower-left corner of the trapezoid\u2019s bounding box. X is 1 if x is present, and Y is 1 if y\nis present. When either x or y\nis unspecified, the value of modal variable geometry-x or geometry-y, respectively, is used instead. Refer to Section\n21 on page 17 for a discussion of how absolute and relative modes affect the interpretation of x and y."),(0,i.yg)("li",{parentName:"ol"},"5  T  is  1  if  ctrapezoid-type  (an  unsigned-integer)  is  present;  otherwise  it  assumes  the  value  of  modal  variable\nctrapezoid-type. Types 0-25 are depicted in Figure 8:")),(0,i.yg)("p",null,"Figure 8\nThe 26 Standard CTRAPEZOID Types"),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 24\n29. 6  The triangle, rectangle, and square forms are provided for compactness and for compatibility with some mask\nwriting pattern file formats. For types 16\u201319, 22\u201323, and 25, height is not used, and H must be 0. For types 20\u201321,\nwidth is not used and W must be 0.\n29. 7  Each  successive  CTRAPEZOID  record  updates  all  ctrapezoid-related  modal  variables  with  the  following\nexception: for the forms where only one of width or height is used (types 16\u201323 and 25), modal variables geometry-\nw and geometry-h are both updated to match the specified dimension.\n29. 8  EXCEPTION HANDLING\n\u2014 For types 0-3 and 6-7, (w < h) should be treated as a fatal error. For types 4-5,\n(w < 2h) should be treated as a fatal error. For types 8-11 and 14-15, (h < w) should be treated as a fatal error. For\ntypes 12-13, (h < 2w) should be treated as a fatal error. For types 16-19, 22\u201323, and 25, an H value of 1 should be\ntreated as a fatal error. For types 20-21, a W value of 1 should be treated as a fatal error. A value of ctrapezoid-type\ngreater  than  25  should  be  treated  as  a  fatal  error.  Implicit  use  of  modal  variables  ctrapezoid-type, geometry-w,\ngeometry-h,  layer  or  datatype  when  they  are  in  the  undefined  state  should  be  treated  as  a  fatal  error.    The\ninterpretation of zero-area trapezoids is application-dependent.\n30  CIRCLE Record\n30. 1  A CIRCLE record represents a circular figure. It has the following format:"),(0,i.yg)("p",null,"\u201827\u2019              circle-info-byte              ","[              layer-number ][ datatype-number ]"," ","[ radius ][ x ]"," ","[ y ][ repetition ]"),(0,i.yg)("ol",{start:30},(0,i.yg)("li",{parentName:"ol"},"2  The circle-info-byte contains the bit pattern \u201800rXYRDL\u2019."),(0,i.yg)("li",{parentName:"ol"},"3  R is 1 if repetition is present. L is 1 if layer-number is present. D is 1 if datatype-number is present. Both\nlayer-number  and  datatype-number are unsigned-integers.  When  layer-number  and/or  datatype-number  are\nunspecified, they assume the value of modal variables layer and datatype, respectively."),(0,i.yg)("li",{parentName:"ol"},"4  x  and  y  are  signed-integer  coordinates  representing  either  the  absolute  or  the  relative  (x,y)  location  of  the\ncircle\u2019s center. X is 1 if x is present, and Y is 1 if y is present. When either x or y is unspecified, the value of modal\nvariable geometry-x or geometry-y, respectively, is used instead. Refer to Section 21 on page 17 for a discussion of\nhow absolute and\nrelative modes affect the interpretation of x and y."),(0,i.yg)("li",{parentName:"ol"},"4.1  r is 1 if radius is present, otherwise radius assumes the value of modal variable circle-radius instead."),(0,i.yg)("li",{parentName:"ol"},"5  Each successive CIRCLE record updates all circle-related modal variables."),(0,i.yg)("li",{parentName:"ol"},"6  EXCEPTION HANDLING\n\u2014 Implicit use of modal variables circle-radius, layer, or datatype when they are in\nthe  undefined  state  should  be  treated  as  a  fatal  error.    The  interpretation  of  zero-area  CIRCLEs  is  application-\ndependent.\n31  PROPERTY Record"),(0,i.yg)("li",{parentName:"ol"},"1  A property is an annotation element consisting of a name plus an optional list of values, supplying descriptive\ninformation about the characteristics of the OASIS file or one of its components. A property may be associated with\nthe  entire  OASIS  file,  a  name  record,  a  CELL,  a  PLACEMENT,  or  an  element  record  within  a  cell.  The\nPROPERTY record has the following format:")),(0,i.yg)("p",null,"\u201828\u2019 prop-info-byte ","[ reference-number | propname-string ][ prop-value-count ]"," ","[ property-value* ]","\n\u201829\u2019"),(0,i.yg)("ol",{start:31},(0,i.yg)("li",{parentName:"ol"},"2  Record  type  \u201829\u2019  provides  a  compact  way  to  specify  a  duplicate  copy  of  the  most-recently-seen  property\ntogether  with  its  value  list.  It  makes  use  of  modal  variables  last-property-name  and  last-value-list,  which  were\ndefined by a previous PROPERTY record."),(0,i.yg)("li",{parentName:"ol"},"3  The prop-info-byte contains the bit pattern \u2018UUUUVCNS\u2019."),(0,i.yg)("li",{parentName:"ol"},"4  When C = 1, the property name reference is explicit, in which case N = 1 means that reference-number (an\nunsigned-integer) is present, and refers to a PROPNAME record where the property name is stored; N = 0 means")),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 25\nthat propname-string (an n-string) is present and stores the property name locally. When C = 0, N is ignored, and\nthe value of modal variable last-property-name is used instead.\n31. 5  When V = 0, values of UUUU from 0 to 14 indicate the number of property-value fields which are part of\nthis  record,  and  prop-value-count  is  omitted.  When  V =  0  and  UUUU =  15,  prop-value-count,  an  unsigned-\ninteger, is present and indicates the number of property-value fields. When V = 1, UUUU must be 0, and modal\nvariable last-value-list  supplies  the  value  list.  See  Section  7.8  on  page  11  for  a  description  of  property-value\ntypes.\n31. 6  When S = 1, a standard property is indicated; when S = 0, a non-standard or user property is indicated. The list\nof  OASIS  Standard  Properties  appears  in  Appendix  2  on  page  36.  That  appendix  also  describes  how  to  represent\nGDSII-Stream-style properties using the S_GDS_PROPERTY standard property.\n31. 7  Each successive PROPERTY record updates modal variables last-property-name and last-value-list.\n31. 8  In  general,  PROPERTY  records  directly  follow  the  record  with  which  they  are  associated.  PROPERTY\nrecords occurring directly after the START record are associated globally with the entire OASIS file. PROPERTY\nrecords  occurring  after  a  CELL  record  or  its  corresponding  CELLNAME  record  pertain  to  that  entire  cell.\nPROPERTY  records  occurring  after  a  PLACEMENT  record  pertain  to  the  placement(s)  it  describes,  including\nrepetitions. PROPERTY records occurring after an element record pertain to that element and any repetitions.\n31. 9  PROPERTY records do not associate with\nCBLOCK or PAD records. Instead, property association occurs as\nthough all CBLOCK records have been uncompressed, and all PAD records have been deleted.\n31. 10  EXCEPTION HANDLING\n\u2014 Implicit use of modal variables last-property-name or last-value-list when they\nare  in  the  undefined  state  should  be  treated  as  a  fatal  error.  Use  of  a  reference-number  for  which  there  is  no\ncorresponding PROPNAME record should be treated as a fatal error.\n32  XNAME Record\n32. 1  An XNAME record allows backward-compatible extension of OASIS name records. It associates a string\nwith a unique reference number. It has the following format:"),(0,i.yg)("p",null,"\u201830\u2019 xname-attribute xname-string\n\u201831\u2019 xname-attribute xname-string reference-number"),(0,i.yg)("ol",{start:32},(0,i.yg)("li",{parentName:"ol"},"2  xname-string is user-defined as an a-string, b-string, or n-string which holds the name. xname-attribute is an\nunsigned-integer providing the ability to associate the XNAME with a user-defined class. The reference-number is\nan unsigned-integer which  is  either  implicitly  or  explicitly  assigned  to  the  name.  Implicit  assignment  occurs  in\nrecord type \u201830\u2019, by assigning sequential reference numbers beginning with 0 as each successive XNAME record is\nencountered. Explicit assignment occurs in record type \u201831\u2019."),(0,i.yg)("li",{parentName:"ol"},"3  Record types \u201830\u2019 and \u201831\u2019 may not both be used in the same OASIS file."),(0,i.yg)("li",{parentName:"ol"},"4  EXCEPTION  HANDLING\n\u2014  The  appearance  of  two  XNAME records  in  the  same  file  with  the  same\nreference  number  but  different  names  should  be  treated  as  a  fatal  error.  The  appearance  of  both  record  types  \u201830\u2019\nand \u201831\u2019 in the same OASIS file should be treated as a fatal error.\n33  XELEMENT Record"),(0,i.yg)("li",{parentName:"ol"},"1  An XELEMENT  record  allows  backward-compatible  extension  of  OASIS  element  records.  It  has  the\nfollowing format:")),(0,i.yg)("p",null,"\u201832\u2019  xelement-attribute  xelement-string"),(0,i.yg)("ol",{start:33},(0,i.yg)("li",{parentName:"ol"},"2  xelement-attribute  is  an  unsigned-integer  providing  the  ability  to  associate  the  XELEMENT  with  a  user-\ndefined class. xelement-string is a b-string containing user-defined data.")),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 26\n34  XGEOMETRY Record\n34. 1  An XGEOMETRY record allows backward-compatible extension of OASIS geometry records. It has the\nfollowing format:"),(0,i.yg)("p",null,"\u201833\u2019 xgeometry-info-byte xgeometry-attribute\n","[ layer-number ][ datatype-number ]"," xgeometry-string ","[ x ][ y ]"," ","[ repetition ]"),(0,i.yg)("ol",{start:34},(0,i.yg)("li",{parentName:"ol"},"2  The xgeometry-info-byte contains the bit pattern \u2018000XYRDL\u2019."),(0,i.yg)("li",{parentName:"ol"},"3  R is 1 if repetition is present. L is 1 if layer-number is present. D is 1 if datatype-number is present. Both\nlayer-number  and  datatype-number are unsigned-integers.  When  layer-number  and/or  datatype-number  are\nunspecified, they assume the value of modal variables layer and datatype, respectively."),(0,i.yg)("li",{parentName:"ol"},"4  x  and  y  are  signed-integer  coordinates  representing  either  the  absolute  or  the  relative  (x,y)  location  of  the\ngeometry. X  is  1  if  x  is  present,  and  Y  is  1  if  y  is  present.  When  either  x  or  y  is  unspecified,  the  value  of  modal\nvariable geometry-x or geometry-y, respectively, is used instead. Refer to Section 21 on page 17 for a discussion of\nhow absolute and relative modes affect the interpretation of x and y."),(0,i.yg)("li",{parentName:"ol"},"5  xgeometry-attribute  is  an  integer  providing  the  ability  to  associate  the  XGEOMETRY  with  a  user-defined\nclass. xgeometry-string is a b-string containing user-defined data describing the geometry."),(0,i.yg)("li",{parentName:"ol"},"6\nEach successive XGEOMETRY record updates all XGEOMETRY-related modal variables."),(0,i.yg)("li",{parentName:"ol"},"7  EXCEPTION HANDLING\n\u2014 Implicit use of modal variables layer, or datatype when they are in the undefined\nstate should be treated as a fatal error.\n35  CBLOCK Record"),(0,i.yg)("li",{parentName:"ol"},"1  A CBLOCK record provides a mechanism for embedding compressed data within the structure of an OASIS\nfile for additional compactness. It has the following format:")),(0,i.yg)("p",null,"\u201834\u2019 comp-type uncomp-byte-count comp-byte-count comp-bytes"),(0,i.yg)("ol",{start:35},(0,i.yg)("li",{parentName:"ol"},"2  comp-type is  an  unsigned-integer  describing  the  type  of  compression  used  for  this  record.  uncomp-byte-\ncount  is  an  unsigned-integer  describing  the  number  of  bytes  prior  to  compression,  and  comp-byte-count  is  an\nunsigned-integer describing  the  number  of  bytes  after  compression.  comp-bytes  is  a  sequence  of  bytes  containing\nthe compressed byte sequence."),(0,i.yg)("li",{parentName:"ol"},"3  When comp-type =  0,  the  compression  scheme  is  the  lossless DEFLATE Compressed Data Format, Version"),(0,i.yg)("li",{parentName:"ol"},"3, as documented in RFC 1951 (1996).  Other values of comp-type are reserved for future versions of the OASIS\nformat;  the  intent  is  to  be  able  to  support  a  mixture  of  compression  methods  within  a  single  OASIS  file  for\nmaximum compactness."),(0,i.yg)("li",{parentName:"ol"},"3.1  One  example  of  compression/decompression  software  that  is  compliant  with  RFC  1951  is  found  in  ZLIB\nversion 1.1.4 (March 2002).  This software version can be used without any licensing or legal encumbrances.  It is\nexpected that future versions of the ZLIB software will also remain RFC-1951-compliant.  Users of future releases\nof ZLIB are cautioned to check for continued conformance to RFC 1951 as well as any changes in the terms of use."),(0,i.yg)("li",{parentName:"ol"},"3.2  Use  of  the  ZLIB  software  is  not  mandatory  in  order  to  be  compliant  with  the  OASIS  specification.    Any\ncompression/decompression  software  that  stores  and  processes  data  in  conformance  with  RFC  1951  is  OASIS-\ncompliant.  It  should  be  noted  that  alternatives  to  the  CBLOCK record  may  emerge  in  the  future,  supporting  other\ncompression mechanisms. Use of multiple compression methods within a single OASIS file is not ruled out."),(0,i.yg)("li",{parentName:"ol"},"4  The START, END, CELL, and nested CBLOCK records may not be stored within a compressed record. This\nmaintains the ability to perform random access at the cell level within an OASIS file. A CBLOCK record may not\nencapsulate more than one \u201cstrict mode\u201d name table (refer to Sections 13 and 14 beginning on page 13). All other\nsequences of records, of any length, may be stored in a CBLOCK record."),(0,i.yg)("li",{parentName:"ol"},"5  EXCEPTION  HANDLING\n\u2014  During  the  reading  of  a  CBLOCK  record,  it  is  a  fatal  error  if  the  number  of\nbytes returned after decompression does not match uncomp-byte-count.")),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 27\n36  Detailed BNF Syntax\n36. 1  This  specification  uses  a  modified  Backus-Naur  Form  (BNF)  notation  to  describe  OASIS  file  syntax.  The\nfollowing table summarizes the conventions used in the modified BNF:\nTable 16  Modified BNF Notation\nSymbol                  Term                  Meaning\nABCD\nBold Uppercase Denotes an OASIS record name\nabcd\nBold Lowercase Denotes a fundamental data type defined in Section 7\n< > Angle Brackets Enclose an element name which is further defined elsewhere in the BNF\n-> Arrow Means \u201cis composed of\u201d\n","[ ]"," Square Brackets Enclose element(s) which are optional, and if present, occur only once\n{ } Braces Enclose element(s) which are required\n| Vertical Bar Indicates a choice between mutually exclusive elements within { } braces"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Asterisk An asterisk following an element means the element may occur zero or more times\n... Ellipsis Appears between elements to indicate a variable-length list of like type\n\u2018 \u2019 Single Quotes Enclose a decimal number denoting an OASIS unsigned-integer\n\u201c \u201d Double Quotes Enclose a literal character string\n\u201cCR\u201d Control Character    Angle brackets enclose the name of an ASCII Control Character within a string\n// Double Virgule Indicates all characters to its right are comments\u2014not part of the syntax")),(0,i.yg)("ol",{start:36},(0,i.yg)("li",{parentName:"ol"},"2  The OASIS syntax is detailed as follows:")),(0,i.yg)("p",null,"oasis-file -> magic-bytes START { CBLOCK | PAD | PROPERTY | cell | name }",(0,i.yg)("em",{parentName:"p"}," END\nname -> { CELLNAME | TEXTSTRING | LAYERNAME | PROPNAME | PROPSTRING | XNAME }\ncell -> { CELL { CBLOCK | PAD | PROPERTY | XYRELATIVE | XYABSOLUTE | element }")," }\nelement -> { geometry | PLACEMENT | TEXT | XELEMENT }\ngeometry -> { RECTANGLE | POLYGON | PATH | TRAPEZOID | CTRAPEZOID | CIRCLE | XGEOMETRY }"),(0,i.yg)("p",null,"magic-bytes -> \u201c%SEMI-OASISCRNL\u201d"),(0,i.yg)("p",null,"PAD -> \u20180\u2019"),(0,i.yg)("p",null,"START -> \u20181\u2019 version-string unit offset-flag ","[ table-offsets ]"),(0,i.yg)("p",null,"END -> \u20182\u2019 ","[ table-offsets ]"," padding-string validation-scheme ","[ validation-signature ]"),(0,i.yg)("p",null,"CELLNAME ->  \u20183\u2019 cellname-string\nCELLNAME ->  \u20184\u2019 cellname-string reference-number"),(0,i.yg)("p",null,"TEXTSTRING -> \u20185\u2019 text-string\nTEXTSTRING -> \u20186\u2019 text-string reference-number"),(0,i.yg)("p",null,"PROPNAME ->\n\u20187\u2019 propname-string\nPROPNAME ->  \u20188\u2019 propname-string reference-number"),(0,i.yg)("p",null,"PROPSTRING ->  \u20189\u2019 prop-string\nPROPSTRING ->  \u201810\u2019 prop-string reference-number"),(0,i.yg)("p",null,"LAYERNAME -> \u201811\u2019 layername-string layer-interval datatype-interval\nLAYERNAME -> \u201812\u2019 layername-string textlayer-interval texttype-interval"),(0,i.yg)("p",null,"CELL -> \u201813\u2019 reference-number"),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 28\nCELL -> \u201814\u2019 cellname-string"),(0,i.yg)("p",null,"XYABSOLUTE -> \u201815\u2019\nXYRELATIVE -> \u201816\u2019"),(0,i.yg)("p",null,"PLACEMENT -> \u201817\u2019 placement-info-byte ","[ reference-number | cellname-string ][x ]"," ","[ y ][ repetition ]","\nPLACEMENT -> \u201818\u2019 placement-info-byte ","[ reference-number | cellname-string> ][ magnification ]"," ","[ angle ][ x ]"," ","[ y ][ repetition ]"),(0,i.yg)("p",null,"TEXT -> \u201819\u2019 text-info-byte ","[ reference-number | text-string ]"," l-t ","[ x ][ y ]"," ","[ repetition ]"),(0,i.yg)("p",null,"RECTANGLE -> \u201820\u2019  rectangle-info-byte l-d ","[ width ][ height ]"," ","[ x ][ y ]"," ","[ repetition ]"),(0,i.yg)("p",null,"POLYGON ->  \u201821\u2019  polygon-info-byte l-d ","[ point-list ][ x ]"," ","[ y ][ repetition ]"),(0,i.yg)("p",null,"PATH -> \u201822\u2019  path-info-byte l-d ","[ half-width ]"," extension-scheme ","[ start-extension ][ end-extension ]"," ]\n","[ point-list ][ x ]"," ","[ y ][ repetition ]"),(0,i.yg)("p",null,"TRAPEZOID -> \u201823\u2019 trap-info-byte l-d ","[ width ][ height ]"," delta-a delta-b\n","[ x ][y ]"," ","[ repetition ]","\nTRAPEZOID -> \u201824\u2019 trap-info-byte l-d ","[ width ][ height ]"," delta-a\n","[ x ][y ]"," ","[ repetition ]","\nTRAPEZOID -> \u201825\u2019 trap-info-byte l-d ","[ width ][ height ]"," delta-b\n","[ x ][y ]"," ","[ repetition ]"),(0,i.yg)("p",null,"CTRAPEZOID -> \u201826\u2019  ctrapezoid-info-byte l-d ","[ ctrapezoid-type ][ width ]"," ","[ height ][ x ]"," ","[ y ][ repetition ]"),(0,i.yg)("p",null,"CIRCLE -> \u201827\u2019  circle-info-byte l-d ","[ radius ][ x ]"," ","[ y ][ repetition ]"),(0,i.yg)("p",null,"PROPERTY ->  \u201828\u2019  prop-info-byte ","[ reference-number | propname-string ][ prop-value-count ]"," ","[ property-value* ]","\nPROPERTY ->  \u201829\u2019"),(0,i.yg)("p",null,"XNAME ->  \u201830\u2019 xname-attribute xname-string\nXNAME ->  \u201831\u2019 xname-attribute xname-string reference-number"),(0,i.yg)("p",null,"XELEMENT ->  \u201832\u2019 xelement-attribute xelement-string"),(0,i.yg)("p",null,"XGEOMETRY ->  \u201833\u2019  xgeometry-info-byte xgeometry-attribute l-d xgeometry-string ","[ x ][ y ]","\n","[ repetition ]"),(0,i.yg)("p",null,"CBLOCK -> \u201834\u2019 comp-type uncomp-byte-count comp-byte-count comp-bytes"),(0,i.yg)("p",null,"table-offsets ->   cellname-flag cellname-offset\ntextstring-flag                                textstring-offset\npropname-flag                                propname-offset\npropstring-flag                                propstring-offset\nlayername-flag                                layername-offset\nxname-flag                                xname-offset"),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 29\noffset-flag, cellname-flag, cellname-offset, textstring-flag, textstring-offset,\npropname-flag, propname-offset, propstring-flag, propstring-offset,\nlayername-flag, layername-offset, xname-flag, xname-offset -> unsigned-integer"),(0,i.yg)("p",null,"padding-string -> b-string"),(0,i.yg)("p",null,"validation-scheme -> unsigned-integer\nvalidation-signature -> byte*"),(0,i.yg)("p",null,"placement-info-byte, text-info-byte, rectangle-info-byte,\npolygon-info-byte, path-info-byte, trap-info-byte, ctrapezoid-info-byte,\ncircle-info-byte, prop-info-byte, xgeometry-info-byte -> byte"),(0,i.yg)("p",null,"layer-interval, datatype-interval, textlayer-interval, texttype-interval -> layer-interval\nlayer-interval -> { li0 | li1 | li2 | li3 | li4 }\nli0 -> \u20180\u2019\nli1 -> \u20181\u2019 bound-a\nli2 -> \u20182\u2019 bound-a\nli3 -> \u20183\u2019 bound-a\nli4 -> \u20184\u2019 bound-a bound-b\nbound-a, bound-b -> unsigned-integer"),(0,i.yg)("p",null,"l-d -> ","[ layer-number ][ datatype-number ]","\nl-t -> ","[ textlayer-number ][ texttype-number ]","\nlayer-number, datatype-number, textlayer-number, texttype-number -> unsigned-integer"),(0,i.yg)("p",null,"reference-number -> unsigned-integer\ncellname-string, propname-string, layername-string -> n-string\nversion-string, text-string -> a-string\nprop-string, xname-string -> { a-string | b-string | n-string }\nxelement-string, xgeometry-string -> b-string"),(0,i.yg)("p",null,"a-string, b-string, n-string -> string-length byte*\nstring-length -> unsigned-integer"),(0,i.yg)("p",null,"xname-attribute, xelement-attribute, xgeometry-attribute -> unsigned-integer"),(0,i.yg)("p",null,"property-value -> { pvreal | pv8 | pv9 | pv10 | pv11 | pv12 | pv13 | pv14 | pv15 }\npvreal -> real\npv8 -> \u20188\u2019 unsigned-integer\npv9 -> \u20189\u2019 signed-integer\npv10 -> \u201810\u2019 a-string\npv11 -> \u201811\u2019 b-string\npv12 -> \u201812\u2019 n-string\npv13 -> \u201813\u2019 reference-number // a-string\npv14 -> \u201814\u2019 reference-number // b-string\npv15 ->\n\u201815\u2019 reference-number // n-string"),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 30\nrepetition ->  { rep0 | rep1 | rep2 | rep3 | rep4 | < rep5> | rep6 | rep7 | rep8 |\nrep9 | rep10 | rep11}\nrep0 -> \u20180\u2019\nrep1 -> \u20181\u2019 x-dimension y-dimension x-space y-space\nrep2 -> \u20182\u2019 x-dimension x-space\nrep3 -> \u20183\u2019 y-dimension y-space\nrep4 -> \u20184\u2019 x-dimension x-space ... x-space\nrep5 -> \u20185\u2019 x-dimension grid x-space ... x-space\nrep6 -> \u20186\u2019 y-dimension y-space ... y-space\nrep7 -> \u20187\u2019 y-dimension grid y-space ... y-space\nrep8 -> \u20188\u2019 n-dimension m-dimension n-displacement m-displacement\nrep9 -> \u20189\u2019 dimension displacement\nrep10 -> \u201810\u2019 dimension displacement ... displacement\nrep11 -> \u201811\u2019 dimension grid displacement ... displacement"),(0,i.yg)("p",null,"grid, x-dimension, y-dimension, dimension, n-dimension, m-dimension,\nx-space, y-space -> unsigned-integer"),(0,i.yg)("p",null,"displacement, n-displacement, m-displacement -> g-delta"),(0,i.yg)("p",null,"point-list -> { pl0 | pl1 | pl2 | pl3 | pl4 | pl5 }\npl0 -> \u20180\u2019  vertex-count <1-delta>",(0,i.yg)("em",{parentName:"p"}," // Implicit manhattan delta point-list (horizontal-first)\npl1 -> \u20181\u2019 vertex-count <1-delta>")," // Implicit manhattan delta point-list (vertical-first)\npl2 -> \u20182\u2019 vertex-count <2-delta>",(0,i.yg)("em",{parentName:"p"}," // Explicit manhattan delta point-list\npl3 -> \u20183\u2019 vertex-count <3-delta>")," // Explicit octangular delta point-list\npl4 -> \u20184\u2019 vertex-count g-delta",(0,i.yg)("em",{parentName:"p"}," // Explicit all-angle delta point-list\npl5 -> \u20185\u2019 vertex-count g-delta")," // Explicit all-angle double-delta point-list"),(0,i.yg)("p",null,"vertex-count, half-width, extension-scheme, ctrapezoid-type -> unsigned-integer\nwidth, height, radius ->  unsigned-integer\nprop-value-count -> unsigned-integer\ndelta-a, delta-b -> <1-delta>"),(0,i.yg)("p",null,"comp-type, uncomp-byte-count, comp-byte-count -> unsigned-integer\ncomp-bytes -> byte*"),(0,i.yg)("p",null,"x, y -> signed-integer\nstart-extension, end-extension -> signed-integer"),(0,i.yg)("p",null,"unit, angle, magnification -> real"),(0,i.yg)("p",null,"<1-delta> -> signed-integer // xxx...xxxd\n<2-delta> -> unsigned-integer // xxx...xxdd\n<3-delta> -> unsigned-integer                                            //                                            xxx...xddd\ng-delta -> unsigned-integer ","[ unsigned-integer ]"," // xxx...xxxddd0   or   xxx...xxxd1  xxx...xxxd"),(0,i.yg)("p",null,"real -> { real0 | real1 | real2 | real3 | real4 | real5 | real6 | real7 }\nreal0 -> \u20180\u2019 unsigned-integer // Positive whole number\nreal1 -> \u20181\u2019 unsigned-integer // Negative whole number\nreal2 -> \u20182\u2019 unsigned-integer // Positive reciprocal\nreal3 -> \u20183\u2019 unsigned-integer // Negative reciprocal\nreal4 -> \u20184\u2019 unsigned-integer unsigned-integer // Positive ratio\nreal5 -> \u20185\u2019 unsigned-integer unsigned-integer // Negative ratio\nreal6 -> \u20186\u2019 ieee-4 // Single-precision floating point\nreal7 -> \u20187\u2019 ieee-8 // Double-precision floating point"),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 31\nAPPENDIX 1\nCALCULATION OF VALIDATION SIGNATURES\nNOTICE:    The  material  in  this  appendix  is  an  official  part  of  SEMI  P39  and  was  approved  by  full  letter  ballot\nprocedures on July 12, 2003.\nA1-1  Sample CRC32 C-Language Source Code\nThe CRC32 must be calculated by processing the file contents as a single stream of bytes (CRC\u2019s are order-\ndependent).  The CRC should be initialized by calling:"),(0,i.yg)("p",null,"uint32  crc;  /",(0,i.yg)("em",{parentName:"p"}," the crc value "),"/\ncrc32_init(&crc);"),(0,i.yg)("p",null,"As each chunk of data in written into the file, one should call :"),(0,i.yg)("p",null,"byte    ",(0,i.yg)("em",{parentName:"p"},"buf;  /")," data written to output ",(0,i.yg)("em",{parentName:"p"},"/\nsize_t  len;   /")," # of bytes of data written to output */\ncrc32_add(&crc, buf, len);"),(0,i.yg)("p",null,"When the END record is to be written, the CRC should be calculated using the"),(0,i.yg)("p",null,"id-value and validation-scheme  only."),(0,i.yg)("p",null,"The final value of the CRC32 should then be appended to the file as a 4-byte value in little-endian order."),(0,i.yg)("p",null,"#define  CHG_ENDIAN32(a)  { byte  ",(0,i.yg)("em",{parentName:"p"},"p, b; \\\np = (byte "),") &(a); b=p","[0]","; p","[0]","=p","[3]","; p","[3]","=b; b=p","[1]","; p","[1]","=p","[2]","; p","[2]","=b; }"),(0,i.yg)("p",null,"#ifdef BIG_ENDIAN_MACHINE\n/",(0,i.yg)("em",{parentName:"p"}," put calculated CRC in LITTLE_ENDIAN order (to align with byte ordering of the polynomial)\n"),"/\nCHG_ENDIAN32(crc);\n#endif"),(0,i.yg)("hr",null),(0,i.yg)("hr",null),(0,i.yg)("p",null,"/",(0,i.yg)("em",{parentName:"p"},"\n(c) Copyright 2003 SEMI   no warranty, express or implied\nnot liable for damages resulting from or in connection with use of this software\n"),"/"),(0,i.yg)("p",null,"#include stdio.h\n#include errno.h"),(0,i.yg)("p",null,"#define TEST"),(0,i.yg)("p",null,"/",(0,i.yg)("strong",{parentName:"p"},(0,i.yg)("strong",{parentName:"strong"},(0,i.yg)("strong",{parentName:"strong"},(0,i.yg)("strong",{parentName:"strong"},"****")))),"/\n/",(0,i.yg)("em",{parentName:"p"}," basic data types "),"/\n/",(0,i.yg)("strong",{parentName:"p"},(0,i.yg)("strong",{parentName:"strong"},(0,i.yg)("strong",{parentName:"strong"},(0,i.yg)("strong",{parentName:"strong"},"****")))),"/\ntypedef unsigned char   byte;\ntypedef unsigned int    uint32;"),(0,i.yg)("p",null,"/",(0,i.yg)("strong",{parentName:"p"},(0,i.yg)("strong",{parentName:"strong"},(0,i.yg)("strong",{parentName:"strong"},"*"))),"/\n/",(0,i.yg)("em",{parentName:"p"}," constants "),"/\n/",(0,i.yg)("strong",{parentName:"p"},(0,i.yg)("strong",{parentName:"strong"},(0,i.yg)("strong",{parentName:"strong"},"*"))),"/\n#define  BUFFER_SZ      8 * 1024\n#define  BITS_IN_BYTE   8"),(0,i.yg)("p",null,"/",(0,i.yg)("strong",{parentName:"p"},(0,i.yg)("strong",{parentName:"strong"},"**")),"/\n/",(0,i.yg)("em",{parentName:"p"}," macros "),"/\n/",(0,i.yg)("strong",{parentName:"p"},(0,i.yg)("strong",{parentName:"strong"},"**")),"/\n#define CHG_ENDIAN(a) {byte ",(0,i.yg)("em",{parentName:"p"},"p, t; p=(byte "),") &(a); t=p","[0]","; p","[0]","=p","[3]","; p","[3]","=t; t=p","[1]","; p","[1]","=p","[2]",";\np","[2]","=t;}"),(0,i.yg)("p",null,"/*\nCRC polynomial as specified in ISO 3309 and ITU-T V.42\nused in Ethernet, FDDI, cksum, etc\npolynomial is  x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"x^8  + x^7  + x^5  + x^4  + x^2  + x^1  + x^0")),(0,i.yg)("p",null,"if the leftmost bit is the msb, this is\nbinary  1 0000 0100 1100 0001 0001 1101 1011 0111"),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 32\nhex     1 0    4    c    1    1    d    b    7\nbig order bit is implicit so we have\n0x04c11db7\n*/"),(0,i.yg)("p",null,"#ifdef _ILP32"),(0,i.yg)("h1",{id:""}),(0,i.yg)("h1",{id:"define--crc32_poly------0x04c11db7ul---polynomial-"},"define  CRC32_POLY      0x04c11db7ul  /",(0,i.yg)("em",{parentName:"h1"}," polynomial "),"/"),(0,i.yg)("h1",{id:"define--crc32_constant--0x4b90b035ul---constant-which-matches-polynomial-above-"},"define  CRC32_CONSTANT  0x4b90b035ul  /",(0,i.yg)("em",{parentName:"h1"}," constant which matches polynomial above "),"/"),(0,i.yg)("h1",{id:"define--leftmost_bit----0x80000000ul"},"define  LEFTMOST_BIT    0x80000000ul"),(0,i.yg)("h1",{id:"define--all_bits--------0xfffffffful"},"define  ALL_BITS        0xfffffffful"),(0,i.yg)("p",null,"#else"),(0,i.yg)("h1",{id:"define--crc32_poly------0x04c11db7u----polynomial-"},"define  CRC32_POLY      0x04c11db7u   /",(0,i.yg)("em",{parentName:"h1"}," polynomial "),"/"),(0,i.yg)("h1",{id:"define--crc32_constant--0x4b90b035u----constant-which-matches-polynomial-above-"},"define  CRC32_CONSTANT  0x4b90b035u   /",(0,i.yg)("em",{parentName:"h1"}," constant which matches polynomial above "),"/"),(0,i.yg)("h1",{id:"define--leftmost_bit----0x80000000u"},"define  LEFTMOST_BIT    0x80000000u"),(0,i.yg)("h1",{id:"define--all_bits--------0xffffffffu"},"define  ALL_BITS        0xffffffffu"),(0,i.yg)("p",null,"#endif"),(0,i.yg)("p",null,"/",(0,i.yg)("em",{parentName:"p"}," initialized to zero by the compiler "),"/\nstatic uint32  Crc32_tbl","[256]",";"),(0,i.yg)("p",null,"static void\ncrc32_tbl_load(void)\n{\nint     i;\nuint32  c;\nint     j;"),(0,i.yg)("p",null,"/",(0,i.yg)("em",{parentName:"p"}," initialize auxiliary table "),"/\nfor (i = 0; i < 256; i++)\n{\nc = i << 24;"),(0,i.yg)("p",null,"for (j = 0; j < BITS_IN_BYTE; j++)\nc = c & LEFTMOST_BIT <? (c << 1) ^ CRC32_POLY : (c << 1);"),(0,i.yg)("p",null,"Crc32_tbl","[i]"," = c;\n}\n}"),(0,i.yg)("p",null,"void\ncrc32_init(uint32  ",(0,i.yg)("em",{parentName:"p"},"crc)\n{\n/")," initialize auxiliary table (if necessary) */\nif (!Crc32_tbl","[1]",")\ncrc32_tbl_load();"),(0,i.yg)("p",null,"/",(0,i.yg)("em",{parentName:"p"}," preload shift register, per CRC-32 spec "),"/\n*crc = ALL_BITS;\n}"),(0,i.yg)("p",null,"void\ncrc32_add(uint32  ",(0,i.yg)("em",{parentName:"p"},"crc,\nbyte    "),"buf,\nsize_t  len\n)\n{\nuint32  val;\nsize_t  i;"),(0,i.yg)("p",null,"val = *crc;\nval = ~val & ALL_BITS;"),(0,i.yg)("p",null,"for (i = 0; i < len; i++)\nval = (val >> 8) ^ Crc32_tbl[ (val ^ buf","[i]",") & 0xff];"),(0,i.yg)("p",null,"val = ~val & ALL_BITS;\n*crc = val;\n}"),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 33\nmain(int argc, char *",(0,i.yg)("em",{parentName:"p"},"argv)\n{\nchar    "),"path;\nFILE    *fptr;\nsize_t  len;\nbyte    buf","[BUFFER_SZ]",";\nuint32  crc;\nuint32  crc_to_file;"),(0,i.yg)("p",null,'switch (argc)\n{\ncase 1 :\npath = "stdin";\nfptr = stdin;  /',(0,i.yg)("em",{parentName:"p"}," read from standard input "),"/\nbreak;"),(0,i.yg)("p",null,"case 2 :\n/",(0,i.yg)("em",{parentName:"p"}," open input file (use the \u2019b\u2019 flag to read as binary rather than text) "),"/\npath = argv","[1]",';\nif ( (fptr = fopen(path, "rb") ) == NULL)\n{\nfprintf(stderr, "\\nerror opening %s (%s)\\n", path, strerror(errno) );\nexit(1);\n}\nbreak;'),(0,i.yg)("p",null,'default :\nfprintf(stderr, "\\nusage: %s   pathname\\n", argv',"[0]",');\nfprintf(stderr, "       -or-");\nfprintf(stderr, "\\n       %s < pathname\\n", argv',"[0]",");\nexit(1);\n}"),(0,i.yg)("p",null,"/",(0,i.yg)("em",{parentName:"p"}," initialize "),"/\ncrc32_init(&crc);"),(0,i.yg)("p",null,"/",(0,i.yg)("em",{parentName:"p"}," calculate crc for all data in file "),"/\nwhile (len = (fread(buf, 1, BUFFER_SZ, fptr) ) )\ncrc32_add(&crc, buf, len);"),(0,i.yg)("p",null,'if (!feof(fptr) )\n{\nfprintf(stderr, "\\nerror reading %s (%s)\\n", path, strerror(errno) );\nif (fptr != stdin)\nfclose(fptr);\nexit(1);\n}'),(0,i.yg)("p",null,"if (fptr != stdin)\nfclose(fptr);"),(0,i.yg)("p",null,"crc_to_file = crc;"),(0,i.yg)("p",null,"/",(0,i.yg)("em",{parentName:"p"}," ensure CRC32 is written to OASIS file in LITTLE_ENDIAN byte order "),"/\n#ifdef BIG_ENDIAN_MACHINE\nCHG_ENDIAN(crc_to_file);\n#endif"),(0,i.yg)("p",null,"#ifdef TEST\n/",(0,i.yg)("em",{parentName:"p"}," this is the crc value that should be the last 4 bytes in the file "),'/\nprintf("crc_to_file                         = 0x%08x\\n", crc_to_file);'),(0,i.yg)("p",null,"/",(0,i.yg)("em",{parentName:"p"}," assume the CRC32 value crc_to_file was appended to the end of the Oasis file "),"/\n/",(0,i.yg)("em",{parentName:"p"}," add the CRC32 (in LITTLE_ENDIAN order) to the data stream and continue CRC calculation "),"/\ncrc32_add(&crc, (byte *) &crc_to_file, size of(crc_to_file) );\n#endif"),(0,i.yg)("p",null,'printf("crc_constant (should be 0x%08x) = 0x%08x\\n", CRC32_CONSTANT, crc);'),(0,i.yg)("p",null,"exit(0);\n}"),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 34\nA1-2  Sample CHECKSUM32 C-Language Source Code\n/",(0,i.yg)("em",{parentName:"p"},"\n(c) Copyright 2003 SEMI\nno warranty, express or implied\nnot liable for damages resulting from or in connection with use of this software\n"),"/"),(0,i.yg)("p",null,"#include stdio.h\n#include errno.h"),(0,i.yg)("p",null,"/",(0,i.yg)("strong",{parentName:"p"},(0,i.yg)("strong",{parentName:"strong"},(0,i.yg)("strong",{parentName:"strong"},(0,i.yg)("strong",{parentName:"strong"},"****")))),"/\n/",(0,i.yg)("em",{parentName:"p"}," basic data types "),"/\n/",(0,i.yg)("strong",{parentName:"p"},(0,i.yg)("strong",{parentName:"strong"},(0,i.yg)("strong",{parentName:"strong"},(0,i.yg)("strong",{parentName:"strong"},"****")))),"/\ntypedef unsigned char   byte;\ntypedef unsigned int    uint32;"),(0,i.yg)("p",null,"#ifdef _ILP32\ntypedef unsigned long long  uint64;\n#else\ntypedef unsigned long       uint64;\n#endif"),(0,i.yg)("p",null,"/",(0,i.yg)("strong",{parentName:"p"},(0,i.yg)("strong",{parentName:"strong"},(0,i.yg)("strong",{parentName:"strong"},"*"))),"/\n/",(0,i.yg)("em",{parentName:"p"}," constants "),"/\n/",(0,i.yg)("strong",{parentName:"p"},(0,i.yg)("strong",{parentName:"strong"},(0,i.yg)("strong",{parentName:"strong"},"*"))),"/\n#define  BUFFER_SZ      8 * 1024\n#define  BITS_IN_BYTE   8"),(0,i.yg)("p",null,"/",(0,i.yg)("strong",{parentName:"p"},(0,i.yg)("strong",{parentName:"strong"},"**")),"/\n/",(0,i.yg)("em",{parentName:"p"}," macros "),"/\n/",(0,i.yg)("strong",{parentName:"p"},(0,i.yg)("strong",{parentName:"strong"},"**")),"/\n#define CHG_ENDIAN(a) {byte ",(0,i.yg)("em",{parentName:"p"},"p, t; p=(byte "),")&(a); t=p","[0]","; p","[0]","=p","[3]","; p","[3]","=t; t=p","[1]","; p","[1]","=p","[2]",";\np","[2]","=t;}"),(0,i.yg)("p",null,"void\nchecksum_init(uint32  ",(0,i.yg)("em",{parentName:"p"},"chksum)\n{\n"),"chksum = 0;\n}"),(0,i.yg)("p",null,"void\nchecksum_add(uint32  ",(0,i.yg)("em",{parentName:"p"},"chksum,\nbyte    "),"buf,\nsize_t  len\n)\n{\nuint64  val;  /",(0,i.yg)("em",{parentName:"p"}," could be a uint32, but overflow handling is undefined "),"/\nsize_t  i;"),(0,i.yg)("p",null,"val = (uint64) *chksum;"),(0,i.yg)("p",null,"for (i = 0; i < len; i++)\n{\nval += buf","[i]",";      /",(0,i.yg)("em",{parentName:"p"}," sum "),"/\nval &= 0xffffffff;  /",(0,i.yg)("em",{parentName:"p"}," limit to 32 bits "),"/\n}"),(0,i.yg)("p",null,"*chksum = (uint32) val;\n}"),(0,i.yg)("p",null,"main(int argc, char *",(0,i.yg)("em",{parentName:"p"},"argv)\n{\nchar    "),"path;\nFILE    *fptr;\nsize_t  len;\nbyte    buf","[BUFFER_SZ]",";\nuint32  chksum;\nuint32  chksum_to_file;"),(0,i.yg)("p",null,"switch (argc)"),(0,i.yg)("p",null,'SEMI P39-0304\nE2\n\xa9 SEMI 2004 35\n{\ncase 1 :\npath = "stdin";\nfptr = stdin;  /',(0,i.yg)("em",{parentName:"p"}," read from standard input "),"/\nbreak;"),(0,i.yg)("p",null,"case 2 :\n/",(0,i.yg)("em",{parentName:"p"}," open input file (use the \u2019b\u2019 flag to read as binary rather than text) "),"/\npath = argv","[1]",';\nif ( (fptr = fopen(path, "rb") ) == NULL)\n{\nfprintf(stderr, "\\nerror opening %s (%s)\\n", path, strerror(errno) );\nexit(1);\n}\nbreak;'),(0,i.yg)("p",null,'default :\nfprintf(stderr, "\\nusage: %s   pathname\\n", argv',"[0]",');\nfprintf(stderr, "       -or-");\nfprintf(stderr, "\\n       %s < pathname\\n", argv',"[0]",");\nexit(1);\n}"),(0,i.yg)("p",null,"/",(0,i.yg)("em",{parentName:"p"}," initialize "),"/\nchecksum_init(&chksum);"),(0,i.yg)("p",null,"/",(0,i.yg)("em",{parentName:"p"}," calculate checksum for all data in file "),"/\nwhile (len = (fread(buf, 1, BUFFER_SZ, fptr) ) )\nchecksum_add(&chksum, buf, len);"),(0,i.yg)("p",null,'if (!feof(fptr) )\n{\nfprintf(stderr, "\\nerror reading %s (%s)\\n", path, strerror(errno) );\nif (fptr != stdin)\nfclose(fptr);\nexit(1);\n}'),(0,i.yg)("p",null,"if (fptr != stdin)\nfclose(fptr);"),(0,i.yg)("p",null,"chksum_to_file = chksum;"),(0,i.yg)("p",null,"/",(0,i.yg)("em",{parentName:"p"}," ensure CHECKSUM32 is written to OASIS file in LITTLE_ENDIAN byte order "),"/\n#ifdef BIG_ENDIAN_MACHINE\nCHG_ENDIAN(chksum_to_file);\n#endif"),(0,i.yg)("p",null,"/",(0,i.yg)("em",{parentName:"p"}," this is the checksum value that should be the last 4 bytes in the file "),'/\nprintf("chksum_to_file = 0x%08x\\n", chksum_to_file);'),(0,i.yg)("p",null,"exit(0);\n}"),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 36\nAPPENDIX 2\nOASIS Standard Properties\nNOTICE:    The  material  in  this  appendix  is  an  official  part  of  SEMI  P39  and  was  approved  by  full  letter  ballot\nprocedures on July 12, 2003.\nA2-1  File-Level Standard Properties\nA2-1.1  Any file-level standard properties must appear immediately after the START record in an OASIS file. Use\nof file-level standard properties is optional\u2014OASIS processors may omit/ignore any or all of them.\nA2-1.2  S_MAX_SIGNED_INTEGER_WIDTH\nA2-1.2.1  This property declares the maximum number of bytes required to represent any signed-integer in the file,\nafter all continuation bits have been removed and the integer has been expressed in twos-complement form. Its value\nlist consists of a single unsigned-integer.\nA2-1.3  S_MAX_UNSIGNED_INTEGER_WIDTH\nA2-1.3.1  This  property  declares  the  maximum  number  of  bytes  required  to  represent  any  unsigned-integer  in  the\nfile, after all continuation bits have been removed. Its value list consists of a single unsigned-integer.\nA2-1.4  S_MAX_STRING_LENGTH\nA2-1.4.1  This property declares the maximum number of bytes permitted in any string within the file. Its value list\nconsists of a single unsigned-integer.\nA2-1.5  S_POLYGON_MAX_VERTICES\nA2-1.5.1  This  property  declares  the  maximum  number  of  vertices  permitted  in  any  polygon  within  the  file,\nincluding any implicit vertices, but counting the initial vertex only once. Its value list consists of a single unsigned-\ninteger.\nA2-1.6  S_PATH_MAX_VERTICES\nA2-1.6.1  This property declares the maximum number of vertices permitted in any path within the file. Its value list\nconsists of a single unsigned-integer.\nA2-1.7  S_TOP_CELL\nA2-1.7.1  This property is used to declare the name of the \u201ctop cell\u201d of a cell hierarchy. Its value list consists of a\nsingle n-string. It may be repeated if more than one distinct cell hierarchy exists within the OASIS file in which it\nappears.\nA2-1.8  S_BOUNDING_BOXES_AVAILABLE\nA2-1.8.1  This property indicates whether or not S_BOUNDING_BOX properties appear in CELLNAME records.\nIts value list consists of a single unsigned-integer. A value of 0 means that S_BOUNDING_BOX properties are not\nprovided. A value of 1 means that at least some S_BOUNDING_BOX properties are provided. A value of 2 means\nthat an S_BOUNDING_BOX property is provided for every CELLNAME record.\nA2-2  Cell-Level Standard Properties\nA2-2.1  Any cell-level standard properties must appear immediately after the corresponding CELLNAME record in\nan  OASIS  file.  Use  of  cell-level  standard  properties  is  optional\u2014OASIS  processors  may  omit/ignore  any  or  all  of\nthem.\nA2-2.2  S_BOUNDING_BOX\nA2-2.2.1  This property may occur once after each CELLNAME record, and declares the bounding box of that cell.\nIts value list consists of the following 5 fields: flags lower-left-x lower-left-y width height. The lower-\nleft-x and lower-left-y fields are signed-integers  representing  the  lower-left  corner  of  the  cell\u2019s  bounding  box.  The\nwidth  and  height  fields  are  unsigned-integers  representing  the  width  and  height  of  the  cell\u2019s  bounding  box.  The"),(0,i.yg)("p",null,"SEMI P39-0304\nE2\n\xa9 SEMI 2004 37\nbounding  box  should  be  calculated  to  cover  the  full  extent  of  all  geometric  figures  and  text  element  (x,y)  points\nwithin that cell and all of its subcells after a full expansion of any hierarchy beneath the cell.\nA2-2.2.2  The flags field is an unsigned-integer. Only the least-significant 3 bits are presently defined, and have the\nfollowing meanings:\nflags.bit.0: 0 = bounding box is known\n1 = bounding box is unknown\nflags.bit.1: 0 = bounding box is non-empty\n1 = bounding box is empty\nflags.bit.2: 0 = bounding box depends on no external cells\n1 = bounding box depends on one or more external cells\nA2-2.3  S_CELL_OFFSET\nA2-2.3.1  This property may occur once after each CELLNAME record. Its value list consists of a single unsigned-\ninteger  which  declares  the  byte  offset  from  the  beginning  of  the  file  (byte  0)  to  where  the  corresponding  CELL\nrecord appears in the file. An offset value of 0 denotes an external cell, with no corresponding CELL record in the\nsame OASIS file.\nA2-3  Element-Level Properties\nA2-3.1  S_GDS_PROPERTY\nA2-3.1.1  This property is intended exclusively for compatibility with GDSII Stream properties. It may occur one or\nmore  times  after  any  element  within  a  CELL  definition.  Its  value  list  contains  exactly  two  values  in  sequence:\nattribute,  an  unsigned-integer,  and  propvalue-string,  a  b-string.  These  values  correspond  to  GDSII  Stream\nPROPATTR and PROPVALUE records, respectively."),(0,i.yg)("p",null,"NOTICE: SEMI makes no warranties or representations as to the suitability of the standards set forth herein for any\nparticular  application.  The  determination  of  the  suitability  of  the  standard  is  solely  the  responsibility  of  the  user.\nUsers  are  cautioned  to  refer  to  manufacturer's  instructions,  product  labels,  product  data  sheets,  and  other  relevant\nliterature,  respecting  any  materials  or  equipment  mentioned  herein.  These  standards  are  subject  to  change  without\nnotice.\nBy  publication  of  this  standard,  Semiconductor  Equipment  and  Materials  International  (SEMI)  takes  no  position\nrespecting  the  validity  of  any  patent  rights  or  copyrights  asserted  in  connection  with  any  items  mentioned  in  this\nstandard. Users of this standard are expressly advised that determination of any such patent rights or copyrights, and\nthe risk of infringement of such rights are entirely their own responsibility."),(0,i.yg)("p",null,"Copyright   by   SEMI\xae   (Semiconductor   Equipment   and   Materials\nInternational), 3081 Zanker Road, San Jose, CA 95134. Reproduction of\nthe  contents  in  whole  or  in  part  is  forbidden  without  express  written\nconsent of SEMI."),(0,i.yg)("p",null,"SEMI P40-1103 \xa9 SEMI 2003 1\nSEMI P40-1103\nSPECIFICATION FOR MOUNTING REQUIREMENTS AND ALIGNMENT\nREFERENCE LOCATIONS FOR EXTREME ULTRAVIOLET\nLITHOGRAPHY MASKS\nThis  specification  was  technically  approved  by  the  Global  Micropatterning  Committee  and  is  the  direct\nresponsibility  of  the  North  American  Micropatterning  Committee.    Current  edition  approved  by  the  North\nAmerican  Regional  Standards  Committee  on  September  3,  2003.    Initially  available  at  ",(0,i.yg)("a",{parentName:"p",href:"http://www.semi.org"},"www.semi.org"),"\nSeptember 2003; to be published November 2003.\n1  Purpose"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"1            This      specification      covers      the      mounting\nrequirements   for   Extreme   Ultraviolet   Lithography\n(EUVL) masks.\n2  Scope"),(0,i.yg)("li",{parentName:"ol"},"1    This  standard  details  the  requirements  for  EUVL\nmask  mounting.    The  mask  mount  is  a  flat  reference\nsurface   against   which   the   mask   is   clamped.      The\nspecific design and material of the mask mount are not\nspecified."),(0,i.yg)("li",{parentName:"ol"},"1.1  The mounting requirements in this standard apply\nto the exposure tool, the mask pattern generator and the\npattern  placement  metrology  tool.    As  an  option,  the\nrequirements   may   be   used   in   other   tools   used   to\nfabricate or measure EUV masks."),(0,i.yg)("li",{parentName:"ol"},"2    This  standard  also  defines  the  area  on  the  EUV\nmask  reserved  for  proper  handling,  identification  (ID)\nmarks  and  alignment  references.  The  forms  of  the\nalignment and ID marks are not specified.\nNOTICE:  This  standard  does  not  purport  to  address\nsafety  issues,  if  any,  associated  with  its  use.    It  is  the\nresponsibility  of  the  users  of  this  standard  to  establish\nappropriate  safety  and  health  practices  and  determine\nthe applicability of regulatory or other limitations prior\nto use.\n3  Referenced Standards"),(0,i.yg)("li",{parentName:"ol"},"1  SEMI Standards\nSEMI  P37  \u2014  Specification  for  Extreme  Ultraviolet\nLithography Mask Substrates\nSEMI  P38  \u2014  Specification  for  Absorbing  Film  Stacks\nand  Multilayers  on  Extreme  Ultraviolet  Lithography\nMask Blanks\nNOTICE:  Unless  otherwise  indicated,  all  documents\ncited shall be the latest published versions.\n4  Terminology"),(0,i.yg)("li",{parentName:"ol"},"1  Abbreviations and Acronyms"),(0,i.yg)("li",{parentName:"ol"},"1.1  EUV \u2014 extreme ultraviolet"),(0,i.yg)("li",{parentName:"ol"},"1.2  EUVL \xf3 extreme ultraviolet lithography"),(0,i.yg)("li",{parentName:"ol"},"2  Definitions"),(0,i.yg)("li",{parentName:"ol"},"2.1  chuck \xf3  the  chuck  is  the  physical  apparatus  in\nthe tools listed in Section 2.1.1 upon which the mask is\nmounted."),(0,i.yg)("li",{parentName:"ol"},"2.2  mounting  surface \xf3  the  mounting  surface  is  the\nsurface  of  the  chuck  in  direct  contact  with  the  mask.\nThe  backside  of  the  mask,  which  is  the  unpatterned\nside,   shall   be   in   direct   contact   with   the   mounting\nsurface while the mask is being used in the tools listed\nin Section 2.1.1."),(0,i.yg)("li",{parentName:"ol"},"2.3  pin  or  pedestal \xf3 the  surface  of  the  chuck  may\nconsist  of  an  array  of  pins  or  pedestals.    Pins  are\nprotrusions from the chuck surface that come to a point\nat the location on their surface farthest from the chuck.\nPedestals  have  a  nominally  flat  surface  at  their  surface\nfarthest  from  the  chuck.    Note  that  if  S\np\n= P\np\nin  Figure\n5, the chuck is referred to as a pin chuck.  Otherwise, it\nis a pedestal chuck."),(0,i.yg)("li",{parentName:"ol"},"2.4  user \xf3   this   term   may   refer   to   the   user   of\nfabrication  equipment  for  EUV  masks  that  contains  a\nchuck,  or  this  term  may  refer  to  the  purchaser  of  an\nEUV mask from a mask supplier.\n5  Mask Layout Requirements"),(0,i.yg)("li",{parentName:"ol"},"1        The    square    substrates    shall    conform    to    the\ndimensional tolerances as defined in Section 6 of SEMI\nP37.    Datum  points  on  the  edges  of  the  mask  substrate\nare defined in Figure 2 of SEMI P37."),(0,i.yg)("li",{parentName:"ol"},"2    Masks  shall  have  areas  reserved  for  patterns  to  be\nprinted,   for   identification   (ID)   marks,   for   reticle\nalignment  on  the  front  side  and  for  handling  as  shown\nin Figure 1."),(0,i.yg)("li",{parentName:"ol"},"2.1    The  mask  layout  shall  include  an  area  reserved\nfor the printable area, which has maximum dimensions")),(0,i.yg)("p",null,"SEMI P40-1103 \xa9 SEMI 2003 2\nof 104 mm by 132 mm.  This region is also centered on\nthe mask as shown in Figure 1.\n5. 2.2      The   region   outside   of   the   printable   area   is\nreserved  for  alignment  marks,  ID  marks  and  handling.\nThe  location  of  the  regions  for  these  items  is  to  be\nnegotiated between user and supplier.\n6  Mounting Requirements\n6. 1    The  mask  mounting  quality  area  is  indicated  in\nFigure 2.  The dimensions of the mask mounting quality\narea, D  and  W,  are  agreed  upon  beween  user  and\nsupplier.    The  edge  length  of  the  mask  substrate,  L,  is\ndefined in Table 1 of SEMI P37.\n6. 2      The   mounting   surface   shall   meet   the   flatness\nrequirements  defined  in  Table  1  over  the  mounting\nquality area shown in Figure 2.\n6. 2.1    The  flatness  error  is  defined  as  the  maximum\ndeviation  of  the  surface  from  the  best  fit  plane  that\nminimizes  the  maximum  deviation  of  the  mounting\nsurface   from   the   best   fit   plane.   This   definition   is\nillustrated  in  Figure  3.    Note  that  the  mounting  surface\nis defined in Section 4.2.2 .\n6. 3    The  mounting  surface  may  be  discontinuous  and\nnot  touch  the  backside  at  all  points  within  the  flatness\nquality area.  In other words, the mounting surface may\nbe an array of pins or pedestals.\n6. 3.1    The  maximum  distance  between  these  pins  must\nmeet  the  requirements  shown  in  Table  4.    Figure  5\ndefines the pin spacing.\n6. 3.2    Other  dimensions  of  the  pins  shown  in  Figure  5\nare to be agreed upon between the user and supplier as\nindicated  in  Table  4.    Note  that  if  S\np\n= P\np\nin  Figure  5,\nthe chuck is referred to as a pin chuck.\n6. 3.3      If   the   mounting   surface   is   discontinuous   as\nallowed   in   Section   6.3,   the   plane   that   defines   the\nmaximum  deviation  will  include  points  near  or  at  the\ntops of the pins or pedestals.  This plane is illustrated in\nFigure 4.\n6. 4      The   mask   will   be   mounted   with   a   clamping\npressure as specified in Table 2. The clamping pressure\nis  the  force  per  unit  area  in  the  plane  of  the  mounting\nsurface.    The  minimum  effective  bending  stiffness  of\nthe chuck cross section is specified in Table 3.\n6. 5      The  mask  mounting  and  chuck  attributes  are  not\nlimited to EUVL exposure/stepper tool but apply to the\nmask    pattern    generator    and    pattern    placement\nmetrology tools.\n7  Test Methods\n7. 1  Flatness \uf8e7  to  be  agreed  upon  between  user  and\nsupplier.\n7. 2  Stiffness \uf8e7  to  be  agreed  upon  between  user  and\nsupplier.\n7. 3  Clamping  Pressure \uf8e7  to  be  agreed  upon  between\nuser and supplier.\n7. 4  Pin   or   Pedestal   Spacing,   Height,   Period   and\nSidewall Angle \uf8e7 to be agreed upon between user and\nsupplier.\n8  Certification\n8. 1    Upon  request  of  the  user,  a  supplier's  certification\nthat   the   chuck   was   manufactured   and   tested   in\naccordance   with   this   specification,   together   with   a\nreport  of  the  test  results,  shall  be  furnished  at  the  time\nof shipment."),(0,i.yg)("p",null,"SEMI P40-1103 \xa9 SEMI 2003 3\nMaximum printable\nfield\n(4x) 104 by 132 mm\n(26 by 33 mm at\nwafer)\nArea reserved for"),(0,i.yg)("p",null,"alignment marks, ID"),(0,i.yg)("p",null,"marks, and handling"),(0,i.yg)("p",null,"(The position of these"),(0,i.yg)("p",null,"items are to be"),(0,i.yg)("p",null,"negotiated between user"),(0,i.yg)("p",null,"and supplier.)"),(0,i.yg)("p",null,"Area for patterns printed on wafer\n66. 0"),(0,i.yg)("ol",{start:76},(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"0")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"0")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"0"))),(0,i.yg)("p",null,"CL"),(0,i.yg)("p",null,"CL"),(0,i.yg)("p",null,"Figure 1\nLayout of the Front Surface of the EUVL Mask, Showing Areas Reserved for Printed Patterns, ID Marks,\nAlignment Marks and Handling\nUnits are in millimeters, and CL identifies the dotted lines as centerlines."),(0,i.yg)("p",null,"L\nD\nW\nMounting\nquality\narea\nL"),(0,i.yg)("p",null,"Figure 2\nDimensions of Mounting Quality Area"),(0,i.yg)("p",null,"SEMI P40-1103 \xa9 SEMI 2003 4\nTable 1  Flatness of the Mounting Surface\nAny Square Region with Specified Edge Length (millimeters)                         Peak-to-Valley                         Flatness                         (nanometers)\n150                                                                                                   48\n75                                                                                                    24\n40                                                                                                    12\n25                                                                                                     8\n20                                                                                                     6\n10                                                                                                     3"),(0,i.yg)("p",null,"Table 2  Clamping Pressure\nMean Clamping Pressure (KPa) Maximum Range of Clamping Pressure within Flatness Quality\nArea (KPa)\n15 \xb1 1.5\n3. 0"),(0,i.yg)("p",null,"Table 3  Minimum Effective Bending Stiffness of the Chuck Cross Section\nBending Stiffness (Newton-meter) (See Note 1.)\n30,000\nNOTE 1: The effective bending stiffness (D) of a chuck with a solid cross section is given by:\nD=\nEh\n3\n12 1\u2212\u03bd\n2\n()"),(0,i.yg)("p",null,"where E is the elastic modulus in N/m\n3\n, h is the thickness in meters and \u03bd is Poisson\u2019s ratio."),(0,i.yg)("p",null,"Table 4  Dimensions of Pins or Pedestals on Chuck Surface\nParameter Label for parameter in\nFigure 5\nUnits                                  Required                                  Value\nMaximum spacing S\np\nmillimeters                        10\nPeriod                                                                      P\np\nmillimeters To be agreed upon between\nuser and supplier\nAngle of sidewall\n\u03b8\ndegrees To be agreed upon between\nuser and supplier\nPin height H\np\nmicrons To be agreed upon between\nuser and supplier"),(0,i.yg)("p",null,"SEMI P40-1103 \xa9 SEMI 2003 5\nP\n1\nMounting surface\nFlatness error\nChuck"),(0,i.yg)("p",null,"Figure 3\nDefinition of Flatness Error\nP\n1\nis the best fit plane that minimizes the maximum deviation of the surface from P\n1\n."),(0,i.yg)("p",null,"P\n1\nMounting surface\nFlatness error\nChuck"),(0,i.yg)("p",null,"Figure 4\nDefinition of Flatness Error for a Pin or Pedestal Chuck\nP\n1\nis the best fit plane that minimizes the maximum deviation from the surface that passes through the\nhighest points on the chuck surface."),(0,i.yg)("p",null,"SEMI P40-1103 \xa9 SEMI 2003 6\nPin sidewall angle\nChuck\nPin spacing, S\np\n\u03b8\nPin period, P\np\nPin height, H\np"),(0,i.yg)("p",null,"Figure 5\nDimensions of Pins or Pedestals on the Chuck Surface"),(0,i.yg)("p",null,"NOTICE: SEMI makes no warranties or representations as to the suitability of the standards set forth herein for any\nparticular  application.    The  determination  of  the  suitability  of  the  standard  is  solely  the  responsibility  of  the  user.\nUsers  are  cautioned  to  refer  to  manufacturer's  instructions,  product  labels,  product  data  sheets,  and  other  relevant\nliterature, respecting any materials or equipment mentioned herein.  These standards are subject to change without\nnotice.\nBy  publication  of  this  standard,  Semiconductor  Equipment  and  Materials  International  (SEMI)  takes  no  position\nrespecting  the  validity  of  any  patent  rights  or  copyrights  asserted  in  connection  with  any  items  mentioned  in  this\nstandard.  Users of this standard are expressly advised that determination of any such patent rights or copyrights, and\nthe risk of infringement of such rights are entirely their own responsibility."),(0,i.yg)("p",null,"Copyright   by   SEMI\xae   (Semiconductor   Equipment   and   Materials\nInternational), 3081 Zanker Road, San Jose, CA 95134. Reproduction o\nf\nthe  contents  in  whole  or  in  part  is  forbidden  without  express  written\nconsent of SEMI."),(0,i.yg)("p",null,"SEMI P41-0304\nE\n\xa9 SEMI 2004 1\nSEMI P41-0304\nE"),(0,i.yg)("p",null,"SPECIFICATION FOR MASK DEFECT DATA HANDLING WITH XML,\nBETWEEN DEFECT INSPECTION TOOLS, REPAIR TOOLS, AND\nREVIEW TOOLS\nThis  specification  was  technically  approved  by  the  Global  Micropatterning  Committee  and  is  the  direct\nresponsibility  of  the  Japanese  Micropatterning  Committee.    Current  edition  approved  by  the  Japanese\nRegional Standards Committee on January 9, 2004.  Initially available at ",(0,i.yg)("a",{parentName:"p",href:"http://www.semi.org"},"www.semi.org")," February 2004; to be\npublished March 2004.\nE\nThis standard was modified in September 2004 to correct editorial errors. Changes were made to Tables 2\nand 3.\n1  Purpose"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"1  This  data  structure  specification  uses  the  standard\nXML  format  for  defect  information  communication\nbetween   defect   inspection   tools,   repair   tools,   and\nreview tools at the mask production floor."),(0,i.yg)("li",{parentName:"ol"},"1.1  Mutual use of the defect information between the\ntools."),(0,i.yg)("li",{parentName:"ol"},"1.2  Optional  usage  by  tools  and  systems  other  than\ndefect inspection, repair, and review tools."),(0,i.yg)("li",{parentName:"ol"},"2  The     equipment     suppliers     who     utilize     this\nstandardized   data   structure   can   send   and   receive\nrequired  information,  with  no  dependence  on  specific\nsoftware and specific hardware.\n2  Scope"),(0,i.yg)("li",{parentName:"ol"},"1  This   standard   can   be   applied   to   defect-related\ninformation     on     photomasks     for     semiconductor\nmanufacturing."),(0,i.yg)("li",{parentName:"ol"},"2  This  data  structure  defines  the  data  hierarchy,  the\ntag  name,  and  contents  of  an  XML  file,  which  are\ntransmitted.      A   particular   database   or   a   particular\nprogramming language is not specified in this standard.\nNOTICE:  This  standard  does  not  purport  to  address\nsafety  issues,  if  any,  associated  with  its  use.    It  is  the\nresponsibility  of  the  users  of  this  standard  to  establish\nappropriate  safety  and  health  practices  and  determine\nthe applicability of regulatory or other limitations prior\nto use.\n3  Limitations"),(0,i.yg)("li",{parentName:"ol"},"1  This  standard  does  not  include  the  provision  of\ndefect information for wafer fabs."),(0,i.yg)("li",{parentName:"ol"},"2  This standard does not specify particular schema."),(0,i.yg)("li",{parentName:"ol"},"3  This  standard  does  not  address  the  name  space\nissue.\n4  Referenced Standards"),(0,i.yg)("li",{parentName:"ol"},"1\nWorld Wide Web Consortium Documents\n1")),(0,i.yg)("p",null,"Extensible   Markup   Language   (XML)   1.0   (Second\nEdition)          \u2014          W3C,6          October          2000\n(",(0,i.yg)("a",{parentName:"p",href:"http://www.w3.org/TR/2000/REC-xml-20001006"},"http://www.w3.org/TR/2000/REC-xml-20001006"),"\n)\n4. 2  JEITA Documents\n2"),(0,i.yg)("p",null,"Reticle Data Management Guideline Ver.1.0 (2001)\nNOTICE: Unless  otherwise  indicated,  all  documents\ncited shall be the latest published versions.\n5  Terminology\n5. 1  Abbreviations and Acronyms\n5. 1.1  MDML \u2014 Mask Defect Markup Language\n5. 2  Definitions\n5. 2.1  defect  inspection  information  \u2014  the  information\ngathered  with  mask  defect  inspection  tools,  such  as\ndefect position and shape.\n5. 2.2  mask defect markup language \u2014 the name of the\nXML file defined in this standard.\n6  Requirements\n6. 1  This  standard  defines  the  layered  structure  of  an\nXML  file,  an  element  name,  an  attribute  name  and  the\ncontents described in them. Users of this standard have\nto  define  the  style  of  the  information  described  in  an\nelement and an attribute, and it must be published.\n6. 2  The  information  on  defect  inspection  information,\ndefect     repair     information,     and     defect     review\ninformation  is  treated  as  one  file.    The  MDML  data\nitem specifications defined in this standard are shown in"),(0,i.yg)("p",null,"1  World Wide Web Consortium (W3C), ,Website:\n",(0,i.yg)("a",{parentName:"p",href:"http://www.w3c.or"},"http://www.w3c.or"),"\ng\n2  Japanese Electronic and Information Technology Industries\nAssociation, Tokyo Chamber of Commerce and Industry Bldg. 2-2,\nMarunouchi 3-chome, Chiyoda-ku, Tokyo 100-0005, Japan. Website:\n",(0,i.yg)("a",{parentName:"p",href:"http://www.jeita.or.jp"},"http://www.jeita.or.jp")),(0,i.yg)("p",null,"SEMI P41-0304\nE\n\xa9 SEMI 2004 2\nTables 2\u20137.  The columns in these tables are described\nin the following sections.  A layered structure is shown\nin Figures 2\u20137.  Figure 1 is explanation of Figures 2\u20137.\n6. 2.1  Item Name Column \u2014 The name with which the\ndata item is referenced.\n6. 2.2  Element    or    Attribute    Column    \u2014    Indicates\nwhether the item is an element or an attribute.\n6. 2.3  Mandatory   or   Optional   Column   \u2014   Indicates\nwhether the item is mandatory or optional.\n6. 2.4  Data Type Column \u2014 The type of data as defined\nin Table 1.\nTable 1  Data Types\nType                                                                                           Description\nString A string of ASCII characters from 0 to 32767characters in length.\nInteger A string of numeric characters (0 through 9) that represent an integer value.\nFloat A string representing a floating point value in exponent float."),(0,i.yg)("ol",{start:6},(0,i.yg)("li",{parentName:"ol"},"2.5  Description Column \u2013 Description of what the data item is and what value restrictions it has\nTable 2  Description of Basic Information Section\nItem\nElement or\nattribute\nMandatory or\nOptional\nData Type Description\nMDML                                                Element                                                Mandatory                                                -                                                Route                                                element.\ndata_no                                               Attribute                                               Optional                                               Integer                                               Management number in inspection tool.\ndate_stamp                                         Attribute                                         Optional            String            Generating time.\nBasicInformation                                Element                                Mandatory                                -                                Top element of basic information.\nMaskMaterialInformation Element Mandatory - Top element of material information.\nMaskSize                                            Element                                            Mandatory                                            -                                            Mask                                            size                                            information.\nunit                                                     Attribute                                                     Mandatory                                                     String                                                     Unit                                                     system.\nshape Attribute Optional String Mask substrate shape.\nMaskSize_X Element Mandatory Float Mask substrate size X.\nMaskSize_Y Element Mandatory Float Mask substrate size Y.\nMaskThickness Element Mandatory Float Mask substrate thickness.\nMaskAbsorber                                    Element                                    Optional                                    String                                    Masking                                    absorber.\nDefectInspection                                 Element                                 Mandatory                                 -                                 Top                                 element of basic information on defect\ninspection.\npreparation_date                                 Attribute                                 Optional                                 String                                 Generating time of basic information on defect\ninspection.\nInspectionTool                                    Element                                    Mandatory                                    -                                    Top                                    element of defect inspection tool\ninformation.\ntool_name                                           Attribute                                           Optional                                           String General name of tool.\ntool_no                                               Attribute                                               Optional                                               String                                               Tool                                               management number at mask fab.\nToolCoordinateInformation                Element                Mandatory                -                Top element of tool work stage coordinate\ninformation. Subsequent structures are in Table")),(0,i.yg)("h1",{id:"5"},"5"),(0,i.yg)("ol",{start:5},(0,i.yg)("li",{parentName:"ol"},"Refer to Figure 9.\nInspectionMethod                               Element                               Mandatory                               String Defect inspection method.\nPreparationOperator                           Element                           Optional                           String                           Operator name who created inspection basic\ninformation.\nReferenceAreaDB Element Optional String When reusable basic information exists, the\nreference address is to be described.\nDirectionInformation                          Element                          Mandatory                          -                          Top                          element of direction for Mask and tool work\nstage. Subsequent structures are in Table 6. Refer\nto Figure 10.\nAreaInformation Element Mandatory - Top element of inspection area information.\nLensDistance Element Optional Float Lens separation at the die to die inspection.")),(0,i.yg)("p",null,"SEMI P41-0304\nE\n\xa9 SEMI 2004 3\nItem\nElement or\nattribute\nMandatory or\nOptional\nData Type Description\nunit                                                     Attribute                                                     Mandatory                                                     String                                                     Unit                                                     system.\nInspectionArea Element Mandatory - Top element of inspection area. Refer to Figure"),(0,i.yg)("h1",{id:"8"},"8"),(0,i.yg)("ol",{start:8},(0,i.yg)("li",{parentName:"ol"},"unit                                                     Attribute                                                     Mandatory                                                     String                                                     Unit                                                     system.\nInspectionArea_X                               Element                               Mandatory                               Float                               Inspection                               area                               X.\nInspectionArea_Y                               Element                               Mandatory                               Float                               Inspection                               area                               Y.\nInspectionAreaChip_X                       Element                       Mandatory                       Float                       Inspection area X of one die in die to die\ninspection.\nInspectionAreaChip_Y                       Element                       Mandatory                       Float                       Inspection area Y of one die in die to die\ninspection.\nChipSize_X Element Mandatory Float Die size X in die to die inspection.\nChipSize_Y Element Mandatory Float Die size Y in die to die inspection.\nInspectionChipNumber                      Element                      Mandatory - Element of die number.\nInspectionChipNumber_X                  Element                  Mandatory                  Integer                  Inspected  number of die in X at die to die\ninspection.\nInspectionChipNumber_Y                  Element                  Mandatory                  Integer                  Inspected  number of die in Y at die to die\ninspection.\nReference                                          Repeatable\nElement\nMandatory - Top element of reference point.\norigin                                                  Attribute                                                  Mandatory                                                  String                                                  Origin                                                  point name of this reference position.\nReferencePointName                          Element                          Mandatory          String          Reference          point          name.\nReferencePosition Element Mandatory - Element of reference position.\nunit                                                     Attribute                                                     Mandatory                                                     String                                                     Unit                                                     system.\nReferencePosition_X                          Element                          Mandatory Float X coordinate value of reference point.\nReferencePosition_Y                          Element                          Mandatory Float Y coordinate value of reference point.\nImageData                                        Repeatable\nElement\nMandatory - Image data of reference position. Subsequent\nstructures are in Table 7.\nInspectionStartPosition                       Element                       Mandatory                       -                       Top element of inspection starting position.\norigin                                                  Attribute                                                  Mandatory                                                  String                                                  Origin                                                  point name of this reference position.\nunit                                                     Attribute                                                     Mandatory                                                     String                                                     Unit                                                     system.\nInspectionStartPosition_X                  Element                  Mandatory Float X coordinate value of inspection start position.\nInspectionStartPosition_Y                  Element                  Mandatory Float Y coordinate value of inspection start position.")),(0,i.yg)("p",null,"Table 3  Description of Result Summary Section\nItem\nElement or\nAttribute\nMandatory or\nOptional\nData type Description\nInspectionResult Element Mandatory - Top element of inspection results.\nSummary Element Mandatory - Top element of summary information.\nInspectionSummary Element Mandatory - Top element of defect inspection summary.\nbeginning_date                                   Attribute                                   Optional                                   String                                   Beginning time of defect inspection.\nending_date                                        Attribute                                        Optional                                        String                                        Ending time of defect inspection.\nInspectionRecipe Element Mandatory - Element of inspection recipe.\nrecipe_name Attribute Optional String Inspection recipe name.\nInspectionModeInformation               Element               Mandatory          String          Inspection          mode.\nInspectionDetectionSummary Element Mandatory - Top element of detected defect summary.\nTotalDefect Element Mandatory Integer Number of detected defects in total.\nClassifyDefect                                  Repeatable\nElement\nMandatory Integer Number of defect types."),(0,i.yg)("p",null,"SEMI P41-0304\nE\n\xa9 SEMI 2004 4\nItem\nElement or\nAttribute\nMandatory or\nOptional\nData type Description\ndefect_type                                         Attribute                                         Mandatory                                         String                                         Defect                                         type.\nInspectionOperator Element Optional String Inspection Operator name.\nReticleJudgment                                 Element                                 Optional            String            Reticle            disposition.\nRepairSummary                                Repeatable\nElement\nMandatory - Top element of repaired defect summary.\nbeginning_date                                   Attribute                                   Optional                                   String Beginning time of defect repair.\nending_date                                        Attribute                                        Optional                                        String                                        Ending time of defect repair.\nRepairTool Element Mandatory - Top element of repair tool information.\ntool_name                                           Attribute                                           Optional                                           String General name of tool.\ntool_no                                               Attribute                                               Optional                                               String                                               Tool                                               management number in mask fab.\nToolCoordinateInformation                Element                Mandatory                -                Top element of tool work stage coordinate\ninformation. Subsequent structures are in Table\n5. Refer to Figure 9.\nRepairMethod                                     Element                                     Mandatory                                     String Method of defect repairing.\nDirectionInformation                          Element                          Mandatory                          -                          Top                          element of direction for Mask and tool work\nstage. Subsequent structures are in Table 6. Refer\nto Figure 10.\nNumberRepairProcessing                   Element                   Mandatory                   -                   Element of number of repair processed.\nTotalRepairProcess Element Mandatory Integer Number of repaired defects in total.\nCalssifyRepairProcess                      Repeatable\nElement\nMandatory Integer Number of defect types.\ndefect_type                                         Attribute                                         Mandatory                                         String                                         Defect                                         type.\nRepairOperator                                   Element                                   Optional            String            Repair            operator            name.\nRepairJudgment                                  Element                                  Optional                                  String                                  Judegement of repair process.\nEvaluationSummary                         Repeatable\nElement\nMandatory - Top element of evaluated defect summary.\nbeginning_date                                   Attribute                                   Optional                                   String Beginning time of evaluation.\nending_date                                        Attribute                                        Optional                                        String Ending time of evaluation.\nEvaluationTool                                   Element                                   Mandatory                                   -                                   Top                                   element of evaluation tool information.\ntool_name                                           Attribute                                           Optional                                           String General name of tool.\ntool_no                                               Attribute                                               Optional                                               String                                               Tool                                               management number in mask fab.\nToolCoordinateInformation                Element                Mandatory                -                Top element of tool work stage coordinate\ninformation. Subsequent structures are in Table\n5. Refer to Figure 9.\nEvaluationMethod                              Element                              Mandatory                              String Method of defect evaluation.\nDirectionInformation                          Element                          Mandatory                          -                          Top                          element of direction for Mask and tool work\nstage. Subsequent structures are in Table 6. Refer\nto Figure 10.\nNumberEvaluationProcessing            Element            Mandatory              -            Element of number of evaluation process.\nTotalEvaluationProcess Element Mandatory Integer Number of evaluated defects in total.\nCalssifyEvaluationProcess               Repeatable\nElement\nMandatory Integer Number of defect types.\ndefect_type                                         Attribute                                         Mandatory                                         String                                         Defect                                         type.\nEvaluationOperator                             Element                             Optional String Evaluation operator name.\nEvaluationJudgment                           Element                           Optional                           String Judgment of evaluation process."),(0,i.yg)("p",null,"SEMI P41-0304\nE\n\xa9 SEMI 2004 5\nTable 4  Description of Each Defect Section\nItem\nElement or\nAttribute\nMandatory or\nOptional\nData Type Description\nDefect                                               Repeatable\nElement\nMandatory - Top element of each defect information.\ndefect_type                                         Attribute                                         Mandatory                                         String                                         Defect                                         type.\ndate_stamp                                         Attribute                                         Optional                                         String                                         Date                                         classified.\nDefectInformation                              Element                              Mandatory                              -                              Top element of defect information.\norigin                                                  Attribute                                                  Mandatory                                                  String                                                  Origin                                                  point name of this reference position.\nDefectPosition                                    Element                                    Mandatory                                    - Element of defect position.\nunit                                                     Attribute                                                     Mandatory                                                     String                                                     Unit                                                     system.\nDefectPosition_X                               Element                               Mandatory                               Float                               X                               coordinate value of defect position.\nDefectPosition_Y                               Element                               Mandatory                               Float                               Y                               coordinate value of defect position.\nDefectSize Element Mandatory - Element of defect size.\nunit                                                     Attribute                                                     Mandatory                                                     String                                                     Unit                                                     system.\nDefectSize_X Element Mandatory Float X size value of defect.\nDefectSize_Y Element Mandatory Float Y size value of defect.\nDefectJudgment                                  Element                                  Mandatory String Judgment of defect.\nImageData                                         Repetable\nElement\nMandatory - Image data of defect.  Subsequent structures are\nin Table 7.\nDefectRepair                                     Repetable\nElement\nMandatory - Top element of defect repair.\ndate_stamp                                         Attribute                                         Optional                                         String Repair processing date.\nRepairRecipe                                      Element                                      Mandatory                                      - Element of repair recipe.\nrecipe_name                                       Attribute                                       Optional                                       String Repair recipe name.\nRepairCondition                                 Element                                 Mandatory          String          Repair          conditions.\nRepairResult                                       Element                                       Mandatory                                       String                                       Repair                                       results.\nImageData                                         Repetable\nElement\nMandatory - Image data of repaired defect.  Subsequent\nstructures are in Table 7.\nDefectEvaluate                                  Repetable\nElement\nMandatory - Top element of defect evaluation.\ndate_stamp                                         Attribute                                         Optional                                         String Evaluation  processing date.\nEvaluateRecipe Element Mandatory - Element of evaluation recipe.\nrecipe_name Attribute Optional String Evaluation recipe name.\nEvaluateCondition                              Element          Mandatory          String          Evaluation          condition.\nEvaluateResult                                    Element                                    Mandatory                                    String                                    Evaluation                                    result.\nImageData                                         Repetable\nElement\nMandatory - Image data of evaluated defect. Subsequent\nstructures are in Table 7."),(0,i.yg)("p",null,"Table 5  Description of Tool Coordinate Section\nItem\nElement or\nattribute\nMandatory or\nOptional\nData Type Description\nCoordinateSystem                              Element                              Mandatory                              String Coordinate system of tool.\nToolOriginPointInformation              Element              Mandatory              - Element of origin point information.\nToolOriginPoint Element Mandatory String Tool origin point information.\nToolOriginPosition Element Mandatory - Element of origin position.\nunit                                                     Attribute                                                     Mandatory                                                     String                                                     Unit                                                     system.\nToolOriginPosition_X                        Element                        Mandatory                        Float                        X                        coordinate value of tool origin position."),(0,i.yg)("p",null,"SEMI P41-0304\nE\n\xa9 SEMI 2004 6\nItem\nElement or\nattribute\nMandatory or\nOptional\nData Type Description\nToolOriginPosition_Y                        Element                        Mandatory                        Float                        Y                        coordinate value of tool origin position.\nToolStageCorrectionInformation       Element         Mandatory - Top element of tool work stage correction\ninformation.\nToolStageCorrection Element Mandatory - Element of correction information.\nunit                                                     Attribute                                                     Mandatory                                                     String                                                     Unit                                                     system.\nToolStageCorrection_X                      Element                      Mandatory                      Float Correction information of X coordinates.\nToolStageCorrection_Y                      Element                      Mandatory                      Float Correction information of Y coordinates.\nToolStageSkew Element Mandatory - Element of skew correction information.\nunit                                                     Attribute                                                     Mandatory                                                     String                                                     Unit                                                     system.\nToolStageSkewCorrection                  Element                  Mandatory           Float           Skew           correction           information.\nMaskOriginPointInformation Element Mandatory - Top element of mask origin position.\nMaskOriginPoint Element Mandatory String Mask origin point information.\nMaskOriginPosition Element Mandatory - Element of mask origin position.\nunit                                                     Attribute                                                     Mandatory                                                     String                                                     Unit                                                     system.\nMaskOriginPosition_X                       Element                       Mandatory                       Float                       X                       coordinate value of mask origin position.\nMaskOriginPosition_Y                       Element                       Mandatory                       Float                       Y                       coordinate value of mask origin position.\nToolOffset Element Mandatory - Element of relative position information on tool\norigin and mask origin.\nunit                                                     Attribute                                                     Mandatory                                                     String                                                     Unit                                                     system.\nToolOffset_X                                      Element                                      Mandatory                                      Float                                      X                                      offset value of relative position of tool origin\nand mask origin.\nToolOffset_Y                                      Element                                      Mandatory                                      Float                                      Y                                      offset value of relative position of tool origin\nand mask origin.\nToolStageAccuracy                            Element                            Optional                            -                            Tool work stage positioning accuracy\ninformation.\nunit                                                     Attribute                                                     Optional                                                     String                                                     Unit                                                     system."),(0,i.yg)("p",null,"Table 6  Description of Mask Direction Information Section\nItem\nElement or\nattribute\nMandatory or\nOptional\nData Type Description\nReferenceMark                                   Element                                   Mandatory                                   String                                   Information on the reference mark for expressing\ndirection of mask.\nMarkRotation                                      Element                                      Mandatory                                      String                                      Information of rotation direction on mask.\nMaskMirror                                         Element                                         Mandatory                                         String                                         Information of mirror direction information on\nmask.\nMaskFlip                                             Element                                             Mandatory                                             String                                             Information of flip direction information on\nmask."),(0,i.yg)("p",null,"Table 7  Description of Image Data Section\nItem\nElement or\nAttribute\nMandatory or\nOptional\nData Type Description\nImageReferenceAddress Element Optional String Reference address information of image data.\nImageInformation Element Mandatory - Element of image data information.\nImageFormat Element Mandatory String Image data format information.\nImageMagnification Element Mandatory Float Image data magnification information.\nImagePixelNumber_X Element Mandatory Integer Number of pixels in X.\nImagePixelNumber_Y Element Mandatory Integer Number of pixels in Y."),(0,i.yg)("p",null,"SEMI P41-0304\nE\n\xa9 SEMI 2004 7\nItem\nElement or\nAttribute\nMandatory or\nOptional\nData Type Description\nImagePixelSize Element Mandatory - Element of pixel size on image data.\nunit                                                     Attribute                                                     Mandatory                                                     String                                                     Unit                                                     system.\nImagePixelSize_X                              Element                              Mandatory Float Size of one pixel in X.\nImagePixelSize_Y                              Element                              Mandatory Float Size of one pixel in Y.\nImageGrayLevel Element Mandatory String Gray level information of image data.\nImageIllumination Element Mandatory String Illumination information of image data.\nImageRotation Element Mandatory String Rotation information of image data.\nImageMirror                                       Element                                       Mandatory                                       String                                       Mirrorring information of image data.\nImageFlip                                            Element                                            Mandatory                                            String                                            Flipping information of image data.\nImageConvertInformation                  Element Optional - Element of image conversion information from\noriginal/raw data.\nImageContrast                                    Element                                    Mandatory                                    String       Image       contrast       information.\nImageBrightness                                 Element                                 Mandatory                                 String Image brightness information.\nImageConversionParameter               Element               Mandatory               String               Image               conversion parameter information.\nImageReference Element Mandatory - Top element of image origin point. Refer to\nFigure 11.\norigin                                                  Attribute                                                  Mandatory                                                  String                                                  Origin                                                  point name of this reference position.\nImageReferencePoint Element Mandatory String Image reference point information.\nImageReferencePosition Element Mandatory - Element of image reference position coordinate\nvalue.\nunit                                                     Attribute                                                     Mandatory                                                     String                                                     Unit                                                     system.\nImageReferencePosition_X                Element                Mandatory                Float                X coordinates value of image reference position.\nImageReferencePosition_Y                Element                Mandatory                Float                Y coordinates value of image reference position.\nImageTarget Element Mandatory - Element of image target.\norigin                                                  Attribute                                                  Mandatory                                                  String                                                  Origin                                                  point name of this reference position.\nImageTargetPosition                          Element                          Mandatory                          -                          Element of target position on image data. Refer\nto Figure 12.\nunit                                                     Attribute                                                     Mandatory                                                     String                                                     Unit                                                     system.\nImageTargetPosition_X                      Element          Mandatory           Float          X          coordinate          value of image target position.\nImageTargetPosition_Y                      Element          Mandatory           Float          Y          coordinate          value of image target position.\nExpressionMark                                  Element                                  Mandatory                                  String                                  Expression of target point on image data."),(0,i.yg)("p",null,"MDML (data_no,date_stamp)\nBasicInformation\nElement name\nAttribute name\nTop element\nUnder element\nInspectionResult"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Defect(defect_type,data_stamp)\nRepeatable mark")),(0,i.yg)("p",null,"Figure 1\nExplanation of Figures 2\u20137"),(0,i.yg)("p",null,"SEMI P41-0304\nE\n\xa9 SEMI 2004 8\nMDML (data_no,date_stamp)\nBasicInformation\nMaskSize (unit,shape)\nMaskSize_X\nMaskSize_Y\nMaskThickness\nMaskAbsorber\nDefectInspection (preparation_data)\nInspectionTool (tool_name,tool_no)\nToolCoordinateInformation\nInspectionMethod\nPreparationOperator\nReferenceAreaDB\nSubsequent structures are in Figure 5.\nDirectionInformation\nAreaInformation\nLensDistance (unit)\nInspectionArea (unit)\nInspectionArea_X\nInspectionArea_Y\nInspectionAreaChip_X\nInspectionAreaChip_Y\nChipSize_X\nChipSize_Y\nInspectionChipNumber\nInspectionChipNumber_X\nInspectionChipNumber_Y"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Reference (origin)\nReferencePointName\nReferencePosition (unit)\nReferencePosition_X\nReferencePosition_Y"),(0,i.yg)("li",{parentName:"ul"},"ImageData\nInspectionStartPosition (origin,unit)\nInspectionStartPosition_Y\nInspectionStartPosition_X\nMaskMaterialInformation\nSubsequent structures are in Figure 6.\nSubsequent structures are in Figure 7.\nSubsequent structures are in Figure 3.")),(0,i.yg)("p",null,"Figure 2\nStructure of Basic Information Section"),(0,i.yg)("p",null,"SEMI P41-0304\nE\n\xa9 SEMI 2004 9\nInspectionResult\nSummary\nInspectionSummary (beginning_date,ending_date)\nInspectionRecipe (recipe_name)\nInspectionModeInformation\nInspectionDetectionSummary\nTotalDefect"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"ClassifyDefect (defect_type)\nInspectionOperator\nReticleJudgement\n+RepairSummary (beginning_date,ending_date)\nRepairTool (tool_name,tool_no)\nRepairMethod\nToolCoordinateInformation\nSubsequent structures are in Figure 5.\nNunberRepairProcessing\nDirectionInformation\nTotalRepairProcess"),(0,i.yg)("li",{parentName:"ul"},"ClassifyRepairProcess (dafect_type)\nRepairOperator\nRepairJudgement\n+EvaluationSummary (beginning_date,ending_date)\nEvaluationTool(tool_name,tool_no)\nEvaluationMethod\nToolCoordinateInformation\nNunberEvaluationProcessing\nDirectionInformation\nTotalEvaluationProcess"),(0,i.yg)("li",{parentName:"ul"},"ClassifyEvaluationProcess (defect_type)\nEvaluationOperator\nEvaluationJudgement\nSubsequent structures are in Figure 6.\nSubsequent structures are in Figure 5.\nSubsequent structures are in Figure 6.\nSubsequent structures are in Figure 4.")),(0,i.yg)("p",null,"Figure 3\nStructure of Result Summary Section"),(0,i.yg)("p",null,"SEMI P41-0304\nE\n\xa9 SEMI 2004 10"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Defect (defect_type,date_stamp)\nDefectInformation (origin)\nDefectPosition_X\nDefectPosition_Y\nDefectSize (unit)\nDefectSize_Y\nDefectSize_X\nDefectJudgement"),(0,i.yg)("li",{parentName:"ul"},"ImageData\nDefectPosition (unit)"),(0,i.yg)("li",{parentName:"ul"},"DefectRepair (date_stamp)\nRepairRecipe (recipe_name)\nRepairCondition\nRepairResult"),(0,i.yg)("li",{parentName:"ul"},"ImageData"),(0,i.yg)("li",{parentName:"ul"},"DefectEvaluate (date_stamp)\nEvaluateRecipe (recipe_name)\nEvaluateCondition\nEvaluateResult"),(0,i.yg)("li",{parentName:"ul"},"ImageData\nsubsequent structures are in Figure 7.\nsubsequent structures are in Figure 7.\nsubsequent structures are in Figure 7.")),(0,i.yg)("p",null,"Figure 4\nStructure of Each Defect Section"))}c.isMDXComponent=!0},5680(e,n,t){t.d(n,{xA:()=>p,yg:()=>g});var a=t(6540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach(function(n){i(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),d=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=d(e.components);return a.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef(function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=d(t),g=i,f=m["".concat(l,".").concat(g)]||m[g]||c[g]||r;return t?a.createElement(f,o(o({ref:n},p),{},{components:t})):a.createElement(f,o({ref:n},p))});function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var d=2;d<r;d++)o[d]=t[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);