"use strict";(globalThis.webpackChunksemiconductor_docs=globalThis.webpackChunksemiconductor_docs||[]).push([[9458],{2073(e,n,t){t.d(n,{A:()=>o});var a=t(6540);const o=function({pdfLink:e,pdfSize:n,title:t,description:o}){if(!e)return null;const r=e.startsWith("http"),i=(e=>{if(!e)return null;try{const n=new URL(e,r?void 0:window.location.origin);return n.pathname.split("/").pop()}catch{return e.split("/").pop()}})(e);return a.createElement("div",{className:"pdf-download-card"},a.createElement("div",{className:"pdf-download-card__header"},a.createElement("div",{className:"pdf-download-card__icon"},"\ud83d\udce5"),a.createElement("div",{className:"pdf-download-card__title"},a.createElement("h3",null,"\u4e0b\u8f7d\u5b8c\u6574PDF"),t&&a.createElement("p",{className:"pdf-download-card__doc-title"},t))),a.createElement("div",{className:"pdf-download-card__info"},a.createElement("div",{className:"pdf-download-card__meta"},a.createElement("span",{className:"pdf-download-card__label"},"\u6587\u4ef6\u5927\u5c0f:"),a.createElement("span",{className:"pdf-download-card__value"},"string"==typeof(s=n)?s:s<1048576?`${(s/1024).toFixed(1)}KB`:`${(s/1024/1024).toFixed(1)}MB`)),o&&a.createElement("div",{className:"pdf-download-card__description"},o),r&&a.createElement("div",{className:"pdf-download-card__notice"},a.createElement("span",{className:"pdf-download-card__notice-icon"},"\u2139\ufe0f"),a.createElement("span",null,"\u6b64\u6587\u4ef6\u6258\u7ba1\u5728GitHub Releases\uff0c\u53ef\u80fd\u9700\u8981GitHub\u8d26\u53f7"))),a.createElement("div",{className:"pdf-download-card__actions"},a.createElement("a",{href:e,className:"pdf-download-card__button pdf-download-card__button--primary",download:r?void 0:i,target:r?"_blank":void 0,rel:r?"noopener noreferrer":void 0},a.createElement("span",{className:"pdf-download-card__button-icon"},"\u2b07\ufe0f"),"\u4e0b\u8f7dPDF"),r&&a.createElement("a",{href:e,className:"pdf-download-card__button pdf-download-card__button--secondary",target:"_blank",rel:"noopener noreferrer"},a.createElement("span",{className:"pdf-download-card__button-icon"},"\ud83d\udd17"),"\u5728\u65b0\u7a97\u53e3\u6253\u5f00")));var s}},3513(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=t(8168),o=(t(6540),t(5680));t(2073);const r={title:"E97-0200A - \xa9 SEMI 200021 const...",description:"SEMI\u6807\u51c6\u6587\u6863",sidebar_label:"E97-0200A - \xa9 SEMI 200021 const...",sidebar_position:550,tags:["SEMI","Standard"],custom_props:{source_type:"pdf",source_file:"semi-chapter-055.pdf",chapter:55,page_count:50}},i=void 0,s={unversionedId:"standards/semi/semi-chapter-055",id:"standards/semi/semi-chapter-055",title:"E97-0200A - \xa9 SEMI 200021 const...",description:"SEMI\u6807\u51c6\u6587\u6863",source:"@site/docs/standards/semi/semi-chapter-055.md",sourceDirName:"standards/semi",slug:"/standards/semi/semi-chapter-055",permalink:"/semiconductor-docs/docs/standards/semi/semi-chapter-055",draft:!1,editUrl:"https://github.com/your-org/semiconductor-docs/tree/main/docs/standards/semi/semi-chapter-055.md",tags:[{label:"SEMI",permalink:"/semiconductor-docs/docs/tags/semi"},{label:"Standard",permalink:"/semiconductor-docs/docs/tags/standard"}],version:"current",sidebarPosition:550,frontMatter:{title:"E97-0200A - \xa9 SEMI 200021 const...",description:"SEMI\u6807\u51c6\u6587\u6863",sidebar_label:"E97-0200A - \xa9 SEMI 200021 const...",sidebar_position:550,tags:["SEMI","Standard"],custom_props:{source_type:"pdf",source_file:"semi-chapter-055.pdf",chapter:55,page_count:50}}},l={},c=[],d={toc:c};function m({components:e,...n}){return(0,o.yg)("wrapper",(0,a.A)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,o.yg)("p",null,'PdfDownloadCard\npdfLink="/pdfs/semi/055.pdf"\npdfSize="0.27MB"\ntitle="E97-0200A - \xa9 SEMI 200021 const..."\ndescription="SEMI\u6807\u51c6\u6587\u6863\uff0c\u517150\u9875"\n/'),(0,o.yg)("h1",{id:"\u6587\u6863\u6807\u9898"},"\u6587\u6863\u6807\u9898"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200021\nconst stringJobStateChangedSubject=\n\u201c/JobSupervision/Job/StateChanged\u201d;\n/",(0,o.yg)("em",{parentName:"p"}," This enumerated type identifies the states of Jobs. It is used in event notifications of state changes. "),"/\nenumJobState{\nJobUndefined,\nJobCreated,\nJobQueued,\nJobActive,\nJobExecuting,\nJobNotPaused,\nJobPausing,\nJobPaused,\nJobNotStopping,\nJobStopping,\nJobNotAborting,\nJobAborting,\nJobFinished,\nJobCanceled,\nJobCompleted,\nJobStopped,\nJobAborted };\nstructJobStateChangedFilters{\nGlobal::Property name;\nGlobal::Property previousState;\nGlobal::Property newState;\n};\nJobStateChangedFilters Properties:\nNameValue TypeDescription\n\u201cName\u201dstringThe name of the Job.\n\u201cPreviousState\u201dstringPrevious state preceding the most recent change.\n\u201cNewState\u201dRegistrationStateNew state following the most recent change.\nstructJobStateChangedEvent{\nstring eventSubject;\nGlobal::TimeStamp eventTimeStamp;\nJobStateChangedFilters eventFilterData;\nGlobal::Properties eventNews;\nJob aJob;\n};\n/",(0,o.yg)("em",{parentName:"p"},"  If  the  Job  cannot  be  completed  by  the  specified  deadline,  a  JobDeadlineCannotBeMetEvent  should  be  sent  as\nearly as possible, not necessarily after the deadline has passed. "),"/\nconst stringJobDeadlineCannotBeMetSubject=\n\u201c/JobSupervision/Job/DeadlineCannotBeMet\u201d;\nstructJobDeadlineCannotBeMetFilters{\nGlobal::Property name;\nGlobal::Property deadline;\n};"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200022\nJobDeadlineCannotBeMetFilters Properties:\nNameValue TypeDescription\n\u201cName\u201dstringThe name of the Job.\n\u201cDeadline\u201dGlobal::TimeStampValue of the Deadline that cannot be met.\nstructJobDeadlineCannotBeMetEvent{\nstring eventSubject;\nGlobal::TimeStamp eventTimeStamp;\nJobDeadlineCannotBeMetFilters eventFilterData;\nGlobal::Properties eventNews;\nJob aJob;\n};\n/",(0,o.yg)("em",{parentName:"p"}," This event is posted when a Job\u2019s deadline date has changed. "),"/\nconst stringJobDeadlineChangedSubject=\n\u201c/JobSupervision/Job/DeadlineChanged\u201d;\nstructJobDeadlineChangedFilters{\nGlobal::Property name;\nGlobal::Property previousDeadline;\nGlobal::Property newDeadline;\n};\nJobDeadlineChangedFilters Properties:\nNameValue TypeDescription\n\u201cName\u201dstringThe name of the Job.\n\u201cPreviousDeadline\u201dGlobal::TimeStampPrevious Deadline.\n\u201cNewDeadline\u201dGlobal::TimeStampNew Deadline.\nstructJobDeadlineChangedEvent{\nstring eventSubject;\nGlobal::TimeStamp eventTimeStamp;\nJobDeadlineChangedFilters eventFilterData;\nGlobal::Properties eventNews;\nJob aJob;\n};\nExceptions:None.\nProvided Services:\n/",(0,o.yg)("em",{parentName:"p"}," Ask the Job for its JobRequestor. "),"/\nJobRequestorgetJobRequestor()\nraises (Global::FrameworkErrorSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Get a named Job property from its Job Specification. "),"/\nGlobal::PropertygetJobProperty(\nin Global::PropertyName aPropertyName)\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidPropertyNameSignal,\nGlobal::PropertyNotFoundSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Set a named Job property in its Job Specification. "),"/"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200023\nvoidsetJobProperty(\nin Global::Property aProperty)\nraises (Global::FrameworkErrorSignal,\nGlobal::SetValueOutOfRangeSignal,\nGlobal::InvalidPropertyNameSignal,\nGlobal::UnsupportedPropertySignal,\nGlobal::ReadOnlyPropertySignal);\n/",(0,o.yg)("em",{parentName:"p"}," Indicates whether results are available for this Job. Each specialization may determine what constitutes results. "),"/\nbooleanareJobResultsAvailable()\nraises( Global::FrameworkErrorSignal );\n/",(0,o.yg)("em",{parentName:"p"}," Retrieve the latest results. Each implementation determines what constitutes relevant results. This may be used for\nreturning current results for complex Jobs. "),"/\nJobSupervisor::ResultsgetJobResults()\nraises( Global::FrameworkErrorSignal );\n/",(0,o.yg)("em",{parentName:"p"},"  Begin  the  process  to  pause  the  Job  at  the  next  safe  opportunity.  Results  in  the  transition  to  Pausing  state  and\neventually Paused state. "),"/\nvoidmakePaused()\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Request Job resume activity from the previous Pause. Results in the transition to the executing state. "),"/\nvoidmakeExecuting()\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\n/",(0,o.yg)("em",{parentName:"p"},"  Request  to  cancel  the  Job.  This  operation  is  only  valid  if  the  Job  is  in  the  Queued  state  (e.g.  the  Job  cannot  be\ncanceled once it is Active). This operation results in the transition to the Canceled state. "),"/\nvoidmakeCanceled()\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Begin the process to stop the Job. This is an orderly termination and should never cause irreparable problems (e.g.\nshould  not  stop  etching  a  wafer  in  mid-cycle).  This  operation  results  in  the  transition  to  the  Stopping  state  and\neventually the Stopped state. "),"/\nvoidmakeStopped()\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Begin the process to abort the Job. Caution should be used with this operation. Aborting a Job requires immediate\ntermination of the Job and could result in irrecoverable change to factory or material state. This operation results in\nthe transition to the Aborting state and eventually the Aborted state. "),"/\nvoidmakeAborted()\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Determine whether the Job is in state indicated. "),"/\nbooleanisAborting()\nraises (Global::FrameworkErrorSignal);\nbooleanisAborted()\nraises (Global::FrameworkErrorSignal);"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200024\nbooleanisActive()\nraises (Global::FrameworkErrorSignal);\nbooleanisCanceled()\nraises (Global::FrameworkErrorSignal);\nbooleanisCompleted()\nraises (Global::FrameworkErrorSignal);\nbooleanisExecuting()\nraises (Global::FrameworkErrorSignal);\nbooleanisFinished()\nraises (Global::FrameworkErrorSignal);\nbooleanisPausing()\nraises (Global::FrameworkErrorSignal);\nbooleanisPaused()\nraises (Global::FrameworkErrorSignal);\nbooleanisQueued()\nraises (Global::FrameworkErrorSignal);\nbooleanisStopping()\nraises (Global::FrameworkErrorSignal);\nbooleanisStopped()\nraises (Global::FrameworkErrorSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Return the estimated time remaining until Job completion. The quality of this estimate is dependent both on the\nspecific  Job  derivative  and  on  the  implementation.  If  the  Job  is  Finished  or  Canceled,  a  zero  Duration  will  be\nreturned. "),"/\nDurationtimeRemaining()\nraises (Global::FrameworkErrorSignal);\n}; //Job\nContracted Services:\nInterfaceComponentService\nJobRequestorJobSupervisioninformJobStateChange"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200025\nQUEUED\nFINISHED\nCOMPLETEDABORTED\nSTOPPED\nCANCELED\nACTIVE\nABORTING\nSTOPPING\nEXECUTING\nPAUSE\nPAUSING\nPAUSED\nCOMPLETEDABORTED\nSTOPPED\nABORTING\nSTOPPING\nEXECUTING\n15\n1\nCANCELED\nPAUSE\nPAUSING\nPAUSED\nPAUSING\nPAUSED\n4\n5\n10\n12\n3\n6\n7\n13\n2\n14\n9\n8\n11\nFigure 5\nJob Dynamic Model\n6. 6.3.1  For implementations (e.g., Job  derivatives), the Executing state is expected to be extended by partitioning it\ninto at least two \u201corthogonal\u201d states. One would hold the Pause states. The other would contain the implementation\nbehavior of Executing.\nObject State Tables:"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200026\nTable 3  Job State Definitions and Query Table\nStateDefinitionQuery for State via\nABORTEDIn this state the Job has aborted execution. This is a\nsubstate of Finished.\nboolean isAborted(); sent to an instance of\nJob; returns TRUE\nJobSequence allFinishedJobs (); sent to\ninstance of JobSupervisor will provide some\nindication.\nABORTINGABORTING represents an immediate termination of the\nJob and activities not completed before the aborting will\nbe terminated. After ABORTING, execution is not\nintended to continue.\nboolean isAborting(); sent to an instance of\nJob; returns TRUE\nACTIVEThis is a parent state representing that the Job is\nACTIVE for the JobSupervisor; i.e., the current status of\nthe Job is tracked by the JobSupervisor when the Job is\nin the ACTIVE state.\nboolean isActive(); sent to an instance of Job;\nreturns TRUE.\nJobSequence allActiveJobs (); or Job\nfindActiveJobNamed (in string jobName);\nsent to instance of JobSupervisor.\nCANCELEDIn this state the Job has been removed from the Queue\nand will never become Active. This is a substate of\nFinished.\nboolean isCanceled(); sent to an instance of\nJob; returns TRUE\nCOMPLETEDThis state represents that the Job has successfully\ncompleted execution. This is a substate of Finished.\nboolean isCompleted(); sent to an instance of\nJob; returns TRUE.\nJob findCompletedJobNamed (in string\njobName); sent to instance of JobSupervisor\nJobSequence allFinishedJobs (); sent to\ninstance of JobSupervisor will provide some\nindication.\nEXECUTINGThis state represents that the Job is EXECUTING.\nSpecializations of Job will normally develop substates\nrepresenting the specialized Job execution behavior.\nboolean isExecuting(); sent to an instance of\nJob; returns TRUE.\nPAUSEParent state of PAUSING, PAUSEDNone.\nPAUSEDIn this state the Job has paused execution.boolean isPaused(); sent to an instance of Job;\nreturns TRUE.\nPAUSINGIn this state the Job is being paused by the executor of\nthe Job. Execution is intended to continue.\nboolean isPausing(); sent to an instance of\nJob; returns TRUE.\nQUEUEDIn this state the Job is waiting to become active.boolean isQueued(); sent to an instance of\nJob; returns TRUE. JobSequence\nallQueuedJobs (); or Job\nfindQueuedJobNamed (in string jobName);\nsent to instance of JobSupervisor.\nSTOPPEDIn this state the Job has stopped execution. This is a\nsubstate of Finished.\nboolean isStopped(); sent to an instance of\nJob; returns TRUE.\nJobSequence allFinishedManagedJobs (); sent\nto instance of JobSupervisor will provide\nsome indication.\nSTOPPINGIn this state the Job is being stopped. Execution is not\nintended to continue.\nSTOPPING represents an ordered termination of the Job\nActivities.  Job Activities not completed before stopping\nmay or may not be performed, depending on the\nimplementation.\nboolean isStopping(); sent to an instance of\nJob; returns TRUE.\nFINISHEDThis is a parent state representing that the Job has\nfinished execution, through either successful execution,\nabort, or stop. This is the superstate of Completed,\nAborted, Stopped, and Canceled.\nboolean isFinished(); sent to an instance of\nJob; returns TRUE.\nJobSequence allFinishedJobs (); sent to\ninstance of JobSupervisor."),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200027\nTable 4  Job State Transitions\n#Current StateTriggerNew StateActionComment\n1Non ExistentJob creation.QUEUEDJobStateChanged Event\npublished by the instance of Job\nNone.\n2QUEUEDInternal to component.EXECUTINGJobStateChanged Event\npublished by the instance of Job\nJob has started.\n3EXECUTINGvoid makePaused ( );\nsent to the Job; or void\nPauseAllJobs ( ); sent to\nan instance of\nJobSupervisor.\nPAUSINGJobStateChanged Event\npublished by the instance of Job\nJob has been told to\npause.\n4PAUSINGInternal to componentPAUSEDJobStateChanged Event\npublished by the instance of Job\nJob has completed\nPAUSING activities.\nWait for resume.\n5PAUSEDvoid makeExecuting ( );\nsent to the Job or void\nresumeAllJobs (); sent\nto an instance of\nJobSupervisor.\nEXECUTINGJobStateChanged Event\npublished by the instance of Job\nRestart EXECUTING\nfrom the point\nPAUSED at.\n6EXECUTINGInternal to componentCOMPLETEDExecution of the Job was\nsuccessful or completed\nnormally.\nNone.\n7EXECUTINGvoid makeAborted ( );\nsent the Job or void\nabortAllJobs ( ); sent to\nthe JobSupervisor.\nABORTINGExecution of the Job stops\nimmediately. Product or Job\nwill be unfinished.\nNone.\n8PAUSEvoid makeAborted ( );\nsent the Job or void\nabortAllJobs ( ); sent to\nthe JobSupervisor.\nABORTINGActive Job is aborted\nimmediately.\nNone.\n9ABORTINGInternal to componentABORTEDJobStateChanged Event\npublished by the instance of Job\nJob has completed\naborting activities.\n10STOPPINGvoid makeAborted ( );\nsent the Job or void\nabortAllJobs ( ); sent to\nthe JobSupervisor.\nABORTINGJobStateChanged Event\npublished by the instance of Job\nNone.\n11PAUSEvoid makeStopped( );\nsent to the Job or void\nstopAllJobs( ); sent to\nthe JobSupervisor.\nSTOPPINGJobStateChanged Event\npublished by the instance of Job\nNone.\n12STOPPINGInternal to componentSTOPPEDJobStateChanged Event\npublished by the instance of Job\nJob has completed\nstopping activities.\n13EXECUTINGvoid makeStopped( );\nsent to the Job or void\nstopAllJobs( ); sent to\nthe JobSupervisor.\nSTOPPINGJobStateChanged Event\npublished by the instance of Job\nNone.\n14QUEUEDvoid makeCanceled( );\nsent to the Job.\nCANCELEDJobStateChanged Event\npublished by the instance of Job\nJob has been canceled\nbefore starting\nexecution. It cannot\nbe restarted.\n15FINISHEDvoid removeFinished-\nJob (in Job aJob); sent\nto an instance of\nJobSupervisor.\nNon ExistentJobStateChanged Event\npublished by the instance of Job\nJob has been removed\nfrom the finished\nqueue."),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200028\n6. 6.4  JobRequestor Interface\nModule:AbstractIF\nInterface:JobRequestor\nInherited Interface:Implementation Dependent\nDescription:In order to request work of a JobSupervisor using the requestJob operation, a component\nmust   implement   the   JobRequestor   interface.   This   is   a   companion   interface   to\nJobSupervisor.    The  JobRequestor  may  also  subscribe  to  the  state  change  events  of  the\nJob, if more detail is required.\ninterfaceJobRequestor{\nExceptions:None.\nPublished Events:None.\nProvided Services:\n/",(0,o.yg)("em",{parentName:"p"}," The Job has transitioned to a new state. Required for transition to Executing from Queued and for any transition\nto a Finished sub-state. This operation is in addition to the required JobStateChangedEvent notifications. "),"/\nvoidinformJobStateChange(\nin Job aJob,\nin Job::JobState previousState,\nin Job::JobState newState)\nraises (Global::FrameworkErrorSignal);\n}; //JobRequestor\nContracted Services:None.\nDynamic Model:None.\nScenario:\naJobRequestor:\nJobRequestor\naJobSupervisor:\nJobSupervisor\naJob :Job\n1: requestJob (Properties, JobRequestor)\n2: Return Job\n3: informJobStateChange (Job, Queued, Executing)\n4: informJobStateChange (Job, Active, Finished)\nCreate Job Here\nFigure 6\nJob Supervision Scenario\n6. 6.4.1  Figure 6 shows the most basic  of scenarios for Job Supervision interactions. It proceeds in this fashion:\n6. 6.4.1.1  The JobRequestor populates a  JobSpecification then requests a Job according to that specification."),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200029\n6. 6.4.1.2  In response to the Job request,  the JobSupervisor facilitates the creation of a Job to represent the task. A\nhandle to the Job is returned to the JobRequestor (assuming the Job request is accepted).\n6. 6.4.1.3   The  Job  Supervision  compone nt  (e.g.  in  the  form  of  the  Job)  informs  the  JobRequestor  when  the  Job\nbegins.\n6. 6.4.1.4  The Job Supervision compone nt (e.g. in the form of the Job) informs the JobRequestor when the Job has\ncompleted (assuming successful completion). It also issues events for each state change (not shown in the scenario\ndiagram).\n6. 7  Factory Component\n6. 7.1   The  Factory  interfaces  provide   configuration  services to  specify  the  existence  and  connectivity  of  factory\nresources that constitute a factory. This includes area configuration and the registration of CIM system components,\nand the ability to dynamically configure a factory to enforce business policy.\n6. 7.1.1   These  interfaces  are  included  h ere  to  satisfy  dependencies  and  meet  needs  of  other  CIM  Framework\nComponents. These interfaces will be moved to the Factory Operations Component in a subsequent revision ballot.\nResource\nOwnedEntity\nFactory Component\nComponentManager\nMa chine\nPe rson\nMESFactory\n0. .",(0,o.yg)("em",{parentName:"p"},"\n0. .1\n0. ."),"\n0. .1\nregisters\nArea\n0. .",(0,o.yg)("em",{parentName:"p"},"\n0. ."),"\n0. .",(0,o.yg)("em",{parentName:"p"},"\n0. ."),"\ngroups\n0. .",(0,o.yg)("em",{parentName:"p"},"\n0. ."),"\n0. .",(0,o.yg)("em",{parentName:"p"},"\n0. ."),"\ngroups\n0. .",(0,o.yg)("em",{parentName:"p"},"0.."),"\nFigure 7\nFactory Component Information Model"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200030\n6. 7.2  Factory Declarations\n6. 7.2.1  The following declarations are  used by the interfaces of the Factory Component.\ninterfaceComponentManager;\ninterfaceArea;\ntypedef sequence ComponentManagerComponentManagerSequence;\ntypedef sequence AreaAreaSequence;\nexceptionAreaNotFoundSignal{Area requestedArea;};\nexceptionAreaDuplicateSignal{};\nexceptionAreaNotAssignedSignal{};\nexceptionAreaRemovalFailedSignal{};\n6. 7.3  MESFactory Interface\nModule:FactoryOperations\nInterface:MESFactory\nInherited Interface:AbstractIF::Resource\nDescription:The MESFactory interface represents one particular factory. This instance is a composite\nobject  referring  to  the  objects  that  represent  factory  resources,  particularly  CIM  system\ncomponents. The factory instance provides overall startup and shutdown capability.\ninterfaceMESFactory: AbstractIF::Resource {\nExceptions:None.\nPublished Events:\n/",(0,o.yg)("em",{parentName:"p"}," MES Factory state change event definition. "),"/\nconst stringMESFactoryStateChangedSubject= \u201c/Factory/MESFactory/StateChanged\u201d;\n/",(0,o.yg)("em",{parentName:"p"}," This enumerated type identifies the states of the MES Factory. It is used in event notifications of state changes. "),"/\nenumMESFactoryState{\nFactoryUndefined,\nFactoryStartingUp,\nFactoryOperating,\nFactoryGoingToStandby,\nFactoryStandby,\nFactoryShuttingDownImmediately,\nFactoryShuttingDownNormally,\nFactoryOff };\nstructMESFactoryStateChangedFilters{\nGlobal::Property name;\nGlobal::Property previousState;\nGlobal::Property newState;\n};"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200031\nMESFactoryStateChangedFilters Properties:\nNameValue TypeDescription\n\u201cMESFactoryName\u201dstringThe name of the MES Factory.\n\u201cPreviousState\u201dMESFactoryStatePrevious state preceding the most recent change.\n\u201cNewState\u201dMESFactoryStateNew state following the most recent change.\nstructMESFactoryStateChangedEvent{\nstring eventSubject;\nGlobal::TimeStamp eventTimeStamp;\nMESFactoryStateChangedFilters eventFilterData;\nGlobal::Properties eventNews;\nMESFactory aMESFactory;\n};\n/",(0,o.yg)("em",{parentName:"p"}," Registration of Component Manager has changed "),"/\nconst string ComponentManagerRegistrationChangedSubject=\n\u201c/Factory/MESFctory/ComponentManagerRegistrationChanged\u201d;\n/",(0,o.yg)("em",{parentName:"p"}," This enumerated type identifies the states of Component Manager registration. It is used in event notifications of\nstate changes. "),"/\nenumRegistrationState{\nRegistrationUndefined,\nRegistered,\nNotRegistered };\nstructRegistrationChangedFilters{\nGlobal::Property MESFactoryName;\nGlobal::Property componentManagerName;\nGlobal::Property newState;\n};\nRegistrationChangedFilters Properties:\nNameValue TypeDescription\n\u201cMESFactoryName\u201dstringThe name of the MES Factory.\n\u201cComponentManagerName\u201dstringThe name of the Component Manager.\n\u201cNewState\u201dRegistrationStateNew state following the most recent change.\nstructComponentManagerRegistrationChangedEvent{\nstring eventSubject;\nGlobal::TimeStamp eventTimeStamp;\nRegistrationChangedFilters eventFilterData;\nGlobal::Properties eventNews;\nMESFactory aMESFactory;\nComponentManager aComponentManager;\n};\nProvided Services:\n/",(0,o.yg)("em",{parentName:"p"}," Add an area to the receiver. Returns the area. "),"/\nAreaaddArea(in Area anArea)\nraises (AreaDuplicateSignal,\nGlobal::FrameworkErrorSignal);"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200032\n/",(0,o.yg)("em",{parentName:"p"}," Remove an area from the receiver. Returns the area removed. "),"/\nArearemoveArea(in Area anArea)\nraises (Global::FrameworkErrorSignal,\nAreaRemovalFailedSignal,\nAreaNotAssignedSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Returns the factory areas "),"/\nAreaSequenceallAreas()\nraises (Global::FrameworkErrorSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Returns collections of various factory resources. "),"/\nEquipmentTracking::MachineSequenceallMachines()\nraises (Global::FrameworkErrorSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Returns a collection of the component managers for the factory. "),"/\nComponentManagerSequenceallComponentManagers()\nraises (Global::FrameworkErrorSignal);\n/",(0,o.yg)("em",{parentName:"p"}," A component informs the factory that it has completed startup. "),"/\nvoidinformComponentManagerIsOperating(in ComponentManager aComponentManager)\nraises (Global::FrameworkErrorSignal);\n/",(0,o.yg)("em",{parentName:"p"}," A component informs the factory that it has completed shutdown. "),"/\nvoidinformComponentManagerIsStopped(in ComponentManager aComponentManager)\nraises (Global::FrameworkErrorSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Factory is requested to go to STARTING UP state. Note MESFactory inherits from the Resource interface and is\nstarted  up  using  the  operations  defined  in  that  interface.  During  the  startup  and  shutdown  the  factory  delegates\nappropriate requests to all registered components. "),"/\nvoidmakeStartingUp()\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Factory is requested to specified state. "),"/\nvoidmakeOperating()\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nvoidmakeStandby()\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nvoidmakeShuttingDownNormaly()\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nvoidmakeShuttingDownImmediately()\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nvoidmakeOff()\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Answer whether the factory is in the state indicated "),"/"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200033\nbooleanisOutOfService()\nraises (Global::FrameworkErrorSignal);\nbooleanisOff()\nraises (Global::FrameworkErrorSignal);\nbooleanisStartingUp()\nraises (Global::FrameworkErrorSignal);\nbooleanisInService()\nraises (Global::FrameworkErrorSignal);\nbooleanisOperating()\nraises (Global::FrameworkErrorSignal);\nbooleanisShuttingDownNormaly()\nraises (Global::FrameworkErrorSignal);\nbooleanisShuttingDownImmediately()\nraises (Global::FrameworkErrorSignal);\nbooleanisGoingToStandby()\nraises (Global::FrameworkErrorSignal);\nbooleanisStandby()\nraises (Global::FrameworkErrorSignal);\n}; //MESFactory\nContracted Services:None.\nDynamic Model:"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200034\nOUT OF SERVICE\nSTARTING UP\nOFF\nSHUTTING DOWN NORMALLY\nSHUTTING DOWN IMMEDIATELY\nIN  SER VIC E\nOPERATING\nGOING TO  STANDBY\nSTANDBY\nSTARTING UP\nOFF\nSHUTTING DOWN NORMALLY\nSHUTTING DOWN IMMEDIATELY\nOPERATING\nGOING TO  STANDBY\nSTANDBY\n2\n4\n5\n6\n7\n8\n9\n10\n1\n3\nFigure 8\nMESFactory Dynamic Model"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200035\nTable 5  MESFactory State Definitions and Query Table\nStateDefinitionQuery for State via\nOUT OF SERVICEA superstate, inherited from Resource,\nencompassing the next four substate definitions.\nboolean isOutOfService ( );\nsent to the instance of MESFactory returns\nFALSE.\nOFFIn this state the MESFactory has a building,\nmachines and other resources. No CIM activities\nshould be allowed. ComponentManagers should\nnot be registered yet.\nboolean isOff ( );\nsent to the instance of MESFactory returns\nTRUE.\nSTARTING UPIn this state the MESFactory has requested\nstartup sequences for all resources.\nboolean isStartingUp ( );\nsent to the instance of MESFactory returns\nTRUE.\nSHUTTING DOWN\nNORMALY\nIn this state MESFactory resources and material\nare brought to a safe state in preparation for\nterminating in an orderly fashion.\nboolean isShuttingDownNormaly ( );\nsent to the instance of MESFactory returns\nTRUE.\nSHUTTING DOWN\nIMMEDIATELY\nIn this state the MESFactory is shutting down\nwithout regard for the safe state of material or\npotential product and data loss. All processes are\nterminated immediately.\nboolean isShuttingDownImmediately ( );\nsent to the instance of MESFactory returns\nTRUE.\nIN SERVICEA superstate, inherited from Resource,\nencompassing the next three substate definitions.\nboolean isInService ( );\nsent to the instance of MESFactory returns\nTRUE.\nOPERATINGIn this state the MESFactory is able to process\nproduct. Applications are prepared to support\nfactory operations to process product.\nboolean isOperating ( );\nsent to the instance of MESFactory returns\nTRUE.\nGOING TO\nSTANDBY\nIn this state the MESFactory is performing\nsequences to make the transition to STANDBY.\nIt brings all product and equipment to a safe\nstopping place.\nboolean isGoingToStandby ( );\nsent to the instance of MESFactory returns\nTRUE.\nSTANDBYSTANDBY means nearly available for\nimmediate use. In this state the MESFactory is\nidle and available; applications are able to\nrespond to a subset of selected messages.\nboolean isStandby ( );\nsent to the instance of MESFactory returns\nTRUE.\nTable 6  MESFactory State Transition Table\n#Current StateTriggerNew StateActionComment\n1non-existentNo CIM Framework\ntrigger necessary\nOFFBuilding(s), machines and\nother resources are added\nafter this transition.\nThe MESFactory object\ninstance is unique in the\nFramework. It is the only\nobject that must be created\nby the implementation.\n2OFFvoid makeStartingUp\n( ); sent to the\ninstance of\nMESFactory.\nSTARTING\nUP\nStartup sequence\nperformed, including\ndelegated messages to\ncomponent managers.\nResource inherited\ninterface also defines\nstartup.\n3STARTING\nUP\nvoid makeOperating\n( ); sent to the\ninstance of\nMESFactory.\nOPERATINGMESFactory is operating\nevent published by the\ninstance of MESFactory.\nRelevant registered\ncomponents inform the\nfactory when they have\ncompleted startup prior to\nstartup being complete."),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200036\n#Current StateTriggerNew StateActionComment\n4OPERATINGvoid makeStandby\n( ); sent to the\ninstance of\nMESFactory.\nGOING TO\nSTANDBY\nMESFactory is requested to\ngo to STANDBY state.\n5GOING TO\nSTANDBY\ncompletion of\nStandby transition by\nMESFactory.\nSTANDBYMESFactory is in\nSTANDBY state event\npublished by the instance of\nMESFactory.\nAll component managers,\nmachines and material are\nidle and in a safe state.\n6STANDBYvoid makeOperating\n( ); sent to\nMESFactory\nOPERATINGvoid startup ( ); sent to an\ninstance of Component-\nManager.\nSince standby means nearly\navailable for immediate\nuse, this startup transition\nshould be minimal.\n7IN SERVICEvoid\nmakeShuttingDown\nImmediately ( ); sent\nto the instance of\nMESFactory.\nSHUTTING\nDOWN\nIMMEDI-\nATELY\nvoid shutdownImmediate\n( ); sent to all instances of\nregistered Component\nManagers.\nAs an action, messages\ndelegated to component\nmanagers. The Resource\ninherited interface also\nimplements\nshutdownImmediate\n8SHUTTING\nDOWN\nIMMEDI-\nATELY\nvoid makeOff (); sent\nto the instance of\nMESFactory.\nOFFvoid informComponent\nManagerIsStopped (in\nComponentManager\naComponentManager); sent\nto the instance of\nMESFactory by the\nComponent Managers.\nMESFactory is off event\npublished by the instance of\nMESFactory.\nThe MESFactory polls the\nComponentManagers and\nResources for completion\nof shutdown before the\nMESFactory state\ntransitions to OFF.\n9IN SERVICEvoid\nmakeShuttingDown\nNormally ( ); sent to\nthe instance of\nMESFactory.\nSHUTTING\nDOWN\nvoid shutdown Normal ( );\nsent to all instances of\nregistered Component-\nManagers.\nAs an action, messages\ndelegated to component\nmanagers.\n10SHUTTING\nDOWN\nNORMALLY\nvoid makeOff ( );\nsent to the instance\nof MESFactory.\nOFFvoid informComponent\nManagerIsStopped (in\nComponentManager\naComponentManager); sent\nto the instance of\nMESFactory by the\nComponent Managers.\nMESFactory is off event\npublished by the instance of\nMESFactory.\nThe MESFactory polls the\nComponentManagers and\nResources for completion\nof shutdown before the\nMESFactory state\ntransitions to OFF.\n6. 7.4  Area Interface\nModule:FactoryOperations\nInterface:Area\nInherited Interface:OwnedEntity\nDescription:Area is the interface corresponding to a physical or logical grouping of factory resources\n(the  complement  of  machines  and/or  personnel  assigned  to  it).  Area  may  represent  a\nsingular entity or it may represent a collection of other Areas. For example, an Area may\nrepresent  an  entire  facility  for  maintenance  purposes,  or  an  Area  may  represent  a\nprocessing area such as a \u201cbay\u201d which is comprised of \u201czones.\u201d"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200037\nThe  association  between  an  Area  and  its  composite  Areas  may  be  hierarchical  or  there\nmay simply be a collection of peer Areas without any explicit or implicit relationship.\nArea may or may not be an optional construct, depending on such issues as security.\ninterfaceArea{\nExceptions:                        None.\nPublished Events:\n/",(0,o.yg)("em",{parentName:"p"}," Area configuration changed event definition. "),"/\nconst stringAreaConfigurationChangedSubject=\n\u201c/Factory/Area/AreaConfigurationChanged\u201d;\n/",(0,o.yg)("em",{parentName:"p"}," This enumerated type identifies the types of configuration changes for Areas. It is used in event notifications of\nstate changes. "),"/\nenumAreaChangeType{\nMachinesChanged,\nPersonsChanged,\nSubAreaChanged };\nstructAreaConfigurationChangedFilters{\nGlobal::Property name;\nGlobal::Property changeType;\n};\nAreaConfigurationChangedFilters Properties:\nNameValue TypeDescription\n\u201cName\u201dstringThe name of the Area.\n\u201cChangeType\u201dAreaChangeTypeThe type of change to the Area.\nstructAreaConfigurationChangedEvent{\nstring eventSubject;\nGlobal::TimeStamp eventTimeStamp;\nAreaConfigurationChangedFilters eventFilterData;\nGlobal::Properties eventNews;\nArea anArea;\n};\nProvided Services:\n/",(0,o.yg)("em",{parentName:"p"}," Answer the Area to which this Area is associated. If no membership has been established, nil is returned. "),"/\nAreagetSuperArea()\nraises (Global::FrameworkErrorSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Get the unique identifier for the Area. "),"/\nstringgetAreaIdentifier()\nraises (Global::FrameworkErrorSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Adds a machine to the receiver. Returns the machine added. "),"/"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200038\nEquipmentTracking::MachineaddMachine(in EquipmentTracking::Machine aMachine)\nraises (Global::FrameworkErrorSignal,\nEquipmentTracking::MachineDuplicateSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Create an association between an Area and the Area to which it belongs. The service will add the Area indicated\nby the argument to the receiver\u2019s set of subareas. The service will also update the superarea for the argument. The\nservice returns the argument. "),"/\nAreaaddSubArea(in Area anArea)\nraises (Global::FrameworkErrorSignal,\nAreaDuplicateSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Adds a person to the receiver. Returns the person added. "),"/\nLabor::PersonaddPerson(in Labor::Person aPerson)\nraises (Global::FrameworkErrorSignal,\nLabor::PersonDuplicateSignal);\n/",(0,o.yg)("em",{parentName:"p"},"  Remove  the  association  between  an  Area  and  the  Area  to  which  it  belongs.  The  service  will  remove  the  Area\nindicated by the argument from the receiver\u2019s set of subareas. The service will also nullify membership (ownership)\nfor the argument. "),"/\nvoidremoveSubArea(in Area anArea)\nraises (Global::FrameworkErrorSignal,\nAreaNotAssignedSignal,\nAreaRemovalFailedSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Removes a machine from the receiver. "),"/\nvoidremoveMachine(in EquipmentTracking::Machine aMachine)\nraises (Global::FrameworkErrorSignal,\nEquipmentTracking::MachineNotAssignedSignal,\nEquipmentTracking::MachineRemovalFailedSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Removes a person from the receiver. "),"/\nvoidremovePerson(in Labor::Person aPerson)\nraises (Global::FrameworkErrorSignal,\nLabor::PersonNotAssignedSignal,\nLabor::PersonRemovalFailedSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Set the unique identifier for the Area. "),"/\nvoidsetAreaIdentifier(in string identifier)\nraises (Global::FrameworkErrorSignal,\nGlobal::DuplicateIdentifierSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Returns the set of subareas associated with this Area, that is, the Areas \u201ccontained\u201d within this higher-level Area.\nIf no membership has been established, an empty set is returned. "),"/\nAreaSequenceallSubAreas()\nraises (Global::FrameworkErrorSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Returns the receiver\u2019s set of process machines. "),"/\nEquipmentTracking::MachineSequenceallMachines()\nraises (Global::FrameworkErrorSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Returns the receiver\u2019s set of persons "),"/\nLabor::PersonSequenceallPersons()\nraises (Global::FrameworkErrorSignal);"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200039\n}; //Area\nContracted Services:None.\nDynamic Model:None.\n6. 7.5  Component Manager Interface\nModule:FactoryOperations\nInterface:ComponentManager\nInherited Interface:Resource\nDescription:The ComponentManager is an abstract interface that supports the registration and control\n(enabling/disabling)  of  a  component\u2019s  interface  and  for  managing  the  resources  in  its\ndomain.\nExceptions:None.\nPublished Events:\ninterfaceComponentManager: Resource {\n/",(0,o.yg)("em",{parentName:"p"}," Component Manager state has changed "),"/\nconst string ComponentManagerStateChangedSubject =\n\u201c/Factory/ComponentManager/ComponentManagerStateChanged\u201d;\n/",(0,o.yg)("em",{parentName:"p"},"  This  enumerated  type  identifies  the  states  of  Component  Managers.  It  is  used  in  event  notifications  of  state\nchanges. "),"/\nenumComponentManagerState{\nComponentManagerUndefined,\nComponentManagerStopped,\nComponentManagerStartingUp,\nComponentManagerShuttingDown };\nstructComponentManagerStateChangedFilters{\nGlobal::Property name;\nGlobal::Property previousState;\nGlobal::Property newState;\n};\nComponentManagerStateChangedFilters Properties:\nNameValue TypeDescription\n\u201cName\u201dstringThe name of the ComponentManager.\n\u201cPreviousState\u201dComponentManagerStatePrevious state prior to the most recent transition.\n\u201cNewState\u201dComponentManagerStateNew state following the most recent transition.\nstructComponentManagerStateChangedEvent{\nstring eventSubject;\nGlobal::TimeStamp eventTimeStamp;\nComponentManagerStateChangedFilters eventFilterData;\nGlobal::Properties eventNews;\nComponentManager aComponentManager;\n};\nProvided Services:\n/",(0,o.yg)("em",{parentName:"p"}," This operation causes the component to do its portion of the registration interchange with the factory indicated by\nthe argument. "),"/"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200040\nvoidmakeRegistered(in MESFactory aFactory)\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\n/",(0,o.yg)("em",{parentName:"p"}," This operation causes the component to remove its registration from the factory. "),"/\nvoidmakeNotRegistered(in MESFactory aFactory)\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\n/",(0,o.yg)("em",{parentName:"p"},"  This  operation  causes  a  registered  component  to  perform  its  startup  sequence.  Each  manager  gets  itself  to  the\npoint where it is capable of interacting with other components. When it is ready to support all services defined in the\ninterface, the component manager tells the factory that component startup is complete. "),"/\nvoidmakeStartingUp()\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\n/",(0,o.yg)("em",{parentName:"p"},"  This  operation  causes  the  component  to  perform  its  shutdown  sequence  and  then  enter  the  state  STOPPED.\nDuring  shutting  down  activities,  time  is  allotted  to  bringing  the  resources  of  a  component  to  a  safe  stopping\ncondition. The component manager tells the factory that component shutdown is complete. "),"/\nvoidmakeShuttingDown()\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\n/",(0,o.yg)("em",{parentName:"p"},"  This  operation  causes  the  component  to  go  into  the  state  STOPPED  without  regard  to  data  loss  or  the  stopping\ncondition of resources or material. There is no communication with the factory. "),"/\nvoidmakeStopped()\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\n/",(0,o.yg)("em",{parentName:"p"}," This operation causes a registered component to go into the state IN SERVICE from the state STOPPED. "),"/\nvoidmakeInService()\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\n/",(0,o.yg)("em",{parentName:"p"}," Answer whether the status of the component is that indicated. "),"/\nbooleanisStopped()\nraises (Global::FrameworkErrorSignal);\nbooleanisStartingUp()\nraises (Global::FrameworkErrorSignal);\nbooleanisShuttingDown()\nraises (Global::FrameworkErrorSignal);\nbooleanisNotRegistered()\nraises (Global::FrameworkErrorSignal);\nbooleanisRegistered()\nraises (Global::FrameworkErrorSignal);\n}; //ComponentManager\nContracted Services:None."),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200041\nDynamic Model:\nComponent Manager Registration\nNOT REGISTERED\nREGISTERED\nNOT REGISTERED\n1\nREGISTERED\n2323\nComponent Manager Service Status\nOUT OF SERVICE\nSHUTTING DOWN\nSTARTING UP\nSTOPPED\nIN SERVICE\nOUT OF SERVICE\nSHUTTING DOWN\nSTARTING UP\nSTOPPED\nSHUTTING DOWN\nSTARTING UP\nSTOPPED\nIN SERVICE\n1111\n44\n66\n55\n99\n8\n1010\n7\nFigure 9\nComponent Manager Dynamic Model\nTable 7  ComponentManager State Definitions and Query Table\nStateDefinitionQuery for State via\nNOT REGISTEREDComponent is not registered with a factory\nand is not connected to the system.\nboolean isNotRegistered ( ); sent to the instance\nof ComponentManager returns TRUE.\nREGISTEREDComponent is registered with a factory and is\nconnected to the system.\nboolean isRegistered ( ); sent to the instance of\nComponentManager returns TRUE.\nSTOPPEDComponent is not able to provide services.boolean isStopped ( ); sent to the instance of\nComponentManager returns TRUE.\nSTARTING UPComponent is performing a startup sequence.boolean isStartingUp ( ); sent to the instance of\nComponentManager returns TRUE.\nIN SERVICEComponent is capable of interacting with\nother components.\nboolean isInService ( ); sent to the instance of\nComponentManager returns TRUE.\nSHUTTING DOWNComponent is performing shutdown\nsequence.\nboolean isShuttingDown ( ); sent to the instance\nof ComponentManager returns TRUE.\nOUT OF SERVICEComponent is not able to provide services.None."),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200042\nTable 8  ComponentManager State Transitions\n#Current StateTriggerNew StateActionComment\n1Non ExistentNo CIM Framework\ntrigger necessary.\nNOT\nREGISTERED\nInstance creation is done\nby the specialization.\nComponentManager is\nan abstract inherited\ninterface designed to\nprovide common\nbehavior for\nspecializations.\n2NOT\nREGISTERED\nmakeRegistered() sent\nto the instance of\nComponentManager.\nREGISTEREDComponent manager\nregisters with a Factory\ninstance via Trader.\nNone.\n3REGISTEREDmakeNotRegistered()\nsent to the instance of\nComponentManager.\nNOT\nREGISTERED\nComponent manager\nremoves registration from\nthe Factory via Trader.\nNone.\n4UnknownmakeStartingUp() sent\nto the instance of\nComponentManager.\nSTARTING\nUP\nComponent manager is\nrequested to startup.\nImplementation can\nuse startup() or\nmakeStartingUp()\nservices.\n5STARTING UPInternal to component.IN SERVICEReport to Factory that\nComponent is able to\nprovide services, via\nevents.\nComponent manager\nhas finished its startup\nsequence.\n6STARTING UPInternal to component.STOPPEDNone.Component Manager\ncould not complete\nstartup procedure and\nis stopped for further\ncorrective action.\n7IN SERVICEmakeStopped() sent to\nthe instance of\nComponent Manager.\nSTOPPEDComponent will also go\nout of service.\nComponentManager is\nstopped and it may be\nresumed as needed.\n8STOPPEDmakeInService() sent to\nthe instance of\nComponent Manager.\nIN SERVICEComponent Manager has\nresumed operations and is\nin service for execution.\nNone.\n9STOPPEDmakeShuttingDown()\nsent to the instance of\nComponentManager.\nSHUTTING\nDOWN\nAs an action it reports to\nthe Factory that resources\nand material are brought\nto a safe state.\nThe component\nmanager receives\n\u201cshutdown normal\u201d\nmessage.\n10IN SERVICEmakeShuttingDown()\nsent to the instance of\nComponentManager.\nSHUTTING\nDOWN\nAs an action it reports to\nthe Factory that resources\nand material are brought\nto a safe state.\nThe component\nmanager receives\n\u201cshutdown normal\u201d\nmessage.\n11SHUTTING\nDOWN\nmakeNotRegistered()\nsent to the instance of\nComponent Manager.\nNon ExistentThe Component Manager\nis unregistered.\nNone."),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200043\nAPPENDIX 1\nFULL IDL SPECIFICATION\nNOTE:  The  material  in  this  appendix  is  an  official  part  of  SEMI  E97  and  was  approved  by  full  letter  ballot  procedures  on\nOctober 21 and December 15, 1999 by the North American Regional Standards Committee.\nmodule CIMFW {\n#ifndef ",(0,o.yg)("em",{parentName:"p"},"CIMFW_GLOBAL"),"\n#define ",(0,o.yg)("em",{parentName:"p"},"CIMFW_GLOBAL"),"\nmodule Global {\ntypedef string Identifier;\ntypedef unsigned long Flags;\nstruct NamedValue{\nIdentifier name;\nany argument;\nlong len;\nFlags arg_modes;\n};\ntypedef NamedValue NameValue;\ntypedef sequence NamedValue NameValueSequence;\ntypedef string PropertyName;\nstruct Property{\nPropertyName Property_name;\nany Property_value;\n};\ntypedef sequence Property Properties;\ntypedef sequence string StringSequence;\ntypedef string Unit;\ntypedef string Units;\ntypedef sequence any anySequence;\ntypedef sequence long longSequence;\nenum PriorityOfEvent { Low,\nMedium,\nHigh,\nAlarm };\nenum LifecycleState { Undefined,\nCreated,\nDeleted,\nMoved,\nCopied };\nenum ReservationState { UndefinedReservationState,\nReserved,\nUnReserved };\nenum E10State { E10Productive,\nE10Standby,\nE10Engineering,\nE10ScheduledDowntime,\nE10UnscheduledDowntime,\nE10NonscheduledTime };"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200044\nstruct ulonglong\n{unsigned long low ;\nunsigned long high ;\n};\ntypedef ulonglong TimeT ;\ntypedef TimeT TimeStamp;\ntypedef sequence TimeStamp TimeStampSequence;\nstruct IntervalT {\nTimeT lower",(0,o.yg)("em",{parentName:"p"},"bound;\nTimeT upper_bound;\n};\ntypedef IntervalT TimeWindow;\ntypedef TimeT Duration;\nstruct ResourceSchedule {\nTimeStamp plannedStartTime;\nTimeStamp plannedEndTime;\nTimeStamp actualStartTime;\nTimeStamp actualEndTime;\n};\ntypedef sequence ResourceSchedule ResourceScheduleSequence;\nexception NotFoundSignal { string errorMessage; };\nexception DuplicateIdentifierSignal {\nstring errorMessage;\nstring duplicateIdentifier; };\nexception InvalidStateTransitionSignal {\nstring errorMessage; };\nexception SetValueOutOfRangeSignal {\nstring errorMessage; };\nexception TimePeriodInvalidSignal {\nstring errorMessage; };\nexception InvalidPropertyNameSignal {};\nexception PropertyNotFoundSignal {};\nexception UnsupportedPropertySignal {};\nexception ReadOnlyPropertySignal {};\nexception FrameworkErrorSignal {\nstring errorMessage;\nunsigned long errorCode;\nany errorInformation;};\nconst unsigned long NOT_IMPLEMENTED = 0;\nconst unsigned long IMPLEMENTED_BY_SUBCLASS = 1;\nconst unsigned long UNKNOWN_EXCEPTION = 2;\nconst unsigned long COMPLETION_UNKNOWN = 3;\n}; // module Global\n#endif // _CIMFW_GLOBAL"),"\nmodule EquipmentTracking {\ninterface Machine {}; // Stub"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200045\ntypedef sequence Machine MachineSequence;\nexception MachineDuplicateSignal { };\nexception MachineNotAssignedSignal { };\nexception MachineRemovalFailedSignal { };\n}; // module EquipmentTracking\nmodule Labor {\ninterface Person {}; // Stub\ntypedef sequence Person PersonSequence;\nexception PersonDuplicateSignal { };\nexception PersonNotAssignedSignal { };\nexception PersonRemovalFailedSignal { };\n}; // module Labor\n#ifndef ",(0,o.yg)("em",{parentName:"p"},"CIMFW_ABSTRACT_IF"),"\n#define ",(0,o.yg)("em",{parentName:"p"},"CIMFW_ABSTRACT_IF"),"\nmodule AbstractIF {\ninterface Resource;\ninterface Material;\ninterface MaterialGroup;\ninterface JobSupervisor;\ninterface Job;\ninterface JobRequestor;\ntypedef sequence Resource ResourceSequence;\ntypedef sequence Material MaterialSequence;\ntypedef sequence MaterialGroup MaterialGroupSequence;\ntypedef sequence Job JobSequence;\ntypedef sequence JobSupervisor JobSupervisorSequence;\ninterface NamedEntity {\nvoid setName (in string name)\nraises (Global::FrameworkErrorSignal);\nstring getName ( )\nraises (Global::FrameworkErrorSignal);\nboolean isNamed (in string testName)\nraises (Global::FrameworkErrorSignal);\n}; // NamedEntity\ninterface OwnedEntity : NamedEntity {\nvoid setOwner (in NamedEntity owner)\nraises (Global::FrameworkErrorSignal);\nNamedEntity getOwner ( )"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200046\nraises (Global::FrameworkErrorSignal);\n}; // OwnedEntity\ninterface Resource : OwnedEntity {\ntypedef sequence Resource ResourceSequence;\nvoid startUp ( )\nraises (Global::FrameworkErrorSignal);\nvoid shutdownNormal ( )\nraises (Global::FrameworkErrorSignal);\nvoid shutdownImmediate ( )\nraises (Global::FrameworkErrorSignal);\nstring resourceLevel ( )\nraises (Global::FrameworkErrorSignal);\nstring nameQualifiedTo (in string resourceLevel)\nraises (Global::FrameworkErrorSignal);\nResourceSequence subresources ( )\nraises (Global::FrameworkErrorSignal);\nboolean isInService ( );\nboolean isOutOfService ( );\n}; // Resource\ninterface Material : NamedEntity {\nstring getIdentifier ( )\nraises (Global::FrameworkErrorSignal);\nvoid setIdentifier (in string identifier)\nraises (Global::FrameworkErrorSignal,\nGlobal::DuplicateIdentifierSignal);\nMaterialGroupSequence materialGroups ( )\nraises (Global::FrameworkErrorSignal);\nboolean isMemberOf (in MaterialGroup aMaterialGroup)\nraises (Global::FrameworkErrorSignal);\n}; // Material\ninterface MaterialGroup : NamedEntity {\nexception DuplicateMaterialSignal {Material aMaterial;};\nexception DuplicateMaterialGroupSignal {Material\naMaterialGroup;};\nexception MaterialRemovalFailedSignal {Material aMaterial;};\nexception MaterialGroupRemovalFailedSignal {\nMaterialGroup  aMaterialGroup;};\nstring getIdentifier ( )\nraises (Global::FrameworkErrorSignal);\nvoid setIdentifier (in string identifier)\nraises (Global::FrameworkErrorSignal,\nGlobal::DuplicateIdentifierSignal);\nvoid addMaterials (in MaterialSequence aMaterialSequence)\nraises  (Global::FrameworkErrorSignal,"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200047\nDuplicateMaterialSignal);\nvoid addMaterial (in Material aMaterial)\nraises (Global::FrameworkErrorSignal,\nDuplicateMaterialSignal);\nvoid removeMaterial (in Material aMaterial)\nraises  (Global::FrameworkErrorSignal,\nMaterialRemovalFailedSignal,\nGlobal::NotFoundSignal);\nMaterialSequence removeAllMaterials ( )\nraises (Global::FrameworkErrorSignal);\nvoid addMaterialGroup (in MaterialGroup aMaterialGroup)\nraises (Global::FrameworkErrorSignal,\nDuplicateMaterialGroupSignal);\nvoid removeMaterialGroup (in MaterialGroup aMaterialGroup)\nraises (Global::FrameworkErrorSignal,\nMaterialGroupRemovalFailedSignal,\nGlobal::NotFoundSignal);\nMaterialSequence allMaterials ( )\nraises (Global::FrameworkErrorSignal);\nMaterialGroupSequence allMaterialGroups ( )\nraises (Global::FrameworkErrorSignal);\nlong size ( )\nraises  (Global::FrameworkErrorSignal);\n}; // MaterialGroup\ninterface JobSupervisor : Resource {\ntypedef Global::NameValueSequence Results;\nexception JobRejectedSignal { string errorMessage; };\nexception JobNotFoundSignal {\nstring errorMessage;\nstring missingJobName; };\nconst string JobLifecycleSubject\n=\u201c/JobSupervision/JobSupervisor/JobLifecycle\u201d;\nstruct JobLifecycleFilters {\nGlobal::Property name;\nGlobal::Property lifecycle;\n};\nstruct JobLifecycleEvent {\nstring eventSubject;\nGlobal::TimeStamp eventTimeStamp;\nJobLifecycleFilters eventFilterData;\nGlobal::Properties eventNews;\nJob aJob; // on Delete, aJob is nil\n};\nJob requestJob (\nin Global::Properties aJobSpecification,\nin JobRequestor aJobRequestor)\nraises (Global::FrameworkErrorSignal,\nJobRejectedSignal);\nResults runJob (\nin Global::Properties aJobSpecification)\nraises (Global::FrameworkErrorSignal,\nJobRejectedSignal);"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200048\nboolean canPerform (\nin Global::Properties aJobSpecification)\nraises (Global::FrameworkErrorSignal);\nvoid pauseAllJobs ()\nraises (Global::FrameworkErrorSignal);\nvoid resumeAllJobs ()\nraises (Global::FrameworkErrorSignal);\nvoid abortAllJobs ()\nraises (Global::FrameworkErrorSignal);\nvoid stopAllJobs ()\nraises (Global::FrameworkErrorSignal);\nvoid removeFinishedJob (in Job aJob)\nraises (Global::FrameworkErrorSignal);\nJob findJobNamed (in string jobName)\nraises (Global::FrameworkErrorSignal,\nJobNotFoundSignal);\nJob findQueuedJobNamed (in string jobName)\nraises (Global::FrameworkErrorSignal,\nJobNotFoundSignal);\nJob findActiveJobNamed (in string jobName)\nraises (Global::FrameworkErrorSignal,\nJobNotFoundSignal);\nJob findCancelledJobNamed (in string jobName)\nraises (Global::FrameworkErrorSignal,\nJobNotFoundSignal);\nJob findFinishedJobNamed (in string jobName)\nraises (Global::FrameworkErrorSignal,\nJobNotFoundSignal);\nJobSequence allJobs ( )\nraises (Global::FrameworkErrorSignal);\nJobSequence allQueuedJobs ( )\nraises (Global::FrameworkErrorSignal);\nJobSequence allCanceledJobs ( )\nraises (Global::FrameworkErrorSignal);\nJobSequence allActiveJobs ( )\nraises (Global::FrameworkErrorSignal);\nJobSequence allExecutingJobs ( )\nraises (Global::FrameworkErrorSignal);\nJobSequence allPausingJobs ( )\nraises (Global::FrameworkErrorSignal);\nJobSequence allPausedJobs ( )\nraises (Global::FrameworkErrorSignal);\nJobSequence allStoppingJobs ( )\nraises (Global::FrameworkErrorSignal);\nJobSequence allAbortingJobs ( )\nraises (Global::FrameworkErrorSignal);\nJobSequence allFinishedJobs ( )\nraises (Global::FrameworkErrorSignal);\nJobSequence allStoppedJobs ( )"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200049\nraises (Global::FrameworkErrorSignal);\nJobSequence allAbortedJobs ( )\nraises (Global::FrameworkErrorSignal);\nJobSequence allCompletedJobs ( )\nraises (Global::FrameworkErrorSignal);\n}; // JobSupervisor\ninterface Job : OwnedEntity {\nconst string JobStateChangedSubject =\n\u201c/JobSupervision/Job/StateChanged\u201d;\nenum JobState {\nJobUndefined,\nJobCreated,\nJobQueued,\nJobActive,\nJobExecuting,\nJobNotPaused,\nJobPausing,\nJobPaused,\nJobNotStopping,\nJobStopping,\nJobNotAborting,\nJobAborting,\nJobFinished,\nJobCanceled,\nJobCompleted,\nJobStopped,\nJobAborted };\nstruct JobStateChangedFilters {\nGlobal::Property name;\nGlobal::Property previousState;\nGlobal::Property newState;\n};\nstruct JobStateChangedEvent {\nstring eventSubject;\nGlobal::TimeStamp eventTimeStamp;\nJobStateChangedFilters eventFilterData;\nGlobal::Properties eventNews;\nJob aJob;\n};\nconst string JobDeadlineCannotBeMetSubject =\n\u201c/JobSupervision/Job/DeadlineCannotBeMet\u201d;\nstruct JobDeadlineCannotBeMetFilters {\nGlobal::Property name;\nGlobal::Property deadline;\n};\nstruct JobDeadlineCannotBeMetEvent {\nstring eventSubject;\nGlobal::TimeStamp eventTimeStamp;\nJobDeadlineCannotBeMetFilters eventFilterData;\nGlobal::Properties eventNews;\nJob aJob;\n};\nconst string JobDeadlineChangedSubject =\n\u201c/JobSupervision/Job/DeadlineChanged\u201d;\nstruct JobDeadlineChangedFilters {\nGlobal::Property name;\nGlobal::Property previousDeadline;"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200050\nGlobal::Property newDeadline;\n};\nstruct JobDeadlineChangedEvent {\nstring eventSubject;\nGlobal::TimeStamp eventTimeStamp;\nJobDeadlineChangedFilters eventFilterData;\nGlobal::Properties eventNews;\nJob aJob;\n};\nexception InvalidPropertyNameSignal {};\nexception PropertyNotFoundSignal {};\nexception UnsupportedPropertySignal {};\nexception ReadOnlyPropertySignal {};\nJobRequestor getJobRequestor ()\nraises (Global::FrameworkErrorSignal);\nGlobal::Property getJobProperty (\nin Global::PropertyName aPropertyName)\nraises (Global::FrameworkErrorSignal,\nInvalidPropertyNameSignal,\nPropertyNotFoundSignal);\nvoid setJobProperty (\nin Global::Property aProperty)\nraises (Global::FrameworkErrorSignal,\nGlobal::SetValueOutOfRangeSignal,\nInvalidPropertyNameSignal,\nUnsupportedPropertySignal,\nReadOnlyPropertySignal);\nboolean areJobResultsAvailable()\nraises( Global::FrameworkErrorSignal);\nJobSupervisor::Results getJobResults()\nraises( Global::FrameworkErrorSignal);\nvoid makePaused ( )\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nvoid makeExecuting ( )\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nvoid makeCanceled ( )\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nvoid makeStopped ( )\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nvoid makeInService ( )\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nvoid makeAborted ( )\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nboolean isAborting ( )\nraises (Global::FrameworkErrorSignal);\nboolean isAborted ( )"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200051\nraises (Global::FrameworkErrorSignal);\nboolean isActive ( )\nraises (Global::FrameworkErrorSignal);\nboolean isCanceled ( )\nraises (Global::FrameworkErrorSignal);\nboolean isCompleted ( )\nraises (Global::FrameworkErrorSignal);\nboolean isExecuting ( )\nraises (Global::FrameworkErrorSignal);\nboolean isFinished ( )\nraises (Global::FrameworkErrorSignal);\nboolean isPausing ( )\nraises (Global::FrameworkErrorSignal);\nboolean isPaused ( )\nraises (Global::FrameworkErrorSignal);\nboolean isQueued ( )\nraises (Global::FrameworkErrorSignal);\nboolean isStopping ( )\nraises (Global::FrameworkErrorSignal);\nboolean isStopped ( )\nraises (Global::FrameworkErrorSignal);\nGlobal::Duration timeRemaining ( )\nraises (Global::FrameworkErrorSignal);\n}; // Job\ninterface JobRequestor {\nvoid informJobStateChange (\nin Job aJob,\nin Job::JobState oldState,\nin Job::JobState newState)\nraises (Global::FrameworkErrorSignal);\n}; // JobRequestor\n}; // module AbstractIF\n#endif // ",(0,o.yg)("em",{parentName:"p"},"CIMFW_ABSTRACT_IF"),"\n#ifndef ",(0,o.yg)("em",{parentName:"p"},"CIMFW_FACTORY_OPERATIONS"),"\n#define ",(0,o.yg)("em",{parentName:"p"},"CIMFW_FACTORY_OPERATIONS"),"\nmodule FactoryOperations {\ninterface ComponentManager;\ninterface Area;\ntypedef sequence ComponentManager ComponentManagerSequence;\ntypedef sequence Area AreaSequence;\nexception AreaNotFoundSignal {Area requestedArea;};\nexception AreaDuplicateSignal { };\nexception AreaNotAssignedSignal { };\nexception AreaRemovalFailedSignal { };"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200052\ninterface MESFactory : AbstractIF::Resource {\nconst string MESFactoryStateChangedSubject =\n\u201c/Factory/MESFactory/StateChanged\u201d;\nenum MESFactoryState { FactoryUndefined,\nFactoryStartingUp,\nFactoryOperating,\nFactoryGoingToStandby,\nFactoryStandby,\nFactoryShuttingDownImmediately,\nFactoryShuttingDownNormally,\nFactoryOff };\nstruct MESFactoryStateChangedFilters {\nGlobal::Property name;\nGlobal::Property previousState;\nGlobal::Property newState;\n};\nstruct MESFactoryStateChangedEvent {\nstring eventSubject;\nGlobal::TimeStamp eventTimeStamp;\nMESFactoryStateChangedFilters eventFilterData;\nGlobal::Properties eventNews;\nMESFactory aMESFactory;\n};\nstruct RegistrationChangedFilters {\nGlobal::Property MESFactoryName;\nGlobal::Property componentManagerName;\nGlobal::Property newState;\n};\nstruct ComponentManagerRegistrationChangedEvent {\nstring eventSubject;\nGlobal::TimeStamp eventTimeStamp;\nRegistrationChangedFilters eventFilterData;\nGlobal::Properties eventNews;\nMESFactory aMESFactory;\nComponentManager aComponentManager;\n};\nArea addArea (in Area anArea)\nraises (AreaDuplicateSignal,\nGlobal::FrameworkErrorSignal);\nArea removeArea (in Area anArea)\nraises (Global::FrameworkErrorSignal,\nAreaRemovalFailedSignal,\nAreaNotAssignedSignal);\nAreaSequence allAreas ( )\nraises (Global::FrameworkErrorSignal);\nEquipmentTracking::MachineSequence allMachines ( )\nraises (Global::FrameworkErrorSignal);\nComponentManagerSequence allComponentManagers ( )\nraises (Global::FrameworkErrorSignal);\nvoid informComponentManagerIsOperating (in ComponentManager\naComponentManager)\nraises (Global::FrameworkErrorSignal);\nvoid informComponentManagerIsStopped (in ComponentManager\naComponentManager)\nraises (Global::FrameworkErrorSignal);"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200053\nvoid makeStartingUp ( )\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nvoid makeOperating ( )\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nvoid makeStandby ( )\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nvoid makeShuttingDownNormaly ( )\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nvoid makeShuttingDownImmediately ( )\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nvoid makeOff ( )\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nboolean isOff ( )\nraises (Global::FrameworkErrorSignal);\nboolean isStartingUp ( )\nraises (Global::FrameworkErrorSignal);\nboolean isOperating ( )\nraises (Global::FrameworkErrorSignal);\nboolean isShuttingDownNormaly ( )\nraises (Global::FrameworkErrorSignal);\nboolean isShuttingDownImmediately ( )\nraises (Global::FrameworkErrorSignal);\nboolean isGoingToStandby ( )\nraises (Global::FrameworkErrorSignal);\nboolean isStandby ( )\nraises (Global::FrameworkErrorSignal);\n}; // MESFactory\ninterface Area : AbstractIF::OwnedEntity {\nconst string AreaConfigurationChangedSubject =\n\u201c/Factory/Area/AreaConfigurationChanged\u201d;\nenum AreaChangeType {\nMachinesChanged,\nPersonsChanged,\nSubAreaChanged };\nstruct AreaConfigurationChangedFilters {\nGlobal::Property name;\nGlobal::Property changeType;\n};\nstruct AreaConfigurationChangedEvent {\nstring eventSubject;\nGlobal::TimeStamp eventTimeStamp;\nAreaConfigurationChangedFilters eventFilterData;\nGlobal::Properties eventNews;\nArea anArea;\n};"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200054\nArea getSuperArea ( )\nraises (Global::FrameworkErrorSignal);\nstring getAreaIdentifier ( )\nraises (Global::FrameworkErrorSignal);\nArea addSubArea (in Area anArea)\nraises (Global::FrameworkErrorSignal,\nAreaDuplicateSignal);\nvoid removeSubArea (in Area anArea)\nraises (Global::FrameworkErrorSignal,\nAreaNotAssignedSignal,\nAreaRemovalFailedSignal);\nvoid setAreaIdentifier (in string identifier)\nraises (Global::FrameworkErrorSignal,\nGlobal::DuplicateIdentifierSignal);\nAreaSequence subAreas ( )\nraises (Global::FrameworkErrorSignal);\nEquipmentTracking::Machine addMachine (in\nEquipmentTracking::Machine aMachine)\nraises (Global::FrameworkErrorSignal,\nEquipmentTracking::MachineDuplicateSignal);\nvoid removeMachine (\nin EquipmentTracking::Machine aMachine)\nraises (Global::FrameworkErrorSignal,\nEquipmentTracking::MachineNotAssignedSignal,\nEquipmentTracking::MachineRemovalFailedSignal);\nLabor::Person addPerson (\nin Labor::Person aPerson)\nraises (Global::FrameworkErrorSignal,\nLabor::PersonDuplicateSignal);\nvoid removePerson (\nin Labor::Person aPerson)\nraises (Global::FrameworkErrorSignal,\nLabor::PersonNotAssignedSignal,\nLabor::PersonRemovalFailedSignal);\nEquipmentTracking::MachineSequence machines ( )\nraises (Global::FrameworkErrorSignal);\nLabor::PersonSequence persons ( )\nraises (Global::FrameworkErrorSignal);\n}; // Area\ninterface ComponentManager : AbstractIF::Resource {\nconst string ComponentManagerStateChangedSubject =\n\u201c/FactoryOperations/ComponentManager/ComponentManagerStateChang\ned\u201d;\nenum ComponentManagerState { ComponentManagerUndefined,\nComponentManagerStopped,\nComponentManagerStartingUp,\nComponentManagerShuttingDown};\nstruct ComponentManagerStateChangedFilters {\nGlobal::Property name;\nGlobal::Property previousState;\nGlobal::Property newState;\n};\nstruct ComponentManagerStateChangedEvent {"),(0,o.yg)("p",null,"SEMI E97-0200A \xa9 SEMI 200055\nstring eventSubject;\nGlobal::TimeStamp eventTimeStamp;\nComponentManagerStateChangedFilters eventFilterData;\nGlobal::Properties eventNews;\nComponentManager aComponentManager;\n};\nconst string ComponentManagerRegistrationChangedSubject =\n\u201c/Factory/ComponentManager/ComponentManagerRegistrationChanged\u201d\n;\nenum RegistrationState {\nRegistrationUndefined,\nRegistered,\nNotRegistered };\nvoid makeRegistered (in MESFactory aFactory)\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nvoid makeNotRegistered (in MESFactory aFactory)\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nvoid makeStartingUp ( )\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nvoid makeShuttingDown ( )\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nvoid makeStopped ( )\nraises (Global::FrameworkErrorSignal,\nGlobal::InvalidStateTransitionSignal);\nboolean isStopped ( )\nraises (Global::FrameworkErrorSignal);\nboolean isStartingUp ( )\nraises (Global::FrameworkErrorSignal);\nboolean isShuttingDown ( )\nraises (Global::FrameworkErrorSignal);\nboolean isNotRegistered ( )\nraises (Global::FrameworkErrorSignal);\nboolean isRegistered ( )\nraises (Global::FrameworkErrorSignal);\n}; // ComponentManager\n}; // module FactoryOperations\n#endif // ",(0,o.yg)("em",{parentName:"p"},"CIMFW_FACTORY_OPERATIONS"),"\n}; // module CIMFW\nNOTICE: SEMI makes no warranties or representations as to the suitability of the standard set forth herein for any\nparticular  application.    The  determination  of  the  suitability  of  the  standard  is  solely  the  responsibility  of  the  user.\nUsers  are  cautioned  to  refer  to  manufacturer\u2019s  instructions,  product  labels,  product  data  sheets,  and  other  relevant\nliterature respecting any materials mentioned herein.  These standards are subject to change without notice.\nThe  user\u2019s  attention  is  called  to  the  possibility  that  compliance  with  this  standard  may  require  use  of  copyrighted\nmaterial  or  of  an  invention  covered  by  patent  rights.    By  publication  of  this  standard,  SEMI  takes  no  position\nrespecting  the  validity  of  any  patent  rights  or  copyrights  asserted  in  connection  with  any  item  mentioned  in  this\nstandard.  Users of this standard are expressly advised that determination of any such patent rights or copyrights, and\nthe risk of infringement of such rights, are entirely their own responsibility.\nCopyright   by   SEMI\xae   (Semiconductor   Equipment   and   Materials\nInternational), 3081 Zanker Road, San Jose, CA 95134. Reproduction o\nf\nthe  contents  in  whole  or  in  part  is  forbidden  without  express  written\nconsent of SEMI."),(0,o.yg)("p",null,"SEMI E98-1102 \xa9 SEMI 2000, 2002 1\nSEMI E98-1102\nPROVISIONAL STANDARD FOR THE OBJECT- BASED EQUIPMENT\nMODEL (OBEM)\nThis provisional standard was technically approved by the Global Information and Control Committee and is\nthe  direct  responsibility  of  the  North  American  Information  and  Control  Committee.    Current  edition\napproved by the North American Regional Standards Committee on November 27, 2001.  Initially available\nat  ",(0,o.yg)("a",{parentName:"p",href:"http://www.semi.org"},"www.semi.org"),"  December  2001;  to  be  published  March  2002.    Originally  published  February  2000;\npreviously published March 2002.\nNOTICE:  The designation of SEMI E98 was updated during the 1102 publishing cycle to reflect revisions to\nSEMI E98.1.\n1  Purpose"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"1  Purposes  of  the  Object-Based  Equipment  Model\ninclude the following:\n\u2022 Define  a  standard  model  for  interfacing  to  multi-\nprocess equipment and other complex equipment.\n\u2022 Define   standard   equipment   components   so   that\ncommunications  can  \u201cdiscuss\u201d  component-related\nissues.\n\u2022 Provide  an  equipment  model  that  can  be  easily\nintegrated    with    SEMI    E81    CIM    Framework\nsystems    by    connecting    an    OBEM-compliant\nequipment to a Machine object."),(0,o.yg)("li",{parentName:"ol"},"2  The purpose of the Object-Based Equipment Model\n(OBEM)  standard  is  to  provide  definitions,  services,\nand behavior, as seen through communications with the\nfactory,  for  the  common  types  of  physical  and  logical\nobjects  of  which  equipment  is  typically  composed,\nincluding   the   equipment   itself.      The   definition   of\nstandardized  objects  allows  the  equipment  to  describe\nits  makeup  to  the  factory  and  provides  the  factory\nvisibility into the equipment.\n2  Scope"),(0,o.yg)("li",{parentName:"ol"},"1    This  is  a  provisional  standard  that  defines  con-\ncepts,  behavior,  and  services  to  support  the  integration\nof  production  equipment  within  a  semiconductor  fac-\ntory.    The  scope  of  this  standard  includes  all  semicon-\nductor manufacturing equipment that provides an inter-\nface  to  the  factory  host  systems.    Some  services  may\nnot be applicable to some material handling systems."),(0,o.yg)("li",{parentName:"ol"},"2    Sections  that  must  be  completed  in  order  for  the\nprovisional status of OBEM to be removed include the\nfollowing:")),(0,o.yg)("h1",{id:"1"},"1"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"Section  11.2 \u2014 Access Management")),(0,o.yg)("h1",{id:"2"},"2"),(0,o.yg)("ol",{start:2},(0,o.yg)("li",{parentName:"ol"},"Section 14 \u2014 OBEM Compliance"),(0,o.yg)("li",{parentName:"ol"},"3  Detail standards will also be added in the future to\nspecify OBEM mappings to different protocols such as\nSECS-II, CORBA IDL, and DCOM."),(0,o.yg)("li",{parentName:"ol"},"4    This  standard  does  not  purport  to  address  safety\nissues,   if   any,   associated   with   its   use.      It   is   the\nresponsibility  of  the  users  of  this  standard  to  establish\nappropriate  safety  and  health  practices  and  determine\nthe applicability of regulatory limitations prior to use.\n3  Limitations"),(0,o.yg)("li",{parentName:"ol"},"1      This   standard   is   not   intended   to   define   the\nattributes,  behavior,  or  services  of  systems  that  are\naggregates of equipment, such as cells."),(0,o.yg)("li",{parentName:"ol"},"2      The   decomposition   of   equipment   into   different\nobjects is chosen by the equipment supplier to map the\nphysical  equipment  to  the  characteristics  of  the  objects\ndefined by this standard."),(0,o.yg)("li",{parentName:"ol"},"3      Object-oriented   technology   is   not   required   for\nimplementations  of  OBEM.    However,  object-oriented\nimplementations should be compatible with OBEM.\n4  Referenced Standards"),(0,o.yg)("li",{parentName:"ol"},"1    This  section  lists  documents  referenced  by  this\nstandard."),(0,o.yg)("li",{parentName:"ol"},"2  SEMI Standards\nSEMI   E5   \u2014   SEMI   Equipment   Communications\nStandard 2 Message Content (SECS-II)\nSEMI E10 \u2014 Standard for Definition and Measurement\nof      Equipment      Reliability,      Availability,      and\nMaintainability (RAM)\nSEMI E15 \u2014 Specification for Tool Load Port\nSEMI  E15.1  \u2014  Provisional  Specification  for  300  mm\nTool Load Port\nSEMI E30 \u2014 Generic Model for Communications and\nControl of Manufacturing Equipment (GEM)\nSEMI  E39  \u2014  Object  Services  Standard:    Concepts,\nBehavior, and Services")),(0,o.yg)("p",null,"SEMI E98-1102 \xa9 SEMI 2000, 2002 2\nSEMI E40 \u2014 Standard for Processing Management\nSEMI E41 \u2014 Exception Management (EM) Standard\nSEMI     E42     \u2014     Recipe     Management     Standard:\nConcepts, Behavior, and Message Services\nSEMI E53 \u2014 Event Reporting\nSEMI E54 \u2014 Sensor/Actuator Network Standard\nSEMI  E58  \u2014  Automated  Reliability,  Availability,  and\nMaintainability      Standard      (ARAMS):      Concepts,\nBehavior, and Services\nSEMI   E81   \u2014   Provisional   Specification   for   CIM\nFramework Domain Architecture\nSEMI  E87  \u2014  Provisional  Specification  for  Carrier\nManagement (CMS)\nSEMI E90 \u2014 Specification for Substrate Tracking\nSEMI E94 \u2014 Provisional Specification for Control Job\nManagement\nNOTE 1: As listed or revised, all documents cited shall be the\nlatest publications of adopted standards.\n5  Terminology\n5. 1  Abbreviations and Acronyms\n5. 1.1  AGV \u2014 Automated Guided Vehicle\n5. 1.2  AMHS \u2014 Automated Material Handling System\n5. 1.3  APC \u2014 Advanced Process Control\n5. 1.4  ARAMS  \u2014  Automated  Reliability,  Availability,\nand Maintainability Standard (SEMI E58)\n5. 1.5  CIM \u2014 Computer Integrated Manufacturing\n5. 1.6  CJM \u2014 Control Job Management\n5. 1.7  CMS \u2014 Carrier Management Standard\n5. 1.8  FDC \u2014 Fault Detection Control\n5. 1.9  FIMS   \u2014   Front-Opening   Interface   Mechanical\nStandard (reference SEMI E62)\n5. 1.10  FOUP \u2014 Front-Opening Unified Pod\n5. 1.11  FPD \u2014 Flat Panel Display\n5. 1.12  OBEM \u2014 Object-Based Equipment Model\n5. 1.13  OSS \u2014 Object Services Standard (SEMI E39)\n5. 1.14  PGV \u2014 Personal Guided Vehicle\n5. 1.15  R2R \u2014 Run-to-Run Control\n5. 1.16  RMS  \u2014  Recipe  Management  Standard  (SEMI\nE42)\n5. 1.17  SMIF  \u2014  Standard  Mechanical  Interface  (SEMI\nE19)\n5. 1.18  STS \u2014 Specification for Substrate Tracking"),(0,o.yg)("p",null,"SEMI E98-1102 \xa9 SEMI 2000, 2002 3\n5. 2  Definitions\n5. 2.1  abstract object type \u2014 an object supertype that is\nnot  instantiated  directly  but  only  through  one  of  its\nsubtypes.\n5. 2.2  actuator  \u2014  an  analog  or  digital  output  device\nthat   is   used   to   affect   changes   in   the   physical\nenvironment.  Examples of actuators include mass flow\ncontrollers (MFCs) and open/closed valves.\n5. 2.3   advanced  process  control  (APC)  \u2014  techniques\ncovering  both  feedforward  and  feedback  control  and\nautomated    fault    detection,    applied    both    by    the\nequipment (in situ) and by the factory (ex situ).\n5. 2.4  Automated Material Handling System (AMHS) \u2014\na  factory  system  used  to  transport  and  store  carriers.\nAMHS   has   two   major   types   of   components:   an\nautomated  transport  system  and  one  or  more  storage\nsystems (stockers).\n5. 2.5  automated transport system \u2014 the component of\nAMHS   used   to   transport   carriers   between   stockers\nand/or production equipment.\n5. 2.6  carrier  \u2014  a  container  with  one  or  more  fixed\npositions at which material may be held.\nNOTE  2:  Positions  within  a  carrier  may  be  considered  as\nmaterial locations owned by the carrier.\n5. 2.7  clock \u2014 a device that is used to provide real-time\ndate and time information.\n5. 2.8  container  \u2014  a  durable  that  is  used  to  hold  other\nmaterial,   including   other   containers,   for   transport,\nstorage,   or   shipping.      Types   of   containers   include\ncarriers and boxes.\n5. 2.9   dry  run  (mechanical  dry  run)  \u2014  a  complete\nequipment  cycle  that  allows  the  material  handling  and\nsoftware  capabilities  of  the  equipment  to  be  exercised\nwithout  requiring  full  facilities  hookups  and  without\nchanging  the  physical  state  of  the  wafer.    Environ-\nmental   control   subsystem   (e.g.,   vacuum,   nitrogen\npurge,  particle  detection)  should  not  be  affected  by  a\ndry run, and process consumables are not used.\n5. 2.10  durable \u2014 a  type  of  material  used  to  facilitate\nmanufacturing   but   not   normally   consumed   in   the\nprocess   that   is   removable,   reusable,   and   trackable.\nExamples include containers, reticles, and pellicles.\n5. 2.11  environmental   subsystem   \u2014   a   subsystem   of\nequipment    with    the    purpose    of    monitoring    or\nmaintaining    one    or    more    specific    environmental\nconditions   or   used   to   handle   product   or   durables.\nEnvironmental  subsystems  include  vacuum  systems,\nparticle detection systems, and nitrogen purge systems.\n5. 2.12  equipment \u2014  equipment  (manufacturing  equip-\nment) performs one or more of the following manufac-\nturing   functions   in   the   factory:   material   process,\nmaterial  transport,  or  material  storage.    Equipment  is\nmade  up  of  various  parts:  modules,  subsystems  and\nsensors/actuators.  Equipment  has  at  least  one  carrier\nport.  Equipment communicates with the factory.\n5. 2.13  equipment   element   \u2014   a   component   of   the\nequipment  that  behaves  as  a  unit,  performs  work,  and\nmay or may not contain lower-level components.\n5. 2.14  equipment    module    (module)    \u2014    a    major\ncomponent  of  equipment  that  contains  at  least  one\nmaterial  location  and  performs  some  task  on  material.\nEquipment  modules  may  be  aggregates  of  equipment\nsubsystems, i/o devices, and other modules.\n5. 2.15  fault  detection  \u2014  analysis  of  data  for  early\ndetection  of  process  faults  before  yield  loss  becomes\nsignificant.\n5. 2.16  Front-Opening Unified Pod (FOUP) \u2014 a front-\nopening   pod   with   an   integrated   (non-removable)\ncassette.\n5. 2.17  implementation  \u2014  the  internal  view  of  a  type,\nclass,  or  instance,  including  any  non-public  properties\nand  behavior.    The  specific  code  and  functionality  that\nimplements an interface. (See SEMI E81.)\n5. 2.18  interface \u2014 the external view of an object type,\nclass,  or  object  that  defines  its  public  properties  and\nservices  without  regard  to  the  internal  structure  and\ninternal behavior.  (See also SEMI E81.)\n5. 2.19  interface  inheritance  \u2014  the  construction  of  an\ninterface  by  incremental  modification  of  other  interfa-\nces (see implementation inheritance). (See SEMI E81.)\nOBEM    specifies    interface    inheritance    but    not\nimplementation inheritance.\n5. 2.20  I/O  device  \u2014  a  general  term  for  any  type  of\nsensor   or   actuator   or   aggregation   of   sensor   and/or\nactuator.\n5. 2.21  linked equipment \u2014 two or more equipment that\nare physically and logically connected and function as a\nsingle  installation  of  equipment.    In  this  case,  the\nindividual  component  equipment  are  modeled  as  high-\nlevel modules of the linked equipment.\n5. 2.22  load port \u2014 The physical interface provided for\nthe  exchange  of  carriers  with  an  agent  of  the  factory\n(operator   or   automated   material   handling   system).\n(Reference SEMI E15.)\n5. 2.23   Manufacturing  Execution  System  (MES)  \u2014  the\nfactory  system  responsible  for  managing  the  manufac-\nturing process, including logistics and process flow."),(0,o.yg)("p",null,"SEMI E98-1102 \xa9 SEMI 2000, 2002 4\n5. 2.24  material \u2014 (1) any material used in, or required\nby, the manufacturing process.  Material is classified as\nconsumable,  durable,  or  product.    (2)  an  abstraction  of\nthe  various  types  of  things  used  during  manufacturing,\nsuch  as  wafers,  carriers,  and  chemicals,  which  require\nsome management.\n5. 2.25  material  location  \u2014  a  reference  to  a  place\nwithin  the  equipment  or  an  equipment  component  that\ncan hold material, such as the top surface of an indexer\nor  substrate  chuck  or  the  end  effector  of  a  substrate\nhandler.\n5. 2.26  measured   value   \u2014   a   value   representing   a\nmeasurement,  with  a  numerical  value,  measurement\nunits, and a valid range.\n5. 2.27  measurement  equipment  \u2014  equipment  whose\nintended  function  is  to  measure  or  inspect  the  product\nand to report results.  Measurement of the product is the\nfactory\u2019s    means    of    gaining    feedback    on    the\nmanufacturing process.\n5. 2.28   Object-Based  Equipment  Model  \u2014  a  model  of\nequipment,  its  components,  behaviors,  attributes,  and\nservices, as defined by this document.\n5. 2.29  object  type  \u2014  a  declaration  (specification)  that\ndescribes  the  common  properties  and  behavior  for  a\ncollection  of  objects.    Types  classify  objects  according\nto    a    common    interface;    classes    classify    objects\naccording   to   a   common   implementation.   (See   also\nSEMI E39 and E81.)\n5. 2.30  object  specifier  \u2014  designates  a  logical  path\npointing  to  a  specific  instance  of  an  object  through  a\nhierarchy of owners.  See SEMI E39.\n5. 2.31   Personal  Guided  Vehicle  (PGV)  \u2014  a  manually\nguided  and  operated  vehicle  capable  of  placing  and\nremoving carriers to and from a carrier port.\n5. 2.32  pod  \u2014  as  used  in  this  document,  a  container\nproviding  environmental  control,  such  as  a  SMIF  or\nFIMS pod\n1\n.\n5. 2.33  production equipment \u2014 process equipment and\nmeasurement equipment.\n5. 2.34  process  durable  \u2014  a  specialized  durable  used\nby  process  equipment  and  specified by the user as part\nof the process, such as a reticle or burin-in board.\n5. 2.35  process    equipment    \u2014    equipment    whose\nintended function is to process product, adding value to\nthe product.\n5. 2.36  product  \u2014  (1)  from  the  equipment\u2019s  perspec-\ntive,  product  is  a  synonym  for  substrate,  and  includes"),(0,o.yg)("p",null,"1 The term \u201cpod\u201d was originally defined as a bottom-opening pod\nwith a SMIF interface.\nnon-product substrates such as test substrates and send-\nahead   substrates;   (2)   from   the   factory   perspective,\nproduct  is  the  material  being  processed  and  produced\nby the factory.\n5. 2.37  run-to-run  control  \u2014  techniques  for  varying\nsettings in one run based on analysis of either incoming\nproduct (feed-forward) or product from an earlier run.\n5. 2.38  sensor \u2014 a component that responds to changes\nin  the  physical  environment  and  provides  an  analog  or\ndigital input value.\n5. 2.39  sensor/actuator device \u2014 a device consisting of\none  or  more  sensors  and/or  actuators  on  the  physical\ntool.  See SEMI E54 for a precise definition of \u201csensor\nor   actuator\u201d   and   for   a   description   of   the   internal\nstructure   of   an   sensor/actuator   network   Common\nDevice Model definition.\n5. 2.40  setup  \u2014  1.  (verb)  the  performance  of  one  or\nmore steps that puts the equipment into a known state in\nwhich  it  is  ready  to  perform  a  specific  process;  2.\n(noun)  the  state  of  the  equipment  once  it  has  been\nsetup.\n5. 2.41  standardized object \u2014 an object that is formally\ndefined  and  compliant  to  SEMI  E39,  Object  Services\nStandard (reference SEMI E42).\n5. 2.42  storage    equipment    (stocker)    \u2014    equipment\nwhose intended function is primarily to provide storage,\neither short-term or long-term, for carriers.\n5. 2.43  subassembly  \u2014  a  component  of  equipment  that\nprovides some limited functionality.\n5. 2.44  substrate  \u2014  basic  unit  of  material  on  which\nwork  is  performed  to  create  a  product.    Examples\ninclude  wafers,  die,  plates  used  for  masks,  flat  panels,\ncircuit boards, and leadframes.\n5. 2.45  subsystem   \u2014   a   subsystem   is   an   intelligent\naggregate that behaves as a unit.  A subsystem is made\nup   of   sensors   and/or   actuators   and   may   contain\nmechanical  assemblies.    Subsystems  may  be  shared  by\nmultiple modules.\n5. 2.46  subtype \u2014  an  object  type  that  is  based  on\n(derived  from)  another  type  and  adds  some  specializa-\ntion  or  overrides  some  properties  or  services.  The  type\nfrom which the subtype is derived is the supertype. For\nadditional   detail,   see   SEMI   E39,   Object   Services\nStandard.\n5. 2.47  supertype  \u2014  an  object  type  which  is  used  as  a\nbasis  from  which  specializations  are  derived.    The\nderived types are called subtypes.  For additional detail,\nsee SEMI E39.\n5. 2.48  transport    equipment    \u2014    equipment    whose\nintended  function  is  primarily  to  move  material  from"),(0,o.yg)("p",null,"SEMI E98-1102 \xa9 SEMI 2000, 2002 5\none   location   in   the   factory   to   another   location.\nTransport   equipment   may   also   provide   short-term\nstorage for material.  (See also AMHS.)\n5. 2.49  virtual sensor (synthetic sensor, derived sensor)\n\u2014  one  or  more  calculated  measured  values  that  are\nbased  on  one  or  more  sensor  readings.    This  may\ninclude results based on neural nets, statistical analysis,\netc. or may be based on a single sensor value.\n5. 2.50  work  \u2014  a  group  of  one  or  more  substrates  that\nundergo processing in a factory. Something that may be\nwork  in  one  kind  of  factory,  such  as  reticles  and\nleadframes,  may  have  a  different  role  in  other  types  of\nfactories.  Work includes, but is not limited to, material\nintended  as  product.    For  example,  it  may  include\nproduct substrates, test substrates, and filler substrates.\n5. 2.50.1    From  the  point  of  view  of  the  equipment,\nwork   is   either   new   (processing   has   not   started),\ncompleted (all intended processing has been performed,\nterminated,  or  aborted,  including  rejected  and  resorted\nwork,  and  no  further  processing  is  to  be  done)  or\nincomplete (work in progress, on hold).\n6  Conventions\n6. 1    This  section  defines  the  conventions  followed  by\nthis document.\n6. 2  Object Conventions \u2014 This document conforms to\nthe  conventions  for  objects  established  by  SEMI  E39,\nincluding  object  diagrams,  object  terminology,  and  re-\nquirements for standardized objects.  Accordingly, not-\nation is based on Object Modeling Technique (OMT) as\ndescribed in Object Oriented Modeling Design\n.\n2"),(0,o.yg)("ol",{start:6},(0,o.yg)("li",{parentName:"ol"},"2.1  Formal Name of an Object \u2014 The text capitalizes\nformal  object  name  references.    Similar  to  the  way\ncapitalization is normally used when discussing entities.\nWhen  describing  something  in  the  general  (like  cities)\nlower  case  is  used,  but  when  a  specific  entity  is  of\ninterest   (New   York   City),   then   first   letters   are\ncapitalized."),(0,o.yg)("li",{parentName:"ol"},"2.2  Components of Complex Attributes \u2014 The names\nof  object  attributes  defined  in  tables  are  left-justified.\nThe individual elements of complex attributes are right-\njustified  in  order  of  appearance  below  the  complex\nattribute.")),(0,o.yg)("p",null,"2 Rumbaugh, James, et al, Object Oriented Modeling Design,\nPrentice Hall, Englewood Cliffs, NJ, c1991."),(0,o.yg)("p",null,"SEMI E98-1102 \xa9 SEMI 2000, 2002 6\n6. 2.3   Names  of  OBEM  Objects  \u2014  The  names  of  abstract  object  types  start  with  the  word  \u201cAbstract\u201d  and  are  not\nintended  to  be  directly  implemented.    All  other  objects  defined  in  OBEM  are  concrete  types  that  may  be  directly\nimplemented.\n6. 3  State Model Conventions\n6. 3.1  This document uses the Harel state chart convention for describing dynamic operation of defined objects.  The\noutline of this convention is described in an attachment of SEMI E30.  The official definition of this convention is\ndescribed in \u201cState charts: A Visual Formalism for Complex Systems\u201d\n3\n.\n6. 3.2    The  Harel  convention  has  not  the  concept  of  state  models  of  \u201ccreation\u201d  and  \u201cextinction\u201d  for  expressing  a\ntemporary entity.  The \u201cjob\u201d described in this document is such an entity, and a copy of the same state model is used\nfor  an  independent  job  newly  created.    In  this  document,  a  circle  with  a  black  circle  inside  is  used  for  expressing\nextinction of an entity.  A filled black circle denotes the entry to the state model (the entity creation).\n6. 3.3  Transition tables are provided in conjunction with the state diagrams to explicitly describe the nature of each\nstate  transition.    A  transition  table  contains  columns  for  Transition  number,  Previous  State,  Trigger,  New  State,\nActions,  and  Comments.    The  \u201ctrigger\u201d  (column  3)  for  the  transition  occurs  while  in  the  \u201cprevious\u201d  state.    The\n\u201cactions\u201d (column 5) includes a combination of:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"Actions taken upon exit of the previous state."),(0,o.yg)("li",{parentName:"ol"},"Actions taken upon entry of the new state.")),(0,o.yg)("h1",{id:"3"},"3"),(0,o.yg)("ol",{start:3},(0,o.yg)("li",{parentName:"ol"},"Actions taken which are most closely associated with the transition."),(0,o.yg)("li",{parentName:"ol"},"3.3.1  No differentiation is made between these cases.\nNum Previous State Trigger New State Actions Comments")),(0,o.yg)("ol",{start:6},(0,o.yg)("li",{parentName:"ol"},"4  Service Message  Representation  \u2014  Services  are  functions  or  methods  that  may  be  provided  by  either  the\nequipment or the host.  A service message may be either a request message, which always requires a response, or a\nnotification message, that does not require a response."),(0,o.yg)("li",{parentName:"ol"},"4.1  Service Definition"),(0,o.yg)("li",{parentName:"ol"},"4.1.1  A service definition table defines the specific set of messages for a given service resource, as shown in the\nfollowing table:\nMessage Service Name                          Type                          Description")),(0,o.yg)("ol",{start:6},(0,o.yg)("li",{parentName:"ol"},"4.1.2  Type can be either \u201cN\u201d = Notification or \u201cR\u201d = Request & Response."),(0,o.yg)("li",{parentName:"ol"},"4.1.3  Notification type messages are initiated by the service provider (e.g., the equipment) and the provider does\nnot expect to get a response from the service user.  Request messages are initiated by a service user (e.g., the host).\nRequest  messages  ask  for  data  or  an  activity  from  the  provider.    Request  messages  expect  a  specific  response\nmessage (no presumption on the message content)."),(0,o.yg)("li",{parentName:"ol"},"4.2  Service Parameter Dictionary"),(0,o.yg)("li",{parentName:"ol"},"4.2.1  A  service  parameter  dictionary  table  defines  the  description,  format  and  its  possible  value  for  parameters\nused by services, as shown in the following table:\nParameter Name Description Format: Possible Value")),(0,o.yg)("ol",{start:6},(0,o.yg)("li",{parentName:"ol"},"4.2.2  A row is provided in the table for each parameter of a service.")),(0,o.yg)("p",null,"3 D. Harel, \u201cState charts: A Visual Formalism for Complex Systems\u201d, Science of Computer Programming 8, 1987."),(0,o.yg)("p",null,"SEMI E98-1102 \xa9 SEMI 2000, 2002 7\n6. 4.3  Service Message Definition\n6. 4.3.1  A service message definition table defines the parameters used in a service, as shown in the following table:\nParameter                                         Req/Ind                                         Res/Cnf                                         Comment"),(0,o.yg)("ol",{start:6},(0,o.yg)("li",{parentName:"ol"},"4.3.2    The  columns  labeled  REQ/IND  and  RSP/CNF  link  the  parameters  to  the  direction  of  the  message.  The\nmessage sent by the initiator is called the \u201cRequest\u201d. The receiver terms this message the \u201cIndication\u201d or the request.\nThe receiver may then send a \u201cResponse\u201d which the original sender terms the \u201cConfirmation\u201d."),(0,o.yg)("li",{parentName:"ol"},"4.3.3    The  following  codes  appear  in  the  REQ/IND  and  RSP/CNF  columns  and  are  used  in  the  definition  of  the\nparameters (eg., how each parameter is used in each direction):\nM Mandatory Parameter \u2014 Must be given a valid value.\nC Conditional Parameter \u2014 May be defined in some circumstances and undefined in others. Whether a value is\ngiven may be completely optional or may depend on the value of the other parameter.\nU           User-Defined           Parameter.")),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"The parameter is not used.\n= (For response only.) Indicates that the value of this parameter in the response must match that in the primary (if\ndefined).")),(0,o.yg)("ol",{start:6},(0,o.yg)("li",{parentName:"ol"},"5  OBEM Standard Structure"),(0,o.yg)("li",{parentName:"ol"},"5.1  The remaining part of this document is organized as follows:"),(0,o.yg)("li",{parentName:"ol"},"5.1.1  Section 7 contains background information to provide a context for the Object-Based Equipment Model."),(0,o.yg)("li",{parentName:"ol"},"5.1.2  Sections 8 provides an overview of two major views of the equipment: the functional view and the internal\ncomposition view."),(0,o.yg)("li",{parentName:"ol"},"5.1.3    Section  9  introduces  the  OBEM  object  model:  the  interface  inheritance  hierarchy  and  the  rules  of\naggregation that together form the foundation of the OBEM model of equipment."),(0,o.yg)("li",{parentName:"ol"},"5.1.4  Section 11 defines the requirements for the component objects within the equipment interface hierarchy: and\nother related objects of significance not defined elsewhere."),(0,o.yg)("li",{parentName:"ol"},"5.1.5  Section 12 defines the message services used in OBEM that are not defined in other standards."),(0,o.yg)("li",{parentName:"ol"},"5.1.6  Section 13 defines the services that are required of the user (factory system, remote access, and operator)."),(0,o.yg)("li",{parentName:"ol"},"5.1.7    Section  14  specifies  the  minimum  requirements  and  optional  capabilities  for  compliance  to  the  OBEM\nstandard."),(0,o.yg)("li",{parentName:"ol"},"5.1.8  Section 15 provides scenarios showing typical message flows during operation."),(0,o.yg)("li",{parentName:"ol"},"5.2  Additional sections are provided as related information: examples and additional material that are not part of\nthe  standard  itself.    These  include  models  for  linked  litho,  300  mm  equipment,  the  relationship  of  OBEM  and  the\nCIM Framework, and representations of date and time.\n7  Background"),(0,o.yg)("li",{parentName:"ol"},"1    Both  modern  manufacturing  processes  and  modern  manufacturing  equipment  are  increasingly  complex.    A\nsingle installation of equipment may have hundreds or thousands of sensors and actuators.  In order to manage this\ncomplexity,  better  methods  of  referencing  the  internal  components  of  equipment  are  needed.    Use  of  the  object\nparadigm provides a means for the equipment to describe its internal composition to the factory in a natural way."),(0,o.yg)("li",{parentName:"ol"},"2    Definition  of  standardized  objects  allows  the  factory  to  be  specific  about  its  requirements  and  its  need  for\ninformation.")),(0,o.yg)("p",null,"SEMI E98-1102 \xa9 SEMI 2000, 2002 8\n7. 3  Computer Manufacturing    Integration    Business\nGoals\n7. 3.1    The  intent  of  this  section  is  to  provide  a  context\nfor,  and  insight  into,  those  requirements  of  industries\nsuch  as  semiconductor  and  flat  panel  display  (FPD)\nmanufacturing  businesses  that  affect  the  object-based\nequipment model.\n7. 3.2   The   primary   purpose   of   computer   integrated\nmanufacturing   (CIM)   technologies   is   to   improve\nfactory   productivity.\n4\nOther   inter-related   secondary\nCIM business goals are listed below.\n\u2022 Maximize product yields (line/mechanical yield).\n\u2022 Maximize    device    yields    (electrical/functional\nyield).\n\u2022 Maximize     total     factory     product     substrate\nthroughput.\n\u2022 Increase  individual  equipment  product  substrate\nthroughput.\n\u2022 Reduce product variability.\n\u2022 Reduce process variability.\n\u2022 Optimize  ability  to  center  processes  in  a  \u201csweet\nspot\u201d.\n\u2022 Reduce the use of non-product substrates.\n\u2022 Reduced time to utilization for equipment (i.e., the\ntime   to   install,   qualify,   characterize   and   ramp\nproduction).\n\u2022 Increase  the  usability,  accuracy,  and  reliability  of\ndata used for metrics.\n\u2022 These  business  goals  can  be  met  by  addressing\ncertain concrete objectives, which are listed below.\n7. 4  OBEM Functional Objectives\n7. 4.1        OBEM    will    standardize    specific    functional\ncapabilities  to  be  implemented  on  semiconductor/FPD\nand   other   manufacturing   equipment,   providing   a\nhierarchical  view  of  equipment  for  effective  factory\nintegration.\n7. 4.2  The OBEM functional objectives are as follows:\n\u2022 Manage material into and through the equipment.\n\u2022 Manage  the  association  of  the  process  instructions\nwith the material."),(0,o.yg)("p",null,"4 For a more detailed discussion and list, see the Guidance and\nGuideline documents at\n",(0,o.yg)("a",{parentName:"p",href:"http://www.sematech.org/public/docubase/abstract/tech-30.htm"},"http://www.sematech.org/public/docubase/abstract/tech-30.htm"),"\n\u2022 Report  data  associated  with  the  equipment,  the\nprocess, and the material.\n\u2022 Facilitate equipment performance monitoring.\n7. 4.3    These  OBEM  functional  objectives,  individually\nand  collectively,  can  be  shown  to  directly  address  the\noverall business goals:\n7. 4.4      The   Object   Based   Model   objective   directly\naffects  the  ability  to  implement  most  of  the  other\nobjectives,  especially  in  the  case  of  highly  modular\nequipment.\n7. 4.5  Equipment performance monitoring has the effect\nof  improving  product  variability,  device  yield  and  can\nreduce  the  need  for  non-product  test  substrates.    It  can\nalso  provide  a  means  of  targeting  a  specific  process\nwindow   to   improve   device   characteristics   such   as\nspeed.\n7. 4.6        Management    of    the    association    of    process\ninstructions  with  the  material  can  reduce  scrap  due  to\nmisprocessing,   thus   improving   product   yield.   The\nmaterial    management    objectives    impact    on    the\nthroughput   of   individual   equipment   and   the   total\nfactory throughput.\n7. 5  Relevant  Factory  Environment  \u2014  Equipment  must\nsupport  a  variety  of  different  factory  environments.\nThis is necessary because factory business practices and\nfactory  configurations  vary  not  only  from  company  to\ncompany but also from one facility within a company to\nanother.    Items  will  be  added  to  this  section  as  their\nrelevance becomes apparent.\n7. 5.1  Material  Handling  Systems  \u2014  Material  may  be\nloaded and unloaded manually by a fab technician or it\nmay be loaded and unloaded using semi-automated and\nautomated   transport   systems.      Types   of   systems\ninclude:\n\u2022 Automated Guided Vehicles (AGV),\n\u2022 Personal Guided Vehicles (PGV),\n\u2022 Overhead   Transport   Systems   (OTS),   including\nOverhead Hoist Transport (OHT), and\n\u2022 Fixed Arm Robots.\n7. 5.2  Containers  \u2014  Containers  may  be  open  (e.g.,\ncassettes) or closed (pods, including reticle pods).  Pods\nmay  be  bottom-opening  (SMIF),  with  a  removable\ncassette,  or  front-opening  (FIMS),  which  may  have\neither   a   removable   cassette   or   an   integrated   (non-\nremovable) cassette (FOUP).\n7. 5.3  Factory Interface \u2014 The equipment must be able\nto support different levels of automation, including:"),(0,o.yg)("p",null,"SEMI E98-1102 \xa9 SEMI 2000, 2002 9\n\u2022 stand-alone  (with  no  connection   to   the   factory\nsystems),\n\u2022 fully on-line and operated locally (by the operator),\n\u2022 fully on-line and operated remotely (by the factory\nsystems), and\n\u2022 fully  on-line  and  able  to  support  and  coordinate\ninteractions    from    multiple    factory    users    and\nsystems at the same time.\n8  Equipment Overview\n8. 1    The  Object-Based  Equipment  Model  defines  the\nobjects  that  are  generic  components  of  equipment  as\nwell  as  the  object  representing  the  equipment  itself.\nOBEM  does  not  dictate  the  makeup  of  equipment.\nThrough  support  of  OBEM,  the  equipment  is  able  to\ndescribe  its  own  makeup  to  the  factory.    However,\nOBEM  does  require  certain  visibility  and  access  to\nthose parts of the equipment that control and/or monitor\nthe environment or the location of the product.\n8. 2    Two  view  areas  are  of  importance:  the  functional\nview  of  the  equipment  and  the  internal  composition\nview of the equipment.\n8. 3  Functional    View    of    Equipment    \u2014    From    a\nfunctional  view,  equipment  is  internally  composed  of\nlogical subsystems with different areas of responsibility\nthat are at different levels within a control hierarchy, as\nillustrated  in  Figure  1.    There  are  three  general  levels.\nEquipment Control is at the highest level, both respon-\nsible  for,  and  representing,  the  equipment  as  an  inte-\ngrated  whole.    The  middle  level  provides  management\nof specific areas, while the lowest level of functionality\nhas specific time-critical responsibilities and handles all\ndirect interaction with the equipment\u2019s I/O (sensors and\nactuators).  The third level is below the factory level of\nvisibility and is discussed here for completeness.\nNOTE  3:  This  is  not  intended  to  represent  the  design  of  an\nactual implementation.\n8. 3.1      The   functional   areas   are   discussed   below   in\nalphabetical order.\n8. 3.2  Access  Management  \u2014  Access  Management  is\nresponsible   for   communications   with   the   factory,\nincluding  factory  computers,  local  and  remote  oper-\nators,  third  party  systems,  and  alternate  users  (desktop\naccess  by  process  engineers,  maintenance  personnel,\nsupplier   remote   diagnostics,   etc.)      Communications\nwith  the  local  operator  include  input  devices  (such  as\nkeyboards,  wands,  buttons,  and  optical  character  read-\ners)  and  display  devices  (console,  light  pole,  and  LCD\npanel) as well as interpretation of operator requests.\n8. 3.3  Communications  Link  \u2014  Communications  Link\nis  responsible  for  low-level  communications,  including\nestablishing   a   connection   with   a   communications\npartner, sending messages, and receiving messages.\n8. 3.4  Date/Time  Management  \u2014  Date/Time  Manage-\nment  is  responsible  for  maintaining  an  accurate  date\nand  time-of-day,  and  for  providing  current  date/time\ninformation to the rest of the system.  This may include\nmaintenance of regular time-based scheduling.\n8. 3.5  Environment  Control  \u2014  Environment  Control  is\nresponsible  for  maintaining  the  internal  environment\naccording  to  the  equipment\u2019s  specifications.    While\nProcess  Control  is  specific  to  a  process  and  recipe,\nother  monitoring  activities  may  be  required  regardless\nof  whether  the  equipment  is  processing  or  idle.    Such\nactivities  include  monitoring  for  particles,  humidity,  or\ntemperature.\n8. 3.6   Equipment  Control  \u2014  Equipment  Control  is  the\nsupervisory   level   with   overall   high-level   control.\nEquipment  Control  represents  the  entire  equipment  as\nan  integrated  whole  to  the  factory  and  represents  the\ndecision-making authority within the equipment.\n8. 3.7  Event  Management  \u2014  Events  continually  occur\nin all equipment states.  A variety of these events are of\ninterest   to   the   factory,   including   those   events   that\ngenerate  a  change  of  state  in  any  standardized  object.\nThe  factory  requires  notification  when  selected  events\noccur, and in many cases, requires reports of the values\nof  specified  information  at  the  time  that  the  event\noccurred.      Event   Management   is   responsible   for\ntracking  those  events  and  the  reports  associated  with\nthose events.\n8. 3.8  Exception  Management  \u2014  Exception  Manage-\nment is responsible for determining the proper response\nto an action or operation that the equipment was unable\nto  perform  which  raised  an  exception  condition.  It\nprompts    notification    to    all    affected    components,\nincluding  internal  components  and  currently  connected\nusers.  In some cases, the proper action may have to be\nresolved by the user.  Exception Management is a high\nlevel activity that is in addition to underlying hardware\nand software interlocks."),(0,o.yg)("p",null,"SEMI E98-1102 \xa9 SEMI 2000, 2002 10\nEquipment\nControl\nFacilities\nInterface\nMaterial\nI/O\nManagement\nRecipe\nManagement\nOperations\nManagement\nRecipe\nExecution\nException\nManagement\nMaterial\nManagement\nProcess\nExecution\nPerformance\nManagement\nAccess\nManagement\nEvent\nManagement\nObject\nManagement\nDate/Time\nManagement\nEnvironment\nControl\nCommunications\nLink\nJob\nManagement\nInformation\nManagement\nMaterial\nMovement\nControl"),(0,o.yg)("p",null,"Figure 1\nFunctional View of Equipment"),(0,o.yg)("ol",{start:8},(0,o.yg)("li",{parentName:"ol"},"3.9   Facilities  Interface  \u2014  The  Facilities  Interface  is\nresponsible   for   managing   the   physical   interfaces\n(hookups)   to   the   factory.      This   includes   bulk   fill,\ncontinuous  chemical  services,  factory  vacuum,  factory\nexhaust,    and    the    electrical    environment    of    the\nequipment."),(0,o.yg)("li",{parentName:"ol"},"3.10      Information     Management     \u2014     Information\nManagement is responsible for the information and data\nstored by the equipment, including information required\nfor  the  user  as  well  as  various  internal  event  and  data\nlogs."),(0,o.yg)("li",{parentName:"ol"},"3.11  Job    Management    \u2014    Job    Management    is\nresponsible  for  all  jobs,  including  process  jobs,  job\nqueues, and job execution."),(0,o.yg)("li",{parentName:"ol"},"3.12  Material   I/O   Management   \u2014   The   Material\nInput/Output   (I/O)   Management   is   responsible   for\nloading and unloading material to and from the factory.\nThis  includes  the  AMHS  interface  (parallel  I/O),  pod\ninterface,    carrier    management,    and    carrier-related\nservices  such  as  reading,  writing,  and  slot  mapping\n(identifying    unoccupied,    correctly    occupied,    and\nincorrectly occupied slots in a carrier)."),(0,o.yg)("li",{parentName:"ol"},"3.13  Material Management \u2014 Material Management\nis   responsible   for   tracking   all   material,   including\ncarriers,  product,  and  consumables,  within  or  used  by\nthe   equipment.      This   includes   providing   historical\ninformation required for product history."),(0,o.yg)("li",{parentName:"ol"},"3.14  Material    Movement    Control    \u2014    Material\nMovement  Control  consists  of  low-level  control  of")),(0,o.yg)("p",null,"SEMI E98-1102 \xa9 SEMI 2000, 2002 11\ninternal   subsystems,   subassemblies,   and   i/o   devices\nused  in  moving  material  within  the  equipment,  such  as\nrobots,   location   sensors,   proximity   sensors,   motors,\ncentering and alignment systems, and material identifier\nreaders.\n8. 3.15  Object Management\n8. 3.15.1    Object  Management  consists  of  management\nof    OBEM    objects,    their    attributes,    and    internal\ncommunications.     It     includes     all     elements     of\nconfiguration     definition,     both     fixed     and     user-\nconfigurable,     that     pertain     to     the     equipment.\nConfiguration  settings  consist  of  those  attributes  that\naffect  the  global  behavior  of  the  equipment  and  are\ngenerally  static  and  change  only  on  request.    They  are\nin  effect  at  all  times  regardless  of  the  current  recipe(s)\nand/or  processing  states.    They  control  activities  that\nmaintain the environment when \u201cnot processing\u201d.\n8. 3.15.2      Configuration   settings   shall   be   retained   in\nnon-volatile  storage.  Some  elements  of  configuration\nmay  be  distributed.    For  example,  individual  process\nchambers may have their own configuration elements.\n8. 3.15.3          Elements     of     configuration     management\ninclude:\n\u2022 configuration of individual physical chambers, and\n\u2022 configuration of individual logical objects.\n8. 3.16  Operations      Management      \u2014      Operations\nManagement is responsible for the overall operation of\nthe  equipment  in  all  operational  modes:  automatic,\nsemi-automatic, and manual.\n8. 3.17  Performance    Management    \u2014    Performance\nManagement  is  responsible  for  managing  information\nand   operations   related   to   the   performance   of   the\nequipment   and   equipment   modules.      This   includes\noversight for manual mode operations performed when\nthe   equipment   and   equipment   modules   are   out   of\nservice.  For  implementations  of  ARAMS,  this  also\nincludes  ARAMS  state  changes  and  data  as  well  as\noversight for manual mode operations performed during\ndowntime and non-scheduled time.\n8. 3.18  Process  Execution  \u2014  Process  Execution  covers\nthose  fixed  algorithms  and  procedures  that  are  not\nreachable or changeable by the user.  This includes any\nembedded    control    and    sequence    algorithms    not\ncontained in recipes.  It consists of low-level control of\nsubsystems,   sensors,   and   actuators   not   covered   by\nMaterial   Management   Control,   such   as,   chemical\ncontrol  (valves,  exhaust),  motion  control  (rotational,\nacceleration,    positional)    and    the    control    of    the\nenvironment    during    processing    of    the    product\n(temperature,     etc.).     It     also     includes     product\nenvironment  control  and  any  fixed  embedded  fault\ndetection  classification,  and/or  fixed  low-level  in-situ\nrun-to-run control for advanced process control.\n8. 3.19  Recipe Execution\n8. 3.19.1      A   recipe   represents   the   pre-planned   and\nreusable set of instructions, algorithms, and settings that\nare   used   by   process   execution   to   control   process,\nincluding  variable  in  situ  process  control  algorithms.\nRecipes  are  created  by  the  user,  and  in  some  cases  by\nthe equipment as well.  Recipes may be of a variety of\ntypes, such as flow sequence, metrology, models, abort,\nand load maps, as well as etch, clean, etc.\n8. 3.19.2  Recipe Execution is responsible for the proper\nand  safe  execution  of  recipes,  including  loading  the\nrecipe into the execution area, verification of the recipe,\nvalidation  of  recipes  (ensuring  the  recipe  does  not\nconflict  with  the  current  equipment  configuration),  and\ninitiation    of    process    execution    based    on    recipe\ninstructions (SEMI E42).\n8. 3.20  Recipe   Management   \u2014   Recipe   Management\nconsists  of  the  management  of  stored  recipes.    This  is\ndifferentiated from short-term storage of recipes and the\nselection and execution of recipes performed by Recipe\nExecution    (SEMI    E42).    Recipes    are    classified\n(organized)   according   to   their   primary   application\nfunction:  process,  environment,  service  (maintenance),\netc.\n8. 4  Relationships with Other Standards\n8. 4.1    Only  those  functional  areas  in  the  middle  in\nFigure  1  are  of  interest  to  the  host.    The  top  level  of\nEquipment  Control  represents  all  of  the  functionality\nbelow  it,  while  the  functional  areas  at  the  bottom  are\nconsidered   to   be   low   level   and   proprietary   to   the\nequipment supplier.\n8. 4.2    Table  1  shows  those  functional  areas  that  are\ndefined  by  OBEM  and  those  that  are  defined  by  other\nSEMI standards.  In some cases, OBEM may extend or\nlimit the functionality defined elsewhere."),(0,o.yg)("p",null,"SEMI E98-1102 \xa9 SEMI 2000, 2002 12\nTable 1  Functional Area Definition\nFunctional Area Where Defined Comments\nAccess Management SEMI E98 (OBEM) Defines different kinds of user control.\nDate/Time Management SEMI E98 (OBEM) Addresses timestamp, date/time synchronization.\nEvent Management SEMI E53 (ERS) SEMI E53 may be required for SECS-II implementations.\nException Management SEMI E41 (EMS) Required for reporting alarms and exceptions.\nMaterial I/O Management SEMI E87 (CMS) Required for Carrier Management.\nMaterial Management SEMI E90 (STS) Required for Substrate Tracking.\nObject Management SEMI E39 (OSS) Required\nOperations Management SEMI E98 (OBEM) Overall coordination.\nPerformance Management SEMI E58 (ARAMS)             Optional             for             EquipmentModule and Equipment.  Not used\nfor lower level components.\nJob Management SEMI E40 (PM),\nSEMI E94 (CJM)\nProcess Managment and Control Job Management\nRecipe Execution SEMI E42 (RMS) Required for processing by EquipmentModule.\nRecipe Management SEMI E42 (RMS) Required for long-term storage by Equipment."),(0,o.yg)("ol",{start:8},(0,o.yg)("li",{parentName:"ol"},"5  Internal Composition View of the Equipment \u2014 The physical makeup of equipment is of interest to the factory,\nparticularly  for  equipment  that  is  complex,  multi-module,  and/or  multi-process.  Productivity  and  maintenance\ntracking,  for  example,  requires  that  the  factory  be  able  to  specify  individual  subsystems  and/or  modules  for\nmaintenance  activities,  where  it  is  possible  to  do  so  without  removing  the  entire  equipment  from  manufacturing\nscheduling.    For  example,  one  or  more  baths  in  a  wet  bench  may  be  down  for  maintenance  even  though  the  wet\nbench itself continues to process.")),(0,o.yg)("p",null,"1+\n1+\nheld at\ninteracts with\nEquipmentClock\nProcess\nModule\nMaterial\nHandling\nSubsystem\nI/O Device\nUser\nCarrier\nLoadPort\n1+"),(0,o.yg)("p",null,"Figure 2\nAn Example of Equipment Internal Composition\n9  OBEM Object Model\n9. 1  OBEM defines generic component objects of Equipment, and the Equipment object itself.  Equipment is made\nup of elements (units or parts) of different levels of intelligence and complexity, such as modules, subsystems, and\nI/O devices.  Each of these elements may itself be made up of several smaller elements, some of which may also be\nintelligent,  and  this  allows  the  complexity  of  the  equipment  to  be  distributed  to  smaller  functional  units.    Many  of"),(0,o.yg)("p",null,"SEMI E98-1102 \xa9 SEMI 2000, 2002 13\nthese  elements  may  be  of  interest  to  the  factory.    In  particular,  process  modules,  which  are  intelligent  and  may  be\nindependently  operable,  are  very  interesting  to  the  factory,  since  these  are  the  units  where  the  product  is  actually\nprocessed.  The factory requires processing modules to be highly visible and individually addressable and to support\ncertain  of  the  same  remote  commands  that  are  required  of  the  equipment.    Other  elements  of  interest  include\nsubsystems for material handling, alignment, and measurement.\n9. 2  The equipment is responsible for all communications at all times, including messages directed to a specific part\nof the equipment.  Service requests directed to components of the equipment shall be managed by the equipment to\nensure equipment integrity.\nEquipment\nModule\nEquipment\nEquipment\nSubsystem\nAbstract\nEquipment\nElement\nEquipment\nIODevice\nAbstract\nEquipment\nSubsystem\nAbstract\nEquipment\nModule\nUser\n1+"),(0,o.yg)("p",null,"Figure 3\nEquipment Object Model"),(0,o.yg)("ol",{start:9},(0,o.yg)("li",{parentName:"ol"},"3    In  Figure  3,  two  hierarchies  are  shown.    On  the  left  is  an  inverted  interface  inheritance  hierarchy,  and  on  the\nright  the  concrete  subtypes  where  rules  of  aggretation  are  shown.  The  interface  inheritance  shows  the  objects  that\ndefine  the  attributes,  state  models,  and  services  of  the  subtype  objects  as  viewed  externally.  These  are  presented\nupside  down  from  the  usual  presentation  so  that  they  may  be  directly  related  to  the  aggregation  hierarchy  on  the\nright.  In both cases, the simpler objects are below the more complex objects."),(0,o.yg)("li",{parentName:"ol"},"4    Those  object  types  starting  with  the  word  \u201cAbstract\u201d  are  abstract  objects  not  intended  to  be  implemented\ndirectly.  Their purpose is solely to define the inherited attributes, state models, and services for those objects used\nto build an OBEM model of equipment.  The remaining objects shown in Figure 3 are concrete objects.  All rules of\naggregation are defined for concrete objects only.")),(0,o.yg)("p",null,"SEMI E98-1102 \xa9 SEMI 2000, 2002 14\n9. 5  OBEM   Object   Requirements   \u2014   By   definition,\nsubtypes  of  objects  inherit  the  properties  (attributes,\nservices, and relationships) of their supertypes. In some\ncases,   properties   of   the   subtype   may   be   further\nspecialized.\n9. 5.1  Object   Services   Requirements   \u2014   All   objects\nformally  defined  by  this  standard  shall  be  compliant  to\nthe fundamental requirements of SEMI E39 (OSS). All\nOBEM-defined  objects  that  are  aggregates,  containers,\nor  managers  of  other  objects  shall  comply  with  the\nadditional    OSS    requirements    for    object    owners.\nAccording   to   OSS,   an   owner   is   any   aggregate,\ncontainer, or manager of one or more other objects.  An\nowner is required to respond to queries about the types\nof   objects   that   it   owns.   Owners   have   additional\nresponsibilities, as specified in OSS.\n9. 5.2  Object Non-volatility\n9. 5.2.1  All    objects    defined    by    OBEM    shall    be\npersistent.      The   individual   object   persists   across\npowerdown  and  powerup  conditions,  and  all  current\nvalues  of  static  attributes  (attributes that do not change\ndynamically   indicating   the   object's   status)   shall   be\nmaintained  and  restored  upon  powerup.    It  may  be\nimportant  to  maintain  other  critical  values  as  well,\ndepending  upon  the  object  and  the  implementation.\nWhen the equipment is powdered on or reset\n5\n, all state\nmodels are restored.  Following initialization, the object\nis  considered  to  be  operational.    Figure  4  shows  this\nconvention  for  a  generic  OBEM  object.    However,\nsince  the  state  model  can  not  be  accessed  by  the  user\nuntil the object is operational, the default entry state for\na  specific  state  model  is  considered  to  be  within  the\nOperational state."),(0,o.yg)("p",null,"(Persistent OBEM Object)\nOPERATIONAL\nPOWER\nDOWN\nINITIALIZATION"),(0,o.yg)("p",null,"Figure 4\nPersistence of OBEM Objects"),(0,o.yg)("p",null,"5 For a more detailed discussion of powerdown, reset, and soft reset,\nsee SEMI E58.\n9. 5.2.2  POWERDOWN   and   INITIALIZATION   are\ncommon to all OBEM objects.  Therefore, they are not\nspecific  to  any  object  and  are  not  generally  shown.\nWhen  operational,  the  OBEM  object  is  capable  of\nmaintaining  state  information.    From  the  user  view,  an\ninstantiation   of   an   OBEM   object   shall   follow   the\nbehavior  or  state  model  as  shown  in  Figure  4.  The\nequipment    representation,    which    consists    of    an\naggregation  of  OBEM  objects,  shall  also  reflect  the\nstate model shown here.\n9. 5.2.3  The equipment is responsible for managing the\nexchange of any of its component parts, including parts\nexchanged    during    powerdown.        This    may    be\naccomplished  through  use  of  intelligent  components\nthat  are  able  to  identify  themselves  or  through  the  user\ninterface.\n9. 5.3  Shared Resources \u2014 When two (or more) objects\ncooperate  in  using  the  services  provided  by  a  third\nobject, then the third object should not be modeled as a\ncomponent  of  either  of  the  first  two  objects.  If  the  two\ncooperating   objects   have   a   common   owner,   either\nlogical  or  physical,  then  the  shared  resource  object\nshould belong to the common owner.\n9. 5.4  Object    Factory    Communications    \u2014    OBEM\nobjects  other  than  the  Equipment  object  are  neither\nrequired nor expected to communicate directly with the\nfactory.    Factory  communications  are  handled  by  the\nEquipment instantiation.\n9. 5.5  Object Event Reporting\n9. 5.5.1      Event   reporting   allows   a   user   to   receive\nnotification  of  events  together  with  related  data  of\ninterest. OBEM compliance requires that the equipment\nprovide  a  standard  mechanism  for  reporting  events  of\ninterest  to  the  user,  together  with  the  current  values  of\nuser-selectable data.\n9. 5.5.2  All transitions in state models are of interest to\nthe  user  and  reportable  unless  otherwise  stated  in  the\nstate model definition.\n9. 6  OBEM Interface Inheritance Hierarchy\n9. 6.1  An  interface  inheritance  hierarchy  begins  with  a\nsimple interface at the highest (most abstract) level, and\nlower   levels   within   the   hierarchy   represent   added\nfunctionality  (specialization).    A  subtype  of  an  object\ninherits   the   attributes,   behavior,   relationships,   and\nservices  of  the  supertype  and  adds  to  and/or  modifies\n(overrides) them."),(0,o.yg)("p",null,"SEMI E98-1102 \xa9 SEMI 2000, 2002 15\nAbstractEquipment\nElement\nEquipment\nAbstractEquipmentModule\nAbstractEquipment-\nSubsystem"),(0,o.yg)("p",null,"Figure 5\nObject Interface Hierarchy Concept"),(0,o.yg)("ol",{start:9},(0,o.yg)("li",{parentName:"ol"},"6.1.1      The   physical   view   shown   in   Figure   2   is\nconcerned   with   the   relationships   between   different\nobjects.    In  that  view,  the  equipment  is  at  the  highest\nlevel  and  owns  (is  responsible  for)  the  lower  level\nobjects  of  which  it  is  made  up.  A  process  chamber  is\nconsidered to be at a higher level than subsystems such\nas substrate handlers."),(0,o.yg)("li",{parentName:"ol"},"6.1.2  From the view of the object interface hierarchy,\nthis  order  is  reversed,  with  AbstractEquipmentElement\nappearing  at  the  top  level  as  shown  in  Figure  5.    From\nthe  view  of  an  object  interface  \u2014  the  interface  to  an\nobject  \u2014  the  higher  the  level,  the  more  simple  the\ninterface.    This  is  because  of  inheritance,  where  the\n\u201cchild\u201d  object  inherits  all  of  the  attributes,  behavior,\nand services of the \u201cparent\u201d object and at the same time\nadds some degree of specialization that will be reflected\nin  either  additional  attributes,  behavior,  or  services,  or\nin restrictions on the more general object."),(0,o.yg)("li",{parentName:"ol"},"6.1.3    All  objects  represent  the  view  as  seen  by  the\nfactory,  not  the  internal  view  of  equipment  control.\nFrom  this  view,  the  information  and  services  required\nfor  an  equipment  part  such  as  a  pod  door  opener  is\nrelatively  simple.    The  view  of  a  module  such  as  a\nprocess  chamber  is  more  complex  but  contains  all  the\nelements  of  the  view  provided  for  the  simpler  part\n(functional  description,  immutable  id,  etc.).    The  view\nof  the  equipment  is  the  most  complex  and  includes  all\nof the attributes and services of the equipment element,\nequipment   subsystem,   equipment   module,   and   the\nequipment itself."),(0,o.yg)("li",{parentName:"ol"},"6.1.4  The object model of equipment presented to the\nfactory  is  based  on  SEMI  E39  (OSS).  OSS  services\nallow  the  factory  to  \u201cdiscover\u201d  the  actual  physical\nmakeup and aggregation hierarchy of the physical view\nof equipment illustrated in Figures 2 and 3."),(0,o.yg)("li",{parentName:"ol"},"6.1.5        Each    object    is    defined    in    terms    of    its\nrequirements,  attributes,  behavior  (state  models),  and\nthe   services   that   it   is   required   to   support.      The\nequipment owns all of the objects that it is made of and\nis responsible for providing the required behavior."),(0,o.yg)("li",{parentName:"ol"},"6.1.6    All  objects  in  OBEM  inherit  the  attributes  and\nservices  defined  for  the  Top  Object  as  specified  in  the\nObject Service Standard (OSS). This allows the factory\nto  use  object  services  to  request  the  equipment  to\ndescribe  its  physical  view  by  reporting  which  objects\nthat it owns."),(0,o.yg)("li",{parentName:"ol"},"6.1.7    Note  that  equipment  support  for  an  OBEM\ninterface to the factory does not imply or require direct\naccess from the factory to any equipment element.\n10  OBEM Object Definitions"),(0,o.yg)("li",{parentName:"ol"},"1  OBEM objects are defined in this section."),(0,o.yg)("li",{parentName:"ol"},"2  AbstractEquipmentElement      Object      \u2014      The\nsupertype    object    of    the    interface    hierarchy    is\nAbstractEquipmentElement,  which  is  an  abstraction  of\nany   equipment   component   that   can   perform   work.\nAbstractEquipmentElement  is  an  abstract  type  that  is\nnot  implemented  directly.    There  are  two  subtypes  of\nAbstractEquipmentElement:      AbstractEquipmentSub-\nsystem,  and  EquipmentIODevice.    AbstractEquipment-\nElement is an abstract type, so that implementations are\nof one of the subtypes."),(0,o.yg)("li",{parentName:"ol"},"2.1  AbstractEquipmentElement Requirements"),(0,o.yg)("li",{parentName:"ol"},"2.1.1  Object Exception Management"),(0,o.yg)("li",{parentName:"ol"},"2.1.1.1    SEMI  E41  defines  a  model  for  Exception\nConditions.    An  Exception  Condition  may  be  either  an\nAlarm   Condition   or   an   Error   Condition.      Error\nConditions may, in some cases, have a set of associated\nRecovery   Actions   that   can   be   performed   by   the\nAbstractEquipmentElement  to  attempt  to  recover  from\nthe abnormal situation."),(0,o.yg)("li",{parentName:"ol"},"2.1.1.2    An  OBEM  object  shall  comply  with  the\nfundamental  requirements  of  SEMI  E41,  Section  10.4.\nException   Condition   objects   shall   be   provided   in\nconformance  with  SEMI  E41  and  shall  be  accessible\nthrough    services    defined    in    SEMI    E39.        The\nAbstractEquipmentElement  owns  all  exceptions  that  it\ngenerates.  Therefore, it shall report all of its Exception\nCondition objects through OSS services."),(0,o.yg)("li",{parentName:"ol"},"2.2  AbstractEquipmentElement   Subtypes   \u2014   The\nAbstractEquipmentElement    has    two    subtypes,    the\nEquipmentIODevice     and     the     AbstractEquipment-\nSubsystem.")))}m.isMDXComponent=!0},5680(e,n,t){t.d(n,{xA:()=>d,yg:()=>u});var a=t(6540);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach(function(n){o(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef(function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(t),u=o,h=p["".concat(l,".").concat(u)]||p[u]||m[u]||r;return t?a.createElement(h,i(i({ref:n},d),{},{components:t})):a.createElement(h,i({ref:n},d))});function u(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=p;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"}}]);