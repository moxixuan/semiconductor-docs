"use strict";(globalThis.webpackChunksemiconductor_docs=globalThis.webpackChunksemiconductor_docs||[]).push([[6549],{2073(e,t,n){n.d(t,{A:()=>r});var o=n(6540);const r=function({pdfLink:e,pdfSize:t,title:n,description:r}){if(!e)return null;const i=e.startsWith("http"),a=(e=>{if(!e)return null;try{const t=new URL(e,i?void 0:window.location.origin);return t.pathname.split("/").pop()}catch{return e.split("/").pop()}})(e);return o.createElement("div",{className:"pdf-download-card"},o.createElement("div",{className:"pdf-download-card__header"},o.createElement("div",{className:"pdf-download-card__icon"},"\ud83d\udce5"),o.createElement("div",{className:"pdf-download-card__title"},o.createElement("h3",null,"\u4e0b\u8f7d\u5b8c\u6574PDF"),n&&o.createElement("p",{className:"pdf-download-card__doc-title"},n))),o.createElement("div",{className:"pdf-download-card__info"},o.createElement("div",{className:"pdf-download-card__meta"},o.createElement("span",{className:"pdf-download-card__label"},"\u6587\u4ef6\u5927\u5c0f:"),o.createElement("span",{className:"pdf-download-card__value"},"string"==typeof(s=t)?s:s<1048576?`${(s/1024).toFixed(1)}KB`:`${(s/1024/1024).toFixed(1)}MB`)),r&&o.createElement("div",{className:"pdf-download-card__description"},r),i&&o.createElement("div",{className:"pdf-download-card__notice"},o.createElement("span",{className:"pdf-download-card__notice-icon"},"\u2139\ufe0f"),o.createElement("span",null,"\u6b64\u6587\u4ef6\u6258\u7ba1\u5728GitHub Releases\uff0c\u53ef\u80fd\u9700\u8981GitHub\u8d26\u53f7"))),o.createElement("div",{className:"pdf-download-card__actions"},o.createElement("a",{href:e,className:"pdf-download-card__button pdf-download-card__button--primary",download:i?void 0:a,target:i?"_blank":void 0,rel:i?"noopener noreferrer":void 0},o.createElement("span",{className:"pdf-download-card__button-icon"},"\u2b07\ufe0f"),"\u4e0b\u8f7dPDF"),i&&o.createElement("a",{href:e,className:"pdf-download-card__button pdf-download-card__button--secondary",target:"_blank",rel:"noopener noreferrer"},o.createElement("span",{className:"pdf-download-card__button-icon"},"\ud83d\udd17"),"\u5728\u65b0\u7a97\u53e3\u6253\u5f00")));var s}},5680(e,t,n){n.d(t,{xA:()=>d,yg:()=>m});var o=n(6540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach(function(t){r(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},d=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef(function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(n),m=r,p=u["".concat(c,".").concat(m)]||u[m]||h[m]||i;return n?o.createElement(p,a(a({ref:t},d),{},{components:n})):o.createElement(p,a({ref:t},d))});function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,a=new Array(i);a[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,a[1]=s;for(var l=2;l<i;l++)a[l]=n[l];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8345(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var o=n(8168),r=(n(6540),n(5680));n(2073);const i={title:"E38-1296 - \xa9 SEMI 1995, 19961...",description:"SEMI\u6807\u51c6\u6587\u6863",sidebar_label:"E38-1296 - \xa9 SEMI 1995, 19961...",sidebar_position:330,tags:["SEMI","Standard"],custom_props:{source_type:"pdf",source_file:"semi-chapter-033.pdf",chapter:33,page_count:50}},a=void 0,s={unversionedId:"standards/semi/semi-chapter-033",id:"standards/semi/semi-chapter-033",title:"E38-1296 - \xa9 SEMI 1995, 19961...",description:"SEMI\u6807\u51c6\u6587\u6863",source:"@site/docs/standards/semi/semi-chapter-033.md",sourceDirName:"standards/semi",slug:"/standards/semi/semi-chapter-033",permalink:"/semiconductor-docs/docs/standards/semi/semi-chapter-033",draft:!1,editUrl:"https://github.com/your-org/semiconductor-docs/tree/main/docs/standards/semi/semi-chapter-033.md",tags:[{label:"SEMI",permalink:"/semiconductor-docs/docs/tags/semi"},{label:"Standard",permalink:"/semiconductor-docs/docs/tags/standard"}],version:"current",sidebarPosition:330,frontMatter:{title:"E38-1296 - \xa9 SEMI 1995, 19961...",description:"SEMI\u6807\u51c6\u6587\u6863",sidebar_label:"E38-1296 - \xa9 SEMI 1995, 19961...",sidebar_position:330,tags:["SEMI","Standard"],custom_props:{source_type:"pdf",source_file:"semi-chapter-033.pdf",chapter:33,page_count:50}},sidebar:"standardsSidebar",previous:{title:"E32-0997 - \xa9 SEMI 1994, 19971...",permalink:"/semiconductor-docs/docs/standards/semi/semi-chapter-031"},next:{title:"E38-1296 - \xa9 SEMI 1995, 199640...",permalink:"/semiconductor-docs/docs/standards/semi/semi-chapter-034"}},c={},l=[],d={toc:l};function h({components:e,...t}){return(0,r.yg)("wrapper",(0,o.A)({},d,t,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("p",null,'PdfDownloadCard\npdfLink="/pdfs/semi/033.pdf"\npdfSize="0.43MB"\ntitle="E38-1296 - \xa9 SEMI 1995, 19961..."\ndescription="SEMI\u6807\u51c6\u6587\u6863\uff0c\u517150\u9875"\n/'),(0,r.yg)("h1",{id:"\u6587\u6863\u6807\u9898"},"\u6587\u6863\u6807\u9898"),(0,r.yg)("p",null,"SEMI E37.1-0702 \xa9 SEMI 1995, 2002 2\n5. 4  The HSMS-SS state machine is illustrated in the diagram below."),(0,r.yg)("p",null,"Figure 1"),(0,r.yg)("ol",{start:5},(0,r.yg)("li",{parentName:"ol"},"5  State Transition Table for Passive Mode Connect\nTable 1  HSMS-SS Passive Mode Connect State Transitions")),(0,r.yg)("h1",{id:""}),(0,r.yg)("h1",{id:"old-state-new-state-trigger-actions"},"Old State New State Trigger Actions"),(0,r.yg)("p",null,"1\n\u2014\nTCP/IP NOT\nCONNECTED\nInitialization\n2       TCP/IP       NOT\nCONNECTED\nHSMS NOT\nSELECTED\nTCP/IP Connect Succeeds:"),(0,r.yg)("h1",{id:"1"},"1"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"TCP/IP \u201caccept\u201d succeeds.\nStart T7 timeout.\n3       HSMS       NOT\nSELECTED\nHSMS\nSELECTED\nHSMS Select Succeeds:"),(0,r.yg)("li",{parentName:"ol"},"Receive Select.req and decide to\nallow it."),(0,r.yg)("li",{parentName:"ol"},"Cancel T7 timeout; and")),(0,r.yg)("h1",{id:"2"},"2"),(0,r.yg)("ol",{start:2},(0,r.yg)("li",{parentName:"ol"},"Send Select.rsp with zero\nSelectStatus.\n4       HSMS       NOT\nSELECTED\nTCP/IP NOT\nCONNECTED\nHSMS Select Fails:"),(0,r.yg)("li",{parentName:"ol"},"T7 Timeout waiting for Select.req;\nor"),(0,r.yg)("li",{parentName:"ol"},"Receive Select.req and decide to\nreject it and send Select.rsp with non-\nzero SelectStatus; or")),(0,r.yg)("h1",{id:"3"},"3"),(0,r.yg)("ol",{start:3},(0,r.yg)("li",{parentName:"ol"},"Receive any HSMS message other\nthan Select.req; or")),(0,r.yg)("h1",{id:"4"},"4"),(0,r.yg)("ol",{start:4},(0,r.yg)("li",{parentName:"ol"},"Receive HSMS message length not\nequal to 10; or")),(0,r.yg)("h1",{id:"5"},"5"),(0,r.yg)("ol",{start:5},(0,r.yg)("li",{parentName:"ol"},"Receive bad HSMS message header;\nor")),(0,r.yg)("h1",{id:"6"},"6"),(0,r.yg)("ol",{start:6},(0,r.yg)("li",{parentName:"ol"},"T8 timeout waiting for TCP/IP; or")),(0,r.yg)("h1",{id:"7"},"7"),(0,r.yg)("ol",{start:7},(0,r.yg)("li",{parentName:"ol"},"Other unrecoverable TCP/IP Error\n(entity-specific)."),(0,r.yg)("li",{parentName:"ol"},"Close TCP/IP connection.")),(0,r.yg)("p",null,"SEMI E37.1-0702 \xa9 SEMI 1995, 2002 3"),(0,r.yg)("h1",{id:"old-state-new-state-trigger-actions-1"},"Old State New State Trigger Actions"),(0,r.yg)("p",null,"5        HSMS\nSELECTED\nTCP/IP NOT\nCONNECTED\nHSMS Connection Terminates:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Decide to terminate and send\nSeparate.req; or"),(0,r.yg)("li",{parentName:"ol"},"Receive Separate.req; or"),(0,r.yg)("li",{parentName:"ol"},"T6 timeout waiting for Linktest.rsp;\nor"),(0,r.yg)("li",{parentName:"ol"},"Receive HSMS message <10; or"),(0,r.yg)("li",{parentName:"ol"},"Receive HSMS message length >\nmaximum supported by entity; or"),(0,r.yg)("li",{parentName:"ol"},"Receive bad HSMS message header;\nor"),(0,r.yg)("li",{parentName:"ol"},"T8 timeout waiting for TCP/IP; or")),(0,r.yg)("h1",{id:"8"},"8"),(0,r.yg)("ol",{start:8},(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Other uncorrectable TCP/IP Error\n(entity-specific).")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Close TCP/IP connection.\n6        HSMS\nSELECTED\nHSMS\nSELECTED\nT3 Timeout waiting for Data Reply\nMessage.")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Cancel the Data Transaction as\nappropriate (entity-specific) but do not\nterminate the TCP/IP connection; and")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"If entity is EQUIPMENT send\nSECS-II S9F9.")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"6   State Transition Table for Active Mode Connect\nTable 2  HSMS-SS Active Mode Connect State Transitions"))),(0,r.yg)("h1",{id:"old-state-new-state-trigger-actions-2"},"Old State New State Trigger Actions"),(0,r.yg)("p",null,"1          \u2013          TCP/IP          NOT\nCONNECTED\nInitialization\n2          TCP/IP          NOT\nCONNECTED\nHSMS NOT\nSELECTED\nTCP/IP Connect Succeeds:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Decide to connect."),(0,r.yg)("li",{parentName:"ol"},"TCP/IP Connect; and"),(0,r.yg)("li",{parentName:"ol"},"Send Select.req; and"),(0,r.yg)("li",{parentName:"ol"},"Start T6 timeout.\n3          HSMS          NOT\nSELECTED\nHSMS\nSELECTED\nHSMS Select Succeeds:"),(0,r.yg)("li",{parentName:"ol"},"Receive Select.rsp with zero\nSelectStatus."),(0,r.yg)("li",{parentName:"ol"},"Cancel T6 timeout.\n4          HSMS          NOT\nSELECTED\nTCP/IP NOT\nCONNECTED\nHSMS Select Fails:"),(0,r.yg)("li",{parentName:"ol"},"T6 Timeout waiting for\nSelect.rsp; or"),(0,r.yg)("li",{parentName:"ol"},"Receive Select.rsp with non-zero\nSelect.Status; or"),(0,r.yg)("li",{parentName:"ol"},"Receive any HSMS message\nother than Select.rsp; or"),(0,r.yg)("li",{parentName:"ol"},"Receive HSMS message length\nnot equal to 10; or"),(0,r.yg)("li",{parentName:"ol"},"Receive bad HSMS message\nheader; or"),(0,r.yg)("li",{parentName:"ol"},"T8 timeout waiting for TCP/IP; or"),(0,r.yg)("li",{parentName:"ol"},"Other unrecoverable TCP/IP\nError (entity-specific)."),(0,r.yg)("li",{parentName:"ol"},"Close TCP/IP connection; and"),(0,r.yg)("li",{parentName:"ol"},"Start T5 Timeout.")),(0,r.yg)("p",null,"SEMI E37.1-0702 \xa9 SEMI 1995, 2002 4"),(0,r.yg)("h1",{id:"old-state-new-state-trigger-actions-3"},"Old State New State Trigger Actions"),(0,r.yg)("p",null,"5          HSMS\nSELECTED\nTCP/IP NOT\nCONNECTED\nHSMS Connection Terminates:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Decide to terminate and send\nSeparate.req; or"),(0,r.yg)("li",{parentName:"ol"},"Receive Separate.req; or"),(0,r.yg)("li",{parentName:"ol"},"T6 timeout waiting for\nLinktest.rsp; or"),(0,r.yg)("li",{parentName:"ol"},"Receive HSMS message length <\n10; or"),(0,r.yg)("li",{parentName:"ol"},"Receive HSMS message length >\nmaximum supported by entity; or"),(0,r.yg)("li",{parentName:"ol"},"Receive bad HSMS message\nheader; or"),(0,r.yg)("li",{parentName:"ol"},"T8 timeout waiting for TCP/IP; or"),(0,r.yg)("li",{parentName:"ol"},"Other uncorrectable TCP/IP Error\n(entity-specific)."),(0,r.yg)("li",{parentName:"ol"},"Close TCP/IP connection.\n6          HSMS\nSELECTED\nHSMS\nSELECTED\nT3 Timeout waiting for Data Reply\nMessage."),(0,r.yg)("li",{parentName:"ol"},"Cancel the Data Transaction as\nappropriate (entry-specific) but do\nnot terminate the TCP/IP\nconnection; and"),(0,r.yg)("li",{parentName:"ol"},"If entity is EQUIPMENT, send\nSECS-II S9F9.")),(0,r.yg)("p",null,"Table 3  When HSMS Transactions are Allowed"),(0,r.yg)("p",null,"HSMS Transition"),(0,r.yg)("p",null,"Allowed in State(s)\nWho Initiates\nTransaction?\nSelect                      HSMS                      Not\nSelected\nActive Entity\nLink Test HSMS Selected Either Entity\nData HSMS Selected Either Entity\nSeparate HSMS Selected Either Entity\n6  HSMS-SS Use of TCP/IP\n6. 1  As defined in HSMS.\n7  HSMS-SS Procedures\n7. 1  Select  Procedure  \u2014  The  Select  Procedure  shall  only  be  initiated  by  the  entity  establishing  the  TCP/IP\nconnection in active mode. The Passive Mode Entity shall not initiate the Select Procedure.\n7. 1.1    The  Select  Procedure  is  only  permitted  in  the  NOT  SELECTED  state.  It  uses  a  SessionID  value  of  0xFFFF\nand implies that all device IDs are available for communication. Immediately following any Select Procedure which\nfails to complete successfully with a zero Select Status, each Entity must close the TCP/IP connection and transit to\nthe NOT CONNECTED state.\n7. 2  Data Procedure \u2014 The Data Procedure is as defined in HSMS Generic Services. Note that any SessionID value\nthat  corresponds  with  a  DeviceID  supported  by  the  Local  Entity  is  valid  as  long  as  the  Local  Entity  is  in  the\nSELECTED state.\n7. 3  Deselect  Procedure  \u2014  Deselect  shall  not  be  used  in  an  HSMS-SS  implementation.  Communication  is  ended\nusing the Separate Procedure.\n7. 4  Linktest  Procedure  \u2014  As  defined  by  HSMS.    Under  HSMS-SS,  the  use  of  Linktest  is  strictly  limited  to  the\nSELECTED state."),(0,r.yg)("p",null,"SEMI E37.1-0702 \xa9 SEMI 1995, 2002 5\n7. 5  Reject   Procedure   \u2014   The   Reject   Procedure   is\noptional  in  HSMS  communications.  Note,  however,\nthat  any  situation  which  would  require  the  use  of  the\nReject as described in HSMS Generic Services shall be\ntreated as a communications failure in implementations\nnot    supporting    reject.    Specifically,    the    TCP/IP\nconnection is immediately closed.\n7. 6  Separate  Procedure  \u2014  Separate  shall  always  use\nSessionID 0xFFFF (binary, all ones). In HSMS-SS, the\nSeparate.req is valid only in the TCP/IP CONNECTED\nstate   and   its   substates.   After   either   initiating   or\nreceiving   a   Separate.req   message,   the   entity   shall\nimmediately close the TCP/IP connection and transit to\nthe TCP/IP NOT CONNECTED state.\n7. 7  Communications Failures \u2014 As defined by HSMS.\nNote  that,  in  addition  to  the  communications  failures\ndefined  under  HSMS,  any  violation  of  the  restrictions\ndefined in prior sections of this document are also to be\ntreated as communication failures.\n8  HSMS-SS Message Format\n8. 1  Session  ID  \u2014  In  HSMS-SS  Data  Messages,  the\nhigh-order  bit  of  Session  ID  is  zero,  and  the  low-order\n15  bits  contain  Device  ID,  a  15-bit  unsigned  integer\nvalue, which occupies the low-order 7 bits (bits 6-0) of\nbyte  0  and  all  of  byte  1  of  the  header.  Device  ID  is  a\nproperty  of  the  equipment,  and  can  be  viewed  as  a\nlogical  identifier  associated  with  a  physical  device  or\nsub-entity  within  the  equipment.  The  precise  meaning\nof  \u201cdevice\u201d  or  \u201csub-entity\u201d  is  equipment-defined.  A\nunit  of  equipment  must  have  at  least  one  Device  ID.\nEquipment which contains several devices may define a\nunique Device ID for each device.\nIn HSMS-SS Control Messages, Session ID will always\nassume the special value 0xFFFF (all one bits).\n8. 2  PType  \u2014  All  HSMS-SS  messages  are  PType  0\n(SECS II encoded) as defined in HSMS.\n8. 3  SType    \u2014    Only    HSMS-defined    STypes    are\npermitted  in  HSMS-SS.  User-defined  SType  messages\nare not permitted.\n9  Special Considerations\n9. 1  Multiblock    Messages    \u2014    For    each    SECS-II\nmessage,  the  SECS-II  standard  defines  whether  that\nmessage  should  be  transmitted  in  SECS-I  as  a  single-\nblock message or as a multiblock message.\nThis   distinction   becomes   unimportant   with   HSMS,\nwhich  transmits  all  messages  in  the  same  fashion.\nHowever,    to    be    compatible    with    older    SECS-I\napplications, when an HSMS application sends a SECS-\nII message defined as single block, the HSMS Message\nLength  should  not  exceed  254  bytes  (10  byte  header\nplus 244 text bytes).\n10  HSMS-SS Documentation\n10. 1      An   HSMS-SS   implementation   is   required   to\ndocument  the  following  information  in  addition  to  the\ninformation required by HSMS."),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"The   number   of   deviceIDs   supported   and   their\nspecific values."),(0,r.yg)("li",{parentName:"ol"},"Whether  or  not  the  implementation  supports  the\nnormal  or  the  restricted  procedure  for  terminating\ncommunications."),(0,r.yg)("li",{parentName:"ol"},"The setting of the host vs. equipment parameter."),(0,r.yg)("li",{parentName:"ol"},"2  Host  vs.  Equipment  \u2014  Many  applications  using\nSECS-II   will   need   to   designate   one   end   of   the\ncommunication  link  as  \u201cEquipment\u201d  and  the  other  end\nas \u201cHost.\u201d HSMS-SS itself does not require configuring\nof \u201cHost\u201d and \u201cEquipment,\u201d but this parameter may be\nincluded  in  configuration  where  needed.  HSMS  can\nalso   be   used   in   applications   where   the   distinction\nbetween Host and Equipment is not used.\nNOTICE:      SEMI      makes      no      warranties      or\nrepresentations  as  to  the  suitability  of  the  standards  set\nforth    herein    for    any    particular    application.    The\ndetermination of the suitability of the standard is solely\nthe  responsibility  of  the  user.    Users  are  cautioned  to\nrefer   to   manufacturer\u2019s   instructions,   product   labels,\nproduct   data   sheets,   and   other   relevant   literature\nrespecting   any   materials   mentioned   herein.   These\nstandards are subject to change without notice.\nThe  user\u2019s  attention  is  called  to  the  possibility  that\ncompliance   with   this   standard   may   require   use   of\ncopyrighted  material  or  of  an  invention  covered  by\npatent  rights.  By  publication  of  this  standard,  SEMI\ntakes  no  position  respecting  the  validity  of  any  patent\nrights  or  copyrights  asserted  in  connection  with  any\nitem  mentioned  in  this  standard.  Users  of  this  standard\nare  expressly  advised  that  determination  of  any  such\npatent rights or copyrights, and the risk of infringement\nof  such  rights,  are  entirely  their  own  responsibility.")),(0,r.yg)("p",null,"SEMI E37.1-0702 \xa9 SEMI 1995, 2002 6\nRELATED INFORMATION 1\nAPPLICATION NOTES\nNOTE: This related information is not an official part of SEMI E37.1 and is not intended to modify or supercede the\nofficial standard. Publication was authorized by full letter ballot. Determination of the suitability of the material is\nsolely the responsiblity of the user.\nR1-1\nR1-1.1 An entity may have more than one session.  If a unit of equipment can be divided into two or more logical\nsub-equipments,  such  as  process  chambers,  or  process  resources,  each  of  these  may  have  separated  session  ID.    If\ntwo  or  more  physical  sub-equipments  are  controlled  by  an  equipment  controller  or  communicated  to  through  a\nTCP/IP  network  device,  each  sub-equipment  may  have  a  separate  session  ID.    Such  a  session  can  be  established\nonce HSMS is selected.  Each session ID corresponds to a device ID.\nR1-1.2 If a unit of equipment has more than one sub-equipment or process resource (e.g. process modules) but the\nsub-equipment share a common resource (e.g. transfer subsystem), it is not recommended that each sub-equipment\nhave an independent session to communicate with host.  Even if the host requests an action to the shared subsystem\nwith  a  session  identifier  specific  for  a  sub-equipment,  the  shared  subsystem  may  not  always  serve  for  the  sub-\nequipment.  Since the host expects the shared subsystem to perform the service for the sub-equipment, an error will\noccur if it is not possible to perform the service for the designated sub-equipment.  See following figure."),(0,r.yg)("p",null,"(Resource-C)\nTransfer Subsystem\n(Resource-B)\nProcess Module B\n(Resource-A)\nProcess Module A\nHSMS-SS\nHOST\ncommon 1 session\n(one device ID)\n(Resource-C)\nTransfer Subs\nystem\n(Resource-B)\nProcess Module B\n(Resource-A)\nProcess Module\nA\nHSMS-SS\nHOST\n2 sessions\n(2 device Ids)\nTypical Case\nProblematic Case:\nEquipment  may  not  know  for  which  module  a  cassette  is\nsent.    Because subsystem doesn\u2019t have its own device ID,\narrival event may be reported with wrong device ID.\n(Resource-D)\nTransfer Subsystem D\n(Resource-B)\nProcess Module B\n(Resource-A)\nProcess Module A\nHSMS-SS\nHOST\n2 sessions\n(2 device Ids)\n(Resource-C)\nTransfer Subsystem C\nPossible Case,\nnot intended\nEquipment Controller\nEquipment Controller\nEquipment Controller\nDevice ID -A\nDevice ID -A\nDevice ID -B\nDevice ID -B"),(0,r.yg)("p",null,"Figure R1-1"),(0,r.yg)("p",null,"SEMI E37.1-0702 \xa9 SEMI 1995, 2002 7\nR1-2  Multiple HSMS Connections\nR1-2.1 Typically, an Equipment will accept only one Host Connection.\nR1-2.2  A  Host  may  connect  to  several  units  of  Equipment,  so  the  Host  may  have  several  simultaneously  active\nConnections (each to one Equipment).\nR1-2.3  A  Cell  Controller  (or  similar  entity)  might  have  one  Connection  by  which  the  Cell  Controller  appears  as\n\u201cEquipment\u201d to the Factory Host Computer, as well as several Connections by which the Cell Controller appears as\n\u201cHost\u201d to Equipment.\nR1-3  Equipment Support for Multiple Hosts\nR1-3.1 HSMS requires Equipment to accept at least one active Connection, and does not require the equipment to\nsupport access by multiple concurrent Hosts. That is, if the Equipment has already accepted a Host Connection, but\na Host (the same or a different Host) attempts a second Connection, the Equipment will immediately terminate that\nsecond Connection attempt.\nR1-3.2  For  specialized  applications,  an  equipment  could  accept  more  than  one  Host  Connection.  Coordination  of\nactivity by multiple hosts is equipment-defined."),(0,r.yg)("p",null,"NOTICE: SEMI makes no warranties or representations as to the suitability of the standards set forth herein for any\nparticular  application.  The  determination  of  the  suitability  of  the  standard  is  solely  the  responsibility  of  the  user.\nUsers  are  cautioned  to  refer  to  manufacturer\u2019s  instructions,  product  labels,  product  data  sheets,  and  other  relevant\nliterature respecting any materials mentioned herein. These standards are subject to change without notice.\nThe  user\u2019s  attention  is  called  to  the  possibility  that  compliance  with  this  standard  may  require  use  of  copyrighted\nmaterial  or  of  an  invention  covered  by  patent  rights.  By  publication  of  this  standard,  SEMI  takes  no  position\nrespecting  the  validity  of  any  patent  rights  or  copyrights  asserted  in  connection  with  any  item  mentioned  in  this\nstandard. Users of this standard are expressly advised that determination of any such patent rights or copyrights, and\nthe risk of infringement of such rights, are entirely their own responsibility."),(0,r.yg)("p",null,"Copyright   by   SEMI\xae   (Semiconductor   Equipment   and   Materials\nInternational), 3081 Zanker Road, San Jose, CA 95134. Reproduction o\nf\nthe  contents  in  whole  or  in  part  is  forbidden  without  express  written\nconsent of SEMI."),(0,r.yg)("p",null,"SEMI E37.2-95 \xa9 SEMI 1995, 2003 1\nSEMI E37.2-95 (Reapproved 0303)\nHIGH-SPEED SECS MESSAGE SERVICES GENERAL SESSION\n(HSMS-GS)\nThis  standard  was  technically  approved  by  the  Global  Information  and  Control  Committee and is the direct\nresponsibility of the North American Information and Control Committee.  Current edition approved by the\nNorth  American  Regional  Standards  Committee  on  October  25,  2002.    Initially  available  at  ",(0,r.yg)("a",{parentName:"p",href:"http://www.semi.org"},"www.semi.org"),"\nDecember 2002; to be published March 2003.  Originally published in 1995.\n1  Purpose"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"1    HSMS-GS  is  intended  to  support  the  needs  of\ncomplex   systems   containing   multiple   independently\naccessible  subsystems  such  as  cluster  tools  or  track\nsystems.  Specifically, procedures are defined to permit\naccess to any individual subsystem or set of subsystems\nwithin any complex system.\n2  Scope"),(0,r.yg)("li",{parentName:"ol"},"1        High-Speed    SECS    Message    Services    General\nSession  (HSMS-GS)  is  a  subsidiary  standard  to  High-\nSpeed   SECS   Message   Services   (HSMS)   Generic\nServices.\nNOTICE:  This  standard  does  not  purport  to  address\nsafety  issues,  if  any,  associated  with  its  use.    It  is  the\nresponsibility  of  the  users  of  this  standard  to  establish\nappropriate  safety  and  health  practices  and  determine\nthe applicability of regulatory or other limitations prior\nto use.\n3  Referenced Standards"),(0,r.yg)("li",{parentName:"ol"},"1  SEMI Standards\nSEMI   E4   \u2014   SEMI   Equipment   Communications\nStandard 1 Message Transfer (SECS-I)\nSEMI   E5   \u2014   SEMI   Equipment   Communications\nStandard 2 Message Content (SECS-II)\nSEMI  E37  \u2014  High-Speed  SECS  Message  Services\n(HSMS) Generic Services\nNOTICE:  Unless  otherwise  indicated,  all  documents\ncited shall be the latest published versions.\n4  Terminology"),(0,r.yg)("li",{parentName:"ol"},"1  Definitions"),(0,r.yg)("li",{parentName:"ol"},"1.1  Selected  Entity  List  \u2014  a  list  of  session  entities\ncurrently   selected   for   communication   on   a   given\nTCP/IP connection."),(0,r.yg)("li",{parentName:"ol"},"1.2  Selection   Count   \u2014   the   number   of   sessions\nopened  by  an  HSMS  Select  procedure  and  not  yet\nended by an HSMS Deselect or Separate procedure."),(0,r.yg)("li",{parentName:"ol"},"1.3  Session Entity \u2014 an individually selectable entity\nwithin an HSMS-GS system."),(0,r.yg)("li",{parentName:"ol"},"1.4  Session  Entity  ID  \u2014  a  16-bit  identifier  for  a\nSession-Entity."),(0,r.yg)("li",{parentName:"ol"},"1.5  SessionEntityList \u2014 a list of all available session\nentities  within  an  HSMS-GS  system  and  associated\nwith a particular IP address and port number."),(0,r.yg)("li",{parentName:"ol"},"2      In   addition,   all   definitions   for   HSMS   Generic\nServices apply."),(0,r.yg)("li",{parentName:"ol"},"3    Note  that  the  terms  HSMS  and  HSMS  Generic\nServices  both  refer  to  the  HSMS  Generic  Services\nstandard definition (SEMI E37).\n5  HSMS-GS Overview and State Machine"),(0,r.yg)("li",{parentName:"ol"},"1      HSMS-GS   provides   a   set   of   definitions   which\npermit  the  individual  subentities  (e.g.,  subsystems)  of\ncomplex   entities   (e.g.,   systems)   to   be   separately\naccessible   during   HSMS   procedures.      HSMS-GS\ndefines  no  new  procedures  or  message  types  beyond\nHSMS  Generic  Services  to  provide  these  services.    It\ndoes,  however,  require  extensions  to  the  HSMS  State\nmachine,   in   the   form   of   additional   state   transition\ndefinitions  and  additional  state  information,  which  are\nused  by  the  extended  state  machine  which  must  be\nmaintained by an HSMS-GS implementation to support\nthe extended state machine.  The additional information\nconsists of the following:"),(0,r.yg)("li",{parentName:"ol"},"The Session Entity List"),(0,r.yg)("li",{parentName:"ol"},"The Selected Entity List"),(0,r.yg)("li",{parentName:"ol"},"The Selection Count"),(0,r.yg)("li",{parentName:"ol"},"2    The  Session  Entity  List  consists  of  the  set  of  all\nSession  Entities  having  individual  accessibility  within\nthe HSMS-GS entity.  The scope of this list is normally\nthe entire HSMS-GS entity.  HSMS-GS, however, does\nnot require this scope:  the supplier may provide access\nto HSMS-GS entity through more than one well known\nport  and  provide  a  different  Session  Entity  List  for\neach."),(0,r.yg)("li",{parentName:"ol"},"3    A  Session  Entity  is  any  individually  addressable\nsubentity  within  the  HSMS-GS  entity:  for  example,  a\nSession  Entity  may  be  an  individual  sub-device  in  a\ntrack  system  or  cluster  tool,  or  may  be  an  individual\nservice provider, such as a data server, within an entity.")),(0,r.yg)("p",null,"SEMI E37.2-95 \xa9 SEMI 1995, 2003 2\nHSMS-GS     only     provides     the     conventions     for\nidentifying Session Entities.  It places no restrictions on\nthe   individual   supplier   as   to   what   constitues   a\nSessionEntity:  the  supplier  must  determine  what  is  the\nmost appropriate for the particular implementation.\n5. 4    The  Selected  Entity  List  is  the  list  of  Session\nEntities  actually  selected  for  access  on  a  given  TCP/IP\nconnection.  When the TCP/IP connection is established\n(CONNECTED   state   entered),   an   empty   Selected\nEntity  List  is  created.    Each  time,  the  Select  Procedure\nis  used  to  select  a  Session  Entity,  its  Session  Entity  ID\nis  added  to  the  Selected  Entity  List  created  for  that\nTCP/IP  connection.    Each  time  the  Session  Entity  is\ndeselected  via  the  Deselect  or  Separate  procedures,  its\nSession  Entity  ID  is  removed  from  the  Selected  Entity\nList.      At   any   given   time   on   any   given   TCP/IP\nconnection  endpoint,  HSMS  Data  Messages  will  only\nbe  accepted  by  an  entity  if  the  SessionID  of  the  Data\nMessage  is  equal  to  any  Session  Entity  ID  in  the\nSelected Entity List.\n5. 5      The   Selection   Count   is   simply   the   number   of\nSession Entity IDs in the Selected Entity List.  Its value\naffects the behavior of the state machine: the transition\nto NOT SELECTED from SELECT can only take place\nwhen the SELECTION COUNT is zero.\n5. 6    Note  that  the  above  lists  and  count  are  defined  for\nthe purpose of explaining state machine operation only.\nThere  is  no  requirement  that  any  of  the  above  lists  and\ncount be explicitly implemented.\n5. 7  HSMS-GS  State  Machine  \u2014  The  HSMS-GS  state\nmachine  is  the  same  as  the  HSMS  Generic  Services\nstate  machine  with  the  addition  of  the  two  new  state\ntransitions  (#6  and  #7)  and  the  use  of  the  Selection\nCount  in  the  other  transitions  as  described  in  the  state\ntransition table below."),(0,r.yg)("p",null,"Figure 1"),(0,r.yg)("ol",{start:5},(0,r.yg)("li",{parentName:"ol"},"8  State Descriptions \u2014 The state descriptions are the\nsame as HSMS Generic Services."),(0,r.yg)("li",{parentName:"ol"},"9  State  Transition  Table  \u2014  The  state  transition  table\nis  almost  identical  with  the  state  transition  table  for\nHSMS  Generic  Services.    For  convenience,  however,\nthe  entire  table  is  reproduced  and  extended  here,  not\njust those areas which differ from it.\nTable 1")),(0,r.yg)("h1",{id:"current----------state----------trigger----------new-state-actions-comment"},"Current          State          Trigger          New State Actions Comment"),(0,r.yg)("p",null,"1 ... Local entity specific\npreparation for TCP/IP\ncommunication.\nNOT\nCONNECTED\nLocal entity-specific. Action depends on\nconnection procedure to be\nused: active or passive.\n2     NOT\nCONNECTED\nA TCP/IP connection is\nestablished for HSMS\ncommunication.\nCONNECTED -\nNOT\nSELECTED\nSet Selection Count = 0\nand create empty Selecte\nd\nEntity List.\nnone\n3     CONNECTED       Breaking     of     TCP\nConnection.\nNOT\nCONNECTED\nLocal entity-specific. none\n4 NOT SELECTED   Successful completion of\nHSMS Select Procedure.\nSELECTED Set Selection Count = 1\nand add selected Session\nEntity to Selected Entity\nList.\nnone\n5 SELECTED Deselect or Separate\nprocedure resulting in\nSelection Count = 0.\nNOT\nSELECTED\nLocal entity-specific. See transition 7 below.\n6 SELECTED Successful completion of\nHSMS Select Procedure\nwhen Selection Count > 0.\nSELECTED          Increment          Selection\nCount and add selected\nSession Entity to Selected\nEntity List.\nnone\n7 SELECTED Successful completion of\nHSMS Deselect or Separate\nwhen Selection Count > 1.\nSELECTED          Decrement          Selection\nCount and remove\nselected Session Entity\nfrom Selected Entity List.\nIf this transition results in\nSelection Count = 0,\nimmediately trigger state\ntransition 5."),(0,r.yg)("p",null,"SEMI E37.2-95 \xa9 SEMI 1995, 2003 3\n6  HSMS-GS Use of TCP/IP\n6. 1    There  is  no  additional  HSMS-GS  specification  for\nthe use of TCP/IP beyond the above mentioned creation\nof the empty \u201cSelected Entity List\u201d upon entry into the\nCONNECTED state, NOT SELECTED substate.\n7  HSMS-GS Specific Procedures\nHSMS-GS    provides    further    specification    of    the\nfollowing procedures.\n7. 1  Select   Procedure   \u2014   The   select   procedure   is\npermitted  in  both  the  NOT  SELECTED  state  and  the\nSELECTED state.  The procedure for both the initiator\nand the responding entity is the same as HSMS Generic\nServices, with the following additional conditions:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"If the responding entity contains no Session Entity\nin  its  Session  Entity  List  whose  ID  matches  the\nSessionID  in  the  Select.req,  a  Select  Status  of  No\nSuch Entity is used in the Select.rsp."),(0,r.yg)("li",{parentName:"ol"},"If the responding entity is unable to provide access\nto the selected entity because it is usable on only a\nsingle  TCP/IP connection at any one time and it is\nalready  in  use  on  a  different  TCP/IP  connection,  a\nresponse  code  of  Entity  In  Use  is  used  in  the  Sel-\nect.rsp."),(0,r.yg)("li",{parentName:"ol"},"If the responding entity finds the SessionID already\nin  its  Selected  Entity  List,  a  response  code  of\nEntity Selected is used in the Select.rsp."),(0,r.yg)("li",{parentName:"ol"},"1.1  The Select Status values referenced above are all\ndefined in Section 8."),(0,r.yg)("li",{parentName:"ol"},"1.2  If none of the above is true, the Select completes\nsuccessfully, and a Select Status of 0 is provided in the\nSelect.rsp.    Both  entities  will  add  the  SessionID  from\nthe Select.req to the Selected Entity List."),(0,r.yg)("li",{parentName:"ol"},"2  Data   Procedure   \u2014   The   Data   Procedure   is   as\ndefined  in  HSMS  Generic  Services.    Note  that  the\nSessionID   of   any   Data   Message   must   match   a\nSessionID in the SelectedEntityList.  If a Data Message\nis  received  with  a  SessionID  other  than  one  from  the\nSelected  Entity  List,  a  Reject.req  message  is  sent  in\nresponse by the receiving entity.  The reason code will\nbe Entity Not Selected."),(0,r.yg)("li",{parentName:"ol"},"3  Deselect  Procedure  \u2014  The  Deselect  procedure  is\nrestricted by the following conditions:"),(0,r.yg)("li",{parentName:"ol"},"The SessionID must be in the Selected Entity List."),(0,r.yg)("li",{parentName:"ol"},"The corresponding SessionEntity is in a state which\npermits  Deselect.    This  decision  is  local  entity\nspecific and not subject to the HSMS-GS."),(0,r.yg)("li",{parentName:"ol"},"3.1    If  both  of  the  above  are  true,  then  the  Deselect\ncan  proceed.    Assuming  that  the  Deselect  completes\nsuccessfully,   the   SessionID   is   removed   from   the\nSelected   Entity   List,   and   the   Selection   Count   is\ndecremented.    The  transition  to  the  NOT  SELECTED\nstate  transpires  only  if  the  resulting  Selection  Count  is\nequal to zero (i.e., an empty Selected Entity List)."),(0,r.yg)("li",{parentName:"ol"},"4  Linktest Procedure \u2014 As defined by HSMS."),(0,r.yg)("li",{parentName:"ol"},"5  Reject Procedure  \u2014  As  defined  by  HSMS.    Note,\nin  particular,  the  use  of  Reject  in  response  to  certain\ndata messages (above)."),(0,r.yg)("li",{parentName:"ol"},"6  Separate Procedure  \u2014  The  Separate  procedures\nand state transitions are subject to the same restrictions\nand conditions as the Deselect."),(0,r.yg)("li",{parentName:"ol"},"7  Communications Failures \u2014 As defined by HSMS.\nNote  that  any  abrupt  termination  has  the  effect  of\ndeselecting all entities in the Selected Entity List.\n8  HSMS-GS Message Format Issues"),(0,r.yg)("li",{parentName:"ol"},"1  Session ID \u2014 In HSMS-GS Select, Data, Deselect,\nReject,   and   Separate   messages,   the   SessionID   will\nequal the Session Entity ID of the target Session Entity\nwhich  must  equal  the  Session  ID  of  a  Session  Entity\ncontained in the Session Entity List.  In the Linktest, it\nis 0xFFFF, as in HSMS."),(0,r.yg)("li",{parentName:"ol"},"2  PType \u2014 HSMS-GS messages are generally PType\n= 0 (SECS-II-encoded) as defined in HSMS.  Although\nother    PTypes    are    permitted,    specific    application\ndomains may restrict the use of HSMS-GS to Ptype = 0."),(0,r.yg)("li",{parentName:"ol"},"3  SType    \u2014    Only    HSMS-defined    STypes    are\npermitted in HSMS-GS."),(0,r.yg)("li",{parentName:"ol"},"4  Select/Deselect  Status  \u2014  The  following  additional\nenumeration  applies  to  the  Select/Deselect  status  in\nHSMS-GS:\nTable 2  SelectStatus\nValueDescription\n4 No Such Entity \u2014 Session ID does not correspond to\nany Session Entity ID available at this connection.\n5 Entity In Use (by another connection) \u2014 Session\nEntity corresponding to session ID is not sharable\nconnections and is already selected by another\nconnection.\n6 Entity Selected (by current connection) \u2014 Session\nentity corresponding to Session ID is already selected\non current connection.")),(0,r.yg)("p",null,"9  Special Considerations\n9. 1      There   are   no   special   considerations   above   and\nbeyond those described in HSMS Generic Services."),(0,r.yg)("p",null,"SEMI E37.2-95 \xa9 SEMI 1995, 2003 4\n10  HSMS-GS Documentation\n10. 1      An   HSMS-GS   implementation   is   required   to\ndocument  the  following  information  in  addition  to  the\ninformation required by HSMS."),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre"},"The  Session  Entity  List  \u2014  specifically  the  number\n")),"of    Session    Entities    available    for    HSMS-GS\ncommunication  and  the  value  of  their  particular\nSession Entity ID\u2019s.")),(0,r.yg)("p",null,"NOTICE: SEMI      makes      no      warranties      or\nrepresentations  as  to  the  suitability  of  the  standards  set\nforth   herein   for   any   particular   application.      The\ndetermination of the suitability of the standard is solely\nthe  responsibility  of  the  user.    Users  are  cautioned  to\nrefer   to   manufacturer's   instructions,   product   labels,\nproduct   data   sheets,   and   other   relevant   literature,\nrespecting   any   materials   or   equipment   mentioned\nherein.    These  standards  are  subject  to  change  without\nnotice.\nBy    publication    of    this    standard,    Semiconductor\nEquipment and Materials International (SEMI) takes no\nposition  respecting  the  validity  of  any  patent  rights  or\ncopyrights   asserted   in   connection   with   any   items\nmentioned  in  this  standard.    Users  of  this  standard  are\nexpressly advised that determination of any such patent\nrights  or  copyrights,  and  the  risk  of  infringement  of\nsuch rights are entirely their own responsibility."),(0,r.yg)("p",null,"SEMI E37.2-95 \xa9 SEMI 1995, 2003 5\nRELATED INFORMATION 1\nAPPLICATION NOTES\nNOTICE: This related information is not an official part of SEMI E37.2 and is not intended to modify or supercede the official\nstandard.  Publication was authorized by full letter ballot procedures.  Determination of the suitability of the material is solely the\nresponsibility of the user.\nR1-1  Supporting Both HSMS-GS and HSMS-SS\nSimultaneously\nR1-1.1          In     certain     applications,     the     equipment\nmanufacturer   may   be   faced   with   a   requirement   of\nproviding       both       HSMS-GS       and       HSMS-SS\ncommunications interfaces.  For example, a cluster tool\nmay  use  HSMS-GS  as  the  intra-tool  communications\nand  HSMS-SS  as  a  GEM  interface  to  the  factory.\nHowever,  implementing  a  communications  facility  that\nis     simultaneously     HSMS-SS-     and     HSMS-GS-\ncompliant is straightforward.\nR1-1.2  Assuming that one has implemented an HSMS-\nGS,  a  simple  test  can  be  added  to  the  first  Select.req\nreceived  by  the  equipment.    If  it  is  a  Select  for  any\nparticular SessionID, then operate as HSMS-GS.  If its\nvalue  is  a  -1,  then  copy  the  contents  of  the  Session\nEntity  List  corresponding  TCP/IP  IP  address  and  port\nnumber  into  the  Selected  Entity  List.    The  Selection\nCounter  would  be  set  to  a  special  value,  such  as  -1,  to\nindicate  selection  in  this  manner.    The  Separate  would\nprovide  the  reverse  function.    If  the  passive  entity  is\nimplemented as an HSMS-SS node and the active entity\nis   an   implementation   that   supports   both   modes   of\noperation, it must be explicitly configured to initiate the\nSelect with a Session ID of -1 and must have a Session\nEntity   List   containing   the   Device   IDs   of   all   the\navailable sub-devices within the passive mode entity.\nR1-1.3      In   the   local   API   for   the   case   where   the\nequipment  must  originate  the  select,  a  configuration\nparameter for the equipment could indicate which mode\nto use for a particular remote target."),(0,r.yg)("p",null,"NOTICE: SEMI      makes      no      warranties      or\nrepresentations  as  to  the  suitability  of  the  standards  set\nforth   herein   for   any   particular   application.      The\ndetermination of the suitability of the standard is solely\nthe  responsibility  of  the  user.    Users  are  cautioned  to\nrefer   to   manufacturer's   instructions,   product   labels,\nproduct   data   sheets,   and   other   relevant   literature,\nrespecting   any   materials   or   equipment   mentioned\nherein.    These  standards  are  subject  to  change  without\nnotice.\nBy    publication    of    this    standard,    Semiconductor\nEquipment and Materials International (SEMI) takes no\nposition  respecting  the  validity  of  any  patent  rights  or\ncopyrights   asserted   in   connection   with   any   items\nmentioned  in  this  standard.    Users  of  this  standard  are\nexpressly advised that determination of any such patent\nrights  or  copyrights,  and  the  risk  of  infringement  of\nsuch rights are entirely their own responsibility."),(0,r.yg)("p",null,"Copyright   by   SEMI\xae   (Semiconductor   Equipment   and   Materials\nInternational),  3081  Zanker  Road,  San  Jose,  CA  95134.    Reproductio\nn\nof  the  contents  in  whole  or  in  part  is  forbidden  without  express  written\nconsent of SEMI."),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 19961\nSEMI E38-1296\nCLUSTER TOOL MODULE COMMUNICATIONS (CTMC)\n1  Purpose"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"1   Cluster  tools  fulfill  a  need  for   modularity  and\nflexibility  in  semiconductor  manufacturing  equipment.\nThis  standard  addresses  the  communications  with  and\namong  modules  within  a  cluster  tool  for  automated\ncontrol."),(0,r.yg)("li",{parentName:"ol"},"2  The module communications s ervices defined here\nwill  enable  standard  interoperability  of  modules  from\nindependent  suppliers.  Together  with  other  cluster  tool\nstandards, this is intended to result in the emergence of\nstandards-compliant   interoperable   sub-systems.   They\nshould  allow  applications  software  to  be  developed\nwhich  can  assume  the  existence  of  these  services  and\nallow software products to be developed to offer them."),(0,r.yg)("li",{parentName:"ol"},"3    The   adoption   of   the   standards    described   will\ngreatly  reduce  the  effort  required  to  integrate  cluster\ntool     components     from     independent     suppliers.\nCompliance requires support of a minimal, but specific,\nset of standard services.\n2  Scope"),(0,r.yg)("li",{parentName:"ol"},"1  Cluster tool module communic ations address only\ncommunications  with  and  among  modules  within  a\ncluster  tool  and  not  the  communications  between  the\ncluster  tool  and  the  factory.  It  is  the  modules  and  their\ninterrelations  which  are  modeled  and  not  the  cluster\ntool seen as a single equipment."),(0,r.yg)("li",{parentName:"ol"},"2   This  standard  does  not  specify   cluster  controller\nfunctionality     (e.g.,     scheduling,     human     machine\ninterface,  cluster  tool  recipe  editing,  and  management)\nbut  will  enable  development  of  standards  in  this  area.\nThe cluster controller is included only to the extent that\nit   represents   the   entity   or   entities   responsible   for\nsupervisory control of the modules in a cluster tool."),(0,r.yg)("li",{parentName:"ol"},"3    This   standard   identifies   the   co mmunications\nservices  necessary  to  achieve  automated  control  of\nindependent transport, process, and cassette modules in\na    cluster    tool.    It    defines    the    essential    module\narchitecture and the concepts and models on which the\ncommunications services are based."),(0,r.yg)("li",{parentName:"ol"},"4   The  scope  includes  primary  co ntrol  services  for\nmaterial   processing   in   process   modules,   material\nmovement    within    the    cluster    tool,    and    material\ninput/output  with  the  factory.  Support  services  also\nexist  to  enable  recipe  handling,  resolution  of  exception\nconditions, event reporting, and data access."),(0,r.yg)("li",{parentName:"ol"},"5     A    reliable    communications    env ironment    is\nrequired  for  distributed  control  and  is  specified  in\nsupplementary standards."),(0,r.yg)("li",{parentName:"ol"},"6   This  standard  specifies  the  app lication  of  more\ngeneral  service  standards  as  required  within  a  cluster\ntool.   This   includes   the   limitations   imposed   by   the\ncluster     tool     architecture     and     the     fundamental\nfunctionality  needed  for  compliance.  The  details  of  the\ngeneral    services,    protocols,    and    communication\nenvironment elements are defined in the corresponding\nstandards documents referenced."),(0,r.yg)("li",{parentName:"ol"},"7  This version of the standard is  provisional because\na  number  of  the  general  services  on  which  it  relies  are\nnot  yet  standardized.  The  sections  referring  to  these\nservices  have  been  omitted  until  they  have  become\nstandards.  These  sections  will  be  balloted  separately\nwith     the     corresponding     general     services     and\nincorporated into this provisional standard."),(0,r.yg)("li",{parentName:"ol"},"8   The  communication  between  t he  cluster  tool  as  a\nsingle equipment and the factory is beyond the scope of\ncluster  tool  module  communications  standardized  here\nand   should   follow   the   applicable   SEMI   standards\n(GEM, MMMS)."),(0,r.yg)("li",{parentName:"ol"},"9   These  standards  place  no  restr iction  on  where,\nwithin the cluster tool control architecture, this specific\nset  of  definitions  is  implemented.  However,  to  have\ncomplete compliance to the standards in the area of the\ncommunications interface definitions, the entire layered\nstructure   as   outlined   in   this   document   must   be\nimplemented.\n3  Referenced Documents"),(0,r.yg)("li",{parentName:"ol"},"1  SEMI Standards\nSEMI    E21    \u2014    Cluster    Tool    Module    Interface:\nMechanical Interface and Wafer Transport Standard\nSEMI E22 \u2014 Cluster Tool Module Interface: Transport\nModule End Effector Exclusion Volume Standard\nSEMI E30 \u2014 Generic Model for Communications and\nControl of SEMI Equipment (GEM)\nSEMI    E32    \u2014    Material    Movement    Management\nStandard\nSEMI  E39  \u2014  Object  Services  Standard:        Concepts,\nBehavior, and Services")),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 19962\n4  Terminology\n4. 1  The following terms are those  that are appropriate\nfor  describing  the  overall  structure  of  cluster  tools.\nThese  terms,  in  addition  to  the  more  specific  terms\nlocated    in    the    individual    service,    protocol,    and\ncommunications  environment  standards,  complete  the\nglossary of terms required.\n4. 1.1   agent  \u2014  an  intelligent  system   within  a  factory\nthat  provides  one  or  more  service  resources  and  uses\nthe  services  of  other  agents.  A  generalization  of  host,\nequipment,    cell,    cluster,    cluster    module,    station\ncontroller,  work  station.  Agents  are  associated  with  a\nphysical  system  or  a  collection  of  physical  systems,\nincluding computer platforms.\n4. 1.2   alarm  \u2014  an  alarm  is  related  to   any  abnormal\nsituation  on  the  equipment  that  may  endanger  people,\nequipment, or material being processed. ","[SEMI E30]","\n4. 1.3   atomic  transfer  \u2014  the  basic  un it  of  movement.\nThe  transfer  of  a  single  material  between  two  partners\nwhere only one change in ownership occurs.\n4. 1.4   attached  module  \u2014  any  comp onent  of  a  cluster\ntool   which   mechanically   attaches   to   the   transport\nmodule at an interface flange. Specifically, the cassette,\nprocess, and docking modules are all attached modules.\nThe attached module can be isolated from the transport\nmodule by an isolation valve controlled by the transport\nmodule.  In  addition,  the  attached  module  may  also\npossess  an  additional  isolation  valve.  The  point  of\nseparation  between  the  isolation  valve  on  the  transport\nmodule  and  the  attached  module  is  called  the  interface\nplane.\n4. 1.5  am transfer job \u2014 a material t ransfer job for an\nattached module specifying all criteria for receiving the\nmaterial  from,  or  sending  the  material  to,  a  transport\nmodule.\n4. 1.6  carrier (material) \u2014 a device  for the holding of\nmaterial  for  various  processing  steps  in  semiconductor\nmanufacturing. ","[SEMI E1]","\n4. 1.7   cassette  module  \u2014  an  attached   module  which\nprovides the means of exchanging material between the\nintertool  environment  and  the  intratool  environment  of\na  particular  cluster.  There  is  no  requirement  that  the\nmaterial interface to the intertool environment with the\nuse of cassettes.\n4. 1.8    cm   input/output   transfer   job   \u2014    a   material\ntransfer job for a cassette module, specifying all criteria\nfor receiving the material from, or sending the material\nto, the factory.\n4. 1.9    cluster   controller   \u2014   the   entity    or   entities\nresponsible for supervisory control within a cluster tool,\nachieved   through   communicating   with   the   various\nmodules.  The  form  of  the  cluster  controller  is  not\ndictated.  It  may  be  a  single  platform,  distributed,  or\nincorporated with one or more modules.\n4. 1.10   cluster  tool  \u2014  an  integrated,  e nvironmentally\nisolated,  manufacturing  system  consisting  of  process,\ntransport,  and  cassette  modules  mechanically  linked\ntogether.  There  is  no  requirement  that  the  modules\ncome from the same supplier. ","[SEMI E21]","\n4. 1.11   decision  authority  \u2014  an  entity   requiring  to  be\nnotified  of  significant  exception  condition  changes  and\nwhich  decides  how  to  proceed  to  resolve  abnormal\nsituations  related  to  recoverable  error  conditions.  The\ndecision authority may be represented by a supervisory\ncontroller   interacting   with   an   operator   who   may\nultimately choose the recovery action.\n4. 1.12   docking  module  \u2014  a  compone nt  for  allowing\nthe exchange, within a cluster tool, of material between\nmultiple   transport   modules.   The   docking   module\npresents  an  attached  module  interface  to  both  transport\nmodules and is modeled as a multi-port process module\nfor intra-cluster tool communications.\n4. 1.13  end effector \u2014 a physical loca tion attached to a\ntransfer resource capable of holding material during an\nend-to-end material transfer.\n4. 1.14    error   condition   \u2014   an   exceptio n   condition\nwhich is not an alarm and which may support recovery\nactions requested by a decision authority.\n4. 1.15  exception condition \u2014 a mana ged condition for\nreporting  on  and  providing  recovery  from  an  abnormal\nsituation in the equipment.\n4. 1.16  factory \u2014 entities outside the  control domain of\nthe cluster tool and from which material is received for\nprocessing and returned upon process completion. Also\nconsidered to be the intertool environment.\n4. 1.17   factory  transport  resource  \u2014   n  operator  or  a\npiece   of   equipment   specialized   in   the   transport   of\nmaterial from one equipment to another.\n4. 1.18   form  \u2014  type  of  data  representi ng  information\ncontained  in  an  object  attribute  or  service  message\nparameter. The data types are detailed in Section 4.2.\n4. 1.19   fundamental  requirements  \u2014  t he  requirement\nfor  information  and  behavior  that  must  be  satisfied  for\ncompliance  to  a  standard.  Fundamental  requirements\napply   to   specific   areas   of   application,   objects,   or\nservices.\n4. 1.20   handoff  micro  move  \u2014  an  ope ration  requested\nby  an  attached  module  and  performed  by  a  transport\nmodule  to  achieve  all  or  part  of  a  material  handoff\nbetween them."),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 19963\n4. 1.21     interface    flange    \u2014    the    bounda ry    plane\nseparating  an  attached  module  and  a  single  transport\nmodule.\n4. 1.22   intertool  environment  \u2014  defin ed  relative  to  a\nparticular  cluster  tool  to  be  everywhere  outside  of  the\nintratool environment.\n4. 1.23  intertool material transfer job  \u2014  a  transfer  job\nin  the  cluster  controller  to  receive  material  from,  or\nsend the material to, the factory. In automated transfer,\nit may be an element of a factory transfer job.\n4. 1.24   intertool  port  resource  \u2014  a  m odule  resource\nassociated   with   a   particular   cassette   module   which\noperates  on  behalf  of  the  said  module  during  material\ntransfer  between  the  cassette  module  and  the  intertool\nenvironment.\n4. 1.25      intratool     environment     \u2014     the     e ntire\nenvironmentally  isolated  volume  contained  within  a\ncluster tool.\n4. 1.26   intratool  port  resource  \u2014  a  m odule  resource\nassociated   with   a   particular   interface   plane   of   a\nparticular attached module which operates on behalf of\nthe  said  module  during  material  transfer  between  the\ntransport module and the attached module.\n4. 1.27  intratool material transfer job  \u2014  a  transfer  job\nin  a  cluster  controller  for  transfer  of  material  from  one\nattached    module    to    another    through    the    linking\ntransport module.\n4. 1.28   isolation  valve  \u2014  a  mechanica l  component\nused  at  an  interface  plane  to  permit  environmental\nisolation between the transport module and an attached\nmodule.\n4. 1.29   material  handoff   \u2014   the   proces s   by   which\nmaterial moves from the sending transfer partner to the\nreceiving transfer partner.\n4. 1.30  material location \u2014 a physica l position capable\nof holding a single material.\n4. 1.31   material  slot \u2014 a material loca tion in a carrier\ncapable  of  holding  a  single  material  with  an  assigned\nidentifier.\n4. 1.32   module  \u2014  an  independently  o perable  unit  that\nis part of a tool or system. ","[SEMI E21]","\n4. 1.33   module  resource  \u2014  an  entity  w hich  provides\nspecific   capabilities   required   of   the   module   to   be\naccessed  or  controlled  externally.  This  includes  the\nphysical   capability   and   the   associated   control   and\naccess  management.  It  may  contain  material  in  one  or\nmore material locations.\n4. 1.34   namespace  \u2014  a  domain  within   which  object\nidentifiers are unique.\n4. 1.35  port \u2014 a point on the cluster a t which a change\nof  ownership  of  material  occurs.  A  port  is  not  itself  a\nlocation  but  must  have  an  associated  location,  such  as\nan interface plane.\n4. 1.36   process  job  \u2014  a  material  proc essing  job  for  a\nprocess module, specifying and tracking the processing\nto be applied to the material while in the module.\n4. 1.37   process  module  \u2014  an  attached   module  which\nprovides  manufacturing  value  to  material  in  a  cluster\ntool.\n4. 1.38    processing   resource   \u2014   a   mod ule   resource\nwithin  a  module  which  is  independently  capable  of\nproviding manufacturing value to material.\n4. 1.39    protocol   (communications)   \u2014   the   message\nencoding   used   when   transferring   a   message   across\nsome communication facility.\n4. 1.40   recipe  \u2014  the  pre-planned  and   reusable  portion\nof the set of instructions, settings, and parameters under\ncontrol   of   a   processing   agent   that   determines   the\nprocessing  environment  seen  by  the  material.  Recipes\nmay  be  subject  to  change  between  runs  or  processing\ncycles.\n4. 1.41   recipe  executor  \u2014  a  compone nt  of  a  module\nthat stores and executes recipes.\n4. 1.42   recipe  namespace  \u2014  a  logical   management\ndomain  with  the  responsibility  for  the  storage  and\nmanagement  of  recipes.  It  ensures  the  uniqueness  of\nrecipe  identifiers  and  provides  services  pertaining  to\nrecipes stored within that domain.\n4. 1.43  recovery action \u2014 an operatio n associated with\nan   error   condition   with   the   aim   of   resolving   the\nabnormal  situation  detected.  It  may  supply  information\nto the exception agent or request the exception agent to\nperform some activity.\n4. 1.44  service \u2014 the set of messages  and definition of\nthe  behavior  of  a  service  provider  that  enables  remote\naccess to a particular functionality.\n4. 1.45   service-provider  \u2014  the  softwa re  control  entity\nthat is the provider of any of the related services.\n4. 1.46   service-user  \u2014  the  software  co ntrol  entity  that\nis the user of any of the related services.\n4. 1.47   transport  module  \u2014  a  module   containing  one\nor  more  transfer  resources  and  a  number  of  interface\nplanes. It is capable of end-to-end transfer between any\nof the interface planes.\n4. 1.48   tm  transfer  job  \u2014  a  material  tr ansfer  job  for  a\ntransport module specifying all criteria for receiving the\nmaterial  from  the  source-attached  module  and  sending\nthe material to the destination module."),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 19964\n4. 1.49  transfer resource \u2014 a module  resource within a\ntransport  module  independently  capable  of  transferring\nmaterial from one attached module to another.\n4. 2  Data Type\n4. 2.1  form \u2014 type of data:  positive  integer, unsigned\ninteger,  integer,  enumerated,  boolean,  text,  formatted\ntext, structure, list, ordered list.\n4. 2.2   positive  integer  \u2014  may  take  th e  value  of  any\npositive   whole   number.   Messaging   protocol   may\nimpose a limit on the range of possible values.\n4. 2.3   unsigned  integer  \u2014  may  take   the  value  of  any\npositive   integer   or   zero.   Messaging   protocol   may\nimpose a limit on the range of possible values.\n4. 2.4  integer \u2014 may take on the val ue of any negative\nor  unsigned  integer.  Messaging  protocol  may  impose  a\nlimit on the range of possible values.\n4. 2.5  enumerated  \u2014  may  take  on  on e  of  a  limited  set\nof  possible  values.  These  values  may  be  given  logical\nnames, but they may be represented by any single-item\ndata type.\n4. 2.6   boolean  \u2014  may  assume  one  o f  two  possible\nvalues, equating to TRUE or FALSE.\n4. 2.7   text  \u2014  a  text  string.  Messaging   protocol  may\nimpose    restrictions,    such    as    length    or    ASCII\nrepresentation.\n4. 2.8   formatted  text  \u2014  a  text  string   with  an  imposed\nformat.  This  could  be  by  position,  by  use  of  special\ncharacters, or both.\n4. 2.9   structure  \u2014  a  complex  structu re  consisting  of  a\nspecific set of items, of possibly mixed data types, in a\nspecified arrangement.\n4. 2.10  list \u2014 a set of one or more item s that are all of\nthe same form (one of the above forms).\n4. 2.11   ordered  list  \u2014  a  list  for  which   the  order  in\nwhich items appear is significant.\n5  Conventions\n5. 1  Harel State Model\n5. 1.1    This   document   uses   the   Harel    State   Chart\nnotation to describe the dynamic behavior of the objects\ndefined. An overview of this notation is presented in an\nAppendix  of  SEMI  E30.  The  formal  definition  of  this\nnotation    is    presented    in    Science    of    Computer\nProgramming  8,  \u201cStatecharts:  A  Visual  Formalism  for\nComplex Systems,\u201d by D. Harel, 1987.\n5. 1.2   Transition  tables  are  provided   in  conjunction\nwith the state diagrams to describe explicitly the nature\nof  each  state  transition.  A  transition  contains  columns\nfor  Transition  #,  Current  State,  Trigger,  New  State,\nAction(s).    The  \u201ctrigger\u201d  (column  3)  for  the  transition\noccurs  while  in  the  \u201ccurrent\u201d  state.    The  \u201cactions\u201d\n(column  5)  include  a  combination  of  (1)  actions  taken\nupon  exit  of  the  current  state,  (2)  actions  taken  upon\nentry  of  the  new  state,  and  (3)  actions  taken  which  are\nmost    closely    associated    with    the    transition.    No\ndifferentiation is made.\n5. 2   OMT  Object  Information  Mod el  \u2014   The  object\nmodels   are   presented   using   the   Object   Modeling\nTechnique  developed  by  Rumbaugh,  James,  et  al.,  in\n\u201cObject-Oriented Modeling and Design,\u201d Prentice Hall,\nEnglewood   Cliffs,   NJ,   \xa91991.      Overviews   of   this\nnotation are provided in an appendix to SEMI E39.\n5. 3   Object  Attribute  Representatio n  \u2014   The  object\ninformation  models  for  standardized  objects  will  be\nsupported   by   an   attribute   definition   table   with   the\nfollowing column headings:\nAttibute NameDefinitionAccessRqmtForm\nThe formal\ntext name of\nthe attribute.\nDescription of\nthe\ninformation\ncontained.\nRO or RW   Y or N(see\nbelow)\nThe Access column uses RO (Read Only) or RW (Read\nand Write) to indicate the access that service-users have\nto the attribute.\nA   \u2018Y\u2019   or   \u2018N\u2019   in   the   requirement   (Rqmt)   column\nindicates  if  this  attribute  must  be  supported  in  order  to\nmeet fundamental compliance for the service.\nThe  Form  column  is  used  to  indicate  the  format  of  the\nattribute. (See Section 4.1 for definitions.)\n6  Overview\nThe  Cluster  Tool  Module  Communications  standard\nspecifies   the   communications   services   necessary   to\nachieve  automated  control  within  a  cluster  tool.  It\ndefines  the  essential  cluster  tool  architecture  and  the\nconcepts  and  models  on  which  the  communications\nservices are based.\nCluster tools provide a means of grouping a number of\nindependent process steps into a single equipment. The\nprimary function of a cluster tool is material processing.\nMaterial enters the cluster tool, undergoes a number of\nsequential   process   steps   which   adds   value   to   the\nmaterial, and then exits."),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 19965\nFrom  a  mechanical  viewpoint,  Cluster  Tool  Module  Interface  standards-compliant  equipment  has  a  physical\nstructure where process modules and cassette modules are attached in a standardized way to some form of transport\nmodule,  a  robotic  material  handler  operating  in  an  isolated  environment.  Cassette  modules  provide  the  input  and\noutput of material for the cluster tool, usually in cassettes.\nThis  communications  standard  enables  the  distributed  control  of  these  cluster  tools,  and  of  other  cluster  tools  and\nmulti-resource  equipment  which  can  be  decomposed  into  process,  transport,  and  cassette  modules,  whether\nenvironmentally  isolated  or  not.  A  basic  assumption  is  made  that  the  primary  human-machine  interfaces  are  not\nlocated at the individual modules.\nCommunication and control services are specified among service-users and service-providers within a cluster tool.\nThe  service-providers  are  the  controlled  processing,  transfer,  intratool  port,  and  intertool  port  resources  in  the\nappropriate  modules.  The  service-users  are  the  application  entities  responsible  for  supervisory  control  and  data\nacquisition within the cluster tool.\nThe  services  are  fully  defined  in  terms  of  the  service-providers,  and  as  such,  do  not  dictate  the  architecture  of  the\nservice-user(s).  An  example  of  cluster  tool  control  architecture  is  shown  in  Figure  1,  where  the  service-user  is  a\nsingle  cluster  controller  platform  providing  internal  scheduling,  human-machine  interface,  and  standardized\ncommunications interface to the factory.\nFigure 1\nExample Cluster Control Architecture\nThe   communication   services   include   primary   control   services   for   material   processing   in   process   modules\n(processing management) and material movement within the cluster tool and material input/output with the factory\n(material  movement  management).  The  cluster  controller,  which  is  responsible  for  supervisory  control  within  the\ncluster tool, is the service-user of these primary control services. The form of the cluster controller is not dictated. It\nmay be a single platform, distributed, or incorporated with one or more modules.\nSupport services are also specified to enable resolution of exception conditions, recipe handling, event reporting and\ndata access. The decision authority, which is responsible for making error recovery decisions, is the service-user for\nexception  management.  Appropriate  agents  are  the  designated  service-users  for  the  recipe  management  and  event\nreporting support services. All service-users access data using the Object Services.\nThe  communications  services  are  defined  independently  of  protocol  in  order  to  allow  future  standardization  of\nalternative  protocols  without  invalidating  the  services.  Figure  2  shows  the  full  communications  stack  needed  for\ncompliance, where the services are mapped to the communications environment, which is defined in supplementary\nstandards."),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 19966\nFigure 2\nCluster Tool Module Communications Standards\nThis standard describes the cluster tool model on which\nthe   communications   are   based.   It   then   defines   the\napplication  of  each  of  the  services  required  within  a\ncluster  tool.  This  includes  limitations  imposed  by  the\ncluster  architecture  as  well  as  clear  a  statement  of  the\nfundamental  requirements  in  order  to  minimize  the\nimplementation  effort.  Connection  establishment  and\nmaintenance are defined together with the requirements\nof  the  communications  environment.  Communications\nenvironment  is  described  in  a  subsection  in  order  to\nallow   additional   options   to   be   standardized   in   the\nfuture. The application notes include factory integration\nissues     and     an     example     scenario     of     standard\ncommunications for the lifecycle of a single material in\na cluster tool.\n6. 1       Compliance      \u2014      Cluster      tool      mo dule\ncommunications   compliance   between   entities   in   a\ncluster   tool   requires   that   all   applicable   exposed\ninterfaces  conform  to  the  standards  specified  in  this\ndocument.\nThe standardized interfaces are:\n\u2022 Process module to Service-user (cluster controller)\n\u2022 Transport     module     to     Service-user     (cluster\ncontroller)\n\u2022 Cassette module to Service-user (cluster controller)\n\u2022 Transport module to Cassette module\n\u2022 Transport module to Process module\nThe  exposed  interfaces  are  those  which  result  from  a\nparticular  partition  of  the  control  entities  in  a  cluster\ntool   which   are   from   independent   suppliers.   Three\nexamples follow:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"All  modules  independent,  single  cluster  controller\nplatform:      Interfaces   are   required   between   the\ncluster  controller  and  each  module,  and  between\nthe  transport  module  and  each  process  and  each\ncassette module."),(0,r.yg)("li",{parentName:"ol"},"Material   handler,   process   modules   independent,\nsingle  cluster  controller  platform:  Interfaces  are\nrequired  between  the  cluster  controller  and  each\nprocess module, between the cluster controller and\neach   logical   module   in   the   material   handler\n(transport  and  cassette  modules),  and  between  the\nmaterial handler and each process module."),(0,r.yg)("li",{parentName:"ol"},"One  independent  process  module  integrating  to  a\ncluster  tool  control  system:  Interfaces  are  required\nbetween  the  cluster  tool  control  system  and  the\nprocess  module  supporting  the  process  module  to\ncluster controller communications, and the process\nmodule to transport module communications.\nFor  fundamental  compliance,  each  exposed  interface\nshall  support  the  fundamental  requirements  of  each  of\nthe     service     groups     required     by     the     entities\ncommunicating.  The  required  service  groups  for  each\ninterface  are  detailed  in  Section  8.6,  and  the  required\nservices for each service group are detailed in Sections"),(0,r.yg)("li",{parentName:"ol"},"1 to 8.6.\n7  Concepts\nThe  Cluster  Tool  architecture  and  requirements  are\nmodeled  in  order  to  extract  only  the  entities  necessary\nfor     robust     automated     control     and     monitoring\ncommunications within a cluster tool.\nFigure  3  illustrates  the  major  module  domains  and  the\nprimary  relationships  between  them.  Module  resources\nand  material  domains  are  represented  differently  to\nothers because they embody the physical entities acting\nand being acted upon respectively.")),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 19967\nFigure 3\nCluster Tool Module Illustration\nThe domains illustrated are as follows:\nMaterial \u2014  The  material,  or  carrier  of  material,  which\nis being received and processed in the cluster tool.\nMaterial    Processing    \u2014     Specifies    the    required\napplication  of  processing  to  material  as  defined  by  the\nassigned recipe, adding value to the material.\nMaterial  Movement  \u2014   Includes  exchange  of  material\nwith  the  factory  and  material  movement  within  the\ncluster,  to  get  the  material  to  the  correct  processing\nresource at the right time.\nModule   Resources   \u2014    Perform   and   coordinate   the\nprocessing and material movement activities.\nRecipe Management \u2014 Provides the services to transfer\nrecipes to be loaded as required for material processing,\nand manages recipe change control.\nException    Handling    \u2014    Provides    for    interactive\nhandling  of  exception  conditions,  including  reporting\nand error recovery.\nEvent   Reporting   \u2014   Enables   flexible   event-based\nreporting of variable data as required by service-users.\nObject   Services   \u2014   Provide   services   to   obtain   and\nmodify standard object attribute data.\nEach  partition  is  presented  in  a  subsection  below  with\ndetailed information models.\nThe  concepts  are  presented  in  this  section  using  two\ntypes   of   formal   models:   OMT   object   information\nmodels  describing  entities  and  relationships,  and  Harel\nstate models describing the behavioral characteristics of\nthe  cluster  tool.  The  graphical  representations  of  these\nmodels are described in Conventions, Section 5.\nThe   events   and   actions   which   result   from   objects\ndynamically    interacting    form    the    basis    for    the\ncommunication     requirements     embodied     in     the\nstandards.   It   is   this   mapping   that   specifies   the\ncommunication services messages to be used.\nThe   major   requirement   of   the   cluster   tool   control\nsystem is that it provide robust supervisory control with\nminimal  overhead.  Within  a  cluster  tool  there  is  a\nsignificant amount of parallel processing. In addition to\nconcurrent  processing  in  multiple  independent  process\nmodules,  each  material  processing  requires  the  use  of\nrecipe  management  (to  get  the  correct  recipe  with  the\ncorrect  material)  and  the  use  of  material  movement  (to\nget   the   correct   material   to   the   correct   processing\nresource at the right time).\nThe  cluster  controller  maintains  the  overall  mission  of\nthe    system.    Sub-missions    are    defined    for,    and\nresponsibility   given   to,   particular   available   module\nresources  for  execution.  Once  this  responsibility  is\ngiven,   that   module   resource   is   fully   in   control,\nincluding direct communication with resources of other\nmodules as required to attain the objective.\n7. 1   Object  Information  Models  \u2014   T he  cluster  tool\nobjects  relevant  to  distributed  control  in  a  number  of\nmodels,  each  emphasizing  a  particular  aspect  of  the\nsystem as partitioned (see Figure 4)."),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 19968\nFigure 4\nObject Designation\nIn addition to OMT conventions (see Section 5.2), each\nobject  in  the  information  models  has  one  of  three\ndesignations:     service     objects     with     standardized\nattributes  (thick  border);  other  objects  described  in  the\nsub-section  (medium  border);  and  objects  described  in\nother   subsections   but   included   to   show   significant\nrelationships (thin border).\nThe models are process- and configuration-independent\nand   do   not   dictate   the   internal   architecture   of   the\ncontrolled modules beyond the physical requirements of\ncluster tools.\nThe   first   two   models   show   major   entities   of   the\nprocessing  equipment  and  material  being  processed.\nSubsequent  models  are  oriented  towards  one  of  the\nmajor functional domains.\n7. 1.1  Cluster Tool Module Model \u2014  The fundamental\ncomponent  of  a  cluster  tool  is  the  module.  Figure  5\nshows that there are three module types within a cluster\ntool:\nFigure 5\nCluster Tool Module Information Model"),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 19969\n\u2022 process  module  (PM)\u2014  provides  manufacturing\nvalue to material\n\u2022 transport module (TM) \u2014 transfers material within\ncluster\n\u2022 cassette  module  (CM)  \u2014  exchanges  material  with\nfactory\nA cluster tool must contain one or more of each of these\nmodule types, as each performs a critical function in the\ncluster    tool    mission.    Any    module    can    contain\nprocessing resources.\nSupervisory   control   within   the   cluster   tool   is   the\nresponsibility   of   the   cluster   controller.   The   cluster\ncontroller   achieves   this   by   supervising   the   various\nmodule  resources  using  the  standard  communications\nservices.  It  is  the  primary  service-user  in  the  cluster\ntool.  The  form  of  the  cluster  controller  is  not  specified\nin this standard. It may be a single platform, distributed,\nor incorporated with one or more modules.\nA module contains and coordinates a number of module\nresources  dedicated  to  fulfilling  a  particular  control\nfunction.    Each  module  resource  contains  at  least  one\nmaterial   location,   which   may   or   may   not   contain\nmaterial.  Note  that  the  location  for  material  processing\nis   defined   separately   from   the   location   where   the\nmaterial is received or sent. This may be virtual if they\nare  physically  the  same  position,  but  they  cannot  be\nassumed   to   be   so   as   this   would   exclude   certain\narchitectures.\nThe  purpose  of  each  type  of  module  is  described  in\ndetail below.\nCassette Module \u2014 The component of a cluster used to\ninterface  the  cluster  to  the  rest  of  the  factory.    It\nprovides  material  input  and  output  for  the  cluster.  It\nmakes  only  one  material  at  a  time  available  to  the\ncluster  transport  (the  intratool  environment),  regardless\nof  how  the  material  enters  the  cassette  module  from\noutside  the  cluster  (the  intertool  environment).  It  is  a\nspecialization of attached module (AM).\nProcess Module \u2014 A process module is any component\nwithin  a  cluster  which  provides  one  or  more  steps  of\nmaterial  processing  for  the  cluster  system.  Material\nenters  the  process  module  through  an  interface  flange,\nundergoes  some  transformation,  and  exits  through  the\nsame    or    another    interface    flange.    It    is    also    a\nspecialization of attached module (AM).\nTransport    Module    \u2014    The    transport    module    is\nresponsible  for  transfer  of  material  from  one  cluster-\nattached  module  to  another.  It  consists  of  a  robotic\nhandler capable of exchanging material with each of the\nattached  modules  at  the  interface  flanges.  It  can  be  a\nvariety  of  physical  topologies  (radial  or  linear,  for\nexample). In SEMI standard cluster tools, the transport\nmodule has an interface isolation valve at each point of\nattachment   to   the   attached   modules.   The   transport\nmodule  is  responsible  for  managing  constraints  on  the\nsimultaneous opening of isolation valves as it relates to\ncontamination of the transport module's environment by\nthat    of    an    attached    module,    as    well    as    cross\ncontamination between attached modules.\nThe  attributes  of  modules  and  related  objects  in  Figure\n5  are  not  standardized  as  these  objects  are  equipment\nand process-dependent.\n7. 1.2  Material Model \u2014  Material is  received from the\nfactory,  in  a  carrier  or  singly,  at  an  intertool  port\nresource.  They  are  transported  within  the  cluster  and\nprocessed  by  processing  resources.  Once  processed,\nthey are returned to the factory at the same, or another,\nintertool port resource.\nThe processing which is to be performed on material is\ndetermined   from   the   process   specification   for   that\nmaterial.\nThe   material      model   in   Figure   6   establishes   the\nrelationships    between    the    material    and    material\nlocations.  Two  material  types  are  of  interest  in  cluster\ntool   module   communications,   single   material   and\ncarriers.  Single  material  may  be  grouped  in  carriers.\nThis  is  modeled  by  defining  the  material  slot  object,\nwhich  is  a  type  of  material  location.  A  carrier  is  made\nup of an ordered set of material slots. A single material\noccupies a material slot when in the carrier. In addition,\na  single  material  may  be  assigned  a  particular  material\nslot which it does not yet occupy, indicating that it is to\nbe received into that material slot when it arrives.\nFigure 6\nMaterial Information Model"),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199610\nCarriers  may  be  cassettes  used  to  transport  single  material  in  the  factory  and  to  input  single  material  to  the  cluster\ntool, or they may be material boats in batch process modules.\nThe  attributes  of  the  material  slot  object  are  standardized  to  enable  mapping  of  single  material  in  carriers.  Other\nobjects in the diagram are not standardized. However, the identifier of the material, MaterialID, is an attribute of the\nmaterial slot object.\nOther  materials  (consumable  gases  and  fluids,  etc.)  are  present  in  the  cluster  tool,  but  outside  the  scope  of  these\nstandards.\n7. 1.3  Material Processing Model \u2014  The material processing model in Figure 7 shows the use of the process job to\ndirect the processing resource to apply the appropriate process, as specified by the recipe, to one or more materials\nin a process module. A processing resource in a process module has processing capabilities which are specified by\ncorresponding recipes.\nFigure 7\nMaterial Processing Information Model\nA process job can control multiple material only if identical processing is applied to all. Processing should begin and\nend simultaneously, synchronized with the arrival of the whole group of material.\nThe  process  job  lifecycle  extends  beyond  the  active  processing  of  the  material.  It  exists  from  just  before  material\narrival at the intratool port resource, through setup and processing, and until just after the material departure at the\nsame, or another, intratool port resource. This allows for material-related pre-conditioning and post-conditioning of\nthe processing resource before the material is received and after it is sent. As material input and output is controlled\nby  the  intratool  port  resource,  it  is  the  responsibility  of  the  process  module  to  ensure  coordination  of  the  intratool\nport and processing resources.\nThis  is  the  model  used  to  establish  the  Processing  Management  definition.  There  is  no  standardization  beyond\ncreation  and  control  (starting,  canceling,  stopping,  aborting,  and  pausing)  of  the  high-level  process  job  since  the\nlow-level control of process modules is application-dependent.\nThere  is  a  component  of  scheduling  embodied  in  this  model.  The  material,  recipes,  and  processing  resources  are\nscheduled by the cluster controller according to the process specification to a particular process module through the\nuse of the process job. In order to perform the required processing, material is transferred to the processing resource,\nas directed by the cluster controller."),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199611\n7. 1.4  Material Movement Models \u2014  Material movement in a cluster tool includes all services required within the\ncluster tool to move material from the factory to a sequence of process modules in order to be processed and then\nback  to  the  factory.  Material  is  moved  individually  within  a  cluster  tool  and  may  be  received  from  the  factory  in\ncassettes or individually.\nThe material movement model is divided into three parts as follows:\n\u2022 intratool material movement defines the transfer of material between attached modules, with the transfer agent\nbeing a transport module.\n\u2022 intertool material movement defines the exchange of carriers and single material with the factory at the cluster\ntool cassette module.\n\u2022 carrier mapping defines presence and identifiers of single material contained in carriers.\nThese three models are used to establish the Material Movement Management definition within a cluster tool.\n7. 1.4.1  Intratool Material Transfer \u2014  The  intratool  material  movement  model  is  shown  in  Figure  8.  An  intratool\nmaterial  transfer  is  the  movement  of  material  from  one  attached  module  to  another  attached  module  through  the\nlinking transport module.\nFigure 8\nIntratool Material Movement Information Model\nThe cluster controller schedules an intratool material transfer job when intratool material transfer is required. This is\nachieved  by  TM  and  AM  transfer  jobs  assigned  to  the  appropriate  module  resource  in  each  of  the  participating\nmodules:\n\u2022 to the transfer resource in the transport module to get the material from the source attached module and put it\ninto the destination attached module.\n\u2022 to the intratool port resource in the source attached module to send the material to the transport module."),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199612\n\u2022   to  the  intratool  port  resource  in  the  destination  attached  module  to  receive  the  material  from  the  transport\nmodule.\nTransfer  jobs  are  made  up  of  atomic  transfers.  An  atomic  transfer  in  one  transfer  partner  synchronizes  with  the\ncorresponding atomic transfer in the other partner to achieve the material transfer through handoff micro moves. In a\ncluster  tool,  the  attached  module  is  the  primary  partner,  requesting  the  handoff  micro  moves,  and  the  transport\nmodule is the secondary partner achieving those micro moves by controlling the end effector on which the material\nis transported.\nThe transport module is responsible for managing constraints on the simultaneous opening of isolation valves as it\nrelates  to  contamination  of  the  transport  module's  environment  by  that  of  an  attached  module,  as  well  as  cross\ncontamination  between  modules.  The  attached  module  ensures  that  its  environment  will  not  contaminate  the\ntransport  module  before  synchronizing  for  handoff.  The  rules  for  re-establishing  isolation  at  verification  are\ndetermined by the transport module.\n7. 1.4.2   Intertool  Material  Transfer  \u2014   The  cassette  module  performs  material  exchange  with  the  factory.  The\nmaterial  generally  consists  of  cassettes  with  single  material  or  empty  cassettes,  but  may  be  individual  single\nmaterial. The intertool material movement model, shown in Figure 9, is similar to the intratool material movement\nmodel. An intertool material transfer is a transfer in the factory which includes the cluster tool as one of the transfer\npartners.\nFigure 9\nIntertool Material Movement Information Model\nIn the cluster tool, the cluster controller schedules an intertool material transfer job when material exchange with the\nfactory  is  required.  This  job  may  be  an  element  of  a  factory  material  transfer  job  in  which  the  cluster  tool  is  a\npartner.\nThe  intertool  material  transfer  job  is  achieved  by  a  CM  input/output  transfer  job  assigned  to  the  intertool  port\nresource  in  the  participating  cassette  module.  It  defines  the  material  exchange  with  the  factory  for  the  cassette\nmodule.  The  CM  input/output  transfer  job  comprises  an  atomic  transfer,  which  defines  the  roles  in  the  material\nhandoff.\nIn the cassette module, material transfer with the transport module is controlled by the intratool port resource. It is\nthe responsibility of the cassette module to coordinate its intertool and intratool port resources."),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199613\nThe   factory   transfer   resource   may   be   an   operator,\nSMIF,   AGV,   or   other   mechanism.   Its   definition,\nassociated transfer jobs, and the handoff, are beyond the\nscope of this standard. Factory material movement may\nbe   achieved   automatically   using   applicable   SEMI\nstandards.\n7. 1.4.3   Carrier  Mapping  \u2014   The   final    element   of\nmaterial  movement  in  a  cluster  tool  is  the  mapping  of\nsingle  material  in  a  carrier.  Once  a  cassette  is  received\nby  the  cluster  tool,  it  is  necessary  to  communicate  the\npresence  and  identifiers  of  the  material  it  contains.\nBatch   process   modules   also   require   these   carrier\nmapping  services  in  order  to  define  loading  of  the\nprocess carrier.\nIn carrier mapping, the carrier may be a cassette used to\nhold single material loaded at the cassette module from\nthe  factory,  or  a  process  carrier  used  to  hold  multiple\nmaterial  for  batch  processing.  For  the  purposes  of\ncarrier    mapping,    these    are    equivalent,    and    the\nrelationships are shown in the material model, Figure 6.\nA   carrier   has   an   ordered   set   of   material   slots,   a\nspecialization  of  material  location,  each  of  which  can\nhold  a  single  material.  The  material  slot  of  a  carrier  is\nonly of interest when the carrier is in the cluster tool, so\nit is viewed as a location of the module which contains\nthe  carrier.  In  addition  to  occupancy,  a  single  material\nmay  be  assigned  to  a  material  slot,  indicating,  for\nexample,  the  particular  slot  to  which  a  single  material\nis to be moved when available. Information on material\npresence  and  assignment  of  the  material  identifier  may\nbe  detected  in  the  module  or  determined  by  the  cluster\ncontroller or a supervisory controller.\n7. 1.5   Exception  Model  \u2014   In  an  auto mated  control\nsystem  where  the  operator  interface  is  remote  from  the\nmodule  controller,  it  is  necessary  to  have  interactive\nexception  handling  for  error  recovery.  In  addition  to\nexception  reporting,  a  module  requires  input  from  a\ndecision   authority   to   resolve   recoverable   abnormal\nsituations.  These  include  exception  conditions  which\nextend beyond the module domain and those for which\nthe  module  has  insufficient  information,  such  as  in\nhardware failure.\nThe  decision  authority  in  a  cluster  tool  is  the  cluster\ncontroller. It may interact with an operator to determine\nthe appropriate recovery action to perform.\nFigure    10    shows    the    exception    model.    Module\nresources    detect    appropriate    exception    conditions,\nwhich  may  be  set  or  cleared.  An  abnormal  situation  is\nindicated   by   the   corresponding   exception   condition\nbeing in the set state. A significant change in exception\ncondition  information  generates  an  exception  report  to\nnotify  the  decision  authority.  Both  detection  of  the\nabnormal situation and its resolution generate exception\nreports.  Reporting  of  each  exception  condition  may  be\nenabled  and  disabled  independently  in  order  to  mask\nnuisance exceptions.\nFigure 10\nException Information Model"),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199614\nError    exception    conditions    may    have    associated\nrecovery actions which can be performed by the module\nresource   to   attempt   to   recover   from   the   abnormal\nsituation.   Alarm   exception   conditions   cannot,   by\ndefinition, be resolved using recovery actions.\nA  list  of  possible  recovery  actions  is  included  in  a\nposted  error  report.  The  decision  authority  can  request\none of the offered recovery actions to resolve the error\ncondition. The selected recovery action is performed by\nthe  appropriate  module  resource  and  may  result  in\nclearing the error condition.\nThis    model    is    used    to    establish    the    Exception\nManagement definition.\n7. 1.6      Recipe     Management     Model     \u2014      Recipe\nmanagement  in  a  module  varies  with  the  requirements\nof the application. Simple modules do not provide local\nrecipe   editing   and   don\u2019t   require   management   of\nmultiple logical domains (namespaces) and local recipe\nversion control.\nFigure 11 shows the full recipe management model for\na sophisticated module.\nFigure 11\nRecipe Management Information Model\nProcess  recipes  specify  the  actual  parameters  of  the\nprocessing   to   be   achieved.   The   module   processing\nresource   identifies,   through   the   process   job,   the\nrequired recipe(s) to be loaded by the recipe executor in\norder to process a particular material.\nThe  recipe  executor  accesses  and  selects  recipes  for\nexecution.  It  uploads  and  downloads  recipes  from  the\ncluster  controller  and  is  capable  of  verifying  that  a\nrecipe is syntactically correct. The recipe executor also\nprovides  for  a  service-user  to  select  a  recipe  to  be\nloaded  into  the  recipe  execution  area.  The  recipe  is\nmade  up  of  a  recipe  body  and  may  have  headers  if  the\nmodule supports recipe namespace management.\nThe    module    accesses    recipe    namespaces    where\nrequested  by  service-users.  A  module  which  does  not\nprovide  local  editing  and  linking  of  recipes  does  not\nneed recipe namespace management. Recipe namespace\nmanagement  requires  management  of  recipe  generic\nand  agent  (module)  specific  headers.  For  example,  a\nprocess   module   could   manage   a   recipe   namespace\ncontaining its process and service recipes.\nThis model is used to establish the Recipe Management\nservices requirements for cluster tool modules.\n7. 1.7  Event Reporting Model\nFigure 12\nEvent Reporting Information Model\nEvent reporting provides a dynamic and flexible means\nby  which  a  service-user  can  receive  notification  of\nevents and data relating to module resources.\nThe  services-user  can  define  and  enable  two  types  of\nreporting, event reporting and trace reporting. Both may\nconvey  data,  the  values  of  identified  variables  at  the\ndata collection time. The variable identifiers required to\nbe reported are specified in the data report definition.\nIn  event  reporting,  data  reports  are  linked  to  event\nreport  definitions  associated  with  each  collection  event\ntype.  On  occurrence  of  the  collection  event,  an  event\nreport  message  is  generated  according  to  the  event\nreport  definition  and  the  linked  data  report  definitions.\nReporting   may   be   enabled   and   disabled   for   each\ncollection  event  type.  Data  reports  and  links  may  be\npredefined or specified dynamically by the service user.\nTrace  reporting  is  time-based  data  reporting.  Trace\nreporting  is  specified  by  the  service-user  dynamically"),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199615\nas    required.    Collection    events    may    initiate    and\nterminate   the   tracing   in   order   to   link   reporting   to\nsignificant  conditions,  such  as  processing.  The  trace\ndata is collected at a frequency specified by the service-\nuser. Trace reports are generated according to the trace\nreport    definition    and    the    associated    data    report\ndefinition.\nThrough  associating  the  event  report  and  trace  report\ndefinition with the service-user, the model provides for\nthe  association  of  multiple  service-users  to  a  single\nservice-provider.   This   allows   for   event   reporting\nbetween  modules  where  needed  as  well  as  the  ability\nfor   direct   connection   of   a   data   acquisition   entity\nindependent of the cluster controller.\n7. 2    Cluster   Tool   Module   Message    Flow   \u2014    The\nappropriate  objects  in  the  information  models  in  the\nprevious section are grouped in the cluster tool module\ntypes.  The  communications  with  the  essential  objects\nare shown in the message flow diagrams in this section.\nThe   diagrams   show   message   flow   between   entities\nwithin  an  agent  (in  this  case  a  module)  and  those\noutside  the  agent.  Entities  are  rectangular  boxes,  and\nthe  agent  is  a  rounded  box.  As  emphasis  is  on  the\nmodule  and  its  services,  only  one  agent  is  shown  on\neach   diagram.   Outside   entities   in   the   cluster   tool\nmodule communications domain appear within an agent\non another diagram. The messaging is shown by arrows\nin  each  direction,  with  a  brief  label  indicating  the\nservices requested or provided.\nThe communications are shown for the primary control\nof  the  process  module  (Figure  13),  cassette  module\n(Figure 14), and transport module (Figure 15). Note that\nthe  transport  module  transfer  resource  communicates\nwith multiple process and cassette module intratool port\nresources.\nFigure 13\nProcess Module Primary Control Message Flow\nFigure 14\nCassette Module Primary Control Message Flow"),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199616\nFigure 15\nTransport Module Primary Control Message Flow\nFigure 16\nModule Exception Message Flow\nFigure 17\nModule Recipe Message Flow\nFigure 18\nModule Event Reporting Message Flow\nThe   communications   for   support   functionality   are\nshown  for  any  module,  as  the  services  are  common  to\nall  module  types.  The  support  functionality  modeled\nincludes    exception    handling    (Figure    16),    recipe\nmanagement  (Figure  17),  and  event  reporting  (Figure\n18).  A  typical  decision  authority  or  service-user  is  the\ncluster controller.\n7. 3   Cluster  Tool  Behavioral  Mode l  \u2014   The  process\nmaterial  is  the  fundamentally  important  object  in  a\ncluster  tool  and  its  lifecycle  is  the  key  component  to\nestablishing  cohesiveness  in  the  communication  and\ncontrols standards.\nThe  finite  state  model  in  Figure  19  presents  the  high-\nlevel behavior of a single material within the domain of\nthe   cluster   tool.   Bold   transitions   trace   the   normal\nlifecycle   of   the   material   and   are   described   in   the\ntransition  table,  Table  1.  Other  transitions  occur  in\nexception  situations  and  are  not  detailed  here.  The\ntransition  table  actions  indicate  the  primary  control\noperations  which  are  requested  of  the  modules  by  the\ncluster controller."),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199617\nFigure 19\nCluster Tool Material State Model\nWhen  ready  to  be  processed  in  the  cluster  tool,  the  material  is  presented  and  loaded  at  the  input  cassette  module\n(intertool material transfer). It is usually contained with other single material in a cassette. The material process sub-\nstate in the scope of this visit to the cluster tool is initially unprocessed. The material is then transferred to the first\nprocess  module  (intratool  material  transfer),  ready  for  process.  At  this  point,  the  material  may  be  returned  to  the\ninput cassette module and back to the factory, as the material has not been physically altered.\nThe material then begins processing in the process module according to the recipe for that process step (process job),\nand the process sub-state changes to in-process.\nOn  successful  completion  of  the  process  step,  the  material  is  then  ready  to  be  transferred  to  the  next  module\n(intratool material transfer). This may be another process module for the next process step or to the output cassette\nmodule if processing in the cluster tool is complete, in which case the process sub-state changes to processed. It is\nalso possible that the next process step be performed in the same process module.\nTable 1  Cluster Material State Transition Table\n#Current StateTriggerNew StateAction(s)\n1    Ready for\nProcessing in cluster\nMaterial being received at cluster CM.  In cluster toolCM Input/Output Transfer Job. CM\nCarrier mapping.\n2    Not in Cluster toolMaterial being received at cluster CM.  Arrived input CM\n3    Not in Cluster toolMaterial being received at cluster CM.  Unprocessed\n4   Arrived input CMInitiate material transfer to PM.Transferring\nbetween modules\nInitiate PM Process Job. TM Transfer\nJob. Source AM Transfer Job (CM send).\nDest. AM Transfer Job (PM receive).\n5   Transferring\nbetween Modules\nMaterial arrived in PM.In PM/Arrived input\nport\n6   In PM/Arrived input\nport\nProcessing initiated on material.In PM/ProcessingPM Process the material.\n7   UnprocessedProcessing initiated on material.In Process\n8   In PM/ProcessingPM processing complete.In PM/Ready output\nport\n9   In ProcessAll required process steps in cluster\ncompleted.\nProcessed\n10  In PM/Ready output\nport\nInitiate intratool material transfer.Transferring\nbetween modules\nInitiate next PM Process Job if material\nprocessing still required. TM Transfer\nJob. Source AM Transfer Job (send).\nDest. AM Transfer Job (receive)."),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199618\n#Current StateTriggerNew StateAction(s)\n11  Transferring\nBetween Modules\nArrived output CM.Arrived output CM   CM Input/Output Transfer Job.\n12  Arrived output CM   Transfer back to factory complete.Processing in cluster\ncomplete\nThe   material   is   finally   unloaded   from   the   output\ncassette   module   to   the   factory   (intertool   material\ntransfer).  If  all  process  steps  in  the  cluster  tool  were\ncompleted  and  were  successful,  the  processing  in  the\ncluster  tool  is  complete;  otherwise,  processing  in  the\ncluster tool was only partially accomplished.\nDetailed   behavioral   models   are   documented   in   the\nindividual    Cluster-Specific    Services    and    in    the\nstandards  which  they  reference.  The  Typical  Operating\nScenario    in    the    application    notes    illustrates    the\nbehavioral  characteristics  of  cluster  tool  control  by\nshowing  the  detailed  messaging  among  modules  and\nsupervisory  controller  through  the  lifecycle  of  material\nas it enters the cluster, is processed, and then leaves the\ncluster.\n7. 4   Cluster  Tool  Control  Topology  \u2014  The  natural\ndecomposition of a cluster tool is into its modules. The\nmodule  controller  is  the  entity  which  performs  internal\ncontrol  of  a  module  and  provides  standard  services.\nModule  controllers  provide  certain  application-specific\nfunctions  (providers  of  services  and  user  of  services)\nand  consist  of  hardware  and  software  components  that\ninteract     with     the     communications     and     control\nenvironment of the cluster tool.\nTraditional   definitions   of   controllers   have   implied\ncertain  PHYSICAL,  hardware  control  topologies  (such\nas  distributed  or  centralized  processors).  These  cluster\ntool  standards  specify  the  communications  in  terms  of\nservices-providers,  enabling  the  module  controllers  to\nbe based on LOGICAL control topologies.\nThe list of possible physical controllers which could be\nused to implement the logical services of the standards\nare  listed  below.  It  is  emphasized,  however,  that  the\nstandard  is  not  based  on  any  constraint  that  each  of\nthese physical controllers be present in a cluster control\nsystem,  but  instead  requires  that  the  logical  services\n(i.e.,   software   functional   components)   be   present\nsomewhere in the cluster control system.\nPossible Controllers:\n\u2022 Cassette Module Controller\n\u2022 Process Module Controller\n\u2022 Transport Module Controller\n\u2022 Cluster Controller\nThe logical control topology allows any combination of\nmodule  controllers  on  a  single  control  unit.  Standard\ncommunication is not required among them. A common\nexample   is   the   grouping   of   transport   module   and\ncassette  module  control  into  a  single  material  handler\ncontrol   unit   as   shown   in   Figure   1.   For   interface\ncompliance,   all   communication   between   a   logical\nmodule controller and remote controller or service-user\nmust be compliant with the standard services.\n8  Cluster Tool Module Serv ices\nThe    Cluster    Tool    control    system    elements,    as\nrepresented     in     the     object     information,     object\ncommunications,    and    behavioral    models,    require\nstandard services in order to interface with one another.\nThe  objects  which  are  fully  standardized  (attributes,\nbehavior, and operations) are only those essential to this\ncommunication,  and  the  services  are  the  interactions\nwith these standard objects.\nThe  services  are  grouped  into  the  following  functional\nareas:\n\u2022 Object Services\n\u2022 Processing Management\n\u2022 Material Movement Management\n\u2022 Exception Management\n\u2022 Recipe Management\n\u2022 Event Reporting\n\u2022 Clock\nThe  services  of  each  of  these  groups  are  described  in\ndetail  in  this  section.  The  services  are  defined  in  terms\nof  services  provided  by  independent  SEMI  standards,\nspecifying their application and limitations with respect\nto the fundamental requirements of cluster tool module\ncommunications.\n8. 1  Object Services \u2014  All standar dized service object\nattribute    access    across    a    cluster    tool    module\ncommunications   interface   is   achieved   using   object\nservices.  Access  may  be  to  read  attribute  values  of\nobjects,  to  get  a  list  of  objects  corresponding  to  certain\ncriteria,  and  to  set  the  values  of  writable  attributes  of\nobjects.  The  message  services  provided  to  accomplish\nthis are Get and Set."),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199619\nThe   specific   object   types,   relations,   attributes,   and\naccess rules are defined in each specific services group.\nThe  object  services  are  defined  in  SEMI  E39  (Object\nServices  Standard:  Concepts,  Behavior,  and  Services).\nCluster  tool  module  communications  require  only  the\nfundamental requirements of that standard except where\nstated in a specific services group below.\n8. 2   Processing  Management  Servi ces  \u2014   Processing\nmanagement  across  a  cluster  tool  module  communica-\ntions   interface   is   achieved   using   the   processing\nmanagement   services.   These   services   provide   the\ncommunications  and  behavior  required  of  the  process-\ning resource by the material processing models through\ndefining the process job object and its operations.\nThe processing management services follow SEMI E40\n(Standard  for  Processing  Management).  Cluster  tool\nmodule  communications  require  full  compliance  with\nthe  information,  behavior,  and  messaging  services  of\nthe fundamental requirements of that document.\nThe  process  job  creation  is  requested  by  the  cluster\ncontroller   using   the   PRJobCreate   service.   If   the\nprocessing  resource  accepts  the  job,  it  performs  the\nrequired  processing  to  completion  once  the  material\narrives.   The   processing   resource   shall   support   the\nPRJobCommand   Abort   service,   which   ceases   any\nprocessing   and   terminates   the   job.   The   processing\nresource reports process job milestones achieved to the\ncluster controller using the PRJobAlert service.\nProcess  job  object  attributes  required  to  be  accessible\nthrough object services follow:\nAttribute NameDescription: Requirements\nObjTypeThe object type: process job.\nPRJobIDIdentifier for the process job.\nPRMtlTypeMaterialType.\nPRMtlNameListMaterial identifier: single material only.\nPRRecipeMethodRecipe specification type: recipeID\nonly.\nRecIDIdentifier of the recipe applied.\nPRJobStateListAll concurrent substates of the process\njob.\nProcessing management messaging services required:\nMessage NameDescription: Requirements\nPRJobCreateCreate process job: single material,\nrecipe identifier only, auto-start.\nPRJobCommandCommand on a process job: abort.\nPRJobAlertNotification: setup, processing,\nprocessing complete, complete.\nProcessing   resource   capabilities   required,   but   not\nalready specified above:\n\u2022 Detect  and  report  success  or  failure  of  a  process\njob.\n\u2022 Reject    incomplete,    invalid,    and    unsupported\nrequests.\nProcessing resource capabilities permitted, but not to be\nrequired, by a service-user:\n\u2022 Pre-conditioning and post-conditioning.\n\u2022 Stop, Pause, and Resume of a process job.\n\u2022 Manual process start.\n\u2022 Process job queuing and queued job Cancel.\n\u2022 Process tuning.\n\u2022 Processing of material groups.\n\u2022 Multiple concurrent process jobs.\n\u2022 Multiple consecutive process jobs.\n\u2022 Process job with no material.\n\u2022 Notification  of  waiting  for  material  and  of  process\njob state changes.\n8. 3   Material  Movement  Services  \u2014   Each  material\nmovement  in  a  cluster  tool  involves  interaction  among\nthe    cluster    controller    and    all    of    the    modules\nparticipating   in   the   transfer.   The   communications\ninterfaces   and   behavior   resulting   from   the   material\nmovement  models  are  defined  for  each  association  by\nthe material movement services.\nThe  material  movement  services  are  partitioned  into\nintratool material movement services, intertool material\nmovement  services,  and  carrier  mapping,  as  in  the\nmodels.\nThe  material  movement  services  follow  the  Material\nMovement   Management   Standard   ","[SEMI   E32]","   and\nObject   Services   Standard:   Concepts,   Behavior,   and\nServices     ","[SEMI     E39]",".     Cluster     tool     module\ncommunications   require   full   compliance   with   the\ninformation,  behavior,  and  messaging  services  of  the\nfundamental requirements of those standards.\n8. 3.1   Intratool  Material  Movement  S ervices  \u2014   From\nthe  intratool  material  movement  models,  an  intratool\nmaterial  transfer \u2014 the  transfer  of  material  from  one\nattached  module  to  another  through  a  transport  module\n\u2014 requires the following interactions:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"The cluster controller decides that material is to be\nmoved  as  the  result  of  either  arrival  of  material  or\nthe  completion  of  some  processing  step  on  the\nmaterial.  It  determines  which  material  is  to  be")),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199620\nmoved   and   the   source   and   destination   of   that\nmovement (cluster-application-specific). It requests\nall the modules involved to perform the appropriate\nTM or AM transfer job.\n2. The   source-   and   destination-attached   modules\ninform the transport module that they are prepared\nto  do  their  specific  activities  during  the  material\ntransfer.  The  transport  module  informs  the  source-\nand   destination-attached   modules,   each   at   the\nappropriate point in time, that it is synchronized for\nmaterial handoff.\n3. The  detailed  transactions  required  to  handoff  the\nmaterial during the transfer are accomplished, first\nat the source and then at the destination.\nThese    interactions    may    require    a    number    of\ncommunications    interfaces    for    intratool    material\ntransfer from the following:\n\u2022 Cluster controller to transport module\n\u2022 transfer  resource:    TM  transfer  job  source  AM\nto destination AM\n\u2022 Cluster controller to source-attached module\n\u2022 intratool port resource:  AM transfer job send\n\u2022 Cluster controller to destination-attached module\n\u2022 intratool port resource:  AM transfer job receive\n\u2022 Transport module to source-attached module\n\u2022 intratool port to transfer resource: handoff get\n\u2022 Transport module to destination-attached module\n\u2022 intratool port to transfer resource: handoff put\nThe     material     movement     services     define     the\ncommunications  and  behavior  required  of  the  attached\nmodule intratool port resource and the transport module\ntransfer resource. They define the TM transfer job, TM\natomic   transfer,   AM   transfer   job,   and   AM   atomic\ntransfer  objects  and  their  operations,  as  well  as  the\nhandoff  operations  between  the  transfer  resource  and\nthe intratool port resource.\nEach interface is described below.\nCluster  Controller  to  Transport  Module  Interface  \u2014\nThe TM transfer job creation is requested by the cluster\ncontroller using the TRJobCreate service. If the transfer\nresource accepts the job, it performs the transfer of the\nmaterial  to  completion,  coordinating  with  the  attached\nmodules.  The  TM  transfer  job  comprises  two  atomic\ntransfers  for  the  material,  one  to  get  (receive)  it  from\nthe source-attached module and another to put (send) it\nto the destination-attached module.\nThe transfer resource shall support the TRJobCommand\nAbort  service,  which  ceases  any  transfer  activity  and\nterminates the job. The transfer resource reports transfer\njob  milestones  achieved  to  the  cluster  controller  using\nthe TRJobAlert service.\nThe transfer resource coordinates material handoff with\neach     attached     module     through     the     transport\nmodule/attached module interface, described below.\nTM   transfer   job   object   attributes   required   to   be\naccessible through object services:\nAttribute NameDescription: Requirements\nObjTypeThe object type: transfer job.\nTRJobIDIdentifier for the transfer job.\n(Ordered list of)\nTRAtomicID\nOrdered list of identifiers for the\natomic transfers in the transfer job:\ntwo atomic transfers for the material.\n(List of)TRJobStateAll concurrent substates of the\ntransfer job.\nTM  atomic  transfer  object  attributes  required  to  be\naccessible through object services:\nAttribute NameDescription: Requirements\nObjTypeThe object type: atomic transfer.\nTRAtomicIDIdentifier for the atomic transfer.\nTRLinkIdentifier to coordinate handoff.\nTRObjTypeMaterial Type.\nTRObjNameMaterial identifier.\nTRRoleRole in transfer control: secondary.\nTRPartnerIdentifies partner-attached module.\nTRDirectionHandoff direction: receive from\nsource AM, send to destination AM.\nTRTypeActive/passive in transfer: active.\n(List of)TRAtomic-\nState\nAll concurrent substates of the atomic\ntransfer.\nMaterial movement messaging services required:\nMessage NameDescription: Requirements\nTRJobCreateCreate transfer job: single material,\nsource to destination AM, auto-start.\nTRJobCommandCommand on transfer job: abort.\nTRJobAlertNotification: started, complete.\nTransfer  resource  capabilities  required,  but  not  already\nspecified above:\n\u2022 Detect  and  report  success  or  failure  of  a  transfer\njob."),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199621\n\u2022 Reject    incomplete,    invalid,    and    unsupported\nrequests.\nTransfer  resource  capabilities  permitted,  but  not  to  be\nrequired, by a service-user:\n\u2022 Stop, Pause, and Resume of a transfer job.\n\u2022 Manual atomic transfer start.\n\u2022 Transfer job queuing and queued job Cancel.\n\u2022 Transferring of material groups.\n\u2022 Multiple concurrent transfer jobs.\n\u2022 Notification of transfer events.\nCluster Controller to Attached Module Interface \u2014  The\nAM  transfer  job  creation  is  requested  by  the  cluster\ncontroller   using   the   TRJobCreate   service.   If   the\nintratool  port  resource  accepts  the  job,  it  coordinates\nwith  and  directs  the  transport  module  to  achieve  the\nmaterial  handoff.  The  AM  transfer  job  comprises  an\natomic transfer for material which is to receive it from,\nor send it to, the transport module.\nThe    intratool    port    resource    shall    support    the\nTRJobCommand   Abort   service,   which   ceases   any\ntransfer  activity  and  terminates  the  job.  The  intratool\nport resource reports transfer job milestones achieved to\nthe cluster controller using the TRJobAlert service.\nThe intratool port resource coordinates material handoff\nwith the transport module through the transport module\nto attached module interface, described below.\nAM   transfer   job   object   attributes   required   to   be\naccessible through object services:\nAttribute NameDescription: Requirements\nObjTypeThe object type: transfer job.\nTRJobIDIdentifier for the transfer job.\n(Ordered list of)\nTRAtomicID\nOrdered list of identifiers for the\natomic transfers in the transfer job:\none atomic transfer for each material.\n(List of)TRJobStateAll concurrent substates of the\ntransfer job.\nAM  atomic  transfer  object  attributes  required  to  be\naccessible through object services:\nAttribute NameDescription: Requirements\nObjTypeThe object type: atomic transfer.\nTRAtomicIDIdentifier for the atomic transfer.\nTRLinkIdentifier to coordinate handoff.\nTRPortAMPort through which transfer\noccurs.\nTRObjTypeMaterial type.\nAttribute NameDescription: Requirements\nTRObjNameMaterial identifier.\nTRRoleRole in transfer control: primary.\nTRPartnerIdentifies partner transport module.\nTRDirectionHandoff direction: receive or send.\nTRTypeActive/passive in transfer.\n(List\nof)TRAtomicState\nAll concurrent substates of the atomic\ntransfer.\nNote that TRLocation is not required to be supported as\nit   is   the   responsibility   of   the   attached   module   to\ndetermine  the  appropriate  location  to  be  used  based  on\nthe material identifier.\nMaterial movement messaging services required:\nMessage NameDescription: Requirements\nTRJobCreateCreate transfer job: single material,\nsend or receive, auto-start.\nTRJobCommandCommand on transfer job: abort.\nTRJobAlertNotification: started, complete.\nTransfer  resource  capabilities  required,  but  not  already\nspecified above:\n\u2022 Detect  and  report  success  or  failure  of  a  transfer\njob.\n\u2022 Reject    incomplete,    invalid,    and    unsupported\nrequests.\nTransfer  resource  capabilities  permitted,  but  not  to  be\nrequired, by a service-user:\n\u2022 Stop, Pause, and Resume of a transfer job.\n\u2022 Manual atomic transfer start.\n\u2022 Transfer job queuing and queued job Cancel.\n\u2022 Transferring of material groups.\n\u2022  Multiple concurrent transfer jobs.\n\u2022 Notification of transfer events.\nTransport Module to Attached Module Interface \u2014 The\ncontrol interface for the handoff of material between the\nend  effector  of  a  transport  module  and  any  attached\nmodule supports a sequence of three phases:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"a  synchronization  phase  that  establishes  that  both\nthe attached module intratool port resource and the\ntransport  module  transfer  resource  are  ready  to\nhandoff the material."),(0,r.yg)("li",{parentName:"ol"},"a physical handoff phase controlled by the intratool\nport resource.")),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199622\n3. a   verification   phase   to   determine   that   actual\nhandoff   took   place.   This   action   completes   the\nhandoff.\nThe   transport   module   is   responsible   for   managing\nconstraints  on  the  simultaneous  opening  of  isolation\nvalves  as  it  relates  to  contamination  of  the  transport\nmodule's environment by that of an attached module, as\nwell   as   cross-contamination   between   modules.   The\nattached  module  ensures  that  its  environment  will  not\ncontaminate the transport module before synchronizing.\nThe rules for re-establishing isolation at verification are\ndetermined by the transport module.\nThe  synchronization  between  the  transfer  resource  and\nthe   intratool   port   resource   is   achieved   by   each,\nindicating  readiness  to  transfer  the  material,  using  the\nHOReady service. Once both partners have received the\nHOReady,   the   intratool   port   resource   directs   the\nphysical handoff. The intratool port resource commands\nthe  transfer  resource  using  the  defined  HOCommand\nservices.  Once  the  physical  handoff  is  complete,  the\nintratool  port  resource  requests  verification  using  the\nHOVerify service.\nThe  transfer  resource  and  intratool  port  resource  shall\nsupport  the  HOCancelReady  service  which  cancels  a\npreviously     sent     HOReady     while     still     in     the\nsynchronization   phase.   The   transfer   resource   shall\nsupport  the  HOHalt  service,  which  ceases  any  transfer\nactivity and terminates the handoff.\nMaterial movement messaging services required:\nMessage NameDescription: Requirements\nHOReadySynchronize with partner.\nHOCommandCommand to the transport resource to\nperform an activity in the transfer\nenvelope. Detailed below.\nHOVerifyVerification of handoff completion\nwith transfer resource.\nHOCancelReadyRescinds previous HOReady\nmessage.\nHOHaltCommand to the partner to stop all\naction.\nHOCommands to be supported by the transfer resource:\nCommandDescription: Requirements\nPickCommands the transfer resource to\ntake all actions necessary to remove\nthe material from the intratool port.\nPlaceCommands the transfer resource to\ntake all actions necessary to place the\nmaterial in the intratool port.\nCommandDescription: Requirements\nExtendCommands the transfer resource to\nreach into the intratool port to a\npredefined position at which the\nmaterial can be accepted or released.\nRetractCommands the transfer resource to\nwithdraw from the intratool port.\nWhere   the   robotic   hardware   does   not   provide   for\nvertical  motion,  Pick  and  Place  are  not  required  to  be\nsupported.\nTransfer  partner  capabilities  required,  but  not  already\nspecified above:\n\u2022 Detect  and  report  success  or  failure  of  handoff\ncommands.\n\u2022 Detect and report success or failure of  the handoff,\nthrough the verification.\n\u2022 Reject    incomplete,    invalid,    and    unsupported\nrequests.\nTransfer  resource  capabilities  permitted,  but  not  to  be\nrequired, by either partner:\n\u2022 Multiple concurrent handoffs.\n\u2022 Additional handoff commands.\n8. 3.2     Intertool    Material    Movement    S ervices    \u2014\nFactory-to-cluster    tool    carrier    or    single    material\ninput/output  management  across  a  cluster  tool  module\ncommunications    interface    is    achieved    using    the\nintertool  material  movement  services.    These  services\nprovide  the  communications  and  behavior  required  of\nthe  intertool  port  resource  by  the  intertool  material\nmovement     models     through     defining     the     CM\ninput/output transfer job object and its operations.\nThis      standard      specifies      only      the      required\ncommunication  between  the  cluster  controller  and  the\ncassette   module   and   does   not   assume   automated\nmaterial movement in the factory. The CM input/output\ntransfer  job  is  compliant  with  SEMI  E32  (Material\nMovement   Management)   and   may   be   extended   to\nsupport automated material movement in the factory.\nThe  CM  input/output  transfer  job  creation  is  requested\nby the cluster controller using the TRJobCreate service.\nIf   the   intertool   port   resource   accepts   the   job,   it\ncoordinates with the operator or some entity to achieve\nthe  material  handoff.  The  CM  input/output  transfer  job\ncomprises  an  atomic  transfer  for  a  cassette  or  single\nmaterial  which  is  to  receive  it  from,  or  send  it  to,  the\nfactory.\nThe    intertool    port    resource    shall    support    the\nTRJobCommand   Abort   service,   which   ceases   any"),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199623\ntransfer  activity  and  terminates  the  job.  The  intertool\nport resource reports transfer job milestones achieved to\nthe cluster controller using the TRJobAlert service.\nCM  input/output  transfer  job  object  attributes  required\nto be accessible through object services:\nAttribute NameDescription: Requirements\nObjTypeThe object type: transfer job.\nTRJobIDIdentifier for the transfer job.\n(Ordered list of)\nTRAtomicID\nOrdered list of identifiers for the\natomic transfers in the transfer job:\none atomic transfer for each material.\n(List of)TRJobStateAll concurrent substates of the\ntransfer job.\nAtomic    transfer    object    attributes    required    to    be\naccessible through object services:\nAttribute NameDescription: Requirements\nObjTypeThe object type: atomic transfer.\nTRAtomicIDIdentifier for the atomic transfer.\nTRLinkIdentifier to coordinate handoff: none.\nTRPortCMPort through which transfer\noccurs.\nTRObjTypeMaterial Type: cassette or single\nmaterial.\nTRObjNameMaterial identifier.\nTRRoleRole in transfer control: secondary.\nTRPartnerIdentifies partner if automated: none.\nTRDirectionHandoff direction: receive or send.\nTRTypeActive/passive in transfer: passive.\n(List\nof)TRAtomicState\nAll concurrent substates of the atomic\ntransfer.\nThe  requirements  above  indicate  the  settings  if  the\ntransfer   is   to   be   manual,   with   the   operator.   The\nattributes TRLink, TRRole, TRPartner, and TRType are\nnot    significant    in    this    situation.    These    become\nsignificant in automated material transfer.\nMaterial movement messaging services required:\nMessage NameDescription: Requirements\nTRJobCreateCreate transfer job: single material\nsend or receive, auto-start.\nTRJobCommandCommand on transfer job: abort.\nTRJobAlertNotification: started, complete.\nIntertool  port  resource  capabilities  required,  but  not\nalready specified above:\n\u2022 Detect  and  report  success  or  failure  of  a  transfer\njob.\n\u2022 Reject    incomplete,    invalid,    and    unsupported\nrequests.\nIntertool port resource capabilities permitted, but not to\nbe required, by a service-user:\n\u2022 Automated transfer of material within factory.\n\u2022 Stop, Pause, and Resume of a transfer job.\n\u2022 Manual atomic transfer start.\n\u2022 Transfer job queuing and queued job Cancel.\n\u2022 Transferring of material groups.\n\u2022 Multiple concurrent transfer jobs.\n\u2022 Notification of transfer events.\n8. 3.3    Carrier   Mapping   Services   \u2014    M apping   of\nmaterial   in   carriers   across   a   cluster   tool   module\ncommunications  interface  is  achieved  using  the  carrier\nmapping     services.     These     services     provide     the\ncommunications  required  of  the  appropriate  module\nresources  by  the  material  models  through  defining  the\nmaterial slot object.\nThe   carrier-mapping   services   are   fully   specified   in\nterms  of  the  material  slot  attributes  accessed  through\nthe  get  and  set  services  of  SEMI  E39  (Object  Services\nStandard:  Concepts,  Behavior,  and  Services).  Cluster\ntool  module  communications  require  full  compliance\nwith  the  information,  behavior,  and  messaging  services\nof the fundamental requirements of that standard.\nThe  mapping  information  is  only  of  interest  to  the\ncluster   tool   for   a   carrier   contained   in   the   module\nresource.   The   material   slot   objects   are,   therefore,\nassociated  with,  and  managed  by,  the  module  resource\nwhich  uniquely  identifies  all  of  its  material  slots.  The\ncarrier-mapping services provide for communication of\nmaterial slot information in both directions between the\ncluster   controller   and   the   module   resource.   The\ninformation  communicated  is  material  presence  and\nmaterial identification. Whether the material presence is\ndetected  by  the  module  resource  or  determined  by  the\ncluster controller is application-specific. This is also the\ncase for material identification.\nA   material   slot   may   be   assigned   the   identifier   of\nmaterial  which  is  not  yet  occupying  the  material  slot.\nThis provides for determination by the cluster controller\nof  which  material  slot  the  material  is  to  be  moved  into\nwhen it arrives at the module.\nMaterial  slot  object  attributes  required  to  be  accessible\nthrough object services are detailed in Table 2."),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199624\nTable 2  Material Slot Attributes\nAttribute NameDefinitionRqmt    AccessForm\nObjTypeThe object type.YROText: \u201cMATERIALSLOT\u201d\nObjIDModule unique identifier for the material slot.YROText: Unique with respect to the module.\nMtlNameIdentifier of the material occupying or\nassigned to the slot.\nYRWText\nOccStateCurrent state of the material slot.YRW    Text:\nSlotUnknown\nSlotEmpty\nSlotOccupied\nSlotActive\nSlotDisabled\nThe material slot occupancy attribute indicates the presence of material as follows:\n\u2022 SlotUnknown \u2014 the carrier is present and slot occupancy is not known, such as from when a carrier is loaded\nuntil the material is detected or the state is set by the cluster controller.\n\u2022 SlotEmpty \u2014 no material in the slot.\n\u2022 SlotOccupied \u2014 material is present in the slot.\n\u2022 SlotActive \u2014 material is being removed from, or is arriving at, the slot.\n\u2022 SlotDisabled \u2014 material slot unusable, such as when the carrier is not present.\nModule resource capabilities required, but not already specified above:\n\u2022 Reject incomplete, invalid, and unsupported requests.\nModule resource capabilities permitted, but not to be required, by the cluster controller:\n\u2022 Detection of the presence of material in a material slot.\n\u2022 Detection of the identifier of material in a material slot.\nTable 3  lock Attributes\nAttribute NameDefinitionRqmtAccessForm\nObjTypeThe object type.YROText: \u201cCLOCK\u201d\nObjIDModule unique identifier for the clock.YROText: Unique with respect to the module. Services\ntimestamp clock is \u201cSERVICESCLOCK\u201d\nDateTimeCurrent time.YRWText: yyyymmddhhmmsscc\n8. 4   Exception  Management  Servic es  \u2014   Exception  management  across  a  cluster  tool  module  communications\ninterface  is  achieved  using  the  exception  management  services.  These  services  provide  the  communications  and\nbehavior  required  of  the  module  resource  by  the  exception  models  described  in  Section  7.1.5  through  defining  the\nexception condition object and its operations.\nThe  exception  management  services  follow  SEMI  Draft  Document  2013C  (SECS  II  Support  for  SEMI  E41\n(Exception   Management   Standard)).   Cluster   tool   module   communications   require   full   compliance   with   the\ninformation, behavior, and messaging services of the fundamental requirements of that standard.\nException  conditions  (alarms  and  error  conditions)  are  created  and  managed  by  the  module  resource  detecting  the\nrelated  abnormal  situation.  The  module  resource  uses  the  EXPost  service  to  report  the  occurrence  of  the  abnormal\nsituation or some significant change in exception condition information while the situation exists. EXCleared reports\nthat  the  abnormal  situation  is  no  longer  apparent  or  relevant.  Reporting  on  an  exception  condition  is  enabled  and\ndisabled by setting its EXEnabled attribute."),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199625\nThe  cluster  controller  may  direct  recovery  of  error\nconditions  using  the  EXRecover  service.  The  module\nresource  performs  the  recovery  action  and  reports  its\ncompletion  using  the  EXRecoveryComplete  service.\nThe module resource is only required to permit a single\nrecovery   action   at   a   time   on   all   set   exception\nconditions,  but  may  support  multiple  recovery  actions.\nThe       module       resource       shall       support       the\nEXRecoveryAbort  service,  which  ceases  any  activity\nand terminates the recovery action.\nException  condition  object  attributes  required  to  be\naccessible through object services:\nAttribute NameDescription: Requirements\nObjTypeThe object type: EXCEPTION.\nEXIDIdentifier for the exception condition.\nEXTypeType of exception condition:alarm or\nerror condition.\nEXMessageText message describing the\nabnormal situation monitored.\nEXEnabledIndicates reporting to decision\nauthority enabled/disabled.\nEXRecActListPossible recovery actions (none for\nalarms).\nEXStateListAll concurrent substates of the\nexception.\nException management messaging services required:\nMessage NameDescription: Requirements\nEXPostNotify/update on abnormal situation.\nEXClearedNotify resolution of abnormal\nsituation.\nEXRecoverCommand to perform recovery\naction.\nEXRecoveryComplete  Notify completion of recovery action.\nEXRecoveryAbortCommand to abort a recovery action.\nReporting   of   all   exception   conditions   is   set   to   be\nenabled on establishment of an association, and those in\nthe set state are posted.\nModule  resource  capabilities  required,  but  not  already\nspecified above:\n\u2022 Reject    incomplete,    invalid,    and    unsupported\nrequests.\nModule  resource  capabilities  permitted,  but  not  to  be\nrequired, by a service-user:\n\u2022 Multiple concurrent recovery actions.\n\u2022 Dynamic  update  of  exception  condition  message\nand valid recovery actions.\n8. 5      Recipe     Management     Services     \u2014      Recipe\nmanagement      across      a      cluster      tool      module\ncommunications  interface  is  achieved  using  the  recipe\nmanagement   services.   These   services   provide   the\ncommunications  and  behavior  required  of  the  module\nby  the  recipe  models  described  in  Section  7.1.6  of  this\ndocument.\nThe  recipe  management  services  follow  SEMI  E42\n(Recipe  Management  Standard).  Cluster  tool  module\ncommunications   require   full   compliance   with   the\ninformation,  behavior,  and  messaging  services  of  the\nfundamental  requirements  of  a  recipe  executor,  and\noptionally   the   recipe   namespace   management,   as\ndefined in that standard.\nThe  module  requiring  recipe  services  contains  a  recipe\nexecutor that is capable of performing recipe download,\nverification,   selection,   deselection,   and   deletion   as\nrequested  by  the  cluster  controller.  The  module  may\nalso support recipe namespace services.\nIn   certain   configurations,   the   module   may   require\nrecipe  management  services  to  be  provided  by  the\ncluster controller, in order that it may request a selected\nrecipe  that  is  not  stored  locally.  The  module  is  the\nservice-user  in  this  case,  and  the  cluster  controller\nshould    support    the    necessary    recipe    namespace\nservices.\nThe module coordinates the activities of the processing\nresource   and   the   recipe   executor   to   ensure   the\nappropriate  recipes  are  loaded  into  the  execution  area\nfor material processing.\nRecipe   executor   object   attributes   required   to   be\naccessible through object services:\nAttribute NameDescription\nObjTypeThe object type: \u201cRcpExec\u201d\nObjIDIdentifier for the recipe executor\nDefaultNamespace  Namespace for all hardware-dependent\nrecipes\nRecipeSelectIDList of recipe identifiers for the currently\nselected recipe\nRecipe management messaging services required:\nMessage NameDescription: Requirements\nRMEDnldVerReceive a recipe, optionally verify it, and\nput it into storage\nRMEDeleteDelete a recipe from storage\nRMESelectSelect recipes for execution\nRMEDeselectDeselect a recipe to prevent its execution\nRMECompleteNotify service-user of completion of an\naction"),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199626\nModules that require more than one recipe class for an\nexecution cycle shall support multi-part recipes. That is,\nthe  ability  to  select  multiple  recipes  in  a  single  process\njob request is not supported in processing management.\nRecipe  executor  capabilities  required  and  not  already\nspecified above:\n\u2022 Reject    incomplete,    invalid,    and    unsupported\nrequests\nRecipe  executor  and  module  capabilities  permitted  by\nnot to be required by a service-user:\n\u2022 Support   for   variable   parameters   (attributes   and\nselect service),\n\u2022 Support for multi-part recipes,\n\u2022 Upload a recipe,\n\u2022 Support recipe namespace services for local recipe\nmanagement,\n\u2022 Local editing.\n8. 6    Event   Reporting   Services   \u2014    E vent   reporting\nservices  are  to  be  supported  in  accordance  with  the\nmodels  described  in  Section  7.1.7.  Both  event-based\nreporting  and  tracing  are  required.  Support  for  user-\ndefined reports is not required.\nEvent reporting for CTMC-compliant modules shall be\nbased on services as described in SEMI E53.\n8. 6.1  The attributes defined in the fo llowing table shall\nbe supported by CTMC compliant modules.\nAttribute NameDescription: Requirements\nObjIDThe identifier for Data Reports, Event\nReports, and Trace Reports.\nDataReportListList of data report identifiers.\nEnabledA flag which controls generation of\nEvent and Trace Reports.\nSamplePeriodTime delay between samples in a Trace\nreport.\nTotalSamplesMaximum number of samples to\ninclude in a Trace report.\nGroupSizeNumber of samples to include before\nsending a report to a service user.\n8. 6.2   Support  for  the  following  mes sages  from  SEMI\nE53 shall be provided.\nMessage NameDescription: Requirements\nEventReportRequestUser can ask for a report to be\ngenerated and sent.\nEventReportSendProvider generates and sends report\non an event.\nDataReportCreateDefine attributes to be sampled for a\nreport.\nDataReportDeleteDelete report definitions\nDataReportRequestUser requests sample and send of a\nreport.\nCollectionEventLinkLink data reports to a collection\nevent.\nCollectionEventUnlink   Unlink a data report\nTraceReportCreateDefine a trace report\nTraceReportDeleteDelete trace report definitions\nTraceReportRequestUser requests a sample and send of a\ntrace data.\nTraceReportSendService provider sends a trace report\nto the user.\nTraceReportResetA trace reporting is set to its IDLE\nstate.\n8. 6.3   Support  for  dynamic  and  user   defined  reports  is\noptional.   However,   implementations   which   support\nthese   advanced   capabilities,   shall   comply   with   the\nspecifications of SEMI E53 and SEMI E39. SEMI E39\nservice messages shall use the optional object specifier\narguments,  such  as  EvtSrcSpec.  Object  services  can\nthen  be  used  to  interrogate  objects  for  their  reportable\nattributes.\n8. 7   Clock  Services  \u2014   The  clock  se rvices  provide  for\nsynchronization of the clocks on the modules with that\nof  the  cluster  controller.  These  services  provide  the\ncommunications  required  of  the  appropriate  module\nresources through defining the clock object.\nThe  clock  services  are  fully  specified  in  terms  of  the\nclock   attributes   accessed   through   the   get   and   set\nservices   of   SEMI   E39   (Object   Services   Standard:\nConcepts, Behavior, and Services). Cluster tool module\ncommunications   require   full   compliance   with   the\ninformation,  behavior,  and  messaging  services  of  the\nfundamental requirements of that standard.\nThe  clock  object  is  uniquely  identified  for  the  module.\nTable 3 describes the attributes of the clock object. The\nidentifier of the clock used for communications services\nis defined. The clock attribute Time is kept current and\nused  to  determine  the  value  of  the  timestamp  used  in\nservice messages. The module returns the current Time\nwhen it receives a get.\nThe  clock  time  is  synchronized  by  using  the  object  set\nservice  on  the  Time  attribute.  On  receipt  of  a  set"),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199627\nrequest,  the  module  performs  the  operations  necessary\nto   set   the   clock   to   the   value   supplied,   within   its\nresolution, from which it shall continue immediately.\nThe  DateTime  attribute  of  the  Clock  object  as  used  in\nClock Services has a resolution in the range of seconds\nto centiseconds. If it is possible to specify the DateTime\naccurate  to  centiseconds,  then  centiseconds  should  be\nspecified. If it is not possible to resolve time to less than\na  second,  then  centiseconds  shall  be  reported  as  \u201c00.\u201d\nThis  requirement  is  for  the  reporting  of  the  DateTime\nattribute  of  the  Clock  object  in  Clock  Services  only;\nother  services  may  require  greater  resolution,  in  which\ncase  the  Clock  Services  DateTime  attribute  resolution\nshall also be greater.\n8. 8  Required Services \u2014  Within a  standards-compliant\nCluster  Tool,  a  number  of  services  must  be  supported,\nat  least  to  the  fundamental  requirements  level.    Due  to\nthe  specialization  of  the  modules  in  a  Cluster  Tool  as\ndetailed  in  the  concepts  section  above,  each  module\ntype  only  needs  to  support  a  subset  of  the  service\ngroups as shown in the message flow diagrams.\nThe  services  requirements  for  each  module  controller\nare  described  in  this  section.  An  example  of  use  of\nservices by a cluster controller is also given.\n8. 8.1  Transport Module Controller\n\u2022 Material   transfer   functions   for   the   end-to-end\nestablishment   of   material   movement   within   the\ncluster  (supported  through  the  Material  Movement\nservices).  Material  transfer  is  set  up  through  a\nTransfer  Job  requested  of  the  transport  module  by\nthe service-user (e.g., cluster controller).\n\u2022 Material Handoff between the process and cassette\nmodules   and   the   transport   module   (supported\nthrough the Material Movement services).\n\u2022 Exception    capabilities    to    post    and    manage\nexception  conditions  within  the  transport  module\n(supported   through   the   Exception   Management\nservices).\n\u2022 Reporting of module variable data linked to  events\nto  the  service-user  (supported  through  the  Event\nReporting services).\n\u2022 Access  to  standard  objects  of  the  specific  services\nabove  as  required  by  the  service-user  (supported\nthrough the Object services).\n8. 8.2  Cassette Module Controller\n\u2022 Material   I/O   functions   for   the   management   of\nmoving cassettes in and out of the cluster as well as\nfor  moving  material  between  the  cassette  module\nand  the  transport  module  (supported  through  the\nMaterial  Movement  services).  Material  I/O  is  set\nup through a Transfer Job requested of the cassette\nmodule     by     the     service-user     (e.g.,     cluster\ncontroller).\n\u2022 Material Handoff between the cassette module and\nthe   transport   module   (supported   through   the\nMaterial Movement services).\n\u2022 Exception    capabilities    to    post    and    manage\nexception  conditions  within  the  transport  module\n(supported   through   the   Exception   Management\nservices).\n\u2022 Reporting of module variable data linked to events\nto  the  service-user  (supported  through  the  Event\nReporting services).\n\u2022 Access  to  standard  objects  of  the  specific  services\nabove  as  required  by  the  service-user  (supported\nthrough the Object services).\n8. 8.3  Process Module Controller\n\u2022 Material  processing  functions  (supported  through\nthe  Processing  Management  services).  Processing\nis  specified  through  a  Process  job  requested  of  the\nprocess  module  by  the  service-user  (e.g.,  cluster\ncontroller).\n\u2022 Recipe  Management  to  verify  and  transfer  recipes\nbetween  the  process  module  and  the  service-user\n(supported   through   the   Processing   Management\nservices).\n\u2022 Material   I/O   functions   for   the   management   of\nmoving  material  in  and  out  of  the  process  module\n(supported    through    the    Material    Movement\nservices).  Material I/O is set up through a Transfer\njob requested of the process module by the service-\nuser (e.g., cluster controller).\n\u2022 Material  Handoff  between  the  process  module  and\nthe   transport   module   (supported   through   the\nMaterial Movement services).\n\u2022 Exception    capabilities    to    post    and    manage\nexception  conditions  within  the  transport  module\n(supported   through   the   Exception   Management\nservices).\n\u2022 Reporting of module variable data linked to events\nto  the  service-user  (supported  through  the  Event\nReporting services).\n\u2022 Access  to  standard  objects  of  the  specific  services\nabove  as  required  by  the  service-user  (supported\nthrough the Object services).\n8. 8.4  Example Cluster Controller\n\u2022 Scheduling      and      primary      module      control.\nSchedules  Transfer  and  Process  jobs  in  order  to"),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199628\nachieve   the   mission   of   the   cluster   tool,   the\nprocessing of material.\n\u2022 Recipe   management   for   storage,   archival,   and\nediting   of   process   module   recipes   (supported\nthrough the Recipe Management services).\n\u2022 Human    interfaces    for    the    attached    process,\ntransport, and cassette modules (supported through\nthe     Event     Reporting     and     Object     Service\ndefinitions).\n\u2022 Exception  resolution  services  for  making  recovery\ndecisions   on   exception   conditions   within   the\ncluster     (supported     through     the     Exception\nManagement services)."),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199629\nAPPENDIX 1\nAPPLICATION NOTES\nNOTE: This appendix was approved as a part of SEMI E38 by full letter ballot procedure.\nA1-1  Factory Integration\nThe  Cluster  Tool  Module  Communications  (CTMC)\nStandard    and    its    associated    services    define    the\ninteractions  of  the  cluster  modules  and  the  cluster\ncontroller.        The    standard    does    not    address    the\ncommunications  between  the  cluster  and  an  external\nfactory \u201chost.\u201d The SEMI standard which addresses the\nequipment  to  host  communications  interface  is  SEMI\nE30 (GEM).\nThe  purpose  of  this  application  note  is  to  discuss  the\nrequirements  and  possible  pitfalls  of  the  factory  host-\ncluster  tool  interface.  The  bulk  of  the  text  will  address\nthe  use  of  the  current  (at  this  writing)  version  of  GEM\n(SEMI  E30).  However,  some  consideration  will  be\ngiven   to   the   possibility   of   direct   access   to   the\ncomponents    of    the    cluster    through    the    cluster\ncommunications environment.\nA1-1.1    Direct  Access  to  Cluster  Modules  \u2014   The\nCTMC   was   designed   to   allow   for   interoperability\namong  the  entities  in  a  cluster.  It  is  possible  to  add  a\nnew    entity    to    the    cluster    and    share    in    this\ninteroperability.  This  means  that  a  software  application\nthat   is   \u201cplugged\u201d   into   the   cluster   communication\nenvironment  will  have  access  to  all  of  the  cluster\nmodules  via  the  standard  message  set.  In  this  way,  a\nfactory  host  computer  can  gain  direct  access  to  cluster\nmodules, by-passing the cluster controller.\nWhile  direct  access  to  the  cluster  modules  has  some\nadvantages,      intrusions      into      the      cluster      tool\ncommunications   environment   can   have   a   profound\neffect  on  the  system.  Below  are  listed  a  few  of  the\npositive  benefits  direct  access  can  bring,  followed  by\nsome of the negatives of such an approach.\nPositives:\n\u2022 If the cluster controller does not have to act as the\nintermediary  in  transactions  between  module  and\nhost, it may be simplified.\n\u2022 Direct   access   of   the   modules   can   be   a   more\nefficient means of obtaining information.\n\u2022 The   factory   host   would   have   the   flexibility   to\nperform   scenarios   which   the   cluster   controller\nsuppliers had not imagined.\nNegatives:\n\u2022 A new, unplanned load on the cluster network may\nhave  a  negative  impact  on  system  performance.    If\nthe  delivered  system\u2019s  network  is  highly  loaded\nand has been tuned for that load, added pressure on\nthe system may have unexpected results.\n\u2022 Direct  access  of  the  cluster  modules  may  have  a\nnegative   impact   on   system   performance.      The\ncluster  modules  are  performing  the  physical  work\nfor  the  cluster.    If  they  become  busy  answering\ninquiries,   it   may   detract   from   their   speed   of\nprocessing.    For  example,  a  simple  query,  such  as\ntemperature  of  chamber,  may  actually  result  in\nmessaging to the sensor itself along the same real-\ntime  communication  path  used  to  open  and  close\nvalves, ect.\n\u2022 System integrity of the cluster tool may be at risk if\nan  external  entity  (e.g.,  Factory  Host)  takes  even\nminor   control   actions.      A   changed   equipment\nconstant may put the cluster controller out of synch\nwith its module.  An external command to perform\nan  action  may  directly  conflict  with  the  cluster\u2019s\ncurrent actions.\n\u2022 The  CTMC  defines  no  access  security  to  prevent\nundesirable actions on the part of external entities.\nIf  there  is  to  be  this  sort  of  direct  communication  with\ncluster   modules,   the   implementer   should   exercise\nextreme caution in the design of the add-on application.\nIt  is  recommended  that  no  active  control  be  attempted\nand  that  no  changes  to  the  system  configuration  be\nattempted  (e.g.,  do  not  set  attributes).  If  data  is  to  be\naccessed,  it  is  best  done  by  asynchronous  event  based\nreporting,   rather   than   by   polling.   Above   all,   it   is\nrecommended   that   any   plans   to   access   the   cluster\nthrough   the   cluster   communication   environment   be\ndiscussed thoroughly with the system supplier.\nA1-1.2  GEM Control of a Cluster Tool \u2014  This section\ndiscusses  the  interactions  between  a  cluster  tool  and\nfactory   host.   The   basis   for   that   communication   is\nassumed  to  be  SEMI  E30,  the  Generic  Equipment\nModel.\nGEM  was  designed  relative  to  the  prevalent  class  of\nequipment at that time:  proprietary, single supplier, and\nlimited to a single process run at a time. The advent of\nmulti-chamber processing equipment and later of multi-\nsupplier    cluster    tools    has    changed    the    general\nrequirements set for the factory-equipment interface. In\nthe   future,   GEM   may   evolve   to   meet   these   new\nrequirements.  Regardless,  the  point  of  this  application\nnote is to explore how best to apply the existing factory"),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199630\nhost     communication     standards     to     cluster-based\nequipment.\nBelow,   each   GEM   capability   will   be   addressed\nseparately,  followed  by  a  look  at  capabilities  which\nGEM  does  not  cover.  The  capabilities  are  taken  in\nroughly  the  order  given  by  SEMI  E30  (GEM)  table  of\ncontents.\nCommunications              State              Model/Establish\nCommunications \u2014  The  Communications  State  Model\nis   related   to   the   ability   to   communicate.   It   is\nindependent    of    the    functionality    offered    by    the\nequipment.  There  is  no  conflict  with  the  cluster  tool\nsupporting this GEM capability.\nControl   State   Model   \u2014    The   control   state   model\nassumes a single operator interface at the equipment.  A\ncluster  tool  is  expected  to  supply  such  an  interface\nconnected to the cluster controller.\nHowever,  there  is  a  potential  disconnect  with  attached\nmodules  which  supply  user  interfaces.  Since  CTMC\ndoes  not  provide  anything  similar  to  the  control  state\nmodel at this time, the cluster controller has no control\nover  access  to  these  separate  user  interfaces,  nor  even\nany  knowledge  of  what  might  be  happening.  In  this\nsituation,    the    cluster    controller    cannot    guarantee\ncompliance to the control state model.\nTo  assure  GEM  compliance,  it  is  recommended  that  a\nmodule  request  and  receive  closure  of  all  control-\nrelated  service  connections  before  allowing  use  of  its\nlocal operator interface in a control mode. This assumes\nthe use of the communication environment as defined in\nSEMI E38.1.\nEquipment  Processing  States  \u2014   GEM  specifies  that\nthere  be  a  processing  state  model.  The  model  given  in\nthe  document  is  only  an  example,  which  shows  the\napproximate  depth  needed  and  suggests  a  form.  The\nexample  applies  to  the  classic  single  chamber,  single-\nprocess    machine.    Thus,    it    may    not    be    directly\napplicable to a cluster tool.  The cluster tool is required\nto provide a processing state model, but the form should\nmatch  the  cluster  tool's  function.  The  Plasma  Etch\nSpecific  Equipment  Model  (document  available  from\nSEMI)  suggested  one  way  to  model  a  multi-chamber,\nmulti-process job machine.\nData  Collection  \u2014   Data  collection  is  a  combination  of\nseveral  different  capabilities.  Each  will  be  discussed  in\nturn.\nThere  is  also  a  high-level  issue  with  data  collection.\nGEM  assumes  a  flat  address  space.  That  is,  it  assumes\nthat  the  smallest  granularity  of  object  is  \u201cequipment.\u201d\nThe equipment has attributes. Some attributes are read-\nonly  (Status  Variables).  Some  have  read/write  access\n(Equipment   Constants).   There   are   a   few   read-only\nattributes   which   are   valid   only   at   certain   times\n(DVVALs).\nCluster tools do not fit this model well. The CTMC was\nbased on a model which includes a hierarchy of objects\nwhich  contain  (or  control)  other  objects.  The  CTMC\nrequirements  are  a  subset  of  that  model  and  include  a\ncluster  controller  (which  does  not  have  to  be  a  single\nentity),    attached    modules,    transport    module,    and\nspecific  objects  associated  with  the  services.  Thus,  to\nrequest information about the processing of a wafer in a\nprocess  module,  the  attributes  of  the  process  job  must\nbe    accessed.    The    chain    then    includes    Cluster\nController->Process       Module->Process       Job->Job\nAttribute. It is quite a challenge to present this attribute\nas SVID #532678.  And yet, this is what must be done.\nThe cluster controller should provide a flat name space\nfrom   which   to   access   critical   module   data.   Object\nservices   with   scopeing   capabilities   may   also   be\nsupported  through  the  host  interface,  but  if  used,  this\nwould be an extension to the host's GEM interface. The\ndata collection categories below give more detail on the\nchallenge and possible solutions.\nEvent  Notification  \u2014   Many  of  the  events  of  interest  to\nthe  host  actually  occur  at  the  attached  modules  (e.g.,\n\u201cEtch   step   complete   for   wafer   x\u201d).   The   cluster\ncontroller  is  responsible  for  assigning  each  of  these\nevents a unique CEID. There are two challenges:  (1) to\nassure  uniqueness  of  events  from  duplicate  modules,\nand  (2)  to  provide  a  scheme  whereby  the  host  can\ndetermine the source of the event. Embedding a module\nnumber within the CEID is one solution which has been\nused   to   address   both   challenges.   For   instance,   the\nhighest  order  byte  of  a  four-byte  integer  might  contain\nthe module ID.\nDynamic Event Report Configuration \u2014 The host must\nbe able to attach the information of interest to the event\nnotifications.  The  cluster  controller  is  responsible  for\nproviding   access   to   the   attributes   of   the   cluster\nmodules. It is also responsible for assuring that the data\ncontained  in  the  event  reports  is  representative  of  the\nstate of the cluster at the time the event occurred.\nThere are three sources of data for the event reports."),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Cluster  Controller:    Data  which  is  local  to  the\ncluster controller may be accessed directly."),(0,r.yg)("li",{parentName:"ol"},"Module (not source of collection event):  This data\nmust be polled unless a data trace for the attributes\nof interest is in progress."),(0,r.yg)("li",{parentName:"ol"},"Module  (source  of  collection  event):    This  data\ntends  to  be  most  closely  related  to  the  event  and\nthus  the  most  time-critical.  While  polling  and  data\ntrace may be used in this case, it is better to use the")),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199631\nCTMC Event Reporting Services to attach the data\nof interest directly to the module collection event.\nVariable  Data  Collection/Status  Data  Collection  \u2014\nAgain,  the  cluster  must  take  measures  to  present  a  flat\naddress space.  See various discussions above.\nLimits  Monitoring  \u2014   Clearly,  most  variables  which\nwould  be  of  interest  for  limits  monitoring  reside  in  the\ncluster  modules.  The  CTMC  does  not  provide  specific\nservices  for  configurable  limits  monitoring.  A  module\nmay  provide  for  some  limits  checking  via  \u201climits\u201d\nattributes   of   objects   which   may   be   set   via   object\nservices.   Notification   of   excursions   beyond   limits\nwould be via exceptions and/or collection events. If this\nmethod  is  not  available,  the  cluster  controller  would\nhave to institute a data trace on the attribute of interest\nand  then  itself  perform  the  limits  checking  activity.\nThe   time   period   of   the   trace   would   be   crucial   to\nassuring that short-term excursions are not missed.\nTrace  Data  Collection  \u2014   Trace  data  collection  maps\nwell from GEM to CTMC. In fact, the CTMC services\nin this area are a superset of the GEM functionality.\nOn-Line Identification  \u2014  At first glance, this seems to\nbe  an  easy  requirement  to  meet.  However,  the  model\nnumber  and  software  revision  included  in  the  message\nare   ambiguous   on   a   cluster   with   separate   model\nnumbers  for  each  module  (and  the  cluster  controller\nitself)  and  separate  software  releases  running  on  each.\nThe  purpose  of  these  data  items  is  to  allow  the  host  to\ndetermine  when  the  equipment  has  been  changed  in\nsuch a way that it may no longer be compatible with the\nhost  software.  At  a  minimum,  the  data  items  should\nindicate a change to the cluster controller software (e.g.,\na   new   revision   of   the   software,   or   a   significant\nreconfiguration such as the addition of a new module).\nAlarm  Management  \u2014   GEM  alarm  management  is  a\nsubset  of  the  functionality  of  the  CTMC  exception\nservices.  Any  exception  message  from  a  module  can,\nwhere  desired,  be  translated  into  a  GEM-compliant\nalarm  message.  The  set  of  CTMC  exceptions  is  a\nsuperset  of  GEM  alarms.  GEM  alarms  are  of  a  serious\nnature  and  expect  human  intervention  to  be  required.\nThe  CTMC  extends  this  set  to  include  problems  which\nthe  controller  may  be  able  to  solve,  and  provides  for\nmodules to suggest appropriate recovery actions.\nThose  CTMC  exceptions  which  fall  into  the  GEM\nalarm category should be passed on via the GEM Alarm\ncapability.   Exceptions   which   are   not   GEM   alarms\nshould be reported only as events.\nRemote  Control  \u2014   Cluster  tools  need  to  be  able  to\nhandle  multiple  tasks  simultaneously.  Most  need  to\nhandle   multiple   lot   or   batch   jobs   at   once.   GEM's\nsupport   for   (process)   job   control   is   minimal.   The\nimplicit  assumption  in  GEM  is  that  only  one  job  at  a\ntime   will   occur   on   a   machine.   It   provides   for   a\n\u201cSTART\u201d  command,  collection  events  when  the  job  is\nactually  started  and  when  it  finishes,  and  also  job\ncontrol  commands  (e.g.,  PAUSE,  RESUME,  ABORT,\nSTOP).  What  GEM  lacks  is  differentiation  of  one  job\nfrom another (e.g., a job ID).\nHowever,  the  GEM  remote  command  message  does\nprovide  for  parameters.  A  cluster  tool  may  be  able  to\nimplement a scheme which is similar to that defined by\nthe Process Management Services. For instance, a \u201cjob\nID\u201d   parameter   may   be   included   in   all   job-related\nmessages.  Thus,  the  equipment  would  set  a  job  ID  in\nthe \u201cStart\u201d or the \u201cPP-Select\u201d message (whichever first\nrefers to the job), and would then refer to that ID in any\nsubsequent  job  control  commands.  The  job  ID  could\nalso  be  available  as  a  data  value  in  collection  event\nreports.   While   it   might   be   preferable   to   have   the\nequipment  assign  the  job  ID,  this  scheme  may  be\nworkable.\nEquipment  Constants  \u2014  Again,  the  flat  address  space\nissue applies. (See the Data Collection section above.)\nProcess  Program  Management  \u2014   The  CTMC  uses\nRecipe Management Services (RMS) to manage recipes\ninternal  to  the  cluster.  GEM's  processing  services  is  a\ndifferent  mechanism.  The  two  can  be  made  to  interact,\nbut  the  combination  is  not  ideal.  It  is  possible  for  the\ncluster  to  translate  a  \u201crecipe\u201d  to  a  \u201cprocess  program\u201d\nfor communication with the host.  However, if a recipe\nis created or modified at the host and then downloaded,\nthe  editor  at  the  host  must  be  compatible  with  RMS\nconcepts,   and   care   must   be   taken   to   maintain   the\nintegrity of the RMS system.\nMaterial  Movement  \u2014   GEM  requires  only  collection\nevents  when  material  is  received  or  sent.  A  cluster  can\neasily satisfy this requirement.\nEquipment  Terminal  Services,  Error  Messages,  and\nSpooling   \u2014    Equipment   Terminal   Services,   Error\nMessages, and Spooling are in the domain of the cluster\ncontroller.   Cluster   modules   do   not   provide   these\nfunctions,   nor   do   they   contribute   to   the   cluster\ncontroller's delivery of the services.\nClock \u2014  A key purpose of clock is to allow the host to\ndetermine  ordering  of  events  from  an  equipment.  The\ncluster  controller  should  ensure  that  this  need  is  met.\nThe  cluster  should  attempt  to  report  consistent  time\nrelative to its modules. Also, when the factory host sets\nthe  time  on  the  cluster,  the  cluster  controller  should\nresynchronize the time on its modules. There should be\nno compatibility problems in this area."),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199632\nFigure 20\nTypical Operating Scenario\nA1-2  Typical Operating Scenario\nThe  purpose  of  this  section  is  to  give  an  example  of  a\ntypical operating scenario that will illustrate the various\nservices  being  used  to  perform  cluster  tool  control\nfunctionality.  This  operating  scenario  is  NOT intended\nto   be   the   only   scenario   to   be   implemented   in   a\nstandards-compliant  cluster.  The  intent  is  to  provide\nguidance  in  navigating  the  various  services  standards.\nAn  exhaustive  use  of  Object  Services  and  Exception\nManagement Services will not be done since these two\nareas tend to be very application-specific.\nThis  scenario  concentrates  on  the  material  processing,\nmaterial   movement   aspects   of   the   cluster-specific\nservices.\nThe  operating  scenario  shown  in  Figure  20  will  be\ngiven  in  the  form  of  a  communication  timing  diagram\nwith  messages  being  sent  between  the  various  cluster\ntool  components  and  will  be  indicated  in  the  following\nmanner:\nServiceGroup_ServiceName.Request      or      Response\n(Service Parameters)\nExample: TRJobCreate.Req(...)\n\u2022 TR  is  the  service  group  that  contains  the  service,\nthe material movement services.\n\u2022 JobCreate   is   the   service   being   used   to   cause\ncommunication  to  take  place  between  two  cluster\ntool  components.    Specifically,  this  service  is  the\nmaterial    movement    service    that    initiates    the\ntransfer of material between modules.\n\u2022 Req indicates that the service is a Request.\n\u2022 (...)  indicates  any  other  parameters  that  might  be\npresent  with  the  service  definition  and  will  be\nservice-dependent.\nDefinitions:\nCC = Cluster Controller\nCM = Cassette Module"),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199633\nTM = Transport Module\nPM1 = Processing Module #1\nPM2 = Processing Module #2\nThe general routing for the scenario is illustrated in the\nmessage sequence below:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"A cassette of wafers arrives from the factory and is\ngiven to the cassette module."),(0,r.yg)("li",{parentName:"ol"},"A mapping of the wafers in the various slots of the\ncassette is determined for use inside the cluster."),(0,r.yg)("li",{parentName:"ol"},"A transfer job is initiated to move a wafer from the\ncassette to a process module (in this case PM1)."),(0,r.yg)("li",{parentName:"ol"},"The  cassette  module  is  commanded  to  send  the\nwafer to the transport module."),(0,r.yg)("li",{parentName:"ol"},"The PM1 is instructed to create the process job and\nto retrieve any pertinent recipe information in order\nto process the wafer."),(0,r.yg)("li",{parentName:"ol"},"The   wafer   is   handed   off   between   the   cassette\nmodule  and  the  transport  module  (Wafer  GET\noperation)."),(0,r.yg)("li",{parentName:"ol"},"The  wafer  is  handed  off  between  the  transport\nmodule and PM1 (this is a Wafer PUT operation)."),(0,r.yg)("li",{parentName:"ol"},"The wafer is processed in PM1.")),(0,r.yg)("h1",{id:"9"},"9"),(0,r.yg)("ol",{start:9},(0,r.yg)("li",{parentName:"ol"},"A transfer job is initiated to the transport module to\nmove a wafer from PM1 to PM2.")),(0,r.yg)("h1",{id:"10"},"10"),(0,r.yg)("ol",{start:10},(0,r.yg)("li",{parentName:"ol"},"The  PM1  is  commanded  to  send  the  wafer  to  the\ntransport module.")),(0,r.yg)("h1",{id:"11"},"11"),(0,r.yg)("ol",{start:11},(0,r.yg)("li",{parentName:"ol"},"The PM2 is instructed to create the process job and\nto retrieve any pertinent recipe information in order\nto process the wafer.")),(0,r.yg)("h1",{id:"12"},"12"),(0,r.yg)("ol",{start:12},(0,r.yg)("li",{parentName:"ol"},"The  wafer  is  handed  off  between  the  PM1  and  the\ntransport module with a GET.")),(0,r.yg)("h1",{id:"13"},"13"),(0,r.yg)("ol",{start:13},(0,r.yg)("li",{parentName:"ol"},"The wafer is handed off between the transport and\nPM2 with a PUT.")),(0,r.yg)("h1",{id:"14"},"14"),(0,r.yg)("ol",{start:14},(0,r.yg)("li",{parentName:"ol"},"The  wafer  is  processed  in  PM2  when  manually\nstarted.")),(0,r.yg)("h1",{id:"15"},"15"),(0,r.yg)("ol",{start:15},(0,r.yg)("li",{parentName:"ol"},"A transfer job is initiated to the transport module to\nmove  a  wafer  from  PM2  back  to  the  cassette\nmodule.")),(0,r.yg)("h1",{id:"16"},"16"),(0,r.yg)("ol",{start:16},(0,r.yg)("li",{parentName:"ol"},"The  PM2  is  commanded  to  send  the  wafer  to  the\ntransport module.")),(0,r.yg)("h1",{id:"17"},"17"),(0,r.yg)("ol",{start:17},(0,r.yg)("li",{parentName:"ol"},"The  cassette  module  is  instructed  to  receive  the\nwafer.")),(0,r.yg)("h1",{id:"18"},"18"),(0,r.yg)("ol",{start:18},(0,r.yg)("li",{parentName:"ol"},"The  wafer  is  handed  off  between  PM2  and  the\ntransport module.")),(0,r.yg)("h1",{id:"19"},"19"),(0,r.yg)("ol",{start:19},(0,r.yg)("li",{parentName:"ol"},"The  wafer  is  handed  off  between  the  transport\nmodule and the cassette module.")),(0,r.yg)("h1",{id:"20"},"20"),(0,r.yg)("ol",{start:20},(0,r.yg)("li",{parentName:"ol"},"The   cassette   module   is   instructed   to   send   the\ncassette to the factory."),(0,r.yg)("li",{parentName:"ol"},"FACTORY TO CM CASSETTE HANDOFF\nThe cassette containing a single wafer in wafer slot 1 to\nbe  processed  by  the  cluster  tool  is  passed  from  the\nfactory environment to the cluster tool.\nAt this point the user (human or host) will be prompted\nto  place  the  cassette  on  the  cassette  module  loading\nsystem. The cassette module is then informed to receive\na cassette from the external environment.\nCC                                     CM",(0,r.yg)("blockquote",{parentName:"li"},(0,r.yg)("blockquote",{parentName:"blockquote"},(0,r.yg)("p",{parentName:"blockquote"},'-------------------------------------\x3e>\nTRJobCreate.Req(MID="Carrier1",Port=Port2\n, Dir=Receive)\nCC                                     CM\n<<-------------------------------------<<\nTRJobCreate.Rsp(JobID=IOJob1,Status=OK)\nThe cassette module prepares to receive the cassette by\nsuch  actions  as  loadlock  venting,  door  opening,  and\nthen requesting handoff from the Factory.\nCC                                     CM\n<<-------------------------------------<<\nTRJobStarted.Req(JobID=IOJob1, TimeStamp)\nThe  actual  cassette  transfer  takes  place,  the  cassette\nmodule takes such actions as door closing and loadlock\npumping  down  to  internal  transfer  pressures,  and  then\nreports completion of the material transfer.\nCC                                     CM\n<<-------------------------------------<<\nTRJobComplete.Req(JobID=IOJob1,TimeStamp,\nStatus=OK))'))))),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199634\n2. WAFER MAPPING\nThe  wafers  in  each  of  the  cassette  wafer  slots  are\nassigned  a  unique  wafer  ID.  In  this  case,  the  wafer  is\nidentified  as  \u201cWafer1.\u201d  If  there  were  more  than  one\nwafer,  this  process  would  be  repeated  until  all  the\nwafers  had  been  given  their  appropriate  identification\nthat is used later when specific wafers are requested for\ntransfer and processing.\nCC                                     CM"),(0,r.yg)("blockquote",null,(0,r.yg)("blockquote",{parentName:"blockquote"},(0,r.yg)("p",{parentName:"blockquote"},'-------------------------------------\x3e>\nSet.Req("WAFERSLOT",SlotID=1,MID=\n"Wafer1")\nCC                                    CM\n<<------------------------------------<<\nSet.Rsp("WAFERSLOT",SlotID=1,Status=OK)\n3. CC TO TM TRANSFER JOB SETUP\nThe CC informs the TM that a wafer transfer is required\nfrom the CM to PM1.\nCC                                    TM\n------------------------------------\x3e>\nTRJobCreate.Req(MID="Wafer1",TRSourceAmID\n="CM",TRDestinationAmID="PM1")\nThe  transport  module  assigns  an  identifier  for  this\nparticular  transfer  job.  This  is  important  in  an  actual\ncluster implementation since multiple transfer jobs may\nbe queued and active at any given time. The transfer job\nis then started by the transport module.\nCC                                     TM\n<\x01------------------------------------<<\nTRJobCreate.Rsp(JobID=TMJob1,Status=OK)\nCC                                     TM\n<<-------------------------------------<<\nTRJobStarted.Req(JobID=TMJob1,TimeStamp)\n4. CC TO CM SEND WAFER\nThe CC informs the CM that a wafer is to be transferred\nto the TM.\nCC                                     CM\n-------------------------------------\x3e>\nTRJobCreate.Req(MID="Wafer1",PortID=\n"Port1",Dir=Send)\nCC                                     CM\n<<-------------------------------------<<\nTRJobCreate.Rsp(JobID=IOJob2,Status=OK)\nWhen   the   cassette   module   is   ready,   it   directly\ncommunicates   with   the   cluster   controller   and   the\ntransport  module  to  indicate  its  readiness  for  wafer\nhandoff.\nCC                                     CM\n<<-------------------------------------<<\nTRJobStarted.Req(JobID=IOJob2, TimeStamp)\nTM                                     CM\n<<-------------------------------------<<\nHOReady.Req(PortID="Port1",AmID="CM",\nHODir=GET,MID="Wafer1")\n5. CC TO PM1 PROCESSING JOB SETUP\nThe  CC  informs  PM1  that  a  wafer  will  be  delivered\n(which  requires  a  TRJob  to  be  created)  and  is  to  be\nprocessed    (this    requires    that    a    process    job    be\nestablished).   This   involves   creating   the   jobs   and\ntransferring   the   appropriate   recipes   to   the   process\nmodule  as  required.  At  some  point  in  this  process,  the\nPM  will  inform  the  transport  module  that  it  is  ready  to\nreceive  the  wafer  with  the  issuing  of  the  HOReady\nRequest.\nThe  CC  informs  PM1  that  a  wafer  is  to  be  transfered\nfrom the TM.\nCC                                   PM1\n------------------------------------\x3e>\nTRJobCreate.Req(MID="Wafer1",Port="Port1"\n, Dir=Receive)\nCC                                   PM1\n<<------------------------------------<<\nTRJobCreate.Rsp(JobID=IOJob3,Status=OK)\nWhen    the    process    module    is    ready,    it    directly\ncommunicates with the cluster controller to indicate its\nreadiness for wafer handoff.\nCC                                    PM1\n<<-------------------------------------<<\nTRJobStarted.Req(JobID=IOJob3, TimeStamp)\nThe process job is created on the process module.\nCC                                    PM1\n-------------------------------------\x3e>\nPRJobCreate.Req(RecID="PP1",MID="Wafer1")\nCC                                    PM1\n<<-------------------------------------<<\nPRJobCreate.Rsp(JobID=PM1Job1,Status=OK)\nCC                                    PM1\n<<-------------------------------------<<\nPRJobSetup.Req(JobID=PM1Job1)'))),(0,r.yg)("p",null,'SEMI E38-1296 \xa9 SEMI 1995, 199635\nThe  process  module  requests  that  all  sections  (headers\nand the body) of the recipe be downloaded.\nCC                                    PM1\n<<-------------------------------------<<\nRCRequest.Req(RecID="PP1",RCTransfer=all)\nCC                                    PM1'),(0,r.yg)("blockquote",null,(0,r.yg)("blockquote",{parentName:"blockquote"},(0,r.yg)("p",{parentName:"blockquote"},'-------------------------------------\x3e>\nRCRequest.Rsp(RecID="PP1",Status=OK)\nCC                                    PM1\n-------------------------------------\x3e>\nRCSend.Req(RecID="PP1",Headers & Body)\nCC                                    PM1\n<<-------------------------------------<<\nRCSend.Rsp(RecID="PP1",Status=OK)\nThe process module informs the transport module that it\nis ready to receive the material.\nTM                                    PM1\n<<-------------------------------------<<\nHOReady.Req(Port=Port1,AmID="PM1",HODir=P\nUT,MID="Wafer1")\n6. CM TO TM WAFER HANDOFF\nThe  CM  transfers  the  wafer  to  the  TM  through  the\nhandoff  sequence,  and  the  CM  and  TM  will  keep  the\ncluster controller informed of its transfer progress.\nThe  transport  module  informs  the  cassette  module  that\nit is proceeding with the "getting" of the wafer.\nCM                                     TM\n<<-------------------------------------<<\nHOReady.Req(Port=Port1,AmID="CM",HODir=GE\nT, MID="Wafer1")\nThe  cassette  module  informs  the  transport  module  to\nuse the PICK sequence to get the wafer.\nCM                                     TM\n-------------------------------------\x3e>\nHOPick.Req(Port=Port1,AmID="CM")\nCM                                     TM\n<<-------------------------------------<<\nHOPick.Rsp(Port=Port1,AmID="CM",\nStatus=OK)\nWhen  the  getting  of  the  wafer  has  been  successful,  the\ncassette  module  informs  the  transport  module  with  a\nverify sequence.\nCM                                     TM\n-------------------------------------\x3e>\nHOVerify.Req(Port=Port1,AmID="CM")\nCM                                     TM\n<<-------------------------------------<<\nHOVerify.Rsp(Port=Port1,AmID="CM",\nStatus=OK)\nThe cassette module then informs the cluster controller\nof its current status.\nCC                                     CM\n<<-------------------------------------<<\nTRJobComplete.Req(JobID=IOJob2,TimeStamp,\nStatus=OK)\n7. TM TO PM1 WAFER HANDOFF\nThe  TM  now  has  possession  of  the  wafer  and  is  ready\nto proceed with the putting of the wafer into the process\nmodule.  The  TM  and  PM1  will  inform  the  cluster\ncontroller of the progress of the transfer of material.\nThe  TM  informs  the  PM  that  it  is  proceeding  with  the\nputting of the wafer.\nPM1                                    TM\n<<-------------------------------------<<\nHOReady.Req(Port=Port1,AmID="PM1",HODir=P\nUT,MID="Wafer1")\nThe process module informs the TM to use the PLACE\nscenario as the put operation.\nPM1                                    TM\n-------------------------------------\x3e>\nHOPlace.Req(Port=Port1,AmID="PM1")\nPM1                                    TM\n<<-------------------------------------<<\nHOPlace.Rsp(Port=Port1,AmID="PM1",\nStatus=OK)'))),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199636\nWhen the putting of the wafer has been successful, the\nPM   informs   the   transport   module   with   a   verify\nsequence.\nPM1                                    TM"),(0,r.yg)("blockquote",null,(0,r.yg)("blockquote",{parentName:"blockquote"},(0,r.yg)("p",{parentName:"blockquote"},'-------------------------------------\x3e>\nHOVerify.Req(Port=Port1,AmID="PM1")\nPM1                                    TM\n<<-------------------------------------<<\nHOVerify.Rsp(Port=Port1,AmID="PM1",\nStatus=OK)\nCC                                    PM1\n<<-------------------------------------<<\nTRJobComplete.Req(JobID=IOJob3,\nTimeStamp)\nThe  TM  then  informs  the  cluster  controller  that  the\nputting  phase  of  the  transfer  is  complete  and  then  that\nthe requested transfer job is complete.\nCC                                     TM\n<<-------------------------------------<<\nTRJobComplete.Req(JobID=TMJob1,\nTimeStamp,Status=OK)\n8. PM1 JOB PROCESSING\nThe process module informs the cluster controller, now\nthat  is  has  received  the  material  and  having  previously\nentered   the   setup   state,   that   it   is   ready   to   initiate\nprocessing  on  the  wafer.  When  actual  processing  is\ninitiated,  the  PM  informs  the  cluster  controller  of  its\ncurrent status.\nCC                                    PM1\n<<-------------------------------------<<\nPRJobProcessing.Req(JobID=PM1Job1,TimeSta\nmp)\nA  data  collection  is  enabled  to  allow  parameters  to  be\nsent  from  the  PM  to  the  cluster  controller  while  the\nwafer  processing  is  taking  place.  A  previously  defined\nevent is enabled and the report structure is established.\nCC                                    PM1\n-------------------------------------\x3e>\nSet.Req(EREvent,EventID=Event1,\nEnabled=TRUE)\nCC                                    PM1\n<<-------------------------------------<<\nSet.Rsp(EREvent,EventID=Event1,Status=OK)\nTwo variables for time and temperature will be reported\nbased on Event1 occurring.\nCC                                    PM1\n<<-------------------------------------<<\nERReport.Req(EventID=Event1,ReportID=Rpt1\n, ValueList={time,temp})\nWhen  wafer  processing  is  complete  on  the  PM,  the\ncluster controller is informed of the current status.\nCC                                    PM1\n<<-------------------------------------<<\nPRJobProcessingComplete.Req(JobID=PM1Job1\n, TimeStamp,Status=OK)\nData collection is then disabled.\nCC                                    PM1\n-------------------------------------\x3e>\nSet.Req(EREvent,EventID=Event1,\nEnabled=FALSE)\nCC                                    PM1\n<<-------------------------------------<<\nSet.Rsp(EREvent,EventID=Event1,Status=OK)\n9. PM1 to PM2 TRANSFER JOB SETUP\nThe CC informs the TM that a wafer transfer is required\nfrom the PM1 to PM2.\nCC                                     TM\n-------------------------------------\x3e>\nTRJobCreate.Req(MID="Wafer1",\nTRSourceAmID="PM1",\nTRDestinationAmID="PM2")\nThe  transport  module  assigns  an  identifier  for  this\nparticular  transfer  job.  The  transfer  job  is  then  started\nby the transport module.\nCC                                     TM\n<<-------------------------------------<<\nTRJobCreate.Rsp(JobID=TMJob2,Status= OK)\nCC                                     TM\n<<-------------------------------------<<\nTRJobStarted.Req(JobID=TMJob2, TimeStamp)'))),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199637\n10. CC TO PM1 SEND WAFER\nThe CC informs PM1 that a wafer is to be transferred to\nthe TM.\nCC                                    PM1"),(0,r.yg)("blockquote",null,(0,r.yg)("blockquote",{parentName:"blockquote"},(0,r.yg)("p",{parentName:"blockquote"},'-------------------------------------\x3e>\nTRJobCreate.Req(MID="Wafer1",Port=\n"Port1", Dir=Send)\nCC                                    PM1\n<<-------------------------------------<<\nTRJobCreate.Rsp(JobID=IOJob4,Status=OK)\nCC                                    PM1\n<<-------------------------------------<<\nTRJobStarted.Rsp(JobID=IOJob4, TimeStamp)\nWhen    the    process    module    is    ready,    it    directly\ncommunicates  with  the  transport  module  to  indicate  its\nreadiness for wafer handoff.\nTM                                    PM1\n<<-------------------------------------<<\nHOReady.Req(PortID="Port1",AmID="CM",\nHODir=GET,MID="Wafer1")\n11. CC TO PM2 PROCESSING JOB SETUP\nThe  CC  informs  PM2  that  a  wafer  will  be  delivered\n(requires a TRJob) and is to be processed (requires that\na process job be established). This involves creating the\njobs  and  transferring  the  appropriate  recipes  to  the\nprocess  module  as  required.  At  some  point  in  this\nprocess, the PM will inform the transport module that it\nis  ready  to  receive  the  wafer  with  the  isssuing  of  the\nHOReady Request.\nCC                                    PM2\n-------------------------------------\x3e>\nTRJobCreate.Req(MID="Wafer1",Port="Port1"\n, Dir=Receive)\nCC                                    PM2\n<<-------------------------------------<<\nTRJobCreate.Rsp(JobID=IOJob5,Status=OK)\nCC                                    PM2\n<<-------------------------------------<<\nTRJobStarted.Req(JobID=IOJob5, TimeStamp)\nCC                                    PM2\n-------------------------------------\x3e>\nPRJobCreate.Req(RecID="PP2",MID="Wafer1",\nManualStart)\nCC                                    PM2\n<<-------------------------------------<<\nPRJobCreate.Rsp(JobID=PM2Job1,Status=OK)\nCC                                    PM2\n<<-------------------------------------<<\nPRJobSetup.Req(JobID=PM2Job1)\nThe  process  module  requests  that  all  sections  (headers\nand the body) of the recipe be downloaded.\nCC                                    PM2\n<<-------------------------------------<<\nRCRequest.Req(RecID="PP2",RCTransfer=all)\nCC                                    PM2\n-------------------------------------\x3e>\nRCRequest.Rsp(RecID="PP2",LinkedID=0,{Bod\ny: "TEMP 250 TIME 40"})\nCC                                    PM2\n-------------------------------------\x3e>\nRCSend.Req(RecID="PP1",Headers & Body)\nCC                                    PM2\n<<-------------------------------------<<\nRCSend.Rsp(RecID="PP1",Status=OK)'))),(0,r.yg)("p",null,'SEMI E38-1296 \xa9 SEMI 1995, 199638\nThe  process  module  then  informs  the  transport  module\nto proceed with the putting of the wafer.\nTM                                    PM2\n<<-------------------------------------<<\nHOReady.Req(Port=Port1,AmID="PM2",HODir=P\nUT,MID="Wafer1")\n12. PM1 TO TM WAFER HANDOFF\nThe  PM1  transfers  the  wafer  to  the  TM  through  the\nhandoff  sequence,  and  the  TM  will  keep  the  cluster\ncontroller   informed   of   its   transfer   progress.   The\ntransport  module  informs  the  process  module  that  it  is\nproceeding with the "getting" of the wafer.\nPM                                     TM\n<<-------------------------------------<<\nHOReady.Req(Port=Port1,AmID="PM1",HODir=G\nET,MID="Wafer1")\nThe  process  module  informs  the  transport  module  to\nuse the PICK sequence to get the wafer.\nPM1                                    TM'),(0,r.yg)("blockquote",null,(0,r.yg)("blockquote",{parentName:"blockquote"},(0,r.yg)("p",{parentName:"blockquote"},'-------------------------------------\x3e>\nHOPick.Req(Port=Port1,AmID="PM1")\nPM1                                    TM\n<<-------------------------------------<<\nHOPick.Rsp (Port=Port1,AmID="PM1",\nStatus=OK)\nWhen  the  getting  of  the  wafer  has  been  successful,  the\nprocess  module  informs  the  transport  module  with  a\nverify sequence.\nPM1                                    TM\n-------------------------------------\x3e>\nHOVerify.Req(Port=Port1,AmID="PM1")\nPM1                                    TM\n<<-------------------------------------<<\nHOVerify.Rsp(Port=Port1,AmID="PM1",\nStatus=OK)\nProcess module #1 then informs the cluster controller of\nits current status.\nCC                                    PM1\n<<-------------------------------------<<\nTRJobComplete.Req(JobID=IOJob4,TimeStamp,\nStatus=OK)\nThe  cluster  controller  is  informed  that  the  processing\njob performed in PM1 is complete.\nCC                                    PM1\n<<-------------------------------------<<\nPRJobComplete.Req(JobID=PM1Job1,\nTimeStamp,Status=OK)\n13. TM TO PM2 WAFER HANDOFF\nThe   TM   informs   the   cluster   controller   that   it   is\nproceeding  with  the  transfer  of  the  wafer.  The  TM\ninforms the PM that it is proceeding with the putting of\nthe wafer.\nPM2                                    TM\n<<-------------------------------------<<\nHOReady.Req(Port=Port1,AmID="PM2",HODir=P\nUT,MID="Wafer1")\nThe   process   module   informs   the   TM   to   use   the\nEXTEND scenario as the put operation.\nPM2                                    TM\n-------------------------------------\x3e>\nHOExtend.Req(Port=Port1,AmID="PM2")\nPM2                                    TM\n<<-------------------------------------<<\nHOExtend.Rsp(Port=Port1,AmID="PM2",\nStatus=OK)\nDuring    this    particular    handoff,    an    exception    is\ngenerated  stating  that  the  pins  in  the  process  module\nfailed  to  come  up  and  receive  the  wafer  from  the  end\neffector.    The  cluster  controller  is  given  three  recovery\noptions to select from in attempting to resume operation\nin the presence of this exception.\nCC                                    PM2\n<<-------------------------------------<<\nEXPost.Req(EXID=Error1, EXType=Error,\nEXMessage="pins failed to raise",\nEXRecoveryList=\n{"Abort","Retry","Continue"}, TimeStamp)'))),(0,r.yg)("p",null,"SEMI E38-1296 \xa9 SEMI 1995, 199639\nThe cluster controller selects the \u201ccontinue\u201d option.\nCC                                    PM2"),(0,r.yg)("blockquote",null,(0,r.yg)("blockquote",{parentName:"blockquote"},(0,r.yg)("p",{parentName:"blockquote"},'-------------------------------------\x3e>\nEXRecover.Req(EXID=Error1,\nEXRecoverySelected= "Continue")\nCC                                    PM2\n<<-------------------------------------<<\nEXRecover.Rsp(EXID=Error1, Status=OK)\nCC                                    PM2\n<<-------------------------------------<<\nEXRecoveryComplete.Rsp(EXID=Error1,\nStatus=OK)\nThis action is successful, and the alarm (exception type)\nclears.\nCC                                    PM2\n<<-------------------------------------<<\nEXCleared.Rsp(EXID=Error1,EXType=Error,\nTimeStamp)\nWhen  the  putting  of  the  wafer  is  now  successful,  the\nPM commands the transport module to Retract.\nPM2                                    TM\n-------------------------------------\x3e>\nHORetract.Req(Port=Port1,AmID="PM2")\nPM2                                    TM\n<<-------------------------------------<<\nHORetract.Rsp(Port=Port1,AmID="PM2",\nStatus=OK)\nUpon  successful  completion  of  the  handoff,  a  verify\nsequence is used to complete the transaction.\nPM2                                    TM\n-------------------------------------\x3e>\nHOVerify.Req(Port=Port1,AmID="PM2")\nPM2                                    TM\n<<-------------------------------------<<\nHOVerify.Rsp(Port=Port1,AmID="PM2",\nStatus=OK)\nCC                                    PM2\n<<-------------------------------------<<\nTRJobComplete.Req(JobID=IOJob5,TimeStamp,\nStatus=OK)\nThe  TM  then  informs  the  cluster  controller  that  the\nputting  of  material  is  complete  and  that  the  requested\ntransfer job is complete.\nCC                                     TM\n<<-------------------------------------<<\nTRJobComplete.Req(JobID=TMJob2,\nTimeStamp,Status=OK)\nThe  process  module  informs  the  cluster  controller  that\nnow  that  is  has  received  the  material,  it  is  ready  to\ninitiate processing on the wafer upon Start command.\nCC                                    PM2\n<<-------------------------------------<<\nPRJobWaitingStart.Req(JobID=PM2Job1)\n14. PM2 JOB PROCESSING\nThe   cluster   controller   commands   the   PM   to   start\nprocessing the wafer.\nCC                                    PM1\n-------------------------------------\x3e>\nPRJobStart.Req(JobID=PM2Job1)\nCC                                    PM1\n<<-------------------------------------<<\nPRJobStart.Rsp(JobID=PM2Job1,Status=OK)\nWhen actual processing is initiated, the PM informs the\ncluster controller of its current status.\nCC                                    PM2\n<<-------------------------------------<<\nPRJobProcessing.Req(JobID=PM2Job1,\nTimeStamp)\nA  data  collection  is  enabled  to  allow  parameters  to  be\nsent  from  the  PM  to  the  cluster  controller  while  the\nwafer  processing  is  taking  place.  A  previously  defined\nevent is enabled and the report structure is established.\nCC                                    PM2\n-------------------------------------\x3e>\nSet.Req(EREvent,EventID=Event1,\nEnabled=TRUE)\nCC                                    PM2\n<<-------------------------------------<<\nSet.Rsp(EREvent,EventID=Event1,Status=OK)\nTwo variables for time and temperature will be reported\nbased on Event1 occurring.\nCC                                    PM2\n<<-------------------------------------<<\nERReport.Req(EventID=Event1,ReportID=Rpt1\n, ValueList={time,temp})\nWhen  wafer  processing  is  complete  on  the  PM,  the\ncluster controller is informed of the current status.\nCC                                    PM2\n<<-------------------------------------<<\nPRJobProcessingComplete.Req(JobID=PM2Job1\n, TimeStamp,Status=OK)'))))}h.isMDXComponent=!0}}]);